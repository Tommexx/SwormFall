<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swarm Defense: Heavy Artillery</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; }
        /* --- UI CONTAINER --- */
#ui {
    position: absolute;
    top: 20px;
    left: 20px;
    width: 340px; /* Fixed width for alignment */
    display: flex;
    flex-direction: column;
    gap: 15px;
    pointer-events: none; /* Allows clicking through gaps */
    font-family: 'Segoe UI', sans-serif;
}

/* --- PANELS --- */
.hud-panel {
    background: rgba(12, 12, 18, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
    border-radius: 12px;
    padding: 15px;
    pointer-events: auto;
    backdrop-filter: blur(10px);
}

/* --- STATS HEADER --- */
.stats-header {
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    margin-bottom: 10px;
    padding-bottom: 5px;
}
.stats-header h1 {
    font-size: 22px;
    color: #00d2ff;
    text-shadow: 0 0 10px rgba(0, 210, 255, 0.4);
    margin: 0;
    text-transform: uppercase;
    letter-spacing: 2px;
}
.stats-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 5px;
    font-size: 14px;
    color: #aab;
}
.stat-val { color: white; font-weight: bold; }

/* --- TABS SYSTEM --- */
.tab-nav {
    display: flex;
    background: rgba(0, 0, 0, 0.4);
    border-radius: 8px;
    padding: 4px;
    gap: 4px;
    margin-bottom: 12px;
}
.tab-btn {
    flex: 1;
    background: transparent;
    border: none;
    color: #667;
    padding: 8px 0;
    font-size: 12px;
    font-weight: 700;
    text-transform: uppercase;
    cursor: pointer;
    border-radius: 6px;
    transition: all 0.2s;
    text-align: center;
}
.tab-btn:hover { background: rgba(255, 255, 255, 0.05); color: #fff; }
.tab-btn.active-tab {
    background: rgba(0, 210, 255, 0.15);
    color: #00d2ff;
    box-shadow: 0 0 10px rgba(0, 210, 255, 0.1);
}

/* --- TOOL BUTTONS --- */
.tab-content { display: none; animation: slideIn 0.2s ease-out; }
.tab-content.active-content { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }

@keyframes slideIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

.tool-btn {
    background: linear-gradient(180deg, #2a2a35 0%, #1a1a20 100%);
    border: 1px solid #3a3a45;
    color: #ccc;
    padding: 10px;
    border-radius: 8px;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    position: relative;
    transition: all 0.2s;
    min-height: 50px;
}
.tool-btn:hover {
    border-color: #00d2ff;
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
}
/* Selected State (matches your JS logic) */
.tool-btn.active {
    background: linear-gradient(180deg, #00d2ff 0%, #0088aa 100%);
    border-color: #fff;
    color: #002233;
}
.tool-btn.active span { color: #004455; } /* Cost text on active */

.btn-label { font-size: 13px; font-weight: bold; margin-bottom: 2px; }
.btn-cost { font-size: 11px; color: #00ff88; font-family: monospace; }
.btn-hotkey { position: absolute; top: 6px; right: 8px; font-size: 10px; opacity: 0.4; font-weight: bold; }

/* Special Delete Button Styling */
.btn-delete { border-color: #ff4444; }
.btn-delete:hover { background: rgba(50, 10, 10, 1); border-color: #ff0000; }
.btn-delete .btn-cost { color: #ff8888; }
.tool-btn.active.btn-delete {
    background: linear-gradient(180deg, #ff4444 0%, #aa0000 100%);
    color: white;
}
        
        /* --- FULL SCREEN OVERLAY --- */
#game-over {
    display: none; /* Hidden by default */
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(10, 0, 0, 0.85); /* Dark red-black tint */
    backdrop-filter: blur(8px);       /* Blurs the game behind it */
    z-index: 10000;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    font-family: 'Segoe UI', Tahoma, monospace;
    overflow: hidden;
}

/* --- SCANLINE EFFECT --- */
#game-over::before {
    content: " ";
    display: block;
    position: absolute;
    top: 0; left: 0; bottom: 0; right: 0;
    background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
    z-index: 2;
    background-size: 100% 2px, 3px 100%;
    pointer-events: none;
}

/* --- THE CARD CONTAINER --- */
.game-over-card {
    position: relative;
    z-index: 5;
    background: #0a0a0a;
    border: 1px solid #ff0033;
    box-shadow: 0 0 50px rgba(255, 0, 51, 0.2), inset 0 0 20px rgba(255, 0, 51, 0.1);
    padding: 60px;
    text-align: center;
    max-width: 500px;
    width: 80%;
    /* "Cut corner" tech look */
    clip-path: polygon(
        0 0, 
        100% 0, 
        100% calc(100% - 30px), 
        calc(100% - 30px) 100%, 
        0 100%
    );
}

/* --- TYPOGRAPHY --- */
#game-over h1 {
    margin: 0 0 10px 0;
    font-size: 4rem;
    color: #ff0033;
    text-transform: uppercase;
    font-weight: 900;
    letter-spacing: 5px;
    text-shadow: 4px 4px 0px #330000;
    animation: glitch 2s infinite;
}

.sub-text {
    color: #ff6666;
    font-size: 1.2rem;
    letter-spacing: 2px;
    margin-bottom: 30px;
    text-transform: uppercase;
    border-bottom: 1px solid #330000;
    padding-bottom: 20px;
}

.stat-box {
    background: rgba(255, 255, 255, 0.05);
    padding: 20px;
    margin-bottom: 30px;
    border-left: 4px solid #ff0033;
}

.stat-label {
    display: block;
    color: #aaa;
    font-size: 0.9rem;
    margin-bottom: 5px;
    text-transform: uppercase;
}

#final-wave {
    font-size: 3.5rem;
    color: white;
    font-weight: bold;
    text-shadow: 0 0 10px rgba(255,255,255,0.5);
}

/* --- BUTTON --- */
.retry-btn {
    background: #ff0033;
    color: white;
    border: none;
    padding: 15px 40px;
    font-size: 1.2rem;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 2px;
    cursor: pointer;
    transition: all 0.3s ease;
    width: 100%;
    clip-path: polygon(0 0, 100% 0, 100% 70%, 95% 100%, 0 100%);
}

.retry-btn:hover {
    background: #ff3366;
    box-shadow: 0 0 30px rgba(255, 0, 51, 0.6);
    transform: translateY(-2px);
}

.retry-btn:active {
    transform: translateY(1px);
}

/* --- ANIMATIONS --- */
@keyframes glitch {
    0% { text-shadow: 4px 4px 0px #330000; }
    2% { text-shadow: -4px -4px 0px #330000; transform: translate(-2px, 0); }
    4% { text-shadow: 2px -2px 0px #330000; transform: translate(2px, 0); }
    6% { text-shadow: 4px 4px 0px #330000; transform: translate(0, 0); }
    100% { text-shadow: 4px 4px 0px #330000; }
}

        /* --- MAIN MENU CONTAINER --- */
#main-menu {
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 200;
    font-family: 'Segoe UI', sans-serif;
}

#main-menu h1 {
    font-size: 72px;
    color: #fff;
    text-shadow: 0 0 10px rgba(0, 210, 255, 0.8), 0 0 40px rgba(0, 210, 255, 0.4);
    margin-bottom: 10px;
    letter-spacing: 4px;
    font-weight: 800;
    text-transform: uppercase;
}

#main-menu p {
    color: #889;
    font-size: 18px;
    margin-bottom: 60px;
    letter-spacing: 2px;
    text-transform: uppercase;
}

/* --- CARDS CONTAINER --- */
.difficulty-container {
    display: flex;
    gap: 25px;
    flex-wrap: wrap;
    justify-content: center;
    perspective: 1000px;
}

/* --- BASE CARD STYLE --- */
.diff-card {
    position: relative;
    width: 200px;
    height: 300px;
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    overflow: hidden;
    backdrop-filter: blur(10px);
}

/* Hover Effect: Lift and Glow */
.diff-card:hover {
    transform: translateY(-15px) scale(1.02);
    background: rgba(255, 255, 255, 0.08);
}

/* Content Styling */
.diff-card .icon {
    width: 60px;
    height: 60px;
    margin-bottom: 20px;
    transition: 0.4s;
}

.diff-card .title {
    font-size: 24px;
    font-weight: bold;
    text-transform: uppercase;
    margin-bottom: 5px;
    color: #fff;
    z-index: 2;
}

.diff-card .stats {
    font-size: 14px;
    opacity: 0.7;
    z-index: 2;
}

.diff-card .desc {
    font-size: 12px;
    color: #aaa;
    margin-top: 15px;
    text-align: center;
    padding: 0 15px;
    line-height: 1.4;
    z-index: 2;
}

/* --- UNIQUE CARD THEMES --- */

/* 1. EASY (Green/Safety) */
.card-easy { border-bottom: 4px solid #00ff88; }
.card-easy .icon svg { fill: #00ff88; filter: drop-shadow(0 0 5px #00ff88); }
.card-easy:hover { box-shadow: 0 0 30px rgba(0, 255, 136, 0.3); border-color: #00ff88; }
.card-easy .stats { color: #00ff88; }

/* 2. MEDIUM (Yellow/Industrial) */
.card-medium { border-bottom: 4px solid #ffcc00; }
.card-medium .icon svg { fill: #ffcc00; filter: drop-shadow(0 0 5px #ffcc00); }
.card-medium:hover { box-shadow: 0 0 30px rgba(255, 204, 0, 0.3); border-color: #ffcc00; }
.card-medium .stats { color: #ffcc00; }

/* 3. HARD (Orange/Warning) */
.card-hard { border-bottom: 4px solid #ff6600; }
.card-hard .icon svg { fill: #ff6600; filter: drop-shadow(0 0 5px #ff6600); }
.card-hard:hover { box-shadow: 0 0 30px rgba(255, 102, 0, 0.4); border-color: #ff6600; }
.card-hard .stats { color: #ff6600; }

/* 4. EXTREME (Red/Danger) */
.card-extreme { 
    border-bottom: 4px solid #ff0000; 
    box-shadow: inset 0 0 20px rgba(255, 0, 0, 0.1); /* Inner red tint */
}

/* The Skull Icon Style */
.card-extreme .icon svg { 
    fill: #ff0000; 
    /* Double shadow for intense glow */
    filter: drop-shadow(0 0 20px #ff0000) drop-shadow(0 0 20px #ff0000);
}

/* Hover Effects */
.card-extreme:hover { 
    box-shadow: 0 0 50px rgba(255, 0, 0, 0.6), inset 0 0 30px rgba(255, 0, 0, 0.2); 
    border-color: #ff0000; 
    animation: violent-shake 0.4s infinite; /* Aggressive jitter */
}
.card-extreme:hover .icon svg {
    filter: drop-shadow(0 0 15px #ff0000) drop-shadow(0 0 40px #ff0000);
    transform: scale(1.1);
}

.card-extreme .stats { color: #ff0000; font-weight: bold; text-shadow: 0 0 10px #ff0000; }

/* 5. CREATIVE (Cyan/GodMode) */
.card-creative { border-bottom: 4px solid #00d2ff; }
.card-creative .icon svg { fill: #00d2ff; filter: drop-shadow(0 0 10px #00d2ff); }
.card-creative:hover { box-shadow: 0 0 40px rgba(0, 210, 255, 0.5); border-color: #00d2ff; }
.card-creative .stats { color: #00d2ff; }

/* Subtle Grid Background on cards */
.diff-card::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background-image: 
        linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
    background-size: 20px 20px;
    opacity: 0.2;
    z-index: 1;
}

@keyframes violent-shake {
    0% { transform: translateY(-15px) rotate(0deg); }
    25% { transform: translateY(-15px) rotate(2deg); }
    50% { transform: translateY(-15px) rotate(-2deg); }
    75% { transform: translateY(-15px) rotate(2deg); }
    100% { transform: translateY(-15px) rotate(0deg); }
}

/* --- PAUSE MENU STYLES --- */
        #pause-menu {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 10, 0.85); /* Dark semi-transparent background */
            backdrop-filter: blur(8px);       /* Blur effect */
            z-index: 300;                     /* Above everything else */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', sans-serif;
        }

        #pause-menu h1 {
            font-size: 60px;
            color: white;
            margin-bottom: 40px;
            text-transform: uppercase;
            letter-spacing: 10px;
            text-shadow: 0 0 20px #00d2ff;
        }

        .pause-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .pause-btn {
            background: transparent;
            color: #00d2ff;
            border: 2px solid #00d2ff;
            padding: 15px 60px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s ease;
            text-align: center;
            width: 300px;
        }

        .pause-btn:hover {
            background: #00d2ff;
            color: #050505;
            box-shadow: 0 0 30px rgba(0, 210, 255, 0.6);
            transform: scale(1.05);
        }

        /* --- ENEMY INTRO OVERLAY --- */
#enemy-intro-overlay {
    display: none; /* Hidden by default */
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.85);
    z-index: 9999; /* On top of everything */
    justify-content: center;
    align-items: center;
    backdrop-filter: blur(5px);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.intro-card {
    background: linear-gradient(135deg, #1a1a24 0%, #0f0f13 100%);
    border: 1px solid #444;
    border-left: 4px solid #ff0044; /* Red Accent */
    width: 650px;
    padding: 30px;
    border-radius: 8px;
    box-shadow: 0 0 50px rgba(0, 0, 0, 0.9);
    color: white;
    position: relative;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.intro-header {
    border-bottom: 1px solid #333;
    padding-bottom: 10px;
    margin-bottom: 10px;
}

.intro-title {
    font-size: 28px;
    font-weight: 800;
    color: #fff;
    text-transform: uppercase;
    letter-spacing: 2px;
    text-shadow: 0 0 10px rgba(255, 0, 68, 0.5);
}

.intro-sub {
    font-size: 11px;
    color: #888;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.intro-content {
    display: flex;
    gap: 25px;
    align-items: flex-start;
}

/* THE PREVIEW CANVAS */
#enemy-preview-canvas {
    background: radial-gradient(circle at center, #2a2a35 0%, #000 100%);
    border: 1px solid #555;
    border-radius: 4px;
    box-shadow: inset 0 0 20px #000;
}

.intro-details {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

/* STAT BARS (10 Rectangles) */
.stat-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.stat-label {
    font-size: 12px;
    color: #aaa;
    font-weight: bold;
    text-transform: uppercase;
    width: 80px;
}

.stat-bar-container {
    display: flex;
    gap: 4px; /* Space between rectangles */
}

.stat-pip {
    width: 14px;
    height: 10px;
    background: #222; /* Empty color */
    border-radius: 1px;
    transition: background 0.3s;
}

/* Filled Colors */
.stat-pip.filled.durability { background: #ff4444; box-shadow: 0 0 5px #ff4444; }
.stat-pip.filled.speed { background: #ffcc00; box-shadow: 0 0 5px #ffcc00; }
.stat-pip.filled.damage { background: #aa00ff; box-shadow: 0 0 5px #aa00ff; }

.lore-text {
    margin-top: 10px;
    font-size: 14px;
    line-height: 1.6;
    color: #ddd;
    font-style: italic;
    background: rgba(255, 255, 255, 0.05);
    padding: 15px;
    border-radius: 4px;
    border-left: 2px solid #666;
}

.continue-btn {
    width: 100%;
    padding: 15px;
    background: #ff0044;
    color: white;
    border: none;
    font-weight: bold;
    font-size: 16px;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 2px;
    transition: 0.2s;
    margin-top: 10px;
}

.continue-btn:hover {
    background: #ff2266;
    box-shadow: 0 0 20px rgba(255, 0, 68, 0.5);
}

/* --- SKILL TREE MODAL (The Window) --- */
/* =========================================
   FUTURE-TECH SKILL TREE CSS
   ========================================= */

/* --- VARIABLES --- */
:root {
    --neon-blue: #00f3ff;
    --neon-purple: #bc13fe;
    --neon-gold: #ffd700;
    --void-bg: #050505;
    --glass-bg: rgba(10, 15, 30, 0.85);
}

/* --- THE MAIN OVERLAY --- */
#skill-tree-overlay {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    background: transparent;
    z-index: 2000;
    display: none;
    flex-direction: column;
    font-family: 'Courier New', monospace;
}

/* --- HEADER --- */
.st-header {
    height: 64px;
    background: linear-gradient(90deg, rgba(5,5,20,0.98) 0%, rgba(10,5,30,0.98) 50%, rgba(5,5,20,0.98) 100%);
    border-bottom: 1px solid rgba(188,19,254,0.6);
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 32px;
    z-index: 10;
    backdrop-filter: blur(20px);
    box-shadow: 0 0 40px rgba(188,19,254,0.25), inset 0 -1px 0 rgba(188,19,254,0.3);
}

.st-title {
    font-size: 22px;
    color: #fff;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 6px;
    text-shadow: 0 0 20px rgba(0,243,255,0.8), 0 0 40px rgba(0,243,255,0.4);
    display: flex;
    align-items: center;
    gap: 12px;
}
.st-title::before {
    content: '';
    display: inline-block;
    width: 8px; height: 8px;
    background: #00f3ff;
    border-radius: 50%;
    box-shadow: 0 0 10px #00f3ff, 0 0 20px #00f3ff;
    animation: titleBlink 2s infinite;
}
@keyframes titleBlink {
    0%,100% { opacity: 1; } 50% { opacity: 0.3; }
}

.st-currency {
    display: flex;
    align-items: center;
    gap: 8px;
    background: rgba(188,19,254,0.1);
    border: 1px solid rgba(188,19,254,0.3);
    padding: 6px 18px;
    border-radius: 4px;
    font-size: 20px;
    color: #e0b0ff;
    font-weight: bold;
    text-shadow: 0 0 10px rgba(188,19,254,0.8);
    box-shadow: 0 0 15px rgba(188,19,254,0.15);
}

.st-close-btn {
    background: transparent;
    color: rgba(0,243,255,0.8);
    border: 1px solid rgba(0,243,255,0.4);
    padding: 8px 24px;
    font-weight: bold;
    cursor: pointer;
    text-transform: uppercase;
    transition: all 0.2s;
    letter-spacing: 3px;
    font-family: 'Courier New', monospace;
    font-size: 12px;
    clip-path: polygon(8px 0, 100% 0, calc(100% - 8px) 100%, 0 100%);
}
.st-close-btn:hover {
    background: rgba(0,243,255,0.15);
    color: #00f3ff;
    box-shadow: 0 0 20px rgba(0,243,255,0.3);
    border-color: #00f3ff;
}

/* --- VIEWPORT --- */
#st-viewport {
    flex: 1;
    overflow: hidden;
    position: relative;
    cursor: grab;
    background: transparent;
}
#st-viewport:active { cursor: grabbing; }

/* --- WORLD --- */
#st-world {
    width: 3000px;
    height: 3000px;
    position: relative;
    background-color: transparent;
}

#st-world::after {
    content: "";
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background: radial-gradient(circle at center, transparent 0%, rgba(0,0,0,0.9) 75%);
    pointer-events: none;
}

/* --- CONNECTION LINES --- */
#st-connections {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 0;
    pointer-events: none;
}
.connection-line {
    stroke: rgba(60,40,100,0.5);
    stroke-width: 2;
    transition: stroke 0.5s, stroke-width 0.5s, opacity 0.5s;
    opacity: 0.6;
    stroke-dasharray: none;
}
.connection-line.active {
    stroke: #bc13fe;
    stroke-width: 3;
    opacity: 1;
    filter: drop-shadow(0 0 6px #bc13fe);
}

/* --- NODES BASE --- */
.skill-node {
    position: absolute;
    transform: translate(-50%, -50%);
    z-index: 2;
    cursor: pointer;
    transition: transform 0.25s cubic-bezier(0.175,0.885,0.32,1.275),
                filter 0.25s ease,
                opacity 0.3s ease;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: #fff;
    user-select: none;
    gap: 4px;
}

/* CORE NODE */
.node-core {
    width: 96px; height: 96px;
    border-radius: 50%;
    background: radial-gradient(circle at 35% 35%, #2a1a4a, #0d0515);
    border: 2px solid rgba(188,19,254,0.8);
    box-shadow: 0 0 30px rgba(188,19,254,0.3), inset 0 0 20px rgba(188,19,254,0.1);
}

/* STAT NODE */
.node-stat {
    width: 58px; height: 58px;
    border-radius: 50%;
    background: radial-gradient(circle at 35% 35%, #111a2a, #050a12);
    border: 1.5px solid rgba(0,150,200,0.5);
    box-shadow: 0 0 12px rgba(0,150,200,0.1);
}

/* UNLOCK NODE ‚Äî octagon */
.node-unlock {
    width: 82px; height: 82px;
    background: radial-gradient(circle at 35% 35%, #1a1a0a, #0a0a05);
    clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);
    border: none;
    box-shadow: none;
}
.node-unlock::before {
    content: "";
    position: absolute;
    inset: 2px;
    background: radial-gradient(circle at 35% 35%, #1a1500, #090900);
    clip-path: polygon(30% 0%, 70% 0%, 100% 30%, 100% 70%, 70% 100%, 30% 100%, 0% 70%, 0% 30%);
    z-index: -1;
}

/* --- NODE STATES --- */

/* LOCKED */
.skill-node.locked {
    opacity: 0.35;
    filter: grayscale(100%) brightness(0.5);
    pointer-events: none;
}
.skill-node.locked.available {
    opacity: 0.65;
    filter: grayscale(60%) brightness(0.7);
    pointer-events: auto;
}

/* AVAILABLE (has parent, can buy) */
.skill-node.available {
    opacity: 1;
    filter: none;
}
.node-core.available, .node-stat.available {
    animation: pulseAvailable 2.5s infinite;
}
.node-unlock.available {
    animation: pulseAvailableHex 2.5s infinite;
}
@keyframes pulseAvailable {
    0%,100% { box-shadow: 0 0 8px rgba(255,200,50,0.2), inset 0 0 8px rgba(255,200,50,0.05); border-color: rgba(255,200,50,0.4); }
    50%      { box-shadow: 0 0 22px rgba(255,200,50,0.6), inset 0 0 12px rgba(255,200,50,0.15); border-color: rgba(255,200,50,0.9); }
}
@keyframes pulseAvailableHex {
    0%,100% { filter: drop-shadow(0 0 4px rgba(255,200,50,0.3)); }
    50%      { filter: drop-shadow(0 0 14px rgba(255,200,50,0.8)); }
}

/* PURCHASED */
.node-core.purchased {
    background: radial-gradient(circle at 35% 35%, #3a1060, #1a0540);
    border-color: #bc13fe;
    box-shadow: 0 0 30px rgba(188,19,254,0.5), 0 0 60px rgba(188,19,254,0.2), inset 0 0 20px rgba(188,19,254,0.2);
    animation: corePurchasedPulse 3s infinite;
}
@keyframes corePurchasedPulse {
    0%,100% { box-shadow: 0 0 25px rgba(188,19,254,0.4), inset 0 0 15px rgba(188,19,254,0.15); }
    50%      { box-shadow: 0 0 45px rgba(188,19,254,0.7), inset 0 0 25px rgba(188,19,254,0.3); }
}
.node-stat.purchased {
    background: radial-gradient(circle at 35% 35%, #0a2a40, #020d18);
    border-color: #00f3ff;
    box-shadow: 0 0 18px rgba(0,243,255,0.4), inset 0 0 10px rgba(0,243,255,0.1);
}
.node-unlock.purchased {
    background: radial-gradient(circle at 35% 35%, #2a1800, #100a00);
    filter: drop-shadow(0 0 12px rgba(255,160,0,0.7));
}

/* HOVER */
.skill-node:not(.locked):hover {
    transform: translate(-50%, -50%) scale(1.18);
    z-index: 100;
}
.node-core:not(.locked):hover    { filter: brightness(1.3); }
.node-stat:not(.locked):hover    { filter: brightness(1.4); }
.node-unlock:not(.locked):hover  { filter: brightness(1.3) drop-shadow(0 0 10px rgba(255,160,0,0.6)); }

/* --- NODE LABEL --- */
.node-label {
    font-size: 8px;
    color: rgba(200,200,220,0.7);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    text-align: center;
    max-width: 70px;
    line-height: 1.2;
    position: absolute;
    bottom: -18px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    pointer-events: none;
}
.node-core .node-label { bottom: -20px; font-size: 9px; color: rgba(220,200,255,0.8); }

/* --- TOOLTIP --- */
#st-tooltip {
    position: fixed;
    background: rgba(4,4,12,0.97);
    border: 1px solid rgba(0,243,255,0.3);
    padding: 0;
    width: 280px;
    pointer-events: none;
    z-index: 9999;
    display: none;
    clip-path: polygon(12px 0, 100% 0, 100% calc(100% - 12px), calc(100% - 12px) 100%, 0 100%, 0 12px);
    box-shadow: 0 0 40px rgba(0,0,0,0.8), 0 0 20px rgba(0,243,255,0.1);
}
#tt-header {
    background: linear-gradient(90deg, rgba(0,243,255,0.1), transparent);
    border-bottom: 1px solid rgba(0,243,255,0.2);
    padding: 12px 16px 10px;
    display: flex;
    align-items: center;
    gap: 10px;
}
#tt-icon-wrap {
    width: 32px; height: 32px;
    flex-shrink: 0;
}
#tt-title {
    margin: 0;
    color: #00f3ff;
    font-size: 13px;
    text-transform: uppercase;
    letter-spacing: 1.5px;
    font-family: 'Courier New', monospace;
}
#tt-type-badge {
    font-size: 9px;
    padding: 2px 6px;
    border-radius: 2px;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-top: 3px;
    display: inline-block;
}
.badge-core   { background: rgba(188,19,254,0.2); color: #d070ff; border: 1px solid rgba(188,19,254,0.3); }
.badge-stat   { background: rgba(0,200,255,0.15); color: #70d0ff; border: 1px solid rgba(0,200,255,0.3); }
.badge-unlock { background: rgba(255,160,0,0.15); color: #ffa030; border: 1px solid rgba(255,160,0,0.3); }
#tt-desc {
    padding: 12px 16px;
    color: #9aaabb;
    font-size: 12px;
    line-height: 1.6;
    margin: 0;
    border-bottom: 1px solid rgba(255,255,255,0.05);
}
#tt-footer {
    padding: 10px 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
#tt-cost {
    font-weight: bold;
    font-size: 14px;
    font-family: 'Courier New', monospace;
}
#tt-status {
    font-size: 10px;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: #555;
}

/* --- VOID TECH BUTTON --- */
.skill-btn {
    background: linear-gradient(135deg, #1a0b2e 0%, #000000 100%);
    border: 1px solid #9b59b6;
    color: #e0d0ff;
    font-family: 'Segoe UI', sans-serif;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-top: 15px;
    padding: 12px 24px;
    cursor: pointer;
    border-radius: 6px;
    box-shadow: 0 0 10px rgba(155,89,182,0.2);
    transition: all 0.3s ease;
    animation: voidPulse 3s infinite ease-in-out;
}
.skill-btn:hover {
    background: linear-gradient(135deg, #381a5c 0%, #0f0f15 100%);
    border-color: #be93d4;
    box-shadow: 0 0 20px rgba(155,89,182,0.6), inset 0 0 10px rgba(155,89,182,0.2);
    transform: translateY(-2px);
    text-shadow: 0 0 8px rgba(224,208,255,0.8);
}
.skill-btn:active { transform: translateY(1px); }
@keyframes voidPulse {
    0%,100% { box-shadow: 0 0 8px rgba(155,89,182,0.2); border-color: #7d3c98; }
    50%      { box-shadow: 0 0 18px rgba(155,89,182,0.5); border-color: #af7ac5; }
}

/* Lock overlay */
.tool-btn { position: relative; }
.tool-btn.is-locked::after {
    content: "üîí";
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.7);
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    border-radius: 8px;
    cursor: not-allowed;
    z-index: 10;
}
.tool-btn.is-locked img, .tool-btn.is-locked span { opacity: 0.3; }
    
/* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
   ACHIEVEMENTS OVERLAY
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */
#achievements-overlay {
    display: none;
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.92);
    backdrop-filter: blur(8px);
    z-index: 9000;
    justify-content: center;
    align-items: center;
    font-family: 'Segoe UI', sans-serif;
}
.ach-modal {
    width: 820px;
    max-height: 88vh;
    background: linear-gradient(160deg,#0e0e18 0%,#070710 100%);
    border: 1px solid #2a2a44;
    border-top: 3px solid #ffd700;
    border-radius: 10px;
    box-shadow: 0 0 60px rgba(255,215,0,0.15), 0 0 120px rgba(0,0,0,0.8);
    display: flex;
    flex-direction: column;
    overflow: hidden;
}
.ach-header {
    padding: 22px 30px 16px;
    border-bottom: 1px solid #1e1e2e;
    display: flex;
    justify-content: space-between;
    align-items: center;
    flex-shrink: 0;
}
.ach-header h2 {
    margin: 0;
    font-size: 22px;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 3px;
    color: #ffd700;
    text-shadow: 0 0 14px rgba(255,215,0,0.5);
}
.ach-header .ach-count {
    font-size: 13px;
    color: #666;
    letter-spacing: 1px;
}
.ach-close-btn {
    background: transparent;
    border: 1px solid #333;
    color: #888;
    font-size: 18px;
    width: 32px; height: 32px;
    border-radius: 4px;
    cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    transition: all 0.2s;
}
.ach-close-btn:hover { border-color: #ffd700; color: #ffd700; }
.ach-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 10px;
    padding: 20px 24px;
    overflow-y: auto;
    flex: 1;
}
.ach-grid::-webkit-scrollbar { width: 5px; }
.ach-grid::-webkit-scrollbar-thumb { background: #2a2a44; border-radius: 3px; }

.ach-item {
    display: flex;
    align-items: center;
    gap: 14px;
    padding: 12px 14px;
    border-radius: 8px;
    border: 1px solid #1a1a28;
    background: rgba(255,255,255,0.02);
    transition: border-color 0.2s;
    position: relative;
    overflow: hidden;
}
.ach-item.unlocked {
    border-color: #2a2a10;
    background: rgba(255,215,0,0.04);
}
.ach-item.unlocked::before {
    content: '';
    position: absolute;
    left: 0; top: 0; bottom: 0;
    width: 3px;
    background: #ffd700;
    box-shadow: 0 0 8px #ffd700;
}
.ach-item.locked { opacity: 0.45; }
.ach-icon {
    font-size: 28px;
    width: 38px; height: 38px;
    display: flex; align-items: center; justify-content: center;
    flex-shrink: 0;
}
.ach-item.locked .ach-icon { filter: grayscale(1); opacity: 0.4; }
.ach-text { flex: 1; min-width: 0; }
.ach-name {
    font-size: 13px;
    font-weight: bold;
    color: #ddd;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin-bottom: 3px;
}
.ach-item.unlocked .ach-name { color: #ffd700; }
.ach-desc {
    font-size: 11px;
    color: #555;
    line-height: 1.35;
}
.ach-item.unlocked .ach-desc { color: #888; }
.ach-check {
    font-size: 16px;
    flex-shrink: 0;
    color: #ffd700;
    text-shadow: 0 0 6px #ffd700;
}
/* Rarity stripe on unlocked */
.ach-item[data-rarity="hard"].unlocked::before   { background: #ff6600; box-shadow: 0 0 8px #ff6600; }
.ach-item[data-rarity="hard"].unlocked           { border-color: #331800; background: rgba(255,102,0,0.04); }
.ach-item[data-rarity="hard"].unlocked .ach-name { color: #ff8844; }
.ach-item[data-rarity="hard"].unlocked .ach-check{ color: #ff6600; text-shadow: 0 0 6px #ff6600; }

.ach-item[data-rarity="legendary"].unlocked::before  { background: linear-gradient(#ff0080,#ff6600); }
.ach-item[data-rarity="legendary"].unlocked          { border-color: #3a0020; background: rgba(255,0,100,0.05); }
.ach-item[data-rarity="legendary"].unlocked .ach-name{ color: #ff66aa; text-shadow: 0 0 8px rgba(255,0,100,0.5); }
.ach-item[data-rarity="legendary"].unlocked .ach-check{ color: #ff66aa; }

/* Toast notification for achievement unlock */
#ach-toast {
    position: fixed;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%) translateY(80px);
    background: linear-gradient(135deg,#1a1a10,#0e0e06);
    border: 1px solid #ffd700;
    border-left: 4px solid #ffd700;
    box-shadow: 0 0 30px rgba(255,215,0,0.25);
    border-radius: 8px;
    padding: 12px 20px;
    display: flex;
    align-items: center;
    gap: 12px;
    z-index: 99999;
    font-family: 'Segoe UI', sans-serif;
    transition: transform 0.4s cubic-bezier(.175,.885,.32,1.275);
    pointer-events: none;
    min-width: 280px;
}
#ach-toast.show { transform: translateX(-50%) translateY(0); }
#ach-toast .toast-icon { font-size: 24px; }
#ach-toast .toast-label { font-size: 10px; color: #ffd700; text-transform: uppercase; letter-spacing: 2px; }
#ach-toast .toast-name  { font-size: 14px; font-weight: bold; color: #fff; margin-top: 2px; }

/* menu-btn variant for achievements */
.achieve-btn {
    background: linear-gradient(135deg,#1a1200 0%,#000000 100%);
    border: 1px solid #ffd700;
    color: #ffd700;
    font-family: 'Segoe UI', sans-serif;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 1px;
    margin-top: 10px;
    padding: 12px 24px;
    cursor: pointer;
    border-radius: 6px;
    box-shadow: 0 0 10px rgba(255,215,0,0.15);
    transition: all 0.3s ease;
    animation: goldPulse 3s infinite ease-in-out;
}
.achieve-btn:hover {
    background: linear-gradient(135deg,#332200 0%,#0e0e00 100%);
    border-color: #ffe066;
    box-shadow: 0 0 20px rgba(255,215,0,0.45), inset 0 0 10px rgba(255,215,0,0.1);
    transform: translateY(-2px);
    text-shadow: 0 0 8px rgba(255,215,0,0.8);
}
.achieve-btn:active { transform: translateY(1px); }
@keyframes goldPulse {
    0%,100% { box-shadow: 0 0 8px rgba(255,215,0,0.15); border-color: #b8860b; }
    50%      { box-shadow: 0 0 18px rgba(255,215,0,0.4); border-color: #ffd700; }
}

</style>
</head>
<body>

    <div id="main-menu">
    <h1>SWARM DEFENSE</h1>
    <p>System Initialized. Select Combat Simulation Level.</p>
    <div class="difficulty-container">
        
        <div class="diff-card card-easy" onclick="startGame('easy')">
            <div class="icon">
                <svg viewBox="0 0 24 24"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.12-3.28 7.79-7 8.94V12H5V6.3l7-3.11v8.8z"/></svg>
            </div>
            <div class="title">Recruit</div>
            <div class="stats">Enemy HP x0.5</div>
            <div class="desc">For new commanders. Enemies are weak and fall easily.</div>
        </div>

        <div class="diff-card card-medium" onclick="startGame('medium')">
            <div class="icon">
                <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v4h-2zm0 6h2v4h-2z"/></svg>
            </div>
            <div class="title">Soldier</div>
            <div class="stats">Enemy HP x1.0</div>
            <div class="desc">The standard experience. Balanced tactical combat.</div>
        </div>

        <div class="diff-card card-hard" onclick="startGame('hard')">
            <div class="icon">
                <svg viewBox="0 0 24 24"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>
            </div>
            <div class="title">Veteran</div>
            <div class="stats">Enemy HP x2.0</div>
            <div class="desc">Enemies are tough. Optimal layouts required to survive.</div>
        </div>

        <div class="diff-card card-extreme" onclick="startGame('extreme')">
            <div class="icon">
                <svg viewBox="0 0 24 24"><path d="M12 2c-4.97 0-9 4.03-9 9 0 4.97 9 13 9 13s9-8.03 9-13c0-4.97-4.03-9-9-9zm0 16c-1.1 0-2-.9-2-2h4c0 1.1-.9 2-2 2zm6-6c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-4 0c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-4 0c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-4 0c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"/></svg>
            </div>
            <div class="title">Nightmare</div>
            <div class="stats">Enemy HP x3.0</div>
            <div class="desc">Massive health pools. One mistake means death.</div>
        </div>

        <div class="diff-card card-creative" onclick="startGame('creative')">
            <div class="icon">
                <svg viewBox="0 0 24 24"><path d="M22.7 19l-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4z"/></svg>
            </div>
            <div class="title">Sandbox</div>
            <div class="stats">Infinite Money</div>
            <div class="desc">Test your defenses with unlimited resources.</div>
        </div>
    </div>
    <button class="menu-btn skill-btn" onclick="openSkillTree()">Void Tech (Skills)</button>
    <button class="menu-btn achieve-btn" onclick="openAchievements()">Achievements</button>
</div>

<div id="ui">
    <div class="hud-panel">
        <div class="stats-header">
            <h1>Swarm Defense V3</h1>
        </div>
        <div class="stats-grid">
            <span>HP: <span id="hp" class="stat-val" style="color:#0f0">100</span></span>
            <span>Wave: <span id="wave" class="stat-val">1</span></span>
            <span>Money: <span id="money" class="stat-val" style="color:gold">400</span></span>
            <span>Enemies: <span id="enemy-count" class="stat-val">0</span></span>
        </div>
    </div>
    
    <div class="hud-panel controls"> <div class="tab-nav">
            <button class="tab-btn active-tab" onclick="openTab(event, 'defense')">Defense</button>
            <button class="tab-btn" onclick="openTab(event, 'attack')">Attack</button>
            <button class="tab-btn" onclick="openTab(event, 'economy')">Economy</button>
        </div>

        <div id="tab-defense" class="tab-content active-content">
            <button id="btn-wall" class="tool-btn active" onclick="setTool('wall')">
                <span class="btn-label">Titan Wall</span>
                <span class="btn-cost">$10</span>
                <span class="btn-hotkey">[1]</span>
            </button>
            <button id="btn-cryo" class="tool-btn" onclick="setTool('cryo_tower')">
                <span class="btn-label">Cryo Tower</span>
                <span class="btn-cost">$100</span>
                <span class="btn-hotkey">[0]</span>
            </button>
            <button id="btn-trap" class="tool-btn" onclick="setTool('trap')">
                <span class="btn-label">Spike Trap</span>
                <span class="btn-cost">$40</span>
                <span class="btn-hotkey">[6]</span>
            </button>
            <button id="btn-bard" class="tool-btn" onclick="setTool('bard_troop')">
                <span class="btn-label">Bard</span>
                <span class="btn-cost">$100</span>
                <span class="btn-hotkey">[B]</span>
            </button>
            <button id="btn-sucker" class="tool-btn" onclick="setTool('sucker')">
                <span class="btn-label">Sucker Tower</span>
                <span class="btn-cost">$150</span>
                <span class="btn-hotkey">[V]</span>
            </button>
            <button id="btn-tripwire" class="tool-btn" onclick="setTool('tripwire')">
                <span class="btn-label">Tripwire Pylon</span>
                <span class="btn-cost">$60</span>
                <span class="btn-hotkey">[P]</span>
            </button>
        </div>

        <div id="tab-attack" class="tab-content">
            <button id="btn-troop" class="tool-btn" onclick="setTool('troop')">
                <span class="btn-label">Soldier</span>
                <span class="btn-cost">$10</span>
                <span class="btn-hotkey">[2]</span>
            </button>
            <button id="btn-sword" class="tool-btn" onclick="setTool('sword_troop')">
                <span class="btn-label">Sword Soldier</span>
                <span class="btn-cost">$50</span>
                <span class="btn-hotkey">[9]</span>
            </button>
            <button id="btn-shield" class="tool-btn" onclick="setTool('shield_troop')">
                <span class="btn-label">Shield Guard</span>
                <span class="btn-cost">$75</span>
                <span class="btn-hotkey">[S]</span>
            </button>
            <button id="btn-barracks" class="tool-btn" onclick="setTool('barracks')">
                <span class="btn-label">Barracks</span>
                <span class="btn-cost">$200</span>
                <span class="btn-hotkey">[3]</span>
            </button>
            <button id="btn-wallturret" class="tool-btn" onclick="setTool('wall_turret')">
                <span class="btn-label">Wall Turret</span>
                <span class="btn-cost">$150</span>
                <span class="btn-hotkey">[7]</span>
            </button>
            <button id="btn-mortar" class="tool-btn" onclick="setTool('mortar')">
                <span class="btn-label">Mortar</span>
                <span class="btn-cost">$200</span>
                <span class="btn-hotkey">[4]</span>
            </button>
            <button id="btn-minigun" class="tool-btn" onclick="setTool('minigun')">
                <span class="btn-label">Minigun</span>
                <span class="btn-cost">$400</span>
                <span class="btn-hotkey">[M]</span>
            </button>
            <button id="btn-flamethrower" class="tool-btn" onclick="setTool('flamethrower')">
                <span class="btn-label">Flamethrower</span>
                <span class="btn-cost">$350</span>
                <span class="btn-hotkey">[F]</span>
            </button>
            <button id="btn-tesla" class="tool-btn" onclick="setTool('tesla')">
                <span class="btn-label">Tesla Coil</span>
                <span class="btn-cost">$250</span>
                <span class="btn-hotkey">[T]</span>
            </button>
            <button id="btn-railgun" class="tool-btn" onclick="setTool('railgun')">
                <span class="btn-label">Titan Railgun</span>
                <span class="btn-cost">$1500</span>
                <span class="btn-hotkey">[A]</span>
            </button>
        </div>

        <div id="tab-economy" class="tab-content">
            <button id="btn-farm" class="tool-btn" onclick="setTool('money_farm')">
                <span class="btn-label">Money Farm</span>
                <span class="btn-cost">$350</span>
                <span class="btn-hotkey">[8]</span>
            </button>
            <button id="btn-bounty" class="tool-btn" onclick="setTool('bounty')">
                <span class="btn-label">Bounty Tower</span>
                <span class="btn-cost">$150</span>
                <span class="btn-hotkey">[Y]</span>
            </button>
            <button id="btn-drill" class="tool-btn" onclick="setTool('drill')">
                <span class="btn-label">‚õèÔ∏è Drill</span>
                <span class="btn-cost">$500</span>
                <span class="btn-hotkey">[D]</span>
            </button>
            <button id="btn-delete" class="tool-btn btn-delete" onclick="setTool('delete')">
                <span class="btn-label">Salvage</span>
                <span class="btn-cost">+50% Refund</span>
                <span class="btn-hotkey">[5]</span>
            </button>
        </div>

        <div style="font-size: 11px; color: #666; margin-top: 10px; text-align: center;">
            Press <strong>'R'</strong> to Rotate
        </div>
    </div>
</div>


    <div id="game-over">
    <div class="game-over-card">
        <h1>CRITICAL FAILURE</h1>
        <div class="sub-text">Base Integrity: 0%</div>
        
        <div class="stat-box">
            <span class="stat-label">Waves Survived</span>
            <span id="final-wave">0</span>
        </div>

        <button class="retry-btn" onclick="location.reload()">
            Initialize Reboot
        </button>
    </div>
</div>

    <div id="pause-menu" style="display: none;">
        <h1>PAUSED</h1>
        <div class="pause-buttons">
            <button class="pause-btn" onclick="togglePause()">RESUME</button>
            <button class="pause-btn" onclick="restartGame()">RESTART</button>
            <button class="pause-btn" onclick="goToMainMenu()">MAIN MENU</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="enemy-intro-overlay">
    <div class="intro-card">
        <div class="intro-header">
            <div class="intro-title" id="intro-name">UNKNOWN ENTITY</div>
            <div class="intro-sub">NEW INTEL ACQUIRED</div>
        </div>

        <div class="intro-content">
            <canvas id="enemy-preview-canvas" width="250" height="250"></canvas>

            <div class="intro-details">
                <div id="intro-stats"></div>
            </div>
        </div>

        <div class="lore-text" id="intro-lore">
            Analyzing biological structure...
        </div>

        <button class="continue-btn" onclick="closeEnemyIntro()">RESUME DEFENSE</button>
    </div>
</div>
<div id="skill-tree-overlay">
    
    <div class="st-header">
        <div class="st-title">VOID RESEARCH</div>
        <div class="st-currency">
            <span>üü£</span> 
            <span id="st-shard-count">0</span> 
            <span style="font-size: 14px; color: #888; margin-left:5px;">Shards</span>
        </div>
        <button class="st-close-btn" onclick="closeSkillTree()">CLOSE</button>
    </div>

    <div id="st-viewport">
        <div id="st-world">
            
            <svg id="st-connections"></svg>
            
            </div>
    </div>

    <div id="st-tooltip">
        <div id="tt-header">
            <canvas id="tt-icon-wrap" width="32" height="32"></canvas>
            <div>
                <h3 id="tt-title">Skill Name</h3>
                <span id="tt-type-badge" class="badge-core">CORE</span>
            </div>
        </div>
        <p id="tt-desc">Description text...</p>
        <div id="tt-footer">
            <div id="tt-cost">üí† 100 Shards</div>
            <div id="tt-status">LOCKED</div>
        </div>
    </div>

</div>
<script>

    /* --- SKILL TREE SYSTEM --- */

    // --- SKILL TREE BACKGROUND ANIMATION ---
// --- SKILL TREE BACKGROUND: NEURAL CONSTELLATION ---
let stCanvas, stCtx;
let stAnimFrame;
let stParticles = [];
const PARTICLE_COUNT = 70;
const CONNECTION_DIST = 150;
const MOUSE_DIST = 200;

// Track mouse relative to canvas
let stMouse = { x: null, y: null };

function initSkillTreeBackground() {
    let container = document.getElementById('skill-tree-overlay');
    
    // 1. Force container transparency so canvas shows
    container.style.background = "transparent"; 

    // 2. Create or Reset Canvas
    if (!document.getElementById('st-bg-canvas')) {
        stCanvas = document.createElement('canvas');
        stCanvas.id = 'st-bg-canvas';
        stCanvas.style.position = 'absolute';
        stCanvas.style.top = '0';
        stCanvas.style.left = '0';
        stCanvas.style.width = '100%';
        stCanvas.style.height = '100%';
        stCanvas.style.zIndex = '-1'; 
        container.insertBefore(stCanvas, container.firstChild);
        
        stCtx = stCanvas.getContext('2d');

        // Mouse Listeners for interactive background
        container.addEventListener('mousemove', function(e) {
            stMouse.x = e.clientX;
            stMouse.y = e.clientY;
        });
        container.addEventListener('mouseleave', function() {
            stMouse.x = null;
            stMouse.y = null;
        });
    }

    // 3. Initialize Particles
    resizeCanvas(); // Set initial size
    stParticles = [];
    for(let i=0; i < PARTICLE_COUNT; i++) {
        stParticles.push(new NetworkParticle());
    }
    
    // 4. Start Loop
    window.addEventListener('resize', resizeCanvas);
    if (stAnimFrame) cancelAnimationFrame(stAnimFrame);
    animateSkillTreeBg();
}

function resizeCanvas() {
    if(!stCanvas) return;
    stCanvas.width = window.innerWidth;
    stCanvas.height = window.innerHeight;
}

class NetworkParticle {
    constructor() {
        this.x = Math.random() * window.innerWidth;
        this.y = Math.random() * window.innerHeight;
        this.vx = (Math.random() - 0.5) * 1.5; // Random velocity X
        this.vy = (Math.random() - 0.5) * 1.5; // Random velocity Y
        this.size = Math.random() * 2 + 1;
        // Randomly assign colors based on your CSS variables
        this.color = Math.random() > 0.5 ? "#00f3ff" : "#bc13fe"; 
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;

        // Bounce off edges
        if (this.x < 0 || this.x > stCanvas.width) this.vx *= -1;
        if (this.y < 0 || this.y > stCanvas.height) this.vy *= -1;

        // Mouse Interaction: Flee from mouse slightly
        if (stMouse.x != null) {
            let dx = stMouse.x - this.x;
            let dy = stMouse.y - this.y;
            let distance = Math.sqrt(dx*dx + dy*dy);
            if (distance < MOUSE_DIST) {
                const forceDirectionX = dx / distance;
                const forceDirectionY = dy / distance;
                const force = (MOUSE_DIST - distance) / MOUSE_DIST;
                this.vx -= forceDirectionX * force * 0.05;
                this.vy -= forceDirectionY * force * 0.05;
            }
        }
    }

    draw() {
        stCtx.beginPath();
        stCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        stCtx.fillStyle = this.color;
        stCtx.fill();
    }
}

function animateSkillTreeBg() {
    if (document.getElementById('skill-tree-overlay').style.display === 'none') return;

    stCtx.clearRect(0, 0, stCanvas.width, stCanvas.height);
    
    // 1. Draw Subtle Background Gradient
    let grad = stCtx.createRadialGradient(stCanvas.width/2, stCanvas.height/2, 0, stCanvas.width/2, stCanvas.height/2, stCanvas.width);
    grad.addColorStop(0, "#0a0f1e"); // Dark Blue Center
    grad.addColorStop(1, "#000000"); // Black Edges
    stCtx.fillStyle = grad;
    stCtx.fillRect(0, 0, stCanvas.width, stCanvas.height);

    // 2. Update and Draw Particles
    stParticles.forEach(p => {
        p.update();
        p.draw();
    });

    // 3. Draw Connections
    connectParticles();

    stAnimFrame = requestAnimationFrame(animateSkillTreeBg);
}

function connectParticles() {
    for (let a = 0; a < stParticles.length; a++) {
        for (let b = a; b < stParticles.length; b++) {
            let dx = stParticles[a].x - stParticles[b].x;
            let dy = stParticles[a].y - stParticles[b].y;
            let distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < CONNECTION_DIST) {
                // Opacity based on distance (closer = brighter)
                let opacity = 1 - (distance / CONNECTION_DIST);
                stCtx.strokeStyle = `rgba(0, 243, 255, ${opacity * 0.2})`; // Neon Blue Lines
                stCtx.lineWidth = 1;
                stCtx.beginPath();
                stCtx.moveTo(stParticles[a].x, stParticles[a].y);
                stCtx.lineTo(stParticles[b].x, stParticles[b].y);
                stCtx.stroke();
            }
        }
        
        // Connect to mouse
        if (stMouse.x != null) {
            let dx = stParticles[a].x - stMouse.x;
            let dy = stParticles[a].y - stMouse.y;
            let distance = Math.sqrt(dx*dx + dy*dy);
            if (distance < MOUSE_DIST) {
                let opacity = 1 - (distance / MOUSE_DIST);
                stCtx.strokeStyle = `rgba(188, 19, 254, ${opacity * 0.4})`; // Neon Purple for Mouse
                stCtx.beginPath();
                stCtx.moveTo(stParticles[a].x, stParticles[a].y);
                stCtx.lineTo(stMouse.x, stMouse.y);
                stCtx.stroke();
            }
        }
    }
}

    const skillData = {
    // =========================================
    // --- CENTER: CORE (Base Upgrades) ---
    // =========================================
    "core_vitality": { 
        name: "Core Vitality", desc: "Base starts with +50 Max HP.", 
        cost: 5, type: "core", x: 0, y: 0, parent: null 
    },
    "core_regen": { 
        name: "Nano-Repair", desc: "Base regenerates 1 HP every 5 seconds.", 
        cost: 100, type: "stat", x: 0, y: 150, parent: "core_vitality" 
    },

    // =========================================
    // --- NORTH: INFANTRY (Sword, Shield, Bard) ---
    // =========================================
    
    // --- Branch 1: Sword ---
    "unlock_sword": {
        name: "UNLOCK: Sword Soldier", desc: "Basic melee unit.",
        cost: 15, type: "unlock", x: 0, y: -150, parent: "core_vitality"
    },
    "sword_dmg": {
        name: "Sharpened Blades", desc: "Sword Soldiers deal +20 Damage.",
        cost: 25, type: "stat", x: -120, y: -160, parent: "unlock_sword"
    },
    "sword_atk_spd": {
        name: "Frenzy Stance", desc: "Sword Soldiers attack 15% faster.",
        cost: 45, type: "stat", x: -140, y: -250, parent: "unlock_sword"
    },
    "sword_move_spd": {
        name: "Lightweight Boots", desc: "Sword Soldiers move 20% faster.",
        cost: 30, type: "stat", x: -80, y: -300, parent: "unlock_sword"
    },

    // --- Branch 2: Shield ---
    "unlock_shield": {
        name: "UNLOCK: Shield Guard", desc: "High HP tank unit.",
        cost: 30, type: "unlock", x: 80, y: -220, parent: "unlock_sword"
    },
    "shield_hp": {
        name: "Titan Armor", desc: "Shield Guards get +200 Max HP.",
        cost: 40, type: "stat", x: 140, y: -280, parent: "unlock_shield"
    },

    // --- Branch 3: Bard ---
    "unlock_bard": {
        name: "UNLOCK: Bard", desc: "Lures enemies away from the base.",
        cost: 50, type: "unlock", x: 0, y: -300, parent: "unlock_sword"
    },
    "bard_range": {
        name: "Louder Music", desc: "Bard lure range increased by 30%.",
        cost: 60, type: "stat", x: -40, y: -380, parent: "unlock_bard"
    },
    "bard_durability": {
        name: "Stage Presence", desc: "Bards have +100 Max HP.",
        cost: 40, type: "stat", x: 40, y: -380, parent: "unlock_bard"
    },

    // =========================================
    // --- WEST: DEFENSE (Turret, Cryo, Spikes) ---
    // =========================================

    // --- Branch 1: Wall Turret ---
    "unlock_wall_turret": {
        name: "UNLOCK: Wall Turret", desc: "Basic defensive tower.",
        cost: 15, type: "unlock", x: -150, y: 0, parent: "core_vitality"
    },
    "turret_fire_rate": {
        name: "Rapid Loader", desc: "Wall Turret fires 20% faster.",
        cost: 30, type: "stat", x: -240, y: -80, parent: "unlock_wall_turret"
    },
    "turret_range": {
        name: "Sniper Lens", desc: "Wall Turret range +40%.",
        cost: 45, type: "stat", x: -150, y: -90, parent: "unlock_wall_turret"
    },
    "turret_dmg": {
        name: "Depleted Uranium", desc: "Wall Turret deals +15 Damage.",
        cost: 50, type: "stat", x: -80, y: -100, parent: "unlock_wall_turret"
    },

    // --- Branch 2: Spikes ---
    "unlock_spikes": {
        name: "UNLOCK: Spike Trap", desc: "Damages enemies walking over it.",
        cost: 25, type: "unlock", x: -240, y: 60, parent: "unlock_wall_turret"
    },
    "spike_dmg": {
        name: "Serrated Tips", desc: "Spikes deal +50% Damage.",
        cost: 40, type: "stat", x: -320, y: 100, parent: "unlock_spikes"
    },

    // --- Branch 3: Cryo Tower ---
    "unlock_cryo": {
        name: "UNLOCK: Cryo Tower", desc: "Slows enemies.",
        cost: 45, type: "unlock", x: -350, y: -20, parent: "unlock_wall_turret"
    },
    "cryo_range": {
        name: "High Pressure", desc: "Cryo Tower range +25%.",
        cost: 60, type: "stat", x: -500, y: -60, parent: "unlock_cryo"
    },
    "cryo_slow": {
        name: "Absolute Zero", desc: "Cryo slows enemies by an extra 15%.",
        cost: 80, type: "stat", x: -470, y: 20, parent: "unlock_cryo"
    },

    // =========================================
    // --- EAST: HEAVY & ECO (Farm, Barracks, Heavy) ---
    // =========================================

    // --- Branch 1: Economy (Farm) ---
    "unlock_farm": {
        name: "UNLOCK: Money Farm", desc: "Generates cash at end of wave.",
        cost: 20, type: "unlock", x: 150, y: 0, parent: "core_vitality"
    },
    "farm_val": {
        name: "Market Stocks", desc: "Farms give +$25 extra per wave.",
        cost: 35, type: "stat", x: 150, y: -110, parent: "unlock_farm"
    },
    "farm_cap": {
        name: "Offshore Accounts", desc: "Farms give another +$25 extra per wave.",
        cost: 70, type: "stat", x: 250, y: -110, parent: "unlock_farm"
    },

    // --- Branch 2: Barracks ---
    "unlock_barracks": {
        name: "UNLOCK: Barracks", desc: "Auto-spawns soldiers.",
        cost: 40, type: "unlock", x: 150, y: 100, parent: "unlock_farm"
    },
    "barracks_speed": {
        name: "Drill Sergeant", desc: "Barracks spawn units 20% faster.",
        cost: 60, type: "stat", x: 100, y: 200, parent: "unlock_barracks"
    },

    // --- Branch 3: Minigun ---
    "unlock_minigun": {
        name: "UNLOCK: Minigun", desc: "Fast fire rate, small damage.",
        cost: 60, type: "unlock", x: 400, y: -40, parent: "unlock_farm"
    },
    "minigun_dmg": {
        name: "Lubricated Barrels", desc: "Minigun does +2 Damage per shot.",
        cost: 70, type: "stat", x: 450, y: -140, parent: "unlock_minigun"
    },
    "minigun_speed": {
        name: "Motor Overdrive", desc: "Minigun attack speed is 15% faster.",
        cost: 80, type: "stat", x: 350, y: -170, parent: "unlock_minigun"
    },

    // --- Branch 4: Mortar ---
    "unlock_mortar": {
        name: "UNLOCK: Mortar", desc: "Long range AoE damage.",
        cost: 70, type: "unlock", x: 300, y: 70, parent: "unlock_farm"
    },
    "mortar_dmg": {
        name: "High Explosive", desc: "Mortar deals +30 Damage.",
        cost: 80, type: "stat", x: 370, y: 140, parent: "unlock_mortar"
    },
    "mortar_area": {
        name: "Napalm Shells", desc: "Mortar explosion radius +25%.",
        cost: 100, type: "stat", x: 300, y: 200, parent: "unlock_mortar"
    },

    // --- Branch 5: Sucker ---
    "unlock_sucker": {
        name: "UNLOCK: Sucker", desc: "Medium range support tower.",
        cost: 60, type: "unlock", x: -350, y: -150, parent: "unlock_cryo"
    },
    "sucker_area": {
        name: "Bigger ventilator", desc: "Sucker gains 15% range",
        cost: 40, type: "stat", x: -450, y: -200, parent: "unlock_sucker"
    },
    "sucker_strenght": {
        name: "Stronger engine", desc: "Sucker sucks 10% more",
        cost: 50, type: "stat", x: -250, y: -200, parent: "unlock_sucker"
    },

    // --- Branch: Wall Regeneration ---
    "wall_regen": {
        name: "Nano-Mortar", desc: "Damaged walls slowly regenerate HP over time. Fully destroyed walls are NOT repaired.",
        cost: 150, type: "stat", x: -80, y: 110, parent: "unlock_wall_turret"
    },

    // --- Branch 6: Tesla ---
    "unlock_tesla": {
        name: "UNLOCK: Tesla", desc: "Medium range chain tower.",
        cost: 100, type: "unlock", x: -150, y: 150, parent: "unlock_wall_turret"
    },
    "tesla_chain": {
        name: "Better power suply", desc: "Tesla gains 2 more chains",
        cost: 80, type: "stat", x: -230, y: 200, parent: "unlock_tesla"
    },
    "tesla_range": {
        name: "Improved materials", desc: "Tesla gains 20% more range",
        cost: 70, type: "stat", x: -70, y: 200, parent: "unlock_tesla"
    },

    // --- Branch 6: Railgun ---
    "unlock_railgun": {
        name: "UNLOCK: Railgun", desc: "Endgame devastating ray of death",
        cost: 1000, type: "unlock", x: 600, y: -40, parent: "unlock_minigun"
    },
    "railgun_width": {
        name: "Better barrel mobility", desc: "Beam is 20% wider",
        cost: 300, type: "stat", x: 700, y: -90, parent: "unlock_railgun"
    },
    "railgun_damage": {
        name: "Railgun overdrive", desc: "Railgun does 50% more damage",
        cost: 700, type: "stat", x: 700, y: 10, parent: "unlock_railgun"
    }
};

// --- CUSTOM SKILL ICON RENDERER ---
function drawSkillIcon(canvas, skillIdentifier) {
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height;
    const cx = w / 2, cy = h / 2;
    const s = w / 50;

    ctx.clearRect(0, 0, w, h);
    ctx.save();
    ctx.translate(cx, cy);
    ctx.lineCap = "round";
    ctx.lineJoin = "round";

    const id = (skillIdentifier || "").toLowerCase();
    const lw = (n) => { ctx.lineWidth = n * s; };
    const arc = (x, y, r, start=0, end=Math.PI*2) => { ctx.beginPath(); ctx.arc(x*s, y*s, r*s, start, end); };
    const stroke = (col) => { ctx.strokeStyle = col; ctx.stroke(); };
    const fill   = (col) => { ctx.fillStyle = col; ctx.fill(); };
    const line   = (x1,y1,x2,y2) => { ctx.beginPath(); ctx.moveTo(x1*s,y1*s); ctx.lineTo(x2*s,y2*s); };

    // === CORE / VITALITY (Glowing Heart) ===
    if (id.includes("core") || id.includes("vitality") || id.includes("hp")) {
        const hg = ctx.createRadialGradient(0,-2*s,0, 0,0,14*s);
        hg.addColorStop(0,"#ff6060"); hg.addColorStop(1,"#800000");
        ctx.beginPath();
        ctx.moveTo(0, 4*s);
        ctx.bezierCurveTo(0,-3*s,-13*s,-13*s,-13*s,-2*s);
        ctx.bezierCurveTo(-13*s,9*s,0,16*s,0,20*s);
        ctx.bezierCurveTo(0,16*s,13*s,9*s,13*s,-2*s);
        ctx.bezierCurveTo(13*s,-13*s,0,-3*s,0,4*s);
        fill(hg); lw(1.5); stroke("#ff4d4d");
        // shine
        ctx.beginPath(); ctx.ellipse(-4*s,-4*s,3*s,2*s,-0.5,0,Math.PI*2);
        fill("rgba(255,255,255,0.3)");
    }

    // === NANO-REPAIR / REGEN (Caduceus/Cross with arrow) ===
    else if (id.includes("regen") || id.includes("repair")) {
        lw(2.5);
        // Cross
        ctx.beginPath();
        ctx.moveTo(0,-14*s); ctx.lineTo(0,14*s);
        ctx.moveTo(-8*s,0); ctx.lineTo(8*s,0);
        stroke("#00ff88");
        // Circle arrows around it
        lw(1.5);
        ctx.beginPath(); ctx.arc(0,0,10*s,0.3, Math.PI*1.8);
        stroke("rgba(0,255,136,0.5)");
        // Arrow tip
        ctx.beginPath(); ctx.moveTo(-7*s,-8*s); ctx.lineTo(-10*s,-10*s); ctx.lineTo(-5*s,-11*s); ctx.closePath();
        fill("rgba(0,255,136,0.5)");
    }

    // === SWORD (Sharpened Blades) ===
    else if (id.includes("sword") || id.includes("blade") || id.includes("frenzy") || id.includes("boot")) {
        ctx.rotate(Math.PI/4);
        // Blade gradient
        const sg = ctx.createLinearGradient(-2*s,-16*s,2*s,8*s);
        sg.addColorStop(0,"#e8e8ff"); sg.addColorStop(1,"#88aacc");
        ctx.beginPath();
        ctx.moveTo(0,-16*s); ctx.lineTo(2*s,6*s); ctx.lineTo(0,8*s); ctx.lineTo(-2*s,6*s);
        ctx.closePath(); fill(sg); lw(1); stroke("#ccd");
        // Crossguard
        ctx.beginPath(); ctx.roundRect(-6*s,5*s,12*s,2.5*s,1*s); fill("#aabbcc"); lw(1); stroke("#889");
        // Handle
        ctx.beginPath(); ctx.roundRect(-2*s,7.5*s,4*s,8*s,1*s); fill("#654321"); stroke("#432");
        // Pommel
        arc(0,17,3); fill("#aabbcc"); stroke("#889");
    }

    // === SHIELD / ARMOR ===
    else if (id.includes("shield") || id.includes("armor") || id.includes("titan")) {
        const shg = ctx.createLinearGradient(0,-12*s,0,14*s);
        shg.addColorStop(0,"#2255aa"); shg.addColorStop(1,"#0a1a44");
        ctx.beginPath();
        ctx.moveTo(-11*s,-11*s); ctx.lineTo(11*s,-11*s);
        ctx.lineTo(11*s,2*s); ctx.quadraticCurveTo(0,17*s,-11*s,2*s);
        ctx.closePath(); fill(shg); lw(1.5); stroke("#4488ff");
        // Emblem cross
        lw(2); ctx.beginPath();
        ctx.moveTo(0,-7*s); ctx.lineTo(0,7*s);
        ctx.moveTo(-5*s,0); ctx.lineTo(5*s,0);
        stroke("rgba(150,200,255,0.7)");
        // Shine
        ctx.beginPath(); ctx.moveTo(-7*s,-9*s); ctx.lineTo(-5*s,-2*s); ctx.lineTo(-3*s,-9*s); ctx.closePath();
        fill("rgba(255,255,255,0.15)");
    }

    // === BARD (Music note with sparkles) ===
    else if (id.includes("bard") || id.includes("music") || id.includes("loud") || id.includes("stage")) {
        // Note
        ctx.beginPath(); ctx.ellipse(-5*s,9*s,4.5*s,3*s,-0.3,0,Math.PI*2);
        fill("#e040fb"); lw(1); stroke("#ab00cc");
        lw(2); ctx.beginPath(); ctx.moveTo(-1*s,9*s); ctx.lineTo(-1*s,-9*s);
        ctx.lineTo(9*s,-12*s); ctx.lineTo(9*s,-4*s); stroke("#e040fb");
        // Sparkles
        [[12,-8],[14,0],[10,4]].forEach(([x,y]) => {
            lw(1); ctx.beginPath();
            ctx.moveTo(x*s,(y-2)*s); ctx.lineTo(x*s,(y+2)*s);
            ctx.moveTo((x-2)*s,y*s); ctx.lineTo((x+2)*s,y*s);
            stroke("rgba(255,150,255,0.6)");
        });
    }

    // === TURRET ===
    else if (id.includes("turret") || id.includes("loader") || id.includes("sniper") || id.includes("uranium")) {
        // Base plate
        ctx.beginPath(); ctx.roundRect(-9*s,6*s,18*s,7*s,2*s);
        fill("#2a3a2a"); lw(1.5); stroke("#4a7a4a");
        // Dome
        const tg = ctx.createRadialGradient(-3*s,2*s,1*s,0,4*s,10*s);
        tg.addColorStop(0,"#3a6a3a"); tg.addColorStop(1,"#1a3a1a");
        ctx.beginPath(); ctx.arc(0,6*s,9*s,Math.PI,0);
        fill(tg); lw(1.5); stroke("#4a8a4a");
        // Barrel
        ctx.beginPath(); ctx.roundRect(-2*s,-14*s,4*s,14*s,1*s);
        fill("#1a2a1a"); lw(1); stroke("#3a6a3a");
        // Muzzle flash
        ctx.beginPath(); ctx.arc(0,-14*s,2.5*s,0,Math.PI*2);
        fill("rgba(100,255,100,0.3)");
    }

    // === SPIKES ===
    else if (id.includes("spike") || id.includes("serrated")) {
        const spikeFill = ctx.createLinearGradient(0,-12*s,0,6*s);
        spikeFill.addColorStop(0,"#cccccc"); spikeFill.addColorStop(1,"#555566");
        const drawSpike = (ox, oy, h) => {
            ctx.beginPath();
            ctx.moveTo((ox-4)*s,(oy+h*0.3)*s);
            ctx.lineTo(ox*s,(oy-h)*s);
            ctx.lineTo((ox+4)*s,(oy+h*0.3)*s);
            ctx.closePath();
            fill(spikeFill); lw(1); stroke("#999");
        };
        drawSpike(-9, 7, 14); drawSpike(0, 8, 16); drawSpike(9, 7, 14);
        // Base
        ctx.beginPath(); ctx.roundRect(-13*s,9*s,26*s,4*s,1*s);
        fill("#444455"); lw(1); stroke("#666");
    }

    // === CRYO / COLD / ZERO ===
    else if (id.includes("cryo") || id.includes("cold") || id.includes("zero") || id.includes("pressure")) {
        const cg = ctx.createRadialGradient(0,0,2*s,0,0,16*s);
        cg.addColorStop(0,"#aaffff"); cg.addColorStop(0.5,"#0088cc"); cg.addColorStop(1,"rgba(0,100,200,0)");
        ctx.beginPath(); ctx.arc(0,0,14*s,0,Math.PI*2); fill(cg);
        // Snowflake arms
        for (let i=0; i<6; i++) {
            ctx.save(); ctx.rotate(i*Math.PI/3);
            lw(2); ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(0,-12*s); stroke("#ccffff");
            lw(1); ctx.beginPath();
            ctx.moveTo(-3*s,-7*s); ctx.lineTo(0,-9*s); ctx.lineTo(3*s,-7*s);
            ctx.moveTo(-2*s,-5*s); ctx.lineTo(0,-7*s); ctx.lineTo(2*s,-5*s);
            stroke("rgba(180,240,255,0.8)");
            ctx.restore();
        }
        // Center
        arc(0,0,3); fill("#ffffff");
    }

    // === FARM / ECONOMY / STOCKS / OFFSHORE ===
    else if (id.includes("farm") || id.includes("val") || id.includes("stocks") || id.includes("offshore")) {
        // Coin stack
        for (let i=2; i>=0; i--) {
            const yoff = i * 3;
            const cng = ctx.createRadialGradient(-3*s,(-8+yoff)*s,1*s,0,(-6+yoff)*s,13*s);
            cng.addColorStop(0,"#ffe066"); cng.addColorStop(1,"#a07800");
            ctx.beginPath(); ctx.ellipse(0,(-6+yoff)*s,11*s,4*s,0,0,Math.PI*2);
            fill(cng); lw(1); stroke("#c8a000");
            // Side
            ctx.beginPath();
            ctx.moveTo(-11*s,(-6+yoff)*s); ctx.lineTo(-11*s,(-4+yoff)*s);
            ctx.ellipse(0,(-4+yoff)*s,11*s,4*s,0,Math.PI,0,true);
            ctx.lineTo(11*s,(-6+yoff)*s);
            fill("#8a6a00"); stroke("#a07800");
        }
        // $ symbol
        lw(2); ctx.beginPath();
        ctx.moveTo(0,-10*s); ctx.lineTo(0,2*s); stroke("#fff8");
        ctx.beginPath();
        ctx.moveTo(3*s,-8*s); ctx.bezierCurveTo(-3*s,-8*s,-3*s,-5*s,0,-5*s);
        ctx.bezierCurveTo(3*s,-5*s,3*s,-2*s,-3*s,-2*s);
        stroke("rgba(255,255,200,0.7)");
    }

    // === BARRACKS / DRILL ===
    else if (id.includes("barracks") || id.includes("drill")) {
        // Roof
        const rg = ctx.createLinearGradient(-12*s,-14*s,12*s,0);
        rg.addColorStop(0,"#cc4400"); rg.addColorStop(1,"#882200");
        ctx.beginPath();
        ctx.moveTo(-13*s,0); ctx.lineTo(0,-14*s); ctx.lineTo(13*s,0);
        ctx.closePath(); fill(rg); lw(1.5); stroke("#ff6600");
        // Walls
        const wg = ctx.createLinearGradient(0,0,0,14*s);
        wg.addColorStop(0,"#5a4a3a"); wg.addColorStop(1,"#3a2a1a");
        ctx.beginPath(); ctx.rect(-10*s,0,20*s,12*s); fill(wg); lw(1); stroke("#6a5a4a");
        // Door
        ctx.beginPath(); ctx.roundRect(-3.5*s,4*s,7*s,8*s,1*s);
        fill("#1a0f05"); stroke("#5a3a1a");
        // Window
        ctx.beginPath(); ctx.rect(-8*s,2*s,4*s,4*s);
        fill("rgba(100,200,255,0.3)"); stroke("#4a6a8a");
    }

    // === MINIGUN / OVERDRIVE / LUBRICATED ===
    else if (id.includes("minigun") || id.includes("lubricated") || id.includes("overdrive")) {
        // Rotating barrel cluster
        const barrelPositions = [[0,-5],[4.5,-2.5],[4.5,2.5],[0,5],[-4.5,2.5],[-4.5,-2.5]];
        barrelPositions.forEach(([bx,by]) => {
            ctx.beginPath(); ctx.ellipse(bx*s,by*s,2*s,5*s,Math.atan2(by,bx)+Math.PI/2,0,Math.PI*2);
            fill("#334455"); lw(1); stroke("#556677");
        });
        // Center ring
        arc(0,0,5); fill("#445566"); lw(2); stroke("#6688aa");
        arc(0,0,2); fill("#223344");
        // Muzzle glow
        arc(0,-5,1.5); fill("rgba(255,200,50,0.8)");
        barrelPositions.forEach(([bx,by]) => {
            arc(bx,by,1); fill("rgba(100,150,200,0.5)");
        });
    }

    // === MORTAR / EXPLOSIVE / NAPALM ===
    else if (id.includes("mortar") || id.includes("explosive") || id.includes("napalm") || id.includes("area")) {
        // Bomb
        const bg = ctx.createRadialGradient(-3*s,0,1*s,0,3*s,12*s);
        bg.addColorStop(0,"#334455"); bg.addColorStop(1,"#111a22");
        arc(0,4,10); fill(bg); lw(2); stroke("#445566");
        // Shine
        arc(-3,-1,2.5); fill("rgba(255,255,255,0.15)");
        // Fuse cord
        lw(2); ctx.beginPath();
        ctx.moveTo(3*s,-5*s); ctx.quadraticCurveTo(8*s,-12*s,12*s,-9*s); stroke("#cc8822");
        // Sparks
        [[12,-9],[13,-7],[11,-7]].forEach(([x,y]) => {
            arc(x,y,1.5); fill(Math.random()>0.5?"#ff4400":"#ffaa00");
        });
        // Explosion arcs
        lw(1); [[14,0],[10,-14],[0,-15]].forEach(([x,y]) => {
            ctx.beginPath(); ctx.arc(x*s,y*s,3*s,0,Math.PI*2); stroke("rgba(255,100,0,0.4)");
        });
    }

    // === SUCKER / VENTILATOR / ENGINE ===
    else if (id.includes("sucker") || id.includes("ventilator") || id.includes("suck")) {
        // Vortex rings
        for (let i=3; i>=1; i--) {
            const alpha = i === 3 ? 0.2 : i === 2 ? 0.4 : 0.7;
            lw(1.5); arc(0,0,i*5); ctx.strokeStyle=`rgba(80,180,255,${alpha})`; ctx.stroke();
        }
        // Fan blades
        for (let i=0; i<5; i++) {
            ctx.save(); ctx.rotate(i*Math.PI*2/5);
            const fg = ctx.createLinearGradient(0,0,0,-10*s);
            fg.addColorStop(0,"#3399cc"); fg.addColorStop(1,"rgba(0,150,255,0)");
            ctx.beginPath();
            ctx.moveTo(0,0); ctx.bezierCurveTo(4*s,-4*s,2*s,-10*s,-2*s,-12*s);
            ctx.bezierCurveTo(-4*s,-10*s,0,-5*s,0,0);
            fill(fg); ctx.restore();
        }
        // Center hub
        arc(0,0,3); fill("#1a3a55"); lw(2); stroke("#3399cc");
        // Center dot
        arc(0,0,1.2); fill("#00ccff");
    }

    // === TESLA / CHAIN / MATERIALS ===
    else if (id.includes("tesla") || id.includes("chain") || id.includes("power") || id.includes("material")) {
        // Lightning bolt
        const lg = ctx.createLinearGradient(4*s,-14*s,-4*s,14*s);
        lg.addColorStop(0,"#ffffff"); lg.addColorStop(0.4,"#88ddff"); lg.addColorStop(1,"#0066cc");
        ctx.beginPath();
        ctx.moveTo(4*s,-14*s); ctx.lineTo(-2*s,-2*s); ctx.lineTo(3*s,-2*s);
        ctx.lineTo(-4*s,14*s); ctx.lineTo(2*s,2*s); ctx.lineTo(-3*s,2*s);
        ctx.closePath(); fill(lg); lw(1); stroke("rgba(150,220,255,0.6)");
        // Glow arcs
        lw(1); [8,12,16].forEach(r => {
            ctx.beginPath(); ctx.arc(0,0,r*s,Math.PI*1.1,Math.PI*1.9);
            ctx.strokeStyle=`rgba(0,150,255,${0.4-r*0.02})`; ctx.stroke();
        });
    }

    // === RAILGUN / BARREL / RAILGUN OVERDRIVE ===
    else if (id.includes("railgun") || id.includes("barrel")) {
        // Rail body
        const rg2 = ctx.createLinearGradient(-14*s,0,14*s,0);
        rg2.addColorStop(0,"#223"); rg2.addColorStop(0.4,"#44668a"); rg2.addColorStop(0.6,"#44668a"); rg2.addColorStop(1,"#112");
        ctx.beginPath(); ctx.roundRect(-14*s,-5*s,28*s,10*s,2*s);
        fill(rg2); lw(1.5); stroke("#446688");
        // Rails (top and bottom)
        [[-3.5],[3.5]].forEach(([y]) => {
            ctx.beginPath(); ctx.rect(-13*s,y*s,26*s,1*s);
            fill("#aaccff");
        });
        // Energy beam
        const eg = ctx.createLinearGradient(-14*s,0,14*s,0);
        eg.addColorStop(0,"rgba(0,200,255,0)");
        eg.addColorStop(0.3,"rgba(0,200,255,0.8)");
        eg.addColorStop(0.7,"rgba(0,200,255,0.8)");
        eg.addColorStop(1,"rgba(255,255,255,0)");
        ctx.beginPath(); ctx.rect(-14*s,-1.5*s,28*s,3*s);
        fill(eg);
        // Muzzle flash
        arc(14,0,5); ctx.fillStyle="rgba(0,200,255,0.3)"; ctx.fill();
        arc(14,0,2.5); fill("rgba(255,255,255,0.8)");
    }

    // Fallback: generic circuit node
    else {
        const fg = ctx.createRadialGradient(0,0,0,0,0,12*s);
        fg.addColorStop(0,"#334"); fg.addColorStop(1,"#111");
        arc(0,0,12); fill(fg); lw(1.5); stroke("#556");
        lw(1.5);
        [[0,-12],[0,12],[-12,0],[12,0]].forEach(([x,y]) => {
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(x*s,y*s); stroke("#446688");
        });
        arc(0,0,3); fill("#668899");
    }

    ctx.restore();
}

// --- SKILL TREE SYSTEM ---

// 1. STATE MANAGEMENT
let playerProgress = JSON.parse(localStorage.getItem('swarm_save_v2')) || {
    shards: 0,
    unlocked: [],     // Array of skill IDs
    seenEnemies: []   // Array of enemy class names seen across all runs
};
// Backfill field for saves that pre-date this feature
if (!playerProgress.seenEnemies) playerProgress.seenEnemies = [];

function saveProgress() {
    localStorage.setItem('swarm_save_v2', JSON.stringify(playerProgress));
    updateSkillVisuals();
}

// 2. RENDERING THE TREE
function initSkillTree() {
    const world = document.getElementById('st-world');
    const svg = document.getElementById('st-connections');
    
    // Clear previous
    world.innerHTML = '<svg id="st-connections"></svg>'; 
    
    // Center the map (1500, 1500 is center of 3000x3000)
    const centerX = 1500;
    const centerY = 1500;

    // Draw Nodes
    for (let id in skillData) {
        const skill = skillData[id];
        
        // Create Node DOM
        const node = document.createElement('div');
        node.className = `skill-node node-${skill.type}`;
        node.setAttribute('data-id', id);
        
        // Position relative to center
        node.style.left = (centerX + skill.x) + 'px';
        node.style.top = (centerY + skill.y) + 'px';
        
        // --- CUSTOM ICON INTEGRATION ---
        const iconCanvas = document.createElement('canvas');
        iconCanvas.width = 48;
        iconCanvas.height = 48;
        iconCanvas.style.display = 'block';
        drawSkillIcon(iconCanvas, id);
        node.appendChild(iconCanvas);

        // Short label under icon
        const label = document.createElement('div');
        label.className = 'node-label';
        // Abbreviate long names
        let shortName = skill.name.replace(/^UNLOCK:\s*/i,'').replace(/^unlock_/i,'');
        if (shortName.length > 14) shortName = shortName.slice(0,13) + '‚Ä¶';
        label.innerText = shortName;
        node.appendChild(label);

        // Events
        node.onmouseover = () => showTooltip(node, skill);
        node.onmouseout = () => hideTooltip();
        node.onclick = () => attemptPurchase(id);

        world.appendChild(node);

        // Draw Line to Parent
        if (skill.parent) {
            const parentSkill = skillData[skill.parent];
            drawLine(
                centerX + parentSkill.x, 
                centerY + parentSkill.y, 
                centerX + skill.x, 
                centerY + skill.y,
                id // ID for coloring later
            );
        }
    }
    
    updateSkillVisuals();
}

function hasSkill(id) {
    return playerProgress && playerProgress.unlocked.includes(id);
}

function drawLine(x1, y1, x2, y2, id) {
    const svg = document.getElementById('st-connections');
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    
    line.setAttribute('x1', x1);
    line.setAttribute('y1', y1);
    line.setAttribute('x2', x2);
    line.setAttribute('y2', y2);
    line.setAttribute('class', 'connection-line');
    line.setAttribute('id', 'line-' + id);
    
    svg.appendChild(line);
}

function updateSkillVisuals() {
    document.getElementById('st-shard-count').innerText = playerProgress.shards;

    for (let id in skillData) {
        const node = document.querySelector(`.skill-node[data-id="${id}"]`);
        if (!node) continue;

        const skill = skillData[id];
        const isBought   = playerProgress.unlocked.includes(id);
        const parentBought = !skill.parent || playerProgress.unlocked.includes(skill.parent);

        // Reset classes
        node.className = `skill-node node-${skill.type}`;

        if (isBought) {
            node.classList.add('purchased');
        } else if (parentBought) {
            node.classList.add('available');
        } else {
            node.classList.add('locked');
        }

        // Connection line
        const line = document.getElementById('line-' + id);
        if (line) {
            if (isBought) {
                line.style.stroke = "#bc13fe";
                line.style.strokeWidth = "3";
                line.style.opacity = "1";
                line.style.filter = "drop-shadow(0 0 4px #bc13fe)";
            } else if (parentBought) {
                line.style.stroke = "rgba(255,200,50,0.4)";
                line.style.strokeWidth = "2";
                line.style.opacity = "0.8";
                line.style.filter = "";
            } else {
                line.style.stroke = "rgba(50,30,80,0.4)";
                line.style.strokeWidth = "1.5";
                line.style.opacity = "0.4";
                line.style.filter = "";
            }
        }
    }
}

// 4. INTERACTION (Buying)
function attemptPurchase(id) {
    const skill = skillData[id];
    
    // Checks
    if (playerProgress.unlocked.includes(id)) return; // Already have it
    
    // Check Parent
    if (skill.parent && !playerProgress.unlocked.includes(skill.parent)) {
        alert("You must unlock the previous node first!");
        return;
    }

    // Check Cost
    if (playerProgress.shards >= skill.cost) {
        if(confirm(`Unlock ${skill.name} for ${skill.cost} Shards?`)) {
            playerProgress.shards -= skill.cost;
            playerProgress.unlocked.push(id);
            saveProgress();
        }
    } else {
        alert(`Not enough Shards! Need ${skill.cost}.`);
    }
}

// 5. TOOLTIP LOGIC
function showTooltip(element, skill) {
    const tt = document.getElementById('st-tooltip');
    const id = element.getAttribute('data-id');
    const isOwned = playerProgress.unlocked.includes(id);
    const parentOwned = !skill.parent || playerProgress.unlocked.includes(skill.parent);

    document.getElementById('tt-title').innerText = skill.name;
    document.getElementById('tt-desc').innerText = skill.desc;

    // Badge
    const badge = document.getElementById('tt-type-badge');
    badge.innerText = skill.type.toUpperCase();
    badge.className = 'badge-' + skill.type;

    // Cost
    const costEl = document.getElementById('tt-cost');
    if (isOwned) {
        costEl.innerText = "‚úì OWNED";
        costEl.style.color = "#00ff88";
    } else {
        costEl.innerText = `üí† ${skill.cost} Shards`;
        costEl.style.color = playerProgress.shards >= skill.cost ? "#ffd700" : "#ff4444";
    }

    // Status
    const statusEl = document.getElementById('tt-status');
    if (isOwned)           { statusEl.innerText = "INSTALLED"; statusEl.style.color = "#00ff88"; }
    else if (!parentOwned) { statusEl.innerText = "LOCKED";    statusEl.style.color = "#555"; }
    else                   { statusEl.innerText = "AVAILABLE"; statusEl.style.color = "#ffd700"; }

    // Icon in tooltip
    const iconCanvas = document.getElementById('tt-icon-wrap');
    drawSkillIcon(iconCanvas, id);

    // Position
    const rect = element.getBoundingClientRect();
    let left = rect.right + 16;
    let top  = rect.top;
    if (left + 280 > window.innerWidth) left = rect.left - 296;
    if (top + 200 > window.innerHeight) top = window.innerHeight - 210;
    tt.style.left = left + 'px';
    tt.style.top  = top  + 'px';
    tt.style.display = 'block';
}
function hideTooltip() { document.getElementById('st-tooltip').style.display = 'none'; }

// 6. PANNING LOGIC (Drag the world)
let isDragging = false;
let startX, startY, scrollLeft, scrollTop;
const viewport = document.getElementById('st-viewport');

viewport.addEventListener('mousedown', (e) => {
    isDragging = true;
    startX = e.pageX - viewport.offsetLeft;
    startY = e.pageY - viewport.offsetTop;
    scrollLeft = viewport.scrollLeft;
    scrollTop = viewport.scrollTop;
});

viewport.addEventListener('mouseleave', () => { isDragging = false; });
viewport.addEventListener('mouseup', () => { isDragging = false; });

viewport.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    e.preventDefault();
    const x = e.pageX - viewport.offsetLeft;
    const y = e.pageY - viewport.offsetTop;
    const walkX = (x - startX) * 1; // Scroll speed
    const walkY = (y - startY) * 1;
    viewport.scrollLeft = scrollLeft - walkX;
    viewport.scrollTop = scrollTop - walkY;
});

// 7. OPEN/CLOSE
function openSkillTree() {
    const overlay = document.getElementById('skill-tree-overlay');
    const viewport = document.getElementById('st-viewport');

    if (overlay && viewport) {
        // 1. Show the menu
        overlay.style.display = 'flex';
        
        // 2. Initialize the tree
        initSkillTree(); 
        initSkillTreeBackground();

        // 3. FORCE CENTER (The Brute Force Math)
        // We wrap this in a double requestAnimationFrame to ensure the 
        // browser has finished "opening" the window before we scroll.
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                const worldSize = 3000; // This matches your CSS width/height
                
                // Formula: (WorldSize - YourWindowSize) / 2
                // This gives us the top-left coordinate needed to put 1500,1500 in the center
                const centerX = (worldSize - viewport.clientWidth) / 2;
                const centerY = (worldSize - viewport.clientHeight) / 2;

                // Apply the scroll
                viewport.scrollLeft = centerX;
                viewport.scrollTop = centerY;
            });
        });
    }
}

function closeSkillTree() {
    document.getElementById('skill-tree-overlay').style.display = 'none';
    updateLockedButtons();
}

    // Track seen enemies (in-memory; seeded from persistent save)
const seenEnemies = new Set(playerProgress.seenEnemies);

// Database of Enemy Info (Keys must match Class Names exactly)
const ENEMY_INTEL = {
    'Enemy': {
        name: "Chitin Scuttler",
        stats: { durability: 2, speed: 5, threat: 2 },
        lore: "The infantry of the void swarm. While individually weak, their strength lies in overwhelming numbers."
    },
    'RunnerEnemy': {
        name: "Scythe Runner",
        stats: { durability: 1, speed: 9, threat: 4 },
        lore: "Evolved for pure velocity. These agile predators swarm in packs to overwhelm point-defense systems."
    },
    'TankEnemy': {
        name: "Void Behemoth",
        stats: { durability: 9, speed: 2, threat: 5 },
        lore: "A slow-moving fortress of chitin. Heavy weaponry is required to penetrate its thick shell."
    },
    'MagnetEnemy': {
        name: "Void Lodestone",
        stats: { durability: 10, speed: 1, threat: 8 },
        lore: "Generates a powerful magnetic field that forcibly redirects projectiles away from high-value targets."
    },
    'BreacherEnemy': {
        name: "Razor Mantis",
        stats: { durability: 4, speed: 8, threat: 6 },
        lore: "A siege unit equipped with hyper-dense scythes. Uses a frenzied dash to shred through fortifications."
    },
    'DasherEnemy': {
        name: "Phase Dasher",
        stats: { durability: 3, speed: 10, threat: 5 },
        lore: "Capable of short-range hyperspace jumps. It flickers in and out of reality to dodge heavy ordinance."
    },
    'SniperEnemy': {
        name: "Spine Launcher",
        stats: { durability: 2, speed: 3, threat: 8 },
        lore: "A stationary organism that fires biological spikes from extreme range. Targets turrets directly."
    },
    'LeaperEnemy': {
        name: "Wall Jumper",
        stats: { durability: 3, speed: 7, threat: 6 },
        lore: "Possesses powerful hydraulic-like legs capable of vaulting over standard walls."
    },
    'ShielderEnemy': {
        name: "Aegis Drone",
        stats: { durability: 5, speed: 4, threat: 7 },
        lore: "Projects an energy barrier that protects nearby units. Neutralize immediately."
    },
    'ReviverEnemy': {
        name: "Necro-Weaver",
        stats: { durability: 4, speed: 4, threat: 10 },
        lore: "Emits a regenerative pheromone that can reanimate fallen biomass."
    },
    'FlyingEnemy': {
        name: "Void Ray",
        stats: { durability: 3, speed: 6, threat: 5 },
        lore: "An airborne unit that floats above the battlefield, bypassing all ground-based obstacles."
    },
    'BroodmotherEnemy': {
        name: "Void Broodmother",
        stats: { durability: 8, speed: 2, threat: 9 },
        lore: "A massive reproductive host. It carries a gestating sack of larvae that it expels onto the battlefield."
    },
    'LarvaEnemy': {
        name: "Parasitic Larva",
        stats: { durability: 1, speed: 9, threat: 3 },
        lore: "Newly hatched spawn. Fragile but moves with erratic speed to harass defenders."
    },
    'SkeletonEnemy': {
        name: "Calcified Thrall",
        stats: { durability: 6, speed: 3, threat: 4 },
        lore: "Reanimated skeletal structure fused with void energy. Continues to advance even after critical damage."
    }
};

// 1. The Trigger
function checkForNewEnemy(enemy) {
    if (!enemy) return;
    const type = enemy.constructor.name;

    // Check if new and if data exists
    if (!seenEnemies.has(type) && ENEMY_INTEL[type]) {
        seenEnemies.add(type);

        // Persist across runs
        if (!playerProgress.seenEnemies.includes(type)) {
            playerProgress.seenEnemies.push(type);
            saveProgress();
        }
        
        // PAUSE GAME
        if (typeof isPaused !== 'undefined') isPaused = true;
        
        // OPEN UI
        openEnemyIntro(enemy, ENEMY_INTEL[type]);
    }
}

// 2. The UI Populator
function openEnemyIntro(enemyInstance, data) {
    const overlay = document.getElementById('enemy-intro-overlay');
    const nameEl = document.getElementById('intro-name');
    const loreEl = document.getElementById('intro-lore');
    const statsEl = document.getElementById('intro-stats');

    if (!overlay) return; // Safety check

    nameEl.textContent = data.name;
    loreEl.textContent = data.lore;

    // Clear and build stats
    statsEl.innerHTML = '';
    createStatRow(statsEl, 'DURABILITY', data.stats.durability, 'durability');
    createStatRow(statsEl, 'VELOCITY', data.stats.speed, 'speed');
    createStatRow(statsEl, 'THREAT', data.stats.threat, 'damage');

    // Render Visuals
    renderEnemyPreview(enemyInstance);

    // Show
    overlay.style.display = 'flex';
}

function createStatRow(container, label, value, colorClass) {
    const row = document.createElement('div');
    row.className = 'stat-row';

    const text = document.createElement('div');
    text.className = 'stat-label';
    text.innerText = label;

    const bars = document.createElement('div');
    bars.className = 'stat-bar-container';

    for (let i = 0; i < 10; i++) {
        const pip = document.createElement('div');
        pip.className = `stat-pip ${i < value ? 'filled ' + colorClass : ''}`;
        bars.appendChild(pip);
    }

    row.appendChild(text);
    row.appendChild(bars);
    container.appendChild(row);
}

// 3. The Close Function
function closeEnemyIntro() {
    const overlay = document.getElementById('enemy-intro-overlay');
    if (overlay) overlay.style.display = 'none';
    
    // UNPAUSE GAME
    if (typeof isPaused !== 'undefined') isPaused = false;
}

// 4. The Renderer (Big, Upwards, Centered)
function renderEnemyPreview(enemy) {
    const pCanvas = document.getElementById('enemy-preview-canvas');
    if (!pCanvas) return;
    
    const pCtx = pCanvas.getContext('2d');
    const w = pCanvas.width;
    const h = pCanvas.height;

    // Clear
    pCtx.clearRect(0, 0, w, h);
    
    // Background
    const grad = pCtx.createRadialGradient(w/2, h/2, 20, w/2, h/2, w/2);
    grad.addColorStop(0, "#2a2a35");
    grad.addColorStop(1, "#15151a");
    pCtx.fillStyle = grad;
    pCtx.fillRect(0, 0, w, h);

    // --- MAGIC SWAP ---
    // We must swap the global context variable so the enemy draws here
    const originalCtx = window.ctx; 
    window.ctx = pCtx;

    pCtx.save();
    
    // 1. Center
    pCtx.translate(w / 2, h / 2);

    // 2. Zoom (Big!)
    const name = enemy.constructor.name;
    let scale = 3.5; // Default Big Zoom
    
    if (name.includes("Brood")) scale = 1.3;      
    else if (name.includes("Tank")) scale = 2.0;  
    else if (name.includes("Magnet")) scale = 2.0;
    else if (name.includes("Breacher")) scale = 2.5;

    pCtx.scale(scale, scale);

    // 3. Mock Position
    const realX = enemy.x;
    const realY = enemy.y;
    const realAngle = enemy.angle;

    enemy.x = 0; 
    enemy.y = 0;
    // 4. Force Upwards
    enemy.angle = -Math.PI / 2; 

    // 5. Draw
    try {
        if (enemy.draw) {
            pCtx.shadowBlur = 20;
            pCtx.shadowColor = "rgba(0,0,0,0.5)";
            enemy.draw();
            pCtx.shadowBlur = 0;
        }
    } catch(e) { console.log(e); }

    // Restore
    enemy.x = realX;
    enemy.y = realY;
    if (realAngle !== undefined) enemy.angle = realAngle;

    pCtx.restore();
    
    // --- RESTORE MAGIC SWAP ---
    window.ctx = originalCtx;
}

    // Function to switch tabs
    function openTab(evt, tabName) {
        // 1. Hide all tab contents
        const contents = document.getElementsByClassName("tab-content");
        for (let i = 0; i < contents.length; i++) {
            contents[i].classList.remove("active-content");
        }

        // 2. Deactivate all tab buttons
        const tabs = document.getElementsByClassName("tab-btn");
        for (let i = 0; i < tabs.length; i++) {
            tabs[i].classList.remove("active-tab");
        }

        // 3. Show current tab and activate button
        document.getElementById('tab-' + tabName).classList.add("active-content");
        evt.currentTarget.classList.add("active-tab");
    }
    /** CONFIGURATION **/
    const CELL_SIZE = 50; 
    
    // Snap width/height to be multiples of CELL_SIZE (50)
    // This ensures the bottom and right walls are fully visible and not cut off
    const COLS = 41;
    const ROWS = 21;

    var canvas, ctx;
    let grid = [];
    let currentAnnouncement = null;
    let isPathBlocked = false;
    let difficultyMultiplier = 1.0; 
    let gameActive = false;
    let isPaused = false;
    this.lastTimer = 0;
    
    // Lists
    let enemies = [];
    let corpses = [];
    let allies = [];      
    let structures = []; 
    let projectiles = []; 
    let particles = [];
    let traps = [];
    let spikes = [];
    this.floaters = []; // Stores the floating money text particles
    
    // Place base in middle of rows
    playerBase = { 
    x: 2, 
    y: Math.floor(ROWS / 2), 
    // Apply Core Vitality
    hp: 100 + (hasSkill('core_vitality') ? 50 : 0), 
    maxHp: 100 + (hasSkill('core_vitality') ? 50 : 0) 
    };
    let money = 200;
    let wave = 1;
    let waveState = 'spawning'; // Options: 'spawning', 'fighting', 'cooldown'
    
    let enemiesToSpawn = 10;    // Total enemies for this wave
    let enemiesSpawned = 0;     // How many have appeared so far
    
    let spawnRate = 60;         // Frames between spawns
    let spawnTimer = 0;
    
    let waveCooldown = 180;     // 3 Seconds rest between waves
    let cooldownTimer = 0;
    let gameOver = false;
    
    let currentTool = 'wall'; 
    let mouseX = 0;
    let mouseY = 0;
    let isMouseDown = false;
    let buildRotation = 0;

    function startGame(mode) {
        achStats = {
            structuresPlaced: 0, wallsPlaced: 0,
            flamethrowerPlaced: false, teslaPlaced: 0, railgunPlaced: false,
            killsThisRun: 0, totalSpent: 0, farmIncome: 0,
            flawlessWave: false, noDamageTaken: true, uniqueTowerTypes: 0,
            _waveFlawless: true,
        };
        // 1. Set Multiplier based on mode
        switch(mode) {
            case 'easy':     difficultyMultiplier = 0.5; break;
            case 'medium':   difficultyMultiplier = 1.0; break;
            case 'hard':     difficultyMultiplier = 2.0; break;
            case 'extreme':  difficultyMultiplier = 3.0; break;
            case 'creative': 
                difficultyMultiplier = 1.0; 
                money = 99999999999; // Infinite money
                break;
        }
        updateFlowField();

        // 2. Update HUD immediately
        document.getElementById('money').innerText = Math.floor(money);

        // 3. Hide Menu
        document.getElementById('main-menu').style.display = 'none';

        // 4. Start the Game Logic
        gameActive = true;
        wave = 0; 
        startNextWave(); 
    }

    function drawHealth(x, y, hp, maxHp) {
    // Only draw if damaged
    if (hp < maxHp) {
        const barW = 24;
        const barH = 4;
        const yOffset = 28;

        const barX = x - (barW / 2);
        const barY = y - yOffset;

        const pct = Math.max(0, Math.min(1, hp / maxHp));
        // Curve the hue so it stays green longer, then quickly turns red
        const hue = (pct * pct) * 120;

        // Background
        ctx.fillStyle = "#333333";
        ctx.fillRect(barX, barY, barW, barH);

        // Health
        ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
        ctx.fillRect(barX, barY, barW * pct, barH);

        // Border
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barW, barH);
    }
}

    /** CLASSES **/

class Corpse {
    constructor(x, y, bounty) { // Added 'bounty' parameter
        this.x = x;
        this.y = y; // This is the "Ground" Y position
        this.bounty = bounty; // Store the enemy's worth
        this.isTargeted = false; // Tells the tower if it's already being grabbed
        
        this.life = 600; 
        this.maxLife = 600;
        this.active = true;
        
        // --- FALLING PHYSICS ---
        this.dropY = -60; // Spawns 60 pixels in the air
        this.velocity = 0;
        this.gravity = 0.8; // How fast it accelerates down
        this.landed = false;

        this.sizeMod = 0.8 + Math.random() * 0.4;
    }

    update() {
        // --- BOUNTY TOWER OVERRIDE ---
        // If an arm grabs this corpse, freeze its physics and life timer
        if (this.isTargeted) return; 

        // 1. FALLING LOGIC
        if (!this.landed) {
            this.velocity += this.gravity;
            this.dropY += this.velocity;

            if (this.fallingIntoHole) {
                // Falls straight into the hole ‚Äî shrink and fade, then vanish
                if (this.dropY > 30) this.active = false;
            } else {
                // Normal ground bounce
                if (this.dropY >= 0) {
                    this.dropY = 0;
                    if (Math.abs(this.velocity) > 2) {
                        this.velocity = -this.velocity * 0.3; 
                    } else {
                        this.landed = true; 
                    }
                }
            }
        }

        // 2. LIFE LOGIC
        if (!this.fallingIntoHole) {
            this.life--;
            if (this.life <= 0) this.active = false;
        }
    }

    draw() {
        ctx.save();
        
        // Sinking logic (End of life) - Don't sink if it's being carried
        let sink = 0;
        if (!this.isTargeted && this.life < 120) sink = (1 - (this.life / 120)) * 10;

        // Combine Falling (dropY) + Sinking (sink)
        ctx.translate(this.x, this.y + this.dropY + sink);

        // Shrink into the hole when falling in
        let holeShrink = 1;
        if (this.fallingIntoHole && this.dropY > 0) {
            holeShrink = Math.max(0, 1 - (this.dropY / 30));
        }
        ctx.scale(this.sizeMod * holeShrink, this.sizeMod * holeShrink);
        
        // Fade out
        ctx.globalAlpha = Math.min(1.0, (this.life / this.maxLife) * 3);

        // --- DRAWING THE CROSS ---
        
        // 1. SHADOW (Only visible when close to ground)
        if (this.dropY > -20) {
            let shadowAlpha = 1 - (Math.abs(this.dropY) / 20);
            ctx.fillStyle = `rgba(0, 0, 0, ${0.4 * shadowAlpha})`;
            ctx.beginPath();
            let sScale = 1 - (Math.abs(this.dropY) / 40); 
            ctx.ellipse(0, 4, 10 * sScale, 5 * sScale, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // 2. THE CROSS (Stone Gray)
        const stoneDark = "#37474f";
        const stoneLight = "#546e7a";
        const stoneOutline = "#263238";

        ctx.strokeStyle = stoneOutline;
        ctx.lineWidth = 1.5;

        // Vertical Beam
        ctx.fillStyle = stoneDark;
        ctx.fillRect(-2.5, -16, 5, 20);
        ctx.strokeRect(-2.5, -16, 5, 20);

        // Horizontal Beam
        ctx.fillStyle = stoneLight;
        ctx.fillRect(-7, -11, 14, 4);
        ctx.strokeRect(-7, -11, 14, 4);

        // 3. CRACK DETAIL
        ctx.strokeStyle = "rgba(0, 0, 0, 0.4)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-1, -16); 
        ctx.lineTo(0, -13); 
        ctx.lineTo(-1, -11);
        ctx.stroke();

        ctx.restore();
    }
}

   class WaveAnnouncement {
    // Now accepts a title, a subtitle, and a color
    constructor(title, subTitle = "", color = "#ffffff") {
        this.text = title;
        this.subText = subTitle;
        this.baseColor = color;
        
        // Positioning
        this.x = VIRTUAL_WIDTH / 2;
        this.y = VIRTUAL_HEIGHT / 2;

        // Animation State
        this.life = 0;           // Frame counter
        this.maxLife = 180;      // Total duration (e.g., 3 seconds at 60fps)
        this.scale = 0;          // Starts invisible
        this.alpha = 0;
        this.active = true;
    }

    update(dt) {
        this.life++;

        // 1. Entrance (Frames 0-30): Fast Pop-in with overshoot
        if (this.life < 30) {
            this.alpha = Math.min(1, this.alpha + 0.1);
            // Elastic ease-out effect
            let t = this.life / 30; 
            this.scale = 1 + Math.sin(t * Math.PI) * 0.2; // Goes to 1.2 then back to 1
        } 
        // 2. Stay Phase (Frames 30-130): Slow drift
        else if (this.life < 130) {
            this.scale = 1.0;
            this.alpha = 1.0;
        } 
        // 3. Exit (Frames 130+): Fade out and scale up slightly
        else {
            this.alpha -= 0.02;
            this.scale += 0.005; // Gentle expansion while fading
        }

        if (this.life >= this.maxLife || this.alpha <= 0) {
            this.active = false;
        }
    }

    draw() {
        if (!this.active) return;

        ctx.save();
        
        // Center alignment
        ctx.translate(this.x, this.y);
        ctx.scale(this.scale, this.scale);
        ctx.globalAlpha = Math.max(0, this.alpha);

        // --- CINEMATIC BACKGROUND STRIP ---
        // Draws a black bar behind text to ensure legibility over chaotic game play
        ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
        // Draw rectangle centered on 0,0
        ctx.fillRect(-VIRTUAL_WIDTH / 2, -60, VIRTUAL_WIDTH, 120);
        
        // --- BORDERS ON STRIP ---
        ctx.beginPath();
        ctx.moveTo(-VIRTUAL_WIDTH / 2, -60);
        ctx.lineTo(VIRTUAL_WIDTH / 2, -60);
        ctx.moveTo(-VIRTUAL_WIDTH / 2, 60);
        ctx.lineTo(VIRTUAL_WIDTH / 2, 60);
        ctx.strokeStyle = this.baseColor;
        ctx.lineWidth = 2;
        ctx.stroke();

        // --- MAIN TEXT ---
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        
        // Glow Effect
        ctx.shadowColor = this.baseColor;
        ctx.shadowBlur = 20;
        
        // Text Style
        ctx.font = "900 80px 'Segoe UI', Verdana, sans-serif"; 
        ctx.fillStyle = this.baseColor;
        ctx.fillText(this.text, 0, -10); // Slightly up to make room for subtext

        // --- SUB TEXT (If provided) ---
        if (this.subText) {
            ctx.shadowBlur = 10; // Less glow for subtext
            ctx.font = "700 30px 'Segoe UI', Verdana, sans-serif";
            ctx.fillStyle = "#ffffff";
            ctx.letterSpacing = "4px"; // Spaced out looks cooler
            ctx.fillText(this.subText.toUpperCase(), 0, 40);
        }
        
        ctx.restore();
    }
}

    class Cell {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.wall = false;
            this.occupied = false; // Cannot build on top of other buildings
            this.distance = 9999; 
            this.vecX = 0; this.vecY = 0;
        }
    }

    function sharedDestroyWalls(enemy, col, row, damage, tickRate) {
    if (enemy.wallDamageCooldown > 0) {
        enemy.wallDamageCooldown--;
        return;
    }

    const _immuneDrill = (enemy.drillImmuneTimer > 0 && enemy.sourceDrill) ? enemy.sourceDrill : null;

    const _myDist = (col >= 0 && col < COLS && row >= 0 && row < ROWS)
        ? grid[col][row].distance : Infinity;

    let bestCell = null, bestScore = Infinity;
    let bestWx = 0, bestWy = 0;
    let bestFaceX = 0, bestFaceY = 0; // contact point on the wall face closest to enemy

    // Only check the 4 cardinal directions ‚Äî diagonal wall cells are corners
    // and produce the spinning/corner-attack behaviour. Cardinal-only means
    // the enemy always attacks the centre of a flat face, never a corner.
    const _dirs4 = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];

    for (const d of _dirs4) {
        let c = col + d.x;
        let r = row + d.y;
        if (c < 0 || c >= COLS || r < 0 || r >= ROWS) continue;

        let targetCell = grid[c][r];
        if (!targetCell.wall) continue;
        if (targetCell.distance >= _myDist) continue;

        if (_immuneDrill &&
            c >= _immuneDrill.col && c <= _immuneDrill.col + 1 &&
            r >= _immuneDrill.row && r <= _immuneDrill.row + 1) continue;

        // Contact point = centre of the shared face between enemy cell and wall cell.
        // This is always on the flat face, never a corner.
        let faceX = (col + d.x * 0.5 + 0.5) * CELL_SIZE; // shared edge centre X
        let faceY = (row + d.y * 0.5 + 0.5) * CELL_SIZE; // shared edge centre Y

        // Wall cell centre (for particle spawning and proximity check)
        let wx = c * CELL_SIZE + CELL_SIZE / 2;
        let wy = r * CELL_SIZE + CELL_SIZE / 2;
        if (Math.hypot(enemy.x - wx, enemy.y - wy) >= enemy.radius + CELL_SIZE) continue;

        let threat      = (_threatMap ? _threatMap[c + r * COLS] : 0);
        let hp          = targetCell.wallHp || 100;
        let improvement = _myDist - targetCell.distance;
        let score       = hp * 0.5 + threat * 20 - improvement * 2;

        if (score < bestScore) {
            bestScore = score;
            bestCell  = targetCell;
            bestWx    = wx;
            bestWy    = wy;
            bestFaceX = faceX;
            bestFaceY = faceY;
        }
    }

    if (bestCell) {
        bestCell.wallHp -= damage;
        createParticles(bestWx, bestWy, "#555", 1);
        enemy.wallDamageCooldown = tickRate;

        if (bestCell.wallHp <= 0) {
            bestCell.wall   = false;
            bestCell.wallHp = 100;
            updateFlowField();
        }
    }
}

// --- NEW HELPER: Raycast to check for clear path ---
    function hasLineOfSight(x0, y0, x1, y1) {
        let dx = x1 - x0;
        let dy = y1 - y0;
        let distance = Math.hypot(dx, dy);
        
        // Check points along the line every 25 pixels (half a cell)
        let steps = Math.ceil(distance / (CELL_SIZE / 2));
        
        for (let i = 0; i <= steps; i++) {
            let t = i / steps;
            let checkX = x0 + dx * t;
            let checkY = y0 + dy * t;
            
            let col = Math.floor(checkX / CELL_SIZE);
            let row = Math.floor(checkY / CELL_SIZE);
            
            // If we hit a wall, line of sight is blocked
            if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
                if (grid[col][row].wall) return false;
            }
        }
        return true; // No walls found
    }

function sharedMovement(enemy, col, row) {
    // --- 0. STATUS EFFECTS ---
    if (enemy.burnTimer > 0) {
        enemy.burnTimer--;
        if (enemy.burnTimer % 8 === 0) enemy.hp -= (enemy.burnDmg || 3);
    }
    if (enemy.stunTimer > 0) {
        enemy.stunTimer--;
        enemy.vx = 0; enemy.vy = 0;
        return false;
    }

    let speedMod = enemy.isSlowed ? 0.5 : 1.0;
    let currentSpeed = enemy.speed * speedMod;
    enemy.isSlowed = false;

    // --- 1. TAUNT CHECK ---
    if (enemy.tauntTarget) {
        if (enemy.tauntTarget.hp <= 0) {
            enemy.tauntTarget = null;
        } else {
            let dx = enemy.tauntTarget.x - enemy.x;
            let dy = enemy.tauntTarget.y - enemy.y;
            let dist = Math.hypot(dx, dy);
            if (dist > 0) {
                enemy.vx += ((dx/dist) * currentSpeed - enemy.vx) * 0.08;
                enemy.vy += ((dy/dist) * currentSpeed - enemy.vy) * 0.08;
            }
            return false;
        }
    }

    // --- 2. WALL CHECK: do this BEFORE flow field steering ---
    // If a cardinal neighbour is a wall that shortens our path, we are
    // "blocked". When blocked we skip the flow field entirely and drive
    // straight into that wall face. This is the ONLY way to stop spinning:
    // the flow field would steer laterally along the wall every frame,
    // fighting resolveWallCollision and producing the spin. Blocking it
    // out lets the enemy plant squarely against the face and attack.
    let onGrid = (col >= 0 && col < COLS && row >= 0 && row < ROWS);
    let cell   = onGrid ? grid[col][row] : null;
    let isBlocked = false;
    let wallFaceX = 0, wallFaceY = 0; // centre of the wall face to drive toward

    if (onGrid && cell) {
        const myDist = cell.distance;
        const dirs4 = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
        let bestWallDist = Infinity;
        for (const d of dirs4) {
            const nc = col + d.x, nr = row + d.y;
            if (nc < 0 || nc >= COLS || nr < 0 || nr >= ROWS) continue;
            const nb = grid[nc][nr];
            if (!nb.wall || nb.distance >= myDist) continue;
            // Face centre = shared edge between enemy cell and wall cell
            const fx = (col + d.x * 0.5 + 0.5) * CELL_SIZE;
            const fy = (row + d.y * 0.5 + 0.5) * CELL_SIZE;
            const fd = Math.hypot(fx - enemy.x, fy - enemy.y);
            if (nb.distance < bestWallDist) {
                bestWallDist = nb.distance;
                isBlocked = true;
                wallFaceX = fx;
                wallFaceY = fy;
            }
        }
    }

    // --- 3. STEERING ---
    if (isBlocked) {
        // Drive straight into the wall face centre, killing all lateral drift.
        const dx = wallFaceX - enemy.x;
        const dy = wallFaceY - enemy.y;
        const d  = Math.hypot(dx, dy) || 1;
        const nx = dx / d, ny = dy / d;
        // Hard-set velocity: full speed straight at the face, zero sideways
        enemy.vx = nx * currentSpeed;
        enemy.vy = ny * currentSpeed;
    } else {
        // Normal flow-field steering
        let moveDir;
        if (onGrid && cell && cell.distance !== Infinity) {
            moveDir = getSmartVector(enemy);
        } else {
            const baseX2 = (playerBase.x * CELL_SIZE) + CELL_SIZE;
            const baseY2 = (playerBase.y * CELL_SIZE) + CELL_SIZE;
            const dx2 = baseX2 - enemy.x, dy2 = baseY2 - enemy.y;
            const d2  = Math.hypot(dx2, dy2) || 1;
            moveDir = { x: dx2/d2, y: dy2/d2 };
        }
        enemy.vx += (moveDir.x * currentSpeed - enemy.vx) * 0.07;
        enemy.vy += (moveDir.y * currentSpeed - enemy.vy) * 0.07;

        // Stuck detection (only when not attacking a wall)
        if (!enemy._stuckFrames) enemy._stuckFrames = 0;
        if (!enemy._stuckSampleX) { enemy._stuckSampleX = enemy.x; enemy._stuckSampleY = enemy.y; }
        if (!enemy._stuckTimer)   enemy._stuckTimer = 0;
        enemy._stuckTimer++;
        if (enemy._stuckTimer >= 30) {
            enemy._stuckTimer = 0;
            const moved = Math.hypot(enemy.x - enemy._stuckSampleX, enemy.y - enemy._stuckSampleY);
            enemy._stuckSampleX = enemy.x;
            enemy._stuckSampleY = enemy.y;
            if (moved < 2) { enemy._stuckFrames++; } else { enemy._stuckFrames = 0; }
            if (enemy._stuckFrames >= 2) {
                enemy._stuckFrames = 0;
                const gx = moveDir.x, gy = moveDir.y;
                const cw  = { x: -gy, y:  gx };
                const ccw = { x:  gy, y: -gx };
                const _score = (d) => {
                    const sc = Math.floor((enemy.x + d.x * CELL_SIZE * 1.5) / CELL_SIZE);
                    const sr = Math.floor((enemy.y + d.y * CELL_SIZE * 1.5) / CELL_SIZE);
                    if (sc < 0 || sc >= COLS || sr < 0 || sr >= ROWS) return Infinity;
                    return grid[sc][sr].distance;
                };
                const chosen = (_score(cw) <= _score(ccw)) ? cw : ccw;
                enemy.vx = chosen.x * currentSpeed * 1.8;
                enemy.vy = chosen.y * currentSpeed * 1.8;
            }
        }
    }

    return isBlocked;
}

   class Enemy {
    constructor() {
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- STATS ---
        this.radius = 8; 
        this.speed = 0.8 + (Math.random() * 0.4);
        this.hp = 20 + (wave * 7);
        this.vx = -1; 
        this.vy = 0;
        this.maxHp = this.hp;
        
        // --- VISUALS ---
        this.angle = 0; 
        this.animTimer = Math.random() * 10; 
        
        this.attackCooldown = 0; 
        this.wallDamageCooldown = 0;
        this.bounty = 2;
    }

    update(dt) {
        // Animation speed
        this.animTimer += 0.3 * dt; 

        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);

        let isBlocked = sharedMovement(this, col, row);
        if (isBlocked) sharedDestroyWalls(this, col, row, 2, 10);

        if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
            this.angle = Math.atan2(this.vy, this.vx);
        }

        this.x += this.vx;
        this.y += this.vy;

        separate(this, enemies, 0.5); 
        separate(this, allies, 0.8);
        resolveWallCollision(this);

        if (this.attackCooldown > 0) this.attackcooldown-=dt;
        
        let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dx, dy) < 30) { takeDamage(5); this.hp = 0; }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        let pct = this.hp / this.maxHp;
        
        // --- PALETTE ---
        let armorColor = "#d8d0a0"; 
        let jointColor = "#4b5320"; 
        let coreColor = `rgba(255, ${Math.floor(50 * pct)}, 0, 1)`; 

        // --- 1. DRAW LEGS ---
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // Updated for Spider Walking Logic
        const drawLeg = (ox, oy, restX, restY, phase, side, widthMod, bendMod) => {
            let cycle = this.animTimer + phase;
            
            // WALKING LOGIC:
            // 1. Move parallel to body (X-axis) for the step.
            //    Math.cos(cycle) creates the Forward/Back stride.
            // 2. Slight In/Out motion (Y-axis) to simulate the arc of lifting the leg.
            //    -Math.sin(cycle) pulls leg in during the 'lift'.
            
            let strideRange = 2.5; // How far the foot steps forward/back
            
            // Calculate dynamic foot position based on resting position
            let footX = ox + restX + (Math.cos(cycle) * strideRange); 
            let footY = oy + restY + (Math.abs(Math.sin(cycle)) * -1.5 * side); // "Lift" effect

            let midX = (ox + footX) / 2;
            let midY = (oy + footY) / 2;
            
            // Knee projection
            let kneeX = midX - 1.5; 
            let kneeY = midY + (side * bendMod); 

            // Thin Outline
            ctx.strokeStyle = "#0f1405"; 
            ctx.lineWidth = 1.5 + widthMod;
            ctx.beginPath();
            ctx.moveTo(ox, oy);
            ctx.lineTo(kneeX, kneeY);
            ctx.lineTo(footX, footY);
            ctx.stroke();

            // Bone Armor
            ctx.strokeStyle = armorColor;
            ctx.lineWidth = 0.8 + widthMod;
            ctx.beginPath();
            ctx.moveTo(ox, oy);       
            ctx.lineTo(kneeX, kneeY); 
            ctx.lineTo(footX, footY); 
            ctx.stroke();

            // Joints
            ctx.fillStyle = jointColor;
            ctx.beginPath();
            ctx.arc(kneeX, kneeY, 1 + widthMod, 0, Math.PI*2);
            ctx.fill();
            
            // Tip
            ctx.fillStyle = "#8b0000"; 
            ctx.beginPath();
            ctx.arc(footX, footY, 0.8, 0, Math.PI*2);
            ctx.fill();
        };

        // --- LEG CONFIGURATION (Spider Gait) ---
        // Using alternating phases (0 vs PI) for adjacent legs creates the "Tripod" run.
        // Also adjusted 'restX' so front legs point forward and back legs point backward.

        // 1. BACK PAIR (Points Backward)
        // ox: -5, restX: -4 (Reaches behind)
        drawLeg(-5, -1.5, -4, -6, 0, -1, 0.5, 3);
        drawLeg(-5, 1.5, -4, 6, Math.PI, 1, 0.5, 3);
        
        // 2. MID-BACK PAIR (Points Slightly Back/Out)
        // ox: -2, restX: -2
        drawLeg(-2, -1.8, -2, -8, Math.PI, -1, 0.2, 5);
        drawLeg(-2, 1.8, -2, 8, 0, 1, 0.2, 5);
        
        // 3. MID-FRONT PAIR (Points Slightly Forward/Out)
        // ox: 1, restX: 2
        drawLeg(1, -1.8, 2, -7, 0, -1, 0.2, 4);
        drawLeg(1, 1.8, 2, 7, Math.PI, 1, 0.2, 4);
        
        // 4. FRONT PAIR (Points Forward)
        // ox: 4, restX: 4 (Reaches ahead)
        drawLeg(4, -1.2, 4, -4, Math.PI, -1, 0.5, 2);
        drawLeg(4, 1.2, 4, 4, 0, 1, 0.5, 2);


        // --- 2. ABDOMEN ---
        let pulse = 0.5 + Math.sin(this.animTimer * 0.5) * 0.1;
        
        ctx.fillStyle = "#2a2205"; 
        ctx.beginPath();
        ctx.ellipse(-4, 0, 9, 3.5, 0, 0, Math.PI * 2);
        ctx.fill();

        // Glowing Vents
        ctx.fillStyle = coreColor;
        ctx.shadowBlur = 6 * pulse;
        ctx.shadowColor = "red";
        for(let i = 0; i < 4; i++) { 
            let xOff = -2 - (i * 2.5);
            ctx.beginPath();
            ctx.ellipse(xOff, 0, 0.8, 2.5 - (i*0.4), 0, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.shadowBlur = 0;

        // --- 3. HEAD ---
        ctx.fillStyle = armorColor;
        ctx.beginPath();
        ctx.moveTo(1, -2.5);
        ctx.lineTo(5, -2);
        ctx.lineTo(9, 0); 
        ctx.lineTo(5, 2);
        ctx.lineTo(1, 2.5);
        ctx.fill();
        
        ctx.strokeStyle = jointColor;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(3, -1.5); ctx.lineTo(3, 1.5);
        ctx.stroke();

        // --- 4. EYES ---
        ctx.fillStyle = '#ccff00';
        ctx.shadowColor = '#ccff00';
        ctx.shadowBlur = 4;
        
        ctx.beginPath(); ctx.arc(7, -1, 1, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(7, 1, 1, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(6, -2, 0.8, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(6, 2, 0.8, 0, Math.PI*2); ctx.fill();
        
        ctx.shadowBlur = 0;

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class TankEnemy {
    constructor() {
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- TANK STATS ---
        this.radius = 22; // Increased size (was 16)
        this.baseSpeed = 0.3 + (Math.random() * 0.2);
        this.speed = this.baseSpeed;
        
        this.hp = 150 + (wave * 50); 
        this.maxHp = this.hp;
        this.bounty = 5;

        this.vx = -1; 
        this.vy = 0;
        this.angle = 0;
        
        this.attackCooldown = 0; 
        this.wallDamageCooldown = 0;
        
        this.animOffset = Math.random() * 10000;
        
        // Jagged Obsidian Body Shape
        this.bodyPoints = [];
        let segments = 7; 
        for (let i = 0; i < segments; i++) {
            this.bodyPoints.push(0.9 + Math.random() * 0.3); 
        }
    }

    update(dt) {
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);

        let isBlocked = sharedMovement(this, col, row);
        
        if (isBlocked) sharedDestroyWalls(this, col, row, 5, 15);

        if (Math.abs(this.vx) > 0.01 || Math.abs(this.vy) > 0.01) {
            this.angle = Math.atan2(this.vy, this.vx);
        }

        this.x += this.vx;
        this.y += this.vy;

        separate(this, enemies, 0.4); 
        separate(this, allies, 0.2);
        resolveWallCollision(this);

        if (this.attackCooldown > 0) this.attackcooldown-=dt;
        
        let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dx, dy) < 30 + this.radius) { takeDamage(20); this.hp = 0; }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        let time = Date.now() + this.animOffset;
        let breath = Math.sin(time * 0.005) * 1.5; // Deeper breath for bigger body

        // --- COLORS ---
        let hpPct = this.hp / this.maxHp;
        let colorBody   = '#151515'; 
        let colorArmor  = '#2a2a2a'; 
        let colorSpike  = '#404040';
        let colorGlow =  '#ff4500'; 

        // --- 1. REAR LEGS (Vestigial) ---
        // Pushed wider to match new body width
        ctx.fillStyle = colorBody;
        const drawLeg = (yOffset, phase) => {
            let kick = Math.sin(time * 0.005 + phase) * 3;
            ctx.beginPath();
            ctx.moveTo(-10, yOffset); // Shifted back
            ctx.lineTo(-16 + kick, yOffset + 4);
            ctx.lineTo(-16 + kick, yOffset - 4);
            ctx.fill();
        };
        drawLeg(-9, 0);       // Wider spacing
        drawLeg(9, Math.PI);

        // --- 2. MAIN BODY ---
        ctx.fillStyle = colorBody;
        ctx.beginPath();
        let segments = this.bodyPoints.length;
        for (let i = 0; i < segments; i++) {
            let theta = (i / segments) * Math.PI * 2;
            // Radius scales automatically here
            let r = (this.radius * 0.85 * this.bodyPoints[i]) + breath;
            let px = Math.cos(theta) * r;
            let py = Math.sin(theta) * r;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();

        // Glowing Cracks (Scaled up)
        ctx.strokeStyle = colorGlow;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-6, 0); ctx.lineTo(6, -3); ctx.lineTo(0, 6);
        ctx.stroke();

        // --- 3. ARMOR PLATES (Scaled positions) ---
        ctx.fillStyle = colorArmor;
        const drawSpikedPlate = (yDir) => {
            ctx.beginPath();
            // Pushed out yDir * 3 to fit bigger body
            ctx.translate(0, yDir * 3); 
            ctx.moveTo(-2, 2 * yDir);
            ctx.lineTo(8, 4 * yDir);
            ctx.lineTo(10, 10 * yDir);
            ctx.lineTo(-6, 12 * yDir);
            ctx.lineTo(-10, 6 * yDir);
            ctx.fill();

            // Spike
            ctx.fillStyle = colorSpike;
            ctx.beginPath();
            ctx.moveTo(0, 7 * yDir);
            ctx.lineTo(14, 14 * yDir); 
            ctx.lineTo(5, 5 * yDir);
            ctx.fill();
            
            // Reset translate
            ctx.translate(0, -yDir * 3);
            ctx.fillStyle = colorArmor;
        };
        drawSpikedPlate(-1);
        drawSpikedPlate(1);

        // --- 4. HEAD / VISOR (Moved forward) ---
        // Moved x from 8 to 12
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(12, 0, 5, 7, 0, 0, Math.PI*2);
        ctx.fill();
        
        ctx.shadowColor = colorGlow;
        ctx.shadowBlur = 10;
        ctx.fillStyle = colorGlow;
        ctx.beginPath();
        ctx.moveTo(12, -5); 
        ctx.lineTo(16, 0); 
        ctx.lineTo(12, 5);
        ctx.lineTo(11, 0); 
        ctx.fill();
        ctx.shadowBlur = 0;

        // --- 5. ARMS (Adjusted for Size) ---
        const drawArm = (side) => {
            let swingPhase = time * 0.003 + (side === 1 ? 0 : Math.PI); 
            let extension = Math.sin(swingPhase) * 5; 
            let rotation = Math.cos(swingPhase) * 0.3;

            ctx.save();
            // Shoulders moved: x (6->10), y (7->12) to clear the fat body
            ctx.translate(10, side * 12); 
            ctx.rotate(rotation);

            // ARM SHAPE: Thick and Short
            ctx.fillStyle = colorArmor;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            // Wrist
            ctx.lineTo(8 + extension, -side * 6); 
            ctx.lineTo(6 + extension, side * 10);
            // Armpit
            ctx.lineTo(-6, side * 7);
            ctx.fill();

            // FIST
            ctx.translate(8 + extension, 0); 
            ctx.rotate(side * 0.5); 
            
            ctx.fillStyle = colorBody;
            ctx.beginPath();
            ctx.moveTo(0, -7); 
            ctx.lineTo(9, -6); 
            ctx.lineTo(14, 0); // Knuckles
            ctx.lineTo(9, 6);
            ctx.lineTo(0, 7);
            ctx.fill();

            // Magma Spike
            ctx.fillStyle = colorGlow;
            ctx.beginPath();
            ctx.moveTo(9, -4); ctx.lineTo(16, 0); ctx.lineTo(9, 4);
            ctx.fill();

            ctx.restore();
        };

        drawArm(-1); 
        drawArm(1);  

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}
    
class RunnerEnemy {
    constructor() {
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- RUNNER STATS ---
        this.radius = 7; // Slightly larger visual presence, same collision feel
        this.baseSpeed = 2.2 + (Math.random() * 0.6); 
        this.speed = this.baseSpeed;
        
        this.hp = 10 + (wave * 3); 
        this.maxHp = this.hp;
        this.bounty = 2;

        this.vx = -1; 
        this.vy = 0;
        this.attackCooldown = 0; 
        
        // --- VISUALS ---
        this.wallDamageCooldown = 0;
        this.animTimer = Math.random() * 10; 
        this.angle = Math.PI; 
    }

    update(dt) {
        this.animTimer += 0.5*dt; // Rapid, jittery movement

        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);

        let isBlocked = sharedMovement(this, col, row);
        
        // Rotate to face velocity
        if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
            this.angle = Math.atan2(this.vy, this.vx);
        }

        if (isBlocked) sharedDestroyWalls(this, col, row, 0.5, 5);

        this.x += this.vx;
        this.y += this.vy;

        separate(this, enemies, 0.5); 
        separate(this, allies, 0.8);
        resolveWallCollision(this);

        if (this.attackCooldown > 0) this.attackcooldown-=dt;
        
        let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dx, dy) < 30) { takeDamage(2); this.hp = 0; }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle); 
        
        // Scale down slightly to fit the tile, but keep details chunky
        // No flip needed, this creature is radially symmetrical-ish
        
        let pct = this.hp / this.maxHp;
        
        // --- PALETTE: High Contrast for Small Scale ---
        // Dark Obsidian Armor
        let armorColor = "#0a0a12"; 
        // Hostile Neon Red/Magenta (Shifts to dull purple when dying)
        let energyColor = `rgb(255, ${50 * pct}, ${100 * pct})`; 
        // Bright core for visibility
        let coreColor = "#ffffff";

        // --- 1. THE LEGS (Scythe Blades) ---
        // Instead of thin lines, we use filled triangles/curves (Scythes).
        // These read much better at small sizes.
        
        ctx.fillStyle = energyColor;
        
        // Helper to draw a scythe leg
        // yOffset: Position on body
        // size: length of blade
        // phase: animation timing
        const drawScythe = (yOffset, size, phase, isRight) => {
            let cycle = Math.sin(this.animTimer + phase);
            let reach = cycle * 4; // How far forward/back it strikes
            let lift = Math.abs(Math.cos(this.animTimer + phase)) * 3; // Up/Down
            
            ctx.save();
            ctx.scale(1, isRight ? 1 : -1); // Mirror for other side
            
            ctx.beginPath();
            // Leg pivot point
            ctx.translate(0, yOffset);
            
            // Movement logic
            let rotation = (reach * 0.1); 
            ctx.rotate(rotation);

            // Draw Scythe Shape (Thick at base, sharp at tip)
            ctx.beginPath();
            ctx.moveTo(0, 0); 
            ctx.lineTo(size, -lift - 4); // The "Elbow"
            ctx.lineTo(size + 2, -lift + 4); // The Tip (stabbing ground)
            ctx.lineTo(2, 2); // Return to body
            ctx.fill();
            
            // Highlight on blade tip
            ctx.fillStyle = coreColor;
            ctx.beginPath();
            ctx.arc(size + 2, -lift + 4, 1, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = energyColor; // Reset

            ctx.restore();
        };

        // Draw 4 Scythe Legs (2 pairs)
        // Back Pair (Larger, bounding)
        drawScythe(2, 8, 0, true);
        drawScythe(2, 8, 0, false);
        
        // Front Pair (Smaller, stabbing)
        drawScythe(-2, 6, Math.PI, true);
        drawScythe(-2, 6, Math.PI, false);

        // --- 2. THE BODY (Exotic Carapace) ---
        // A sharp, diamond/arrowhead shape
        ctx.fillStyle = armorColor;
        ctx.strokeStyle = energyColor;
        ctx.lineWidth = 1.5;

        ctx.beginPath();
        ctx.moveTo(8, 0);   // Head tip (Sharp)
        ctx.lineTo(2, -4);  // Shoulder
        ctx.lineTo(-6, -2); // Rear
        ctx.lineTo(-8, 0);  // Tail tip
        ctx.lineTo(-6, 2);  // Rear
        ctx.lineTo(2, 4);   // Shoulder
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // --- 3. THE CORE (Visibility Anchor) ---
        // A glowing stripe down the back so you can see it in the dark
        ctx.shadowBlur = 6;
        ctx.shadowColor = energyColor;
        ctx.fillStyle = energyColor;
        
        ctx.beginPath();
        ctx.moveTo(4, 0);
        ctx.lineTo(-4, 0);
        ctx.lineWidth = 2;
        ctx.strokeStyle = energyColor;
        ctx.stroke();
        
        // Center "Eye" or "Reactor"
        ctx.fillStyle = coreColor;
        ctx.beginPath();
        ctx.arc(2, 0, 1.5, 0, Math.PI*2);
        ctx.fill();
        
        ctx.shadowBlur = 0; // Reset

        // --- 4. MANDIBLES (Hostility) ---
        // Tiny pincers at the front
        ctx.fillStyle = armorColor;
        ctx.beginPath();
        
        // Left Mandible
        ctx.moveTo(7, -1);
        ctx.lineTo(10, -2);
        ctx.lineTo(9, -0.5);
        
        // Right Mandible
        ctx.moveTo(7, 1);
        ctx.lineTo(10, 2);
        ctx.lineTo(9, 0.5);
        ctx.fill();

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}
class BreacherEnemy {
    constructor() {
        // --- SPAWN ---
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- STATS ---
        this.radius = 14; 
        this.speed = 0.8;       
        this.hp = 40 + (wave * 8); 
        this.maxHp = this.hp;
        this.bounty = 7;

        this.vx = -1; 
        this.vy = 0;
        
        // --- EXPLOSION LOGIC ---
        this.triggered = false;
        this.explodeTimer = 35; 
        this.explodeRadius = 70; 

        // --- VISUALS ---
        this.walkCycle = Math.random() * 10;
        this.antennaTimer = 0;
    }

    update(dt) {
        this.antennaTimer += 0.2*dt;

        // --- 1. ANIMATION SPEED ---
        if (!this.triggered) {
            this.walkCycle += 0.3; 
        } else {
            this.walkCycle += 0.8; 
        }

        // --- 2. TRIGGER LOGIC (COUNTDOWN) ---
        if (this.triggered) {
            this.explodeTimer--;
            this.vx *= 0.85; 
            this.vy *= 0.85;
            
            if (Math.random() < 0.2) createParticles(this.x, this.y, "#ff4500", 1);
            if (this.explodeTimer <= 0) this.detonate();
            return; 
        }

        // --- 3. MOVEMENT & TARGETING ---
        let moveDir = {x:0, y:0};
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);
        
        // Check grid boundaries
        let onGrid = (col >= 0 && col < COLS && row >= 0 && row < ROWS);
        let cell = onGrid ? grid[col][row] : null;
        let hasPath = (onGrid && cell.distance !== Infinity);

        if (hasPath) {
            moveDir = getSmartVector(this);
        } else {
            // Fallback: Move straight to base if no path found
            let dx = (playerBase.x * CELL_SIZE + CELL_SIZE/2) - this.x;
            let dy = (playerBase.y * CELL_SIZE + CELL_SIZE/2) - this.y;
            let dist = Math.hypot(dx, dy);
            if (dist > 0) moveDir = {x: dx/dist, y: dy/dist};
        }

        this.vx += (moveDir.x * this.speed - this.vx) * 0.15;
        this.vy += (moveDir.y * this.speed - this.vy) * 0.15;

        this.x += this.vx;
        this.y += this.vy;

        separate(this, enemies, 0.4); 
        resolveWallCollision(this);

        // --- 4. IMPROVED WALL DETECTION ---
        
        // A. Check Current Cell (Did user place a wall ON me?)
        if (onGrid && grid[col][row].wall) {
            this.triggered = true;
        }

        // B. Check Forward Collision (Am I walking INTO a wall?)
        // We look slightly ahead in the direction of movement + radius
        let lookAheadDist = this.radius + 4;
        let checkX = this.x + (moveDir.x * lookAheadDist);
        let checkY = this.y + (moveDir.y * lookAheadDist);
        let checkCol = Math.floor(checkX / CELL_SIZE);
        let checkRow = Math.floor(checkY / CELL_SIZE);

        if (checkCol >= 0 && checkCol < COLS && checkRow >= 0 && checkRow < ROWS) {
            if (grid[checkCol][checkRow].wall) {
                this.triggered = true;
            }
        }

        // C. Check Base Collision
        let dxBase = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dyBase = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dxBase, dyBase) < 30) this.triggered = true;
        
        // D. Check Ally Collision
        for (let ally of allies) {
            if (Math.hypot(this.x - ally.x, this.y - ally.y) < this.radius + ally.radius + 4) {
                this.triggered = true;
                break;
            }
        }
    }

    detonate() {
        // Visuals
        for(let i=0; i<25; i++) {
            createParticles(this.x, this.y, (Math.random()>0.5 ? "#ff4500" : "#ffff00"), 4);
        }

        // Damage Allies
        for (let i = allies.length - 1; i >= 0; i--) {
            let ally = allies[i];
            if (Math.hypot(this.x - ally.x, this.y - ally.y) < this.explodeRadius) {
                ally.hp -= 80; 
                createParticles(ally.x, ally.y, "red", 3);
            }
        }

        // Damage Walls
        let range = Math.ceil(this.explodeRadius / CELL_SIZE);
        let centerCol = Math.floor(this.x / CELL_SIZE);
        let centerRow = Math.floor(this.y / CELL_SIZE);

        for (let i = -range; i <= range; i++) {
            for (let j = -range; j <= range; j++) {
                let c = centerCol + i;
                let r = centerRow + j;
                if (c >= 0 && c < COLS && r >= 0 && r < ROWS) {
                    let cell = grid[c][r];
                    if (cell.wall) {
                        let wx = c * CELL_SIZE + CELL_SIZE/2;
                        let wy = r * CELL_SIZE + CELL_SIZE/2;
                        // Calculate distance to wall center
                        if (Math.hypot(this.x - wx, this.y - wy) < this.explodeRadius) {
                            cell.wallHp -= 150; 
                            if(cell.wallHp <= 0) {
                                cell.wall = false; 
                                createParticles(wx, wy, "#666", 4);
                            }
                            // Important: Recalculate paths if a wall breaks
                            updateFlowField();
                        }
                    }
                }
            }
        }

        // Damage Base
        let baseDist = Math.hypot(this.x - (playerBase.x * CELL_SIZE), this.y - (playerBase.y * CELL_SIZE));
        if (baseDist < this.explodeRadius + 20) takeDamage(40);

        this.hp = 0; // Enemy dies
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        let angle = Math.atan2(this.vy, this.vx);
        if (Math.abs(this.vx) + Math.abs(this.vy) < 0.1) angle = Math.PI;
        ctx.rotate(angle);

        // --- PALETTE ---
        let legColor = "#dddddd"; 
        let jointColor = "#ffffff"; 
        let bodyColor = "#8b0000"; 
        let headColor = "#a52a2a"; 
        
        // Trigger Effects
        let swell = 0;
        let buttColor = "#ff4500"; 
        if (this.triggered) {
            swell = Math.sin(Date.now() / 30) * 2; 
            buttColor = (Math.floor(Date.now() / 40) % 2 === 0) ? "#ffffff" : "#ff4500";
        } else {
            swell = Math.sin(Date.now() / 200) * 0.5;
        }

        // --- 1. ABDOMEN ---
        ctx.fillStyle = buttColor;
        ctx.beginPath();
        ctx.arc(-11, 0, 10 + swell, 0, Math.PI*2);
        ctx.fill();
        
        ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        ctx.beginPath();
        ctx.arc(-11, 0, 7 + swell, 0, Math.PI*2);
        ctx.fill();

        // --- 2. LEGS ---
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        const drawLeg = (ox, oy, restX, restY, phase, side, widthMod, bendMod) => {
            let cycle = this.walkCycle + phase;
            let strideRange = 3.5;
            
            let footX = ox + restX + (Math.cos(cycle) * strideRange); 
            let footY = oy + restY + (Math.abs(Math.sin(cycle)) * -2.0 * side); 

            let midX = (ox + footX) / 2;
            let midY = (oy + footY) / 2;
            
            let kneeX = midX - 1.5; 
            let kneeY = midY + (side * bendMod); 

            ctx.strokeStyle = "#111"; 
            ctx.lineWidth = 1.5 + widthMod;
            ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(kneeX, kneeY); ctx.lineTo(footX, footY); ctx.stroke();

            ctx.strokeStyle = legColor;
            ctx.lineWidth = 0.8 + widthMod;
            ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(kneeX, kneeY); ctx.lineTo(footX, footY); ctx.stroke();

            ctx.fillStyle = jointColor;
            ctx.beginPath(); ctx.arc(kneeX, kneeY, 1 + widthMod, 0, Math.PI*2); ctx.fill();
            
            ctx.fillStyle = "#ff0000"; 
            ctx.beginPath(); ctx.arc(footX, footY, 0.8, 0, Math.PI*2); ctx.fill();
        };

        // --- LEG CONFIGURATION ---
        drawLeg(-2, -4, -2, -8, Math.PI, -1, 0.2, 5);
        drawLeg(-2, 4, -2, 8, 0, 1, 0.2, 5);
        drawLeg(3, -4, 2, -7, 0, -1, 0.2, 4);
        drawLeg(3, 4, 2, 7, Math.PI, 1, 0.2, 4);
        drawLeg(7, -3, 4, -4, Math.PI, -1, 0.5, 2);
        drawLeg(7, 3, 4, 4, 0, 1, 0.5, 2);


        // --- 3. THORAX ---
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.ellipse(0, 0, 8, 4.5, 0, 0, Math.PI*2);
        ctx.fill();

        // Thorax Armor Plate
        ctx.fillStyle = "rgba(255,255,255,0.1)";
        ctx.beginPath();
        ctx.ellipse(0, -1, 5, 2, 0, 0, Math.PI*2);
        ctx.fill();

        // --- 4. HEAD ---
        ctx.fillStyle = headColor;
        ctx.beginPath();
        ctx.arc(10, 0, 4.5, 0, Math.PI*2);
        ctx.fill();

        // Mandibles
        ctx.fillStyle = "#eee";
        ctx.beginPath();
        ctx.moveTo(13, -2); ctx.lineTo(17, -3); ctx.lineTo(14, -1);
        ctx.moveTo(13, 2); ctx.lineTo(17, 3); ctx.lineTo(14, 1);
        ctx.fill();

        // Eyes
        ctx.fillStyle = this.triggered ? "#fff" : "#ffff00";
        ctx.beginPath(); ctx.arc(11, -2, 1.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(11, 2, 1.5, 0, Math.PI*2); ctx.fill();

        // Antennae
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 1;
        let twitch = Math.sin(this.antennaTimer) * 1;
        ctx.beginPath(); ctx.moveTo(12, -2); ctx.lineTo(19, -8 + twitch); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(12, 2); ctx.lineTo(19, 8 - twitch); ctx.stroke();

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

    class DasherEnemy {
    constructor() {
        // --- STANDARD SPAWN LOGIC ---
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- DASHER STATS ---
        this.radius = 8; // Much smaller hitbox (was 12)
        this.hp = 25 + (wave * 5); // Slightly less HP due to size
        this.maxHp = this.hp;
        this.bounty = 4;
        
        // Speed Setup
        this.baseSpeed = 0.7; // Slightly faster base speed because small = fast
        this.dashSpeed = 6.0; 
        this.speed = this.baseSpeed;
        
        this.vx = -1; 
        this.vy = 0;
        this.attackCooldown = 0; 
        this.wallDamageCooldown = 0;

        // --- DASH SPECIFIC LOGIC ---
        this.dashTimer = 0;
        this.dashThreshold = 120; // Frames until dash
        this.isDashing = false;

        // --- VISUAL VARS ---
        this.wobbleOffset = Math.random() * 1000;
        this.glowColorHex = "#ff4500"; 
    }

    update(dt) {
        // --- 1. DASH MECHANIC ---
        this.dashTimer++;

        // State A: NOT Dashing (Normal Behavior)
        if (!this.isDashing) {
            // Trigger Dash
            if (this.dashTimer > this.dashThreshold) { 
                this.isDashing = true;
                this.dashTimer = 0;
                
                let currentSpeed = Math.hypot(this.vx, this.vy);
                
                // Calculate dash vector
                if (currentSpeed > 0.01) {
                    this.vx = (this.vx / currentSpeed) * 8; 
                    this.vy = (this.vy / currentSpeed) * 8;
                } else {
                    let dx = (playerBase.x * CELL_SIZE + CELL_SIZE/2) - this.x;
                    let dy = (playerBase.y * CELL_SIZE + CELL_SIZE/2) - this.y;
                    let dist = Math.hypot(dx, dy);
                    this.vx = (dx / dist) * 8;
                    this.vy = (dy / dist) * 8;
                }
                
                // Big burst of particles on the "Flap"
                createParticles(this.x, this.y, this.glowColorHex, 8);
            }
        } 
        // State B: CURRENTLY DASHING
        else {
            if (this.dashTimer > 20) {
                this.isDashing = false;
                this.dashTimer = 0;
                this.vx *= 0.2; // Brake
                this.vy *= 0.2;
            }
        }

        // --- 2. MOVEMENT & WALLS ---
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);

        if (!this.isDashing) {
            let isBlocked = sharedMovement(this, col, row);
            if (isBlocked) sharedDestroyWalls(this, col, row, 1, 8);
        } else {
            let onGrid = (col >= 0 && col < COLS && row >= 0 && row < ROWS);
            let cell = onGrid ? grid[col][row] : null;
            let pathExists = (onGrid && cell.distance !== Infinity);

            if (!pathExists) {
                sharedDestroyWalls(this, col, row, 8, 2);
            }
        }

        // --- 3. PHYSICS ---
        this.x += this.vx;
        this.y += this.vy;

        separate(this, enemies, 0.4); 
        separate(this, allies, 0.6);
        resolveWallCollision(this);

        // --- 4. ATTACK ALLIES ---
        if (this.attackCooldown > 0) this.attackcooldown-=dt;

        for (let ally of allies) {
            let dist = Math.hypot(ally.x - this.x, ally.y - this.y);
            if (dist < this.radius + ally.radius + 5) {
                if (this.attackCooldown <= 0) {
                    ally.hp -= (this.damage || 4); 
                    this.attackCooldown = 60; 
                    createParticles(ally.x, ally.y, "red", 3);
                }
                if (!this.isDashing) {
                    this.vx *= 0.5;
                    this.vy *= 0.5;
                }
            }
        }
        
        // --- 5. ATTACK BASE ---
        let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dx, dy) < 20) { 
            takeDamage(5); 
            this.hp = 0;    
            createParticles(this.x, this.y, this.glowColorHex, 10);
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        // Rotate towards movement
        let angle = Math.atan2(this.vy, this.vx);
        if (Math.abs(this.vx) + Math.abs(this.vy) < 0.1) angle = Math.PI;
        ctx.rotate(angle);

        let time = Date.now() / 100 + this.wobbleOffset;

        // --- PALETTE ---
        const chitinDark = "#1a0505";   
        const chitinMid = "#5c0a0a";    
        const wingColor = "#a31414";  
        const glowColor = this.glowColorHex; 

        // --- WING ANIMATION LOGIC ---
        let wingAngle = 0.5; // Default angle (radians)

        if (this.isDashing) {
            // DASHING: Wings snapped back tight (aerodynamic)
            // They stay back for the duration of the dash
            wingAngle = 2.8; 
        } 
        else {
            // NOT DASHING
            let timeUntilDash = this.dashThreshold - this.dashTimer;
            
            if (timeUntilDash < 30) {
                // WIND-UP PHASE (Last 0.5s before dash):
                // Wings spread WIDE open to prepare for the stroke
                // Lerp from normal flutter to wide open (approx PI/2)
                let percent = 1 - (timeUntilDash / 30);
                wingAngle = 0.5 + (percent * 1.5); // Opens up to ~2.0 rads
                
                // Add a violent shake just before launch
                wingAngle += Math.sin(time * 50) * 0.1; 
            } else {
                // IDLE: Gentle flutter
                wingAngle = 0.4 + Math.sin(time * 0.8) * 0.2;
            }
        }

        // --- DRAW WINGS (Under Body) ---
        // Top Wing
        ctx.save();
        ctx.fillStyle = wingColor;
        ctx.rotate(-wingAngle);
        ctx.beginPath();
        // Sharp, aggressive insect wing shape
        ctx.moveTo(0, 0); 
        ctx.lineTo(8, -8); // Wing tip (scaled down)
        ctx.lineTo(12, -2); 
        ctx.lineTo(2, 2); 
        ctx.fill();
        ctx.restore();

        // Bottom Wing (Mirrored)
        ctx.save();
        ctx.fillStyle = wingColor;
        ctx.rotate(wingAngle);
        ctx.beginPath();
        ctx.moveTo(0, 0); 
        ctx.lineTo(8, 8); 
        ctx.lineTo(12, 2); 
        ctx.lineTo(2, -2); 
        ctx.fill();
        ctx.restore();


        // --- DRAW BODY (Scaled Down) ---
        // Tail (Engine)
        ctx.save();
        ctx.translate(-6, 0); 
        ctx.fillStyle = chitinDark;
        ctx.beginPath();
        ctx.moveTo(0, -3); ctx.lineTo(-6, 0); ctx.lineTo(0, 3);
        ctx.fill();
        // Engine Glow
        if(this.isDashing || this.dashTimer > 100) {
            ctx.fillStyle = glowColor;
            ctx.globalAlpha = (this.isDashing) ? 1 : 0.5;
            ctx.beginPath(); ctx.arc(-4, 0, 2, 0, Math.PI*2); ctx.fill();
            ctx.globalAlpha = 1;
        }
        ctx.restore();

        // Thorax (Middle)
        ctx.fillStyle = chitinMid;
        ctx.beginPath();
        ctx.ellipse(0, 0, 5, 3, 0, 0, Math.PI*2);
        ctx.fill();

        // Head
        ctx.save();
        ctx.translate(5, 0);
        ctx.fillStyle = chitinDark;
        ctx.beginPath();
        ctx.moveTo(-2, -3); ctx.lineTo(4, -1); ctx.lineTo(4, 1); ctx.lineTo(-2, 3);
        ctx.fill();

        // Glowing Eyes
        ctx.fillStyle = glowColor;
        if(this.isDashing) {
            ctx.shadowBlur = 5; ctx.shadowColor = glowColor;
        }
        ctx.beginPath(); ctx.arc(2, -1.5, 1, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(2, 1.5, 1, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;

        // Mandibles (Tiny)
        ctx.strokeStyle = chitinMid;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(4, -1); ctx.lineTo(7, -0.5); // Top
        ctx.moveTo(4, 1); ctx.lineTo(7, 0.5);   // Bottom
        ctx.stroke();

        ctx.restore(); // Head Restore
        ctx.restore(); // Main Restore
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class SniperEnemy {
    constructor() {
        // --- POSITION ---
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- STATS ---
        this.radius = 15; // Increased radius for bulkier appearance
        this.hp = 20 + (wave * 5);
        this.maxHp = this.hp;
        this.bounty = 10;
        this.damage = 100; 
        
        // --- MOVEMENT ---
        this.speed = 0.7;
        this.vx = -1; 
        this.vy = 0;
        
        // --- COMBAT ---
        this.range = 450;        
        this.shootCooldown = 60;
        this.shootTimer = 0;
        this.isAiming = false;
        this.currentTarget = null;
        
        // --- VISUALS ---
        this.angle = 0;
        this.animTimer = Math.random() * 100;
        this.laserTargetX = null;
        this.laserTargetY = null;
        this.laserAlpha = 0;
    }

    update(dt) {
        this.animTimer += 0.1*dt;

        // 1. TARGETING
        let baseX = playerBase.x * CELL_SIZE + CELL_SIZE/2;
        let baseY = playerBase.y * CELL_SIZE + CELL_SIZE/2;
        
        let foundTarget = null;
        let minDist = this.range;

        // A. Base Check
        let distToBase = Math.hypot(this.x - baseX, this.y - baseY);
        if (distToBase <= this.range) {
            foundTarget = { x: baseX, y: baseY, isBase: true };
            minDist = distToBase;
        }

        // B. Soldier Check
        if (typeof allies !== 'undefined') {
            for (let ally of allies) {
                let d = Math.hypot(this.x - ally.x, this.y - ally.y);
                if (d < minDist) {
                    minDist = d;
                    foundTarget = ally;
                }
            }
        }

        // 2. STATE MACHINE
        if (foundTarget) {
            // ATTACK
            this.currentTarget = foundTarget;
            this.isAiming = true;
            this.shootTimer++;

            this.vx *= 0.5; this.vy *= 0.5;
            this.angle = Math.atan2(foundTarget.y - this.y, foundTarget.x - this.x);

            if (this.shootTimer >= this.shootCooldown) {
                this.fire(foundTarget);
                this.shootTimer = 0; 
            }

        } else {
            // MOVE
            this.isAiming = false;
            this.shootTimer = Math.max(0, this.shootTimer - 2); 
            this.currentTarget = null;

            let col = Math.floor(this.x / CELL_SIZE);
            let row = Math.floor(this.y / CELL_SIZE);
            let isBlocked = sharedMovement(this, col, row);
            if (isBlocked) sharedDestroyWalls(this, col, row, 10, 40);

            this.x += this.vx;
            this.y += this.vy;

            if (Math.abs(this.vx) > 0.05 || Math.abs(this.vy) > 0.05) {
                this.angle = Math.atan2(this.vy, this.vx);
            }
        }

        // 3. PHYSICS
        separate(this, enemies, 0.6); 
        resolveWallCollision(this);
    }

    fire(target) {
        this.laserTargetX = target.x;
        this.laserTargetY = target.y;
        this.laserAlpha = 1.0; 
        
        createParticles(target.x, target.y, "#ff4500", 8); 
        createParticles(this.x + Math.cos(this.angle)*25, this.y + Math.sin(this.angle)*25, "#ffffaa", 5); 

        if (target.isBase) takeDamage(this.damage); 
        else target.hp -= this.damage; 
    }

    draw() {
        ctx.save();
        
        // --- ANIMATION VALUES ---
        let progress = Math.min(1, this.shootTimer / this.shootCooldown);
        
        // Phase 1: Jaws Open (0% to 30%)
        let jawOpenPct = Math.min(1, Math.max(0, progress / 0.3));
        
        // Phase 2: Barrel Slides Out (20% to 80%)
        let barrelSlidePct = Math.min(1, Math.max(0, (progress - 0.2) / 0.6));
        
        // Phase 3: Vibration (80%+)
        let shake = (progress > 0.8) ? (Math.random() - 0.5) * 2 : 0;
        let kick = (this.shootTimer < 5 && this.isAiming) ? 6 : 0;

        // --- 1. LASER ---
        if (this.laserAlpha > 0) {
            ctx.globalAlpha = this.laserAlpha;
            ctx.lineCap = "round";
            ctx.shadowBlur = 20; ctx.shadowColor = "#ff2200";
            ctx.strokeStyle = `rgba(255, 69, 0, ${this.laserAlpha})`; 
            ctx.lineWidth = 6 + Math.random() * 4; 
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.laserTargetX, this.laserTargetY); ctx.stroke();
            ctx.shadowBlur = 0;
            ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; 
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.laserTargetX, this.laserTargetY); ctx.stroke();
            ctx.globalAlpha = 1.0;
            this.laserAlpha -= 0.08; 
        }

        // --- TRANSFORM ---
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.translate(-kick, 0); 

        // --- 2. LEGS ---
        ctx.fillStyle = "#111"; 
        ctx.strokeStyle = "#444"; ctx.lineWidth = 0.5;
        for(let i = -1; i <= 1; i+=2) {
             let offset = (i===-1) ? 0 : Math.PI; 
             let walk = Math.sin(this.animTimer + offset) * 3;
             ctx.beginPath(); ctx.ellipse(-6 + walk, i * 8, 4, 2, Math.PI/4 * i, 0, Math.PI*2); ctx.fill(); ctx.stroke();
             ctx.beginPath(); ctx.ellipse(4 - walk, i * 7, 3, 2, -Math.PI/4 * i, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        }

        // ===============================================
        // === ROBUST JAWS & HEAVY BARREL ===
        // ===============================================

        // -- PART A: BOTTOM JAW (Heavy Armor) --
        ctx.save();
        let jawAngle = 0.5 * jawOpenPct; 
        ctx.rotate(jawAngle);
        
        // Main Jaw Structure
        ctx.fillStyle = "#111"; // Dark metal
        ctx.beginPath();
        ctx.moveTo(-2, 1);    // Hinge Inner
        ctx.lineTo(2, 9);     // Heavy Base Down
        ctx.lineTo(16, 7);    // Mid Armor Angle
        ctx.lineTo(24, 4);    // Blunt Tip Bottom
        ctx.lineTo(24, 2);    // Blunt Tip Top
        ctx.lineTo(20, 1);    // Inner Tooth
        ctx.lineTo(6, 1);     // Inner Grip Surface
        ctx.lineTo(-2, 1);    // Back to Hinge
        ctx.fill();

        // Armor Plate Highlight (The "Chin")
        ctx.fillStyle = "#222"; 
        ctx.beginPath(); ctx.moveTo(2, 9); ctx.lineTo(16, 7); ctx.lineTo(12, 3); ctx.lineTo(4, 3); ctx.fill();
        
        // Edge Highlight
        ctx.strokeStyle = "#666"; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(-2, 1); ctx.lineTo(2, 9); ctx.lineTo(16, 7); ctx.lineTo(24, 4); ctx.stroke();
        ctx.restore();

        // -- PART B: TOP JAW (Heavy Armor) --
        ctx.save();
        ctx.rotate(-jawAngle);
        
        // Main Jaw Structure
        ctx.fillStyle = "#111"; 
        ctx.beginPath();
        ctx.moveTo(-2, -1);   // Hinge Inner
        ctx.lineTo(2, -9);    // Heavy Base Up
        ctx.lineTo(16, -7);   // Mid Armor Angle
        ctx.lineTo(24, -4);   // Blunt Tip Top
        ctx.lineTo(24, -2);   // Blunt Tip Bottom
        ctx.lineTo(20, -1);   // Inner Tooth
        ctx.lineTo(6, -1);    // Inner Grip Surface
        ctx.lineTo(-2, -1);   // Back to Hinge
        ctx.fill();

        // Armor Plate Highlight
        ctx.fillStyle = "#222"; 
        ctx.beginPath(); ctx.moveTo(2, -9); ctx.lineTo(16, -7); ctx.lineTo(12, -3); ctx.lineTo(4, -3); ctx.fill();

        // Edge Highlight
        ctx.strokeStyle = "#666"; 
        ctx.beginPath(); ctx.moveTo(-2, -1); ctx.lineTo(2, -9); ctx.lineTo(16, -7); ctx.lineTo(24, -4); ctx.stroke();
        ctx.restore();

        // -- PART C: THE HEAVY BARREL (Slides Out) --
        if (jawOpenPct > 0.1) {
            let slide = barrelSlidePct * barrelSlidePct * (3 - 2 * barrelSlidePct); 
            let extension = slide * 16; 
            
            // 1. Heavy Rail Housing
            let grad = ctx.createLinearGradient(0, -6, 0, 6);
            grad.addColorStop(0, "#1a1a1a");
            grad.addColorStop(0.5, "#444");
            grad.addColorStop(1, "#1a1a1a");
            ctx.fillStyle = grad;
            ctx.fillRect(4, -5, 12 + extension, 10);
            
            // 2. Vents
            ctx.fillStyle = "#000";
            for(let i=0; i<3; i++) ctx.fillRect(8 + (i*4) + (extension*0.5), -4, 2, 8);

            // 3. Magma Core
            let heatColor = progress > 0.7 ? "#ffff00" : "#ff4500";
            ctx.fillStyle = heatColor;
            ctx.shadowColor = heatColor; ctx.shadowBlur = 10 * progress;
            ctx.fillRect(6, -1.5, 10 + extension, 3); 
            ctx.shadowBlur = 0;

            // 4. Muzzle
            let headX = 16 + extension; 
            ctx.fillStyle = "#2a2a2a";
            ctx.beginPath();
            ctx.moveTo(headX, -5); ctx.lineTo(headX + 4, -6); ctx.lineTo(headX + 6, -3);
            ctx.lineTo(headX + 6, 3); ctx.lineTo(headX + 4, 6); ctx.lineTo(headX, 5);
            ctx.fill();

            // 5. Charge
            if (progress > 0.6) {
                ctx.fillStyle = `rgba(255, 255, 255, ${progress})`;
                ctx.shadowColor = "#ffaa00"; ctx.shadowBlur = 20;
                ctx.beginPath(); ctx.arc(headX + 6, 0, 3 * progress + Math.random(), 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;
            }
        }
        
        // -- PART D: MECHANICAL HINGE (Pivot Point) --
        // Draws a mechanical circle where the jaws meet the body
        ctx.fillStyle = "#333";
        ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#000"; ctx.lineWidth = 1; ctx.stroke();
        ctx.fillStyle = "#555"; ctx.beginPath(); ctx.arc(0, 0, 2, 0, Math.PI*2); ctx.fill();

        // ===============================================

        // --- 3. MAIN BODY ---
        ctx.fillStyle = "#180505"; 
        ctx.beginPath(); ctx.ellipse(-4, 0, 11, 9, 0, 0, Math.PI*2); ctx.fill();
        
        // Pulsing Core
        let pulse = Math.sin(this.animTimer * 0.5) * 1.5;
        let coreColor = progress > 0.8 ? "#fff" : (progress > 0.4 ? "#ff8800" : "#a00");
        ctx.shadowBlur = 10 + (progress * 15); ctx.shadowColor = "#f00";
        ctx.fillStyle = coreColor;
        ctx.beginPath(); ctx.ellipse(-5 + shake, 0 + shake, 6 + (pulse*0.2), 4 + (pulse*0.2), 0, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;

        // Armor Shell
        ctx.fillStyle = "#222"; 
        ctx.beginPath(); ctx.moveTo(-2, -5); ctx.lineTo(-8, -8); ctx.lineTo(-13, -3); ctx.fill(); 
        ctx.beginPath(); ctx.moveTo(-2, 5); ctx.lineTo(-8, 8); ctx.lineTo(-13, 3); ctx.fill();
        ctx.strokeStyle = "#555"; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(-2, -5); ctx.lineTo(-8, -8); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-2, 5); ctx.lineTo(-8, 8); ctx.stroke();

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class BroodmotherEnemy {
    constructor() {
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // STATS
        this.radius = 18; // Slightly larger hitbox for the new body
        this.hp = 100 + (wave * 20); 
        this.maxHp = this.hp;
        this.bounty = 20; 
        
        this.speed = 0.5; 
        this.vx = -0.5; 
        this.vy = 0;
        
        this.wallDamageCooldown = 0;

        // SUMMONING STATS
        this.state = "MOVING"; 
        this.spawnTimer = 0;
        this.spawnCooldown = 240; 
        this.spawnDuration = 60; 
        
        // Animation
        this.walkCycle = 0;
    }

    update() {
        this.walkCycle += 0.1; // Animate legs

        // 1. Spawning Mechanic
        this.spawnTimer = (this.spawnTimer || 0) + 1;
        if (this.spawnTimer > 180) { 
            this.spawnTimer = 0;
            // Spawn 2 Larvae
            for(let i=0; i<2; i++) {
                enemies.push(new LarvaEnemy(this.x - 10, this.y + Math.random()*20-10));
            }
            createParticles(this.x, this.y, "#adff2f", 15); // Goo explosion
        }

        // 2. Movement
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);

        let isBlocked = sharedMovement(this, col, row);

        if (isBlocked) sharedDestroyWalls(this, col, row, 5, 20);

        this.x += this.vx;
        this.y += this.vy;

        // 3. Physics
        separate(this, enemies, 0.2); 
        separate(this, allies, 0.1);
        resolveWallCollision(this);

        // 4. Base Damage
        let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dx, dy) < 40) { 
            takeDamage(2); 
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // 1. CALCULATE ROTATION
        // Standard Math: 0 radians = Facing Right.
        let angle = Math.atan2(this.vy, this.vx);
        
        // If the enemy is barely moving, force it to face Left (towards player base usually)
        // But since we draw Facing Right, we need Math.PI to face Left.
        if (Math.abs(this.vx) + Math.abs(this.vy) < 0.1) angle = Math.PI; 
        
        ctx.rotate(angle);

        let pct = this.hp / this.maxHp;

        // --- DRAW LEGS (6 Insect Legs) ---
        ctx.strokeStyle = "#1a2b0a"; // Dark Green/Black
        ctx.lineWidth = 2;
        ctx.lineCap = "round";
        
        for(let i = 0; i < 3; i++) { 
            let sideOffset = (i * 6) - 6; 
            let legLength = 18;
            
            // Animation: Tripod Gait
            let legSwing = Math.sin(this.walkCycle + (i%2 * Math.PI)) * 5;
            
            // Top Legs
            ctx.beginPath();
            ctx.moveTo(sideOffset, -5);
            ctx.lineTo(sideOffset - legSwing, -legLength); // Swing is inverted to match direction
            ctx.stroke();

            // Bottom Legs
            ctx.beginPath();
            ctx.moveTo(sideOffset, 5);
            ctx.lineTo(sideOffset - legSwing, legLength);
            ctx.stroke();
        }

        // --- DRAW BODY PARTS (Facing RIGHT) ---

        // 1. ABDOMEN (The Egg Sack) - REAR (Negative X)
        let spawnPressure = (this.spawnTimer / 180);
        let pulse = spawnPressure > 0.8 ? Math.sin(this.spawnTimer * 0.5) * 2 : 0;
        
        let sackR = 50 + (150 * spawnPressure);
        let sackG = 100 + (50 * spawnPressure);
        
        ctx.fillStyle = `rgb(${sackR}, ${sackG}, 20)`;
        ctx.beginPath();
        // MOVED TO NEGATIVE X (-10)
        ctx.ellipse(-10, 0, 14 + pulse, 10 + pulse, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#1a2b0a";
        ctx.lineWidth = 1;
        ctx.stroke();

        // Abdomen Details
        ctx.fillStyle = "rgba(0,0,0,0.2)";
        ctx.beginPath();
        ctx.arc(-8, -4, 2, 0, Math.PI*2);
        ctx.arc(-12, 3, 3, 0, Math.PI*2);
        ctx.arc(-6, 2, 2, 0, Math.PI*2);
        ctx.fill();

        // 2. THORAX (Armor) - CENTER
        let darkGreen = `rgb(${20 + 40*pct}, ${40 + 60*pct}, 20)`;
        ctx.fillStyle = darkGreen;
        ctx.beginPath();
        ctx.ellipse(4, 0, 8, 6, 0, 0, Math.PI * 2); // MOVED TO POSITIVE X
        ctx.fill();
        ctx.stroke();

        // 3. HEAD (Mandibles) - FRONT (Positive X)
        ctx.fillStyle = darkGreen;
        ctx.beginPath();
        ctx.arc(12, 0, 5, 0, Math.PI * 2); // MOVED TO POSITIVE X
        ctx.fill();
        ctx.stroke();

        // Mandibles (Pincers) - Pointing Right
        ctx.strokeStyle = "#8b0000"; 
        ctx.beginPath();
        ctx.moveTo(14, -2); ctx.lineTo(20, -4); // Point Right
        ctx.moveTo(14, 2);  ctx.lineTo(20, 4);  // Point Right
        ctx.stroke();

        // Glowing Eyes
        ctx.fillStyle = "#f00"; 
        ctx.beginPath();
        ctx.arc(14, -2, 1.5, 0, Math.PI*2);
        ctx.arc(14, 2, 1.5, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class LarvaEnemy {
    constructor(x, y) {
        this.x = x; 
        this.y = y;
        
        // Very weak, very fast
        this.radius = 5; 
        this.hp = 10; 
        this.maxHp = 10;
        this.bounty = 1; 
        
        this.speed = 1.5; 
        this.vx = (Math.random() - 0.5) * 5; 
        this.vy = (Math.random() - 0.5) * 5;
        
        this.wallDamageCooldown = 0;
        
        // Animation randomizer
        this.wiggleOffset = Math.random() * 100;
        this.wiggleTimer = 0;
    }

    update() {
        this.wiggleTimer += 0.5;

        // 1. Movement
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);

        let isBlocked = sharedMovement(this, col, row);
        if (isBlocked) sharedDestroyWalls(this, col, row, 0.2, 5);

        this.x += this.vx;
        this.y += this.vy;

        // 2. Physics
        separate(this, enemies, 0.8); 
        separate(this, allies, 0.5);
        resolveWallCollision(this);

        // 3. Attack (Suicide)
        let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dx, dy) < 20) { 
            takeDamage(1); 
            this.hp = 0; 
            createParticles(this.x, this.y, "#adff2f", 5);
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Rotate to face movement
        let angle = Math.atan2(this.vy, this.vx);
        ctx.rotate(angle);

        let wiggle = Math.sin(this.wiggleTimer + this.wiggleOffset) * 2;

        // Colors
        let pct = this.hp / this.maxHp;
        let r = 100 + (100 * pct);
        let g = 200 + (55 * pct);
        
        // Draw Maggot Body (3 overlapping circles decreasing in size)
        
        // 1. Tail (Wiggles the most)
        ctx.fillStyle = `rgb(${r-40}, ${g-40}, 0)`;
        ctx.beginPath();
        ctx.arc(-8, wiggle, 3, 0, Math.PI*2);
        ctx.fill();

        // 2. Mid-Body (Wiggles a little)
        ctx.fillStyle = `rgb(${r-20}, ${g-20}, 0)`;
        ctx.beginPath();
        ctx.arc(-4, wiggle * 0.5, 4, 0, Math.PI*2);
        ctx.fill();

        // 3. Head (Steady)
        ctx.fillStyle = `rgb(${r}, ${g}, 0)`; // Brightest
        ctx.strokeStyle = "#1a2b0a";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.ellipse(2, 0, 5, 4, 0, 0, Math.PI*2); // Oval head
        ctx.fill();
        ctx.stroke();

        // Tiny Pincers/Mouth
        ctx.strokeStyle = "black";
        ctx.beginPath();
        ctx.moveTo(6, -2); ctx.lineTo(8, 0); ctx.lineTo(6, 2);
        ctx.stroke();

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class LeaperEnemy {
    constructor() {
        // --- SPAWN LOGIC ---
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- STATS ---
        this.radius = 12;
        this.speed = 0.8; // Slow walk
        this.hp = 25 + (wave * 5); 
        this.maxHp = this.hp;
        this.bounty = 5;
        
        this.vx = -1;
        this.vy = 0;
        
        // --- JUMP MECHANICS ---
        this.state = 'RUN';
        this.jumpTimer = 0;
        this.jumpDuration = 45; 
        this.jumpCooldown = 0;  
        this.jumpHeight = 0;    
        
        // --- VISUALS ---
        this.angle = Math.PI;
        this.animTimer = Math.random() * 100;
        this.wingOpenAmount = 0; 
    }

    update(dt) {
        this.animTimer += 0.1*dt;
        if (this.jumpCooldown > 0) this.jumpCooldown--;

        let dx = (playerBase.x * CELL_SIZE + CELL_SIZE/2) - this.x;
        let dy = (playerBase.y * CELL_SIZE + CELL_SIZE/2) - this.y;
        let distToBase = Math.hypot(dx, dy);

        // --- STATE MACHINE ---
        if (this.state === 'RUN') {
            let col = Math.floor(this.x / CELL_SIZE);
            let row = Math.floor(this.y / CELL_SIZE);
            
            // 1. STANDARD MOVEMENT
            // We call sharedMovement to handle walking/pathfinding. 
            // We store 'isStuck' to know if the base is totally sealed off.
            let isStuck = sharedMovement(this, col, row);

            // 2. ROTATION (Face movement)
            if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
                let targetAngle = Math.atan2(this.vy, this.vx);
                let diff = targetAngle - this.angle;
                while (diff < -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;
                this.angle += diff * 0.05; 
            }
            if (this.wingOpenAmount > 0) this.wingOpenAmount -= 0.05;

            // --- 3. PROACTIVE JUMP CHECK ---
            // We check for a wall directly towards the base, even if 'isStuck' is false.
            if (this.jumpCooldown <= 0 && distToBase > 60) {
                
                // Look ahead 40px (approx 1 cell) towards the base
                let lookDist = 40;
                let lookX = this.x + (Math.cos(this.angle) * lookDist);
                let lookY = this.y + (Math.sin(this.angle) * lookDist);
                
                let wallCol = Math.floor(lookX / CELL_SIZE);
                let wallRow = Math.floor(lookY / CELL_SIZE);

                // Is there a wall right in front of us?
                if (wallCol >= 0 && wallCol < COLS && wallRow >= 0 && wallRow < ROWS) {
                    if (grid[wallCol][wallRow].wall) {
                        
                        // WALL FOUND! Now check the landing spot (Jump over 1 wall = ~2 cells away)
                        let landDist = 90; // 40 (wall) + 50 (landing)
                        let landX = this.x + (Math.cos(this.angle) * landDist);
                        let landY = this.y + (Math.sin(this.angle) * landDist);
                        
                        let landCol = Math.floor(landX / CELL_SIZE);
                        let landRow = Math.floor(landY / CELL_SIZE);
                        
                        let canLand = true;

                        // Check if landing spot is valid
                        if (landCol >= 0 && landCol < COLS && landRow >= 0 && landRow < ROWS) {
                            // CANNOT jump if the landing spot is ALSO a wall (Double Wall)
                            if (grid[landCol][landRow].wall) {
                                canLand = false;
                            }
                        } else {
                            canLand = false; // Don't jump off map
                        }

                        // DECISION:
                        if (canLand) {
                            // A single wall detected + clear landing -> JUMP!
                            this.vx = 0; 
                            this.vy = 0;
                            this.state = 'CHARGE';
                            this.jumpTimer = 100; // 1.6s wait
                        } 
                    }
                }
            }

            // --- 4. STUCK LOGIC ---
            // If we are stuck (base sealed) AND we didn't start a jump above, break the wall.
            if (isStuck && this.state !== 'CHARGE') {
                sharedDestroyWalls(this, col, row, 1, 5);
            }

            this.jumpHeight = 0;
        } 
        else if (this.state === 'CHARGE') {
            this.angle += (Math.random() - 0.5) * 0.1; // Shaking effect
            this.jumpTimer--;
            
            if (this.wingOpenAmount < 0.5) this.wingOpenAmount += 0.005;

            if (this.jumpTimer <= 0) {
                this.state = 'AIR';
                this.jumpTimer = this.jumpDuration;
                
                // Launch towards base
                let angleToBase = Math.atan2(dy, dx);
                let jumpDist = CELL_SIZE * 2.5; 
                let requiredSpeed = jumpDist / this.jumpDuration;

                this.vx = Math.cos(angleToBase) * requiredSpeed;
                this.vy = Math.sin(angleToBase) * requiredSpeed;
                this.angle = angleToBase;
            }
        }
        else if (this.state === 'AIR') {
            this.jumpTimer--;
            if (this.wingOpenAmount < 1) this.wingOpenAmount += 0.1;

            // Parabolic Arc
            let t = 1 - (this.jumpTimer / this.jumpDuration); 
            this.jumpHeight = Math.sin(t * Math.PI) * 60; 

            if (this.jumpTimer <= 0) {
                // Land
                this.state = 'RUN';
                this.jumpCooldown = 120; 
                this.vx = 0; 
                this.vy = 0;
                createParticles(this.x, this.y, "#00ffcc", 8); 
            }
        }

        // Apply Velocity
        this.x += this.vx;
        this.y += this.vy;

        if (distToBase < 30) { takeDamage(10); this.hp = 0; }

        // Physics (Do not collide with walls while in AIR)
        if (this.state !== 'AIR') {
            separate(this, enemies, 0.5);
            resolveWallCollision(this);
        }
    }

    draw() {
        ctx.save();
        
        let shadowSize = 8 - (this.jumpHeight / 10);
        if (shadowSize < 0) shadowSize = 0;
        ctx.fillStyle = "rgba(0,0,0,0.4)";
        ctx.beginPath();
        ctx.ellipse(this.x, this.y + 5, shadowSize, shadowSize * 0.5, 0, 0, Math.PI*2);
        ctx.fill();

        ctx.translate(this.x, this.y - this.jumpHeight);
        ctx.rotate(this.angle);

        if (this.state === 'CHARGE') {
            let scaleMod = 1.0 - (Math.sin(Date.now() / 20) * 0.05);
            ctx.scale(scaleMod, 1/scaleMod); 
        }

        const cNeon = "#00d2ff";
        const cDark = "#005566";
        const cBlack = "#002233";

        // Legs
        ctx.strokeStyle = cNeon;
        ctx.lineWidth = 3;
        ctx.lineJoin = "round";
        const drawHindLeg = (side) => {
            let legOffset = (this.state === 'RUN') ? Math.sin(this.animTimer * 2 + side) * 5 : -10;
            if (this.state === 'AIR') legOffset = 15; 
            ctx.beginPath();
            ctx.moveTo(-5, side * 5); 
            ctx.lineTo(-15 + legOffset, side * 12); 
            ctx.lineTo(-5 + legOffset, side * 15); 
            ctx.stroke();
            ctx.fillStyle = cDark;
            ctx.beginPath();
            ctx.ellipse(-10 + (legOffset/2), side * 8, 4, 2, 0.5 * side, 0, Math.PI*2);
            ctx.fill();
        };
        drawHindLeg(1);
        drawHindLeg(-1);

        // Wings
        if (this.wingOpenAmount > 0.01) {
            ctx.save();
            ctx.fillStyle = "rgba(0, 210, 255, 0.4)";
            ctx.globalCompositeOperation = "lighter";
            ctx.beginPath();
            ctx.rotate(-0.2 * this.wingOpenAmount);
            ctx.moveTo(-5, -5); ctx.quadraticCurveTo(-20, -20, -25, -5); ctx.lineTo(-5, -2); ctx.fill();
            ctx.rotate(0.4 * this.wingOpenAmount); 
            ctx.beginPath();
            ctx.moveTo(-5, 5); ctx.quadraticCurveTo(-20, 20, -25, 5); ctx.lineTo(-5, 2); ctx.fill();
            ctx.restore();
        }

        // Body
        ctx.fillStyle = cBlack;
        ctx.beginPath(); ctx.ellipse(-8, 0, 10, 5, 0, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = cNeon; ctx.lineWidth = 1;
        for(let i=0; i<3; i++) { ctx.beginPath(); ctx.arc(-6 - (i*4), 0, 4 - i, -Math.PI/2, Math.PI/2); ctx.stroke(); }
        ctx.fillStyle = cDark;
        ctx.beginPath(); ctx.ellipse(2, 0, 6, 5, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "rgba(255,255,255,0.2)";
        ctx.beginPath(); ctx.ellipse(2, -2, 4, 2, 0, 0, Math.PI*2); ctx.fill();

        // Head
        ctx.fillStyle = cBlack;
        ctx.beginPath(); ctx.moveTo(6, -3); ctx.lineTo(14, 0); ctx.lineTo(6, 3); ctx.fill();
        ctx.fillStyle = (this.state === 'CHARGE') ? "#fff" : "#ff0044"; 
        ctx.beginPath(); ctx.arc(8, -2, 1.5, 0, Math.PI*2); ctx.arc(8, 2, 1.5, 0, Math.PI*2); ctx.fill();

        let twitch = Math.sin(Date.now() / 50) * 2;
        ctx.strokeStyle = cDark; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(14, -1); ctx.lineTo(16 + (twitch/4), -3);
        ctx.moveTo(14, 1);  ctx.lineTo(16 + (twitch/4), 3); ctx.stroke();

        // Front Legs
        ctx.strokeStyle = cNeon; ctx.lineWidth = 1.5;
        const drawFrontLeg = (side, offset) => {
            let legMove = (this.state === 'RUN') ? Math.sin(this.animTimer * 3 + offset) * 3 : 0;
            if (this.state === 'AIR') legMove = -5;
            ctx.beginPath(); ctx.moveTo(4, side * 3); ctx.lineTo(8 + legMove, side * 8); ctx.lineTo(12 + legMove, side * 10); ctx.stroke();
        };
        drawFrontLeg(1, 0); drawFrontLeg(-1, Math.PI);

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class ReviverEnemy {
    constructor() {
        // Spawn Logic
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        this.type = "REVIVER_XENOID";
        
        // STATS
        this.radius = 16; 
        this.speed = 0.55; 
        this.hp = 300 + (wave * 40); 
        this.maxHp = this.hp;
        this.bounty = 70; 
        
        this.vx = 0; 
        this.vy = 0;
        this.angle = 0; 
        
        // LOGIC
        this.reviveRadius = 180; 
        this.reviveSpeed = 1.3;  
        
        // ANIMATION STATE
        this.walkCycle = 0; 
        this.mandibleTwitch = 0;
        this.abdomenPulse = 0;
        this.isSinging = false;
        
        // VISUALS
        this.strideLength = 40; // Wider steps
    }

    update(dt) {
        // --- ANIMATION SYNC ---
        let moveSpeed = Math.hypot(this.vx, this.vy);
        
        // Much slower animation increment for a "Heavy" feel
        if (moveSpeed > 0.01) {
            this.walkCycle += 0.015; // Was 0.04
        } else {
            this.walkCycle += 0.005; // Idle breathing
        }

        this.mandibleTwitch += 0.1;
        this.abdomenPulse += 0.05;

        // --- 1. MOVEMENT ---
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);
        
        let isBlocked = sharedMovement(this, col, row);
        if (isBlocked) sharedDestroyWalls(this, col, row, 2, 12);

        this.x += this.vx;
        this.y += this.vy;
        
        // Smooth Rotation
        if (Math.abs(this.vx) > 0.01 || Math.abs(this.vy) > 0.01) {
            let targetAngle = Math.atan2(this.vy, this.vx);
            let diff = targetAngle - this.angle;
            while (diff < -Math.PI) diff += Math.PI * 2;
            while (diff > Math.PI) diff -= Math.PI * 2;
            this.angle += diff * 0.08; 
        }
        
        separate(this, enemies, 1.2); 

        // --- 2. HIVE MIND REVIVAL ---
        this.isSinging = false;
        for (let i = corpses.length - 1; i >= 0; i--) {
            let c = corpses[i];
            if (!c.active) continue;

            if (Math.hypot(c.x - this.x, c.y - this.y) < this.reviveRadius) {
                this.isSinging = true;
                if (typeof c.reviveProgress === 'undefined') c.reviveProgress = 0;
                c.reviveProgress += this.reviveSpeed;

                if (Math.random() > 0.85) createParticles(c.x, c.y, "#7c43bd", 1); 

                if (c.reviveProgress >= 100) {
                    enemies.push(new SkeletonEnemy(c.x, c.y));
                    createParticles(c.x, c.y, "#d500f9", 25); 
                    c.active = false; 
                }
            }
        }
        
        // Base Damage
        let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dx, dy) < 30) {
             takeDamage(20);
             this.hp = 0;
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle); 
        
        let s = 0.5; 
        ctx.scale(s, s);

        let pulse = Math.sin(this.abdomenPulse) * 2;

        // --- 1. WIDE SPIDER LEGS ---
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        const drawLeg = (side, row) => {
            let isFront = row < 2;
            
            // INCREASED LENGTH (Was 26/20)
            let legLen = isFront ? 36 : 28; 
            
            // --- GAIT TIMING ---
            const gaitOffset = [0, 0.5, 0.25, 0.75, 0.1][row];
            let t = (this.walkCycle + gaitOffset + (side === -1 ? 0.5 : 0)) % 1.0;
            
            // --- STANCE VS SWING ---
            let cycleX = 0; 
            let cycleLift = 0; 
            
            let swingDuration = 0.3; // 30% of time spent moving forward

            if (t < swingDuration) {
                // == SWING (AIR) ==
                let p = t / swingDuration; 
                // Move from Back (-1) to Front (+1)
                cycleX = -1 + (p * 2); 
                // Higher lift for longer legs
                cycleLift = Math.sin(p * Math.PI) * 12;
            } else {
                // == STANCE (GROUND) ==
                let p = (t - swingDuration) / (1.0 - swingDuration); 
                // Move from Front (+1) to Back (-1)
                cycleX = 1 - (p * 2); 
                cycleLift = 0; 
            }

            // --- CALCULATE POSITIONS ---
            
            // 1. Mount Point
            let mountX, mountY;
            if (isFront) {
                mountX = 9 - (row * 7); 
                mountY = side * 6;
            } else {
                let backIndex = row - 2;
                mountX = -14 - (backIndex * 8); 
                mountY = side * 8; 
            }

            // 2. Neutral Angle
            // Slight adjustment to fan them out more given the length
            let baseAngle = isFront ? (0.4 - row * 0.35) : (2.7 + (row-2) * 0.35);
            
            // 3. Apply Stride
            let strideOffset = cycleX * (this.strideLength / 2);
            
            let neutralReach = legLen;
            let nx = mountX + (Math.cos(baseAngle) * neutralReach);
            let ny = mountY + (Math.sin(baseAngle) * neutralReach * side);
            
            let footX = nx + strideOffset;
            let footY = ny; 

            // 4. IK for the Knee
            let midX = (mountX + footX) / 2;
            let midY = (mountY + footY) / 2;
            let dx = footX - mountX;
            let dy = footY - mountY;
            let dist = Math.hypot(dx, dy);
            
            // KNEE OUT: Increased to handle longer legs (Was 14)
            let kneeOut = 20 + (cycleLift * 0.8); 
            
            let perpX = -dy / dist;
            let perpY = dx / dist;
            if (perpY * side < 0) { perpX = -perpX; perpY = -perpY; }

            let kneeX = midX + (perpX * kneeOut);
            let kneeY = midY + (perpY * kneeOut);

            // --- DRAW ---
            
            // Shadow
            if (cycleLift > 1) {
                ctx.fillStyle = "rgba(0,0,0,0.3)";
                ctx.beginPath();
                // Shadow location slightly under the lifted foot
                ctx.arc(footX - (cycleX * 4), footY, 3, 0, Math.PI*2); 
                ctx.fill();
            }

            // Femur
            ctx.strokeStyle = "#1a237e"; 
            ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(mountX, mountY); ctx.lineTo(kneeX, kneeY); ctx.stroke();
            
            // Tibia
            let lightness = 57 + (cycleLift * 4); 
            ctx.strokeStyle = `hsl(231, 48%, ${lightness}%)`;
            ctx.lineWidth = 2.5;
            ctx.beginPath(); ctx.moveTo(kneeX, kneeY); ctx.lineTo(footX, footY); ctx.stroke();

            // Joints
            ctx.fillStyle = "#000"; ctx.beginPath(); ctx.arc(mountX, mountY, 3, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "#4a148c"; ctx.beginPath(); ctx.arc(kneeX, kneeY, 3.5, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "#d500f9"; ctx.beginPath(); ctx.arc(footX, footY, 2, 0, Math.PI*2); ctx.fill();
        };

        // Render Legs (Back to Front)
        for(let i=4; i>=2; i--) { drawLeg(1, i); drawLeg(-1, i); }
        
        // --- BODY ---
        ctx.strokeStyle = "#212121"; ctx.lineWidth = 10;
        ctx.beginPath(); ctx.moveTo(4, 0); ctx.lineTo(-12, 0); ctx.stroke();

        ctx.save();
        ctx.translate(-22, 0); 
        ctx.fillStyle = "#0d1b2a"; 
        ctx.beginPath(); ctx.ellipse(0, 0, 15, 11 + (pulse*0.3), 0, 0, Math.PI*2); ctx.fill();
        
        let buttGrad = ctx.createLinearGradient(0, -10, 0, 10);
        buttGrad.addColorStop(0, "#1a237e"); buttGrad.addColorStop(0.5, "#000"); buttGrad.addColorStop(1, "#1a237e");
        ctx.fillStyle = buttGrad;
        ctx.beginPath(); ctx.ellipse(3, 0, 11, 7, 0, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = this.isSinging ? "#d500f9" : "#4a148c";
        ctx.shadowBlur = 15; ctx.shadowColor = ctx.fillStyle;
        ctx.beginPath(); ctx.arc(-9, 0, 5, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
        ctx.restore();

        // Front Legs
        drawLeg(1, 1); drawLeg(-1, 1);
        drawLeg(1, 0); drawLeg(-1, 0);

        // Thorax
        ctx.fillStyle = "#1a237e";
        ctx.beginPath();
        ctx.moveTo(12, 0); ctx.lineTo(6, 8); ctx.lineTo(-4, 7); ctx.lineTo(-8, 0); ctx.lineTo(-4, -7); ctx.lineTo(6, -8);
        ctx.fill();
        ctx.fillStyle = "#304ffe";
        ctx.beginPath(); ctx.moveTo(9, 0); ctx.lineTo(0, 2); ctx.lineTo(-6, 0); ctx.lineTo(0, -2); ctx.fill();

        // Head
        ctx.save();
        ctx.translate(12, 0);
        let twitch = Math.sin(this.mandibleTwitch) * 0.2;
        ctx.fillStyle = "#283593"; ctx.strokeStyle = "#5c6bc0"; ctx.lineWidth = 1;
        
        ctx.save(); ctx.rotate(-0.4 + twitch);
        ctx.beginPath(); ctx.moveTo(0, -3); ctx.lineTo(13, -6); ctx.lineTo(10, -1); ctx.lineTo(0, 0);
        ctx.fill(); ctx.stroke(); ctx.restore();
        
        ctx.save(); ctx.rotate(0.4 - twitch);
        ctx.beginPath(); ctx.moveTo(0, 3); ctx.lineTo(13, 6); ctx.lineTo(10, 1); ctx.lineTo(0, 0);
        ctx.fill(); ctx.stroke(); ctx.restore();

        ctx.fillStyle = "#000"; ctx.beginPath(); ctx.arc(0, 0, 5.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#00e5ff"; ctx.shadowBlur = 5; ctx.shadowColor = "#00e5ff";
        ctx.beginPath(); ctx.arc(3, -2, 1.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(4, -1, 1, 0, Math.PI*2); ctx.fill(); 
        ctx.beginPath(); ctx.arc(3, 2, 1.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(4, 1, 1, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
        
        ctx.strokeStyle = "#d500f9"; ctx.lineWidth = 0.5;
        ctx.beginPath(); ctx.moveTo(5, -1); ctx.lineTo(18, -6 + Math.sin(Date.now()/60)*2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(5, 1); ctx.lineTo(18, 6 - Math.sin(Date.now()/60)*2); ctx.stroke();
        ctx.restore();

        // Singing
        if (this.isSinging) {
            let wavePhase = (Date.now() / 150) % 10;
            ctx.lineWidth = 1.5;
            for(let w=0; w<3; w++) { 
                let r = (wavePhase + (w*4)) * 6;
                let alpha = 1 - (r/45);
                if (alpha > 0) {
                    ctx.strokeStyle = `rgba(0, 229, 255, ${alpha})`; 
                    ctx.beginPath(); ctx.arc(15, 0, r, -0.8, 0.8); ctx.stroke();
                }
            }
        }

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class SkeletonEnemy {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.type = "SKELETON_UNIT";
        
        // Stats
        this.hp = 30 + (wave * 5);
        this.maxHp = this.hp;
        this.speed = 1.6;
        this.vx = 0; 
        this.vy = 0;
        this.radius = 12;
        this.bounty = 1;
        
        this.angle = 0;
        this.walkCycle = 0;
        this.twitch = 0; // Replaced "flicker" with a muscular spasm
    }

    update(dt) {
        this.walkCycle += 0.15; // Slower, more deliberate stride
        this.twitch = Math.random() > 0.98 ? Math.random() * 2 : 0; 
        
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);
        
        let isBlocked = sharedMovement(this, col, row);
        if (isBlocked) sharedDestroyWalls(this, col, row, 5, 5);

        this.x += this.vx;
        this.y += this.vy;
        
        if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
            this.angle = Math.atan2(this.vy, this.vx);
        }
        
        separate(this, enemies, 0.5);
    }

    draw() {
        ctx.save();
        ctx.translate(this.x + this.twitch, this.y + this.twitch); // Spasmodic movement
        ctx.rotate(this.angle);

        // Biological animation variables
        let breathe = Math.sin(this.walkCycle) * 1.5;
        let limbSwing = Math.sin(this.walkCycle);
        
        // --- 1. THE SPINE (Calcified Bone) ---
        ctx.strokeStyle = "#e0e0ce"; // Aged bone color
        ctx.lineWidth = 3;
        ctx.lineCap = "round";

        // Segmented vertebrae
        for(let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.fillStyle = i % 2 === 0 ? "#f5f5dc" : "#d2b48c";
            ctx.arc(-8 + (i * 4), 0, 2.5, 0, Math.PI * 2);
            ctx.fill();
        }

        // --- 2. ROTTING RIBCAGE ---
        ctx.strokeStyle = "#f5f5dc";
        ctx.lineWidth = 2;
        
        // Curved ribs instead of straight lines
        [1, -1].forEach(side => {
            ctx.beginPath();
            ctx.moveTo(2, side * 2);
            // Ribs expand and contract (breathing)
            ctx.quadraticCurveTo(-2, side * (8 + breathe), 4, side * (6 + breathe));
            ctx.stroke();
        });

        // --- 3. THE SKULL ---
        // Main cranium
        ctx.fillStyle = "#f5f5dc"; 
        ctx.beginPath();
        ctx.arc(6, 0, 5, 0, Math.PI * 2);
        ctx.fill();
        
        // Sunken Jaw
        ctx.beginPath();
        ctx.ellipse(8, 2, 3, 4, Math.PI/4, 0, Math.PI * 2);
        ctx.fill();

        // --- 4. THE EYE (Malevolent Glow) ---
        ctx.shadowBlur = 10;
        ctx.shadowColor = "#ff0000";
        ctx.fillStyle = "#4a0404"; // Dark socket
        ctx.beginPath();
        ctx.arc(7, -2, 2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = "#ff4444"; // Pinprick pupil
        ctx.beginPath();
        ctx.arc(7.5, -2, 0.8, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // --- 5. LASHING LIMBS (Exposed Tendons) ---
        ctx.strokeStyle = "#8b0000"; // Deep blood red
        ctx.lineWidth = 2;

        // Right Arm - Swinging erratically
        ctx.beginPath();
        ctx.moveTo(2, -4); 
        let rArmX = 10 + (limbSwing * 4);
        ctx.bezierCurveTo(rArmX, -10, rArmX + 2, -5, rArmX + 4, -8); 
        ctx.stroke();

        // Left Arm
        ctx.beginPath();
        ctx.moveTo(2, 4);
        let lArmX = 10 - (limbSwing * 4);
        ctx.bezierCurveTo(lArmX, 10, lArmX + 2, 5, lArmX + 4, 8);
        ctx.stroke();

        // --- 6. MIASMA / BLOOD DRIP (Rear) ---
        ctx.fillStyle = "#660000";
        ctx.globalAlpha = 0.3 + (Math.random() * 0.2);
        ctx.beginPath();
        ctx.arc(-12, breathe, 3, 0, Math.PI * 2);
        ctx.arc(-15, -breathe, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class FlyingEnemy {
    constructor() {
        // Spawn off-screen
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- STATS ---
        this.radius = 9;       
        this.speed = 0.6;      
        this.hp = 150 + (wave * 10)* difficultyMultiplier; 
        this.maxHp = this.hp;
        this.bounty = 7;

        this.vx = 0;
        this.vy = 0;
        
        this.animOffset = Math.random() * 1000;
    }

    update(dt) {
        // 1. MOVEMENT (Straight Line)
        let baseX = (playerBase.x * CELL_SIZE) + CELL_SIZE;
        let baseY = (playerBase.y * CELL_SIZE) + CELL_SIZE;
        
        let dx = baseX - this.x;
        let dy = baseY - this.y;
        let dist = Math.hypot(dx, dy);

        if (dist > 0) {
            this.vx = (dx / dist) * this.speed;
            this.vy = (dy / dist) * this.speed;
        }

        // REMOVED: The "wobble" code was here. 
        // Now it just tracks directly towards the base.

        this.x += this.vx *dt;
        this.y += this.vy *dt;

        // 2. PHYSICS
        separate(this, enemies, 0.5);

        // 3. ATTACK
        if (dist < 30) {
            takeDamage(5); 
            this.hp = 0;   
            createParticles(this.x, this.y, "#ff3300", 10); 
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        // --- SCALING ---
        ctx.scale(0.7, 0.9); 

        // 1. ORIENTATION (Face Forward)
        let angle = Math.atan2(this.vy, this.vx);
        ctx.rotate(angle + Math.PI / 2); 

        // Animation Variables
        let time = Date.now();
        let flutterFront = Math.sin((time / 60) + this.animOffset); 
        let flutterBack = Math.cos((time / 60) + this.animOffset);

        // --- 2. WINGS ---
        ctx.save();
        ctx.fillStyle = "rgba(200, 255, 255, 0.15)";
        ctx.strokeStyle = "rgba(0, 255, 255, 0.4)";
        ctx.lineWidth = 1;

        const drawWing = (xOffset, yOffset, length, width, rot) => {
            ctx.save();
            ctx.translate(xOffset, yOffset);
            ctx.rotate(rot); 
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(width, -length * 0.2); 
            ctx.lineTo(0, -length); 
            ctx.lineTo(-width, -length * 0.2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Inner Vein
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, -length * 0.8); ctx.stroke();
            ctx.restore();
        };

        // Front Wings
        drawWing(4, -5, 22, 4, 1.0 + (flutterFront * 0.3)); 
        drawWing(-4, -5, 22, 4, -1.0 - (flutterFront * 0.3));

        // Back Wings
        drawWing(3, 0, 16, 3, 2.2 + (flutterBack * 0.4));   
        drawWing(-3, 0, 16, 3, -2.2 - (flutterBack * 0.4));  
        ctx.restore();

        // --- 3. BODY & TAIL ---
        // Tail
        ctx.fillStyle = "#1a1a1a"; 
        ctx.strokeStyle = "#cc3300"; 
        ctx.lineWidth = 1;

        for(let i = 0; i < 4; i++) {
            let tailSize = 6 - i; 
            let tailY = 10 + (i * 4);
            let wiggle = Math.sin(time / 400 + (i * 0.5)) * 1; 

            ctx.beginPath();
            ctx.moveTo(wiggle, tailY);
            ctx.lineTo(wiggle + tailSize, tailY + tailSize);
            ctx.lineTo(wiggle, tailY + (tailSize * 2));
            ctx.lineTo(wiggle - tailSize, tailY + tailSize);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            if (i === 3) { 
                ctx.fillStyle = "#ff0000";
                ctx.beginPath(); ctx.arc(wiggle, tailY + 4, 2, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = "#1a1a1a";
            }
        }

        // Thorax
        ctx.fillStyle = "#222"; 
        ctx.beginPath();
        ctx.moveTo(0, -8); ctx.lineTo(6, -2); ctx.lineTo(4, 8); ctx.lineTo(-4, 8); ctx.lineTo(-6, -2);
        ctx.closePath(); ctx.fill(); ctx.stroke();

        // Head
        ctx.beginPath();
        ctx.moveTo(0, -8); ctx.lineTo(5, -14); ctx.lineTo(0, -18); ctx.lineTo(-5, -14);
        ctx.closePath(); ctx.fillStyle = "#000"; ctx.fill();

        // --- 4. FACE ---
        ctx.fillStyle = "#ff3300"; 
        ctx.shadowColor = "#ff0000"; ctx.shadowBlur = 8;
        ctx.beginPath(); ctx.ellipse(-3, -12, 2, 4, -0.3, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(3, -12, 2, 4, 0.3, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0; 

        // Mandibles
        ctx.strokeStyle = "#999"; ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(-2, -18); ctx.quadraticCurveTo(-6, -22, -1, -24);
        ctx.moveTo(2, -18); ctx.quadraticCurveTo(6, -22, 1, -24);
        ctx.stroke();

        ctx.restore();

        if (this.hp < this.maxHp) {
            const barW = 24;
            const barH = 4;
            const yOffset = 28;

            const barX = this.x - (barW / 2);
            const barY = this.y - yOffset;

            const pct = Math.max(0, Math.min(1, this.hp / this.maxHp));
            const hue = (pct * pct) * 120;

            ctx.fillStyle = "#333333";
            ctx.fillRect(barX, barY, barW, barH);

            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
            ctx.fillRect(barX, barY, barW * pct, barH);

            ctx.strokeStyle = "#000000";
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barW, barH);
        }
    }
}

class MagnetEnemy {
    constructor() {
        // --- SPAWN SETUP ---
        this.x = (typeof VIRTUAL_WIDTH !== 'undefined') ? VIRTUAL_WIDTH + 60 : 1000;
        let playableHeight = (typeof VIRTUAL_HEIGHT !== 'undefined') ? VIRTUAL_HEIGHT : 600;
        this.y = CELL_SIZE + Math.random() * (playableHeight - (CELL_SIZE * 2));

        // --- STATS ---
        this.radius = 22;          
        this.hp = 3000 + (wave * 150); 
        this.maxHp = this.hp;
        this.speed = 0.50;         
        this.bounty = 280;       
        
        // --- PHYSICS ---
        this.vx = 0;
        this.vy = 0;
        this.friction = 0.92;
        this.angle = Math.PI;      

        // --- ABILITY ---
        this.magnetRange = 340;    
        this.magnetForce = 1.6;   

        // --- VISUALS ---
        this.animTimer = 0;
        this.pulsePhase = 0;
        this.legCycle = 0;
        this.scale = 0.55; 
    }

    update(dt) {
        if (!dt) dt = 1;
        this.animTimer += dt * 0.05;
        this.pulsePhase += dt * 0.12;

        // --- MOVEMENT ---
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);
        
        let isBlocked = false;
        if (typeof sharedMovement === 'function') {
            isBlocked = sharedMovement(this, col, row);
        }

        if (isBlocked && typeof sharedDestroyWalls === 'function') {
            sharedDestroyWalls(this, col, row, 6, 30);
        }

        // Apply Velocity
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= this.friction;
        this.vy *= this.friction;

        // Calculate speed
        let speed = Math.hypot(this.vx, this.vy);
        
        // Face movement direction
        if (speed > 0.05) {
            let targetAngle = Math.atan2(this.vy, this.vx);
            let diff = targetAngle - this.angle;
            while (diff < -Math.PI) diff += Math.PI * 2;
            while (diff > Math.PI) diff -= Math.PI * 2;
            this.angle += diff * 0.08;
            
            // Leg animation
            this.legCycle += speed * 0.35; 
        }

        // --- MAGNET LOGIC (Fixed: Single Owner) ---
        if (typeof projectiles !== 'undefined') {
            for (let p of projectiles) {
                if (!p.active) continue;

                let dx = this.x - p.x;
                let dy = this.y - p.y;
                let distSq = dx*dx + dy*dy;
                let rangeSq = this.magnetRange * this.magnetRange;

                // 1. Release Lock if Out of Range
                // If I own this bullet but it's now too far away, let it go.
                if (distSq >= rangeSq) {
                    if (p.magnetOwner === this) {
                        p.magnetOwner = null;
                    }
                    continue; // Skip attraction
                }

                // 2. Check Ownership
                // If it is owned by someone else, AND that owner is still alive:
                if (p.magnetOwner && p.magnetOwner !== this) {
                    if (p.magnetOwner.hp > 0) {
                        continue; // Don't touch it
                    } else {
                        // Previous owner is dead, I can steal it
                        p.magnetOwner = null; 
                    }
                }

                // 3. Apply Attraction
                // Claim ownership
                p.magnetOwner = this;
                
                // Hijack Homing Target (if applicable)
                if (p.target && p.target !== this) p.target = this;

                let dist = Math.sqrt(distSq);

                // Stronger pull closer to center
                let strength = 1 + (1 - dist/this.magnetRange); 
                let force = this.magnetForce * strength;

                p.vx += (dx / dist) * force;
                p.vy += (dy / dist) * force;

                if (typeof p.angle !== 'undefined') {
                    let tA = Math.atan2(dy, dx);
                    let aD = tA - p.angle;
                    while (aD < -Math.PI) aD += Math.PI * 2;
                    while (aD > Math.PI) aD -= Math.PI * 2;
                    p.angle += aD * 0.2;
                }
            }
        }
        
        if (typeof separate === 'function') separate(this, enemies, 0.45);
        if (typeof resolveWallCollision === 'function') resolveWallCollision(this);
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        // --- 1. FIELD AURA ---
        let pulse = Math.sin(this.pulsePhase);
        let fieldR = this.magnetRange * (0.9 + pulse * 0.03);
        
        ctx.beginPath();
        ctx.arc(0, 0, fieldR, 0, Math.PI*2);
        let grad = ctx.createRadialGradient(0, 0, 10, 0, 0, fieldR);
        grad.addColorStop(0, "rgba(0,0,0,0)");
        grad.addColorStop(0.9, `rgba(100, 40, 160, ${0.05 + pulse * 0.02})`);
        grad.addColorStop(1, `rgba(100, 40, 160, 0)`);
        ctx.fillStyle = grad;
        ctx.fill();

        // ROTATE & SCALE
        ctx.rotate(this.angle);
        ctx.scale(this.scale, this.scale); 

        // --- 2. MULTI-JOINTED LEGS (SHORTER VERSION) ---
        const legConfig = [
            { side: 1,  yBase: -12, angle: -0.6, len: 28 },
            { side: -1, yBase: -12, angle: -0.6, len: 28 },
            { side: 1,  yBase: 0,   angle: 0,    len: 32 },
            { side: -1, yBase: 0,   angle: 0,    len: 32 },
            { side: 1,  yBase: 14,  angle: 0.8,  len: 30 },
            { side: -1, yBase: 14,  angle: 0.8,  len: 30 }
        ];

        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        legConfig.forEach((leg, index) => {
            ctx.save();
            let isGroupA = (index === 0 || index === 3 || index === 4);
            let legPhase = this.legCycle + (isGroupA ? 0 : Math.PI);
            
            let stride = Math.sin(legPhase) * 10; 
            let lift = Math.cos(legPhase) * 5;
            
            let startX = 5;
            let startY = leg.yBase;
            let baseAngle = (leg.side === 1 ? Math.PI/2 : -Math.PI/2) + (leg.angle * leg.side);
            
            let footDist = 20 + leg.len + lift;
            let footX = startX + Math.cos(baseAngle) * footDist + (stride * 0.5);
            let footY = startY + Math.sin(baseAngle) * footDist + stride;

            let coxaLen = 10;
            let coxaX = startX + Math.cos(baseAngle) * coxaLen;
            let coxaY = startY + Math.sin(baseAngle) * coxaLen;

            let dx = footX - coxaX;
            let dy = footY - coxaY;
            let dist = Math.hypot(dx, dy);
            let midX = coxaX + dx * 0.5;
            let midY = coxaY + dy * 0.5;
            
            let kneePush = 16;
            let perpX = -dy / dist;
            let perpY = dx / dist;
            if (leg.side === -1) { perpX = -perpX; perpY = -perpY; }
            
            let kneeX = midX + perpX * kneePush;
            let kneeY = midY + perpY * kneePush;

            // Draw Segments
            ctx.strokeStyle = "#150a1a";
            ctx.lineWidth = 7;
            ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(kneeX, kneeY); ctx.stroke();

            ctx.strokeStyle = "#25152e";
            ctx.lineWidth = 5;
            ctx.beginPath(); ctx.moveTo(kneeX, kneeY); ctx.lineTo(footX, footY); ctx.stroke();

            // Sharp tips
            ctx.strokeStyle = "#4a2d54";
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(footX, footY); ctx.lineTo(footX + (footX-kneeX)*0.4, footY + (footY-kneeY)*0.4); ctx.stroke();

            ctx.fillStyle = "#3d2a45";
            ctx.beginPath(); ctx.arc(kneeX, kneeY, 4, 0, Math.PI*2); ctx.fill();

            ctx.restore();
        });

        // --- 3. BODY STRUCTURE ---

        // Abdomen
        ctx.fillStyle = "#0d0612";
        ctx.strokeStyle = "#2a1a35";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-10, -15);
        ctx.lineTo(-30, -10);
        ctx.lineTo(-40, 0);   
        ctx.lineTo(-30, 10);
        ctx.lineTo(-10, 15);
        ctx.fill();
        ctx.stroke();

        // Thorax
        ctx.fillStyle = "#1a0e21";
        ctx.beginPath();
        ctx.moveTo(0, -18);
        ctx.lineTo(15, -12);
        ctx.lineTo(20, 0);
        ctx.lineTo(15, 12);
        ctx.lineTo(0, 18);
        ctx.lineTo(-10, 10);
        ctx.lineTo(-10, -10);
        ctx.closePath();
        ctx.fill();
        
        ctx.strokeStyle = "#3c2547";
        ctx.beginPath();
        ctx.moveTo(-5, -15); ctx.lineTo(10, -10);
        ctx.moveTo(-5, 15);  ctx.lineTo(10, 10);
        ctx.stroke();

        // Head
        ctx.fillStyle = "#25142e";
        ctx.beginPath();
        ctx.moveTo(20, -8);
        ctx.lineTo(28, -10);
        ctx.lineTo(32, -4);
        ctx.lineTo(32, 4);
        ctx.lineTo(28, 10);
        ctx.lineTo(20, 8);
        ctx.fill();

        // --- 4. STATIC SHARP MANDIBLES ---
        ctx.fillStyle = "#1a1a1a"; 
        ctx.strokeStyle = "#604070"; 
        ctx.lineWidth = 1;

        // TOP MANDIBLE (Left)
        ctx.beginPath();
        ctx.moveTo(32, -5);         
        ctx.lineTo(38, -10); 
        ctx.lineTo(36, -12); 
        ctx.lineTo(55, -18); // Sharp tip
        ctx.lineTo(50, -8);  
        ctx.lineTo(32, -2);          
        ctx.fill();
        ctx.stroke();

        // BOTTOM MANDIBLE (Right)
        ctx.beginPath();
        ctx.moveTo(32, 5);
        ctx.lineTo(38, 10);
        ctx.lineTo(36, 12);
        ctx.lineTo(55, 18); // Sharp tip
        ctx.lineTo(50, 8);
        ctx.lineTo(32, 2);
        ctx.fill();
        ctx.stroke();

        // Eyes
        ctx.fillStyle = "#ff0044";
        ctx.shadowBlur = 8; 
        ctx.shadowColor = "#ff0044";
        ctx.beginPath(); ctx.arc(26, -7, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(26, 7, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;

        // --- 5. GLOWING VENTS ---
        let ventGlow = 0.5 + Math.sin(this.pulsePhase * 3) * 0.5;

        ctx.save();
        ctx.translate(-20, -6);
        ctx.rotate(-0.2);
        ctx.shadowColor = `rgba(255, 50, 80, ${ventGlow})`;
        ctx.shadowBlur = 15;
        ctx.fillStyle = `rgba(255, 50, 80, ${0.5 + ventGlow * 0.5})`;
        ctx.beginPath();
        ctx.moveTo(0, 0); ctx.lineTo(10, -2); ctx.lineTo(0, -4); ctx.fill(); 
        ctx.restore();

        ctx.save();
        ctx.translate(-20, 6);
        ctx.rotate(0.2);
        ctx.shadowColor = `rgba(50, 180, 255, ${ventGlow})`;
        ctx.shadowBlur = 15;
        ctx.fillStyle = `rgba(50, 180, 255, ${0.5 + ventGlow * 0.5})`;
        ctx.beginPath();
        ctx.moveTo(0, 0); ctx.lineTo(10, 2); ctx.lineTo(0, 4); ctx.fill(); 
        ctx.restore();

        // Final Gloss
        ctx.fillStyle = "rgba(255,255,255,0.08)";
        ctx.beginPath();
        ctx.moveTo(5, -5); ctx.lineTo(15, -8); ctx.lineTo(10, 0); ctx.fill();

        ctx.restore(); 

        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class BossEnemy {
    constructor() {
        this.col = COLS - 1;
        this.row = Math.floor(ROWS / 2);
        this.x   = this.col * CELL_SIZE + CELL_SIZE / 2;
        this.y   = this.row * CELL_SIZE + CELL_SIZE / 2;

        this.radius = 45;
        this.speed  = 0.4;
        this.maxHp  = 1000 * difficultyMultiplier * (wave * 0.3);
        this.hp     = this.maxHp;
        this.damage = 9999;
        this.bounty = 500;
        this.active = true;

        this.vx = 0; this.vy = 0;
        this.angle     = Math.PI;
        this.animTimer = 0;

        this.armorColor = "#5c5443";

        // Pre-compute constants used every frame
        this._baseSq      = (this.radius + 30) * (this.radius + 30);
        this._crushSq     = (this.radius + 15) * (this.radius + 15);
        this._gridRadius  = Math.ceil(this.radius / CELL_SIZE);
        this._halfCell    = CELL_SIZE / 2;
        this._TWO_PI      = Math.PI * 2;
    }

    update(dt) {
        const targetX = playerBase.x * CELL_SIZE + CELL_SIZE;
        const targetY = playerBase.y * CELL_SIZE + CELL_SIZE;
        const dx = targetX - this.x;
        const dy = targetY - this.y;
        const distSq = dx * dx + dy * dy;

        if (distSq > 1) {
            const invDist = 1 / Math.sqrt(distSq);
            this.x += dx * invDist * this.speed;
            this.y += dy * invDist * this.speed;

            let diff = Math.atan2(dy, dx) - this.angle;
            if (diff < -Math.PI) diff += this._TWO_PI;
            else if (diff > Math.PI) diff -= this._TWO_PI;
            this.angle += diff * 0.04;
        }

        // Wall crush ‚Äî every other frame only
        if (gameFrame % 2 === 0) {
            const cx = Math.floor(this.x / CELL_SIZE);
            const cy = Math.floor(this.y / CELL_SIZE);
            const gr = this._gridRadius;
            const cSq = this._crushSq;
            const hc = this._halfCell;
            const tp = this._TWO_PI;

            for (let i = -gr; i <= gr; i++) {
                const col = cx + i;
                if (col < 0 || col >= COLS) continue;
                for (let j = -gr; j <= gr; j++) {
                    const row = cy + j;
                    if (row < 0 || row >= ROWS) continue;
                    const cell = grid[col][row];
                    if (!cell.wall) continue;
                    const cellX = col * CELL_SIZE + hc;
                    const cellY = row * CELL_SIZE + hc;
                    const wx = this.x - cellX;
                    const wy = this.y - cellY;
                    if (wx * wx + wy * wy < cSq) {
                        cell.wall = false;
                        cell.occupied = false;
                        for (let k = 0; k < 3; k++) {
                            particles.push({
                                x: cellX, y: cellY,
                                vx: (Math.random() - 0.5) * 10,
                                vy: (Math.random() - 0.5) * 10,
                                life: 60, color: this.armorColor,
                                size: Math.random() * 4
                            });
                        }
                    }
                }
            }
        }

        if (distSq < this._baseSq) {
            this.hp = 0;
            takeDamage(this.damage);
        }

        this.animTimer += 0.08;
    }

    draw() {
        const TWO_PI = this._TWO_PI;

        // Body (rotated)
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        const s  = 2.8;
        const s2 = 2 * s, s3 = 3 * s, s4 = 4 * s, s5 = 5 * s,
              s6 = 6 * s, s7 = 7 * s, s8 = 8 * s, s9 = 9 * s,
              s10 = 10 * s, s11 = 11 * s, s12 = 12 * s, s13 = 13 * s,
              s14 = 14 * s, s22 = 22 * s;

        const chitinDark  = "#120b05";
        const chitinMid   = "#3d3215";
        const chitinLight = "#6e5d38";
        const bone        = "#8c8260";
        const joint       = "#0f0505";
        const ventGlow    = "rgba(255, 100, 0, 0.8)";

        const breathe   = Math.sin(this.animTimer * 0.8);
        const walkCycle = this.animTimer;

        const drawLeg = (ox, oy, restX, restY, phase, side) => {
            const cycle  = walkCycle + phase;
            const lift   = Math.max(0, Math.sin(cycle));
            const stride = Math.cos(cycle);
            const sx = ox * s, sy = oy * s;
            const fx = sx + restX * s + stride * 5 * s;
            const fy = sy + restY * s + lift * -4 * side * s;
            const kx = (sx + fx) / 2 - s2;
            const ky = (sy + fy) / 2 + side * s6;

            ctx.lineCap = "round";
            ctx.strokeStyle = chitinMid; ctx.lineWidth = 3.5 * s;
            ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(kx, ky); ctx.stroke();

            ctx.strokeStyle = bone; ctx.lineWidth = s2;
            ctx.beginPath(); ctx.moveTo(kx, ky); ctx.lineTo(fx, fy); ctx.stroke();

            ctx.fillStyle = joint;
            ctx.beginPath(); ctx.arc(kx, ky, 2.2 * s, 0, TWO_PI); ctx.fill();

            ctx.fillStyle = bone;
            ctx.beginPath();
            ctx.moveTo(kx, ky);
            ctx.lineTo(kx - s, ky - side * s4);
            ctx.lineTo(kx + s, ky);
            ctx.fill();

            ctx.fillStyle = "#5e0e0e";
            ctx.beginPath(); ctx.arc(fx, fy, 0.8 * s, 0, TWO_PI); ctx.fill();
        };

        // Rear legs (dimmed)
        ctx.filter = "brightness(0.6)";
        drawLeg(-6, -3, -8, -8, 0, -1);
        drawLeg(-6,  3, -8,  8, Math.PI, 1);
        ctx.filter = "none";

        // Abdomen
        const sacPulse = 1 + breathe * 0.05;
        ctx.beginPath();
        ctx.moveTo(-4*s, -5*s);
        ctx.bezierCurveTo(-15*s, -12*s*sacPulse, -32*s, -s9, -38*s, 0);
        ctx.bezierCurveTo(-32*s,  s9,  -15*s,  12*s*sacPulse, -4*s, 5*s);
        ctx.lineTo(-4*s, -5*s);

        ctx.save();
        ctx.clip();

        const sacGrad = ctx.createRadialGradient(-20*s, 0, s2, -20*s, 0, s22);
        sacGrad.addColorStop(0,   "#ff5500");
        sacGrad.addColorStop(0.6, "#3b2010");
        sacGrad.addColorStop(1,   "#1a0f05");
        ctx.fillStyle = sacGrad;
        ctx.fill();

        ctx.strokeStyle = "rgba(0,0,0,0.5)"; ctx.lineWidth = s2;
        for (let i = 1; i <= 4; i++) {
            const rx = -s8 - i * s6;
            ctx.beginPath();
            ctx.moveTo(rx, -s10);
            ctx.quadraticCurveTo(rx - s4, 0, rx, s10);
            ctx.stroke();
        }
        ctx.restore();

        // Spinal plates
        ctx.fillStyle = chitinDark;
        ctx.strokeStyle = "rgba(110, 93, 56, 0.5)"; ctx.lineWidth = 0.5;
        for (let i = 0; i < 6; i++) {
            const spX = -s8 - i * 5 * s;
            const h   = s4 * (1 - i / 7);
            ctx.beginPath();
            ctx.moveTo(spX + s3, 0); ctx.lineTo(spX, -h);
            ctx.lineTo(spX - s3, 0); ctx.lineTo(spX,  h);
            ctx.fill();
            ctx.beginPath(); ctx.moveTo(spX, -h); ctx.lineTo(spX - s2, 0); ctx.stroke();
        }

        // Front legs
        drawLeg(-2, -4, -4, -11, Math.PI * 0.5, -1);
        drawLeg(-2,  4, -4,  11, Math.PI * 1.5,  1);
        drawLeg( 4, -4,  4, -10, 0, -1);
        drawLeg( 4,  4,  4,  10, Math.PI, 1);
        drawLeg( 8, -3, 10,  -5, Math.PI, -1);
        drawLeg( 8,  3, 10,   5, 0, 1);

        // Thorax
        const thoraxGrad = ctx.createRadialGradient(0, 0, s, 0, 0, s14);
        thoraxGrad.addColorStop(0, chitinMid);
        thoraxGrad.addColorStop(1, chitinDark);
        ctx.fillStyle = thoraxGrad;
        ctx.beginPath();
        ctx.moveTo(s10, -5*s); ctx.lineTo(s14, -s2);
        ctx.lineTo(s14,  s2);  ctx.lineTo(s10,  5*s);
        ctx.lineTo(-4*s, s7);  ctx.lineTo(-s8,  0);
        ctx.lineTo(-4*s, -s7); ctx.fill();

        ctx.fillStyle = chitinDark; ctx.strokeStyle = chitinLight; ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(s8, 0); ctx.lineTo(s2, -3.5*s);
        ctx.lineTo(-s6, 0); ctx.lineTo(s2, 3.5*s);
        ctx.closePath(); ctx.fill(); ctx.stroke();

        ctx.fillStyle = ventGlow;
        for (let i = 0; i < 3; i++) {
            const vx = i * 2.5 * s;
            ctx.beginPath(); ctx.ellipse(vx, -5.5*s, 0.6*s, 1.5*s,  0.4, 0, TWO_PI); ctx.fill();
            ctx.beginPath(); ctx.ellipse(vx,  5.5*s, 0.6*s, 1.5*s, -0.4, 0, TWO_PI); ctx.fill();
        }

        // Head
        ctx.save();
        ctx.translate(13 * s, 0);

        ctx.fillStyle = "#000000";
        ctx.beginPath(); ctx.arc(0, 0, 4.5 * s, 0, TWO_PI); ctx.fill();

        const innerTwitch = Math.sin(this.animTimer * 8) * 0.3;
        for (let dir = -1; dir <= 1; dir += 2) {
            ctx.save();
            ctx.translate(2.5 * s, dir * s);
            ctx.scale(1, dir);
            ctx.rotate(innerTwitch);
            ctx.fillStyle = "#2e1a1a";
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(s2, -0.5*s, s3, 0.5*s);
            ctx.lineTo(2.5*s, 0.8*s); ctx.lineTo(0, 0.5*s);
            ctx.fill();
            ctx.fillStyle = "#ff0000";
            ctx.beginPath(); ctx.arc(s3, 0.5*s, 0.2*s, 0, TWO_PI); ctx.fill();
            ctx.restore();
        }

        const biteOpen = 0.2 + Math.sin(this.animTimer * 1.5) * 0.15;
        const mGrad = ctx.createLinearGradient(0, 0, s14, 0);
        mGrad.addColorStop(0,   "#1a1616");
        mGrad.addColorStop(0.5, "#4a0a0a");
        mGrad.addColorStop(1,   "#000000");

        const drawNightmareMandible = (scaleY) => {
            ctx.save();
            ctx.scale(1, scaleY);
            ctx.rotate(-biteOpen);
            ctx.fillStyle = mGrad; ctx.strokeStyle = "#0d0505"; ctx.lineWidth = 0.3 * s;
            ctx.beginPath();
            ctx.moveTo(0, -s2);
            ctx.bezierCurveTo(s3, -3.5*s, s5, -3.5*s, s7, -s2);
            ctx.lineTo(7.2*s, -2.2*s);
            ctx.bezierCurveTo(s9, -s3, s12, -1.5*s, s14, 0.5*s);
            ctx.lineTo(s13, 0.8*s); ctx.lineTo(s11, 0);
            ctx.lineTo(10.5*s, 0.8*s); ctx.lineTo(s9, 0.2*s);
            ctx.lineTo(s8, 1.2*s);    ctx.lineTo(s6, 0.5*s);
            ctx.lineTo(s5, 1.5*s);    ctx.lineTo(0, 1.5*s);
            ctx.closePath(); ctx.fill(); ctx.stroke();
            ctx.strokeStyle = "rgba(0,0,0,0.5)"; ctx.lineWidth = 0.15 * s;
            ctx.beginPath();
            ctx.moveTo(s2, -s); ctx.quadraticCurveTo(s7, -1.5*s, s12, 0.2*s); ctx.stroke();
            ctx.restore();
        };

        ctx.save(); ctx.translate(s3, -1.5*s); drawNightmareMandible( 1); ctx.restore();
        ctx.save(); ctx.translate(s3,  1.5*s); drawNightmareMandible(-1); ctx.restore();

        // Head carapace
        const skullGrad = ctx.createRadialGradient(s2, 0, s, s4, 0, s8);
        skullGrad.addColorStop(0, "#2a2222");
        skullGrad.addColorStop(1, "#0a0a0a");
        ctx.fillStyle = skullGrad;
        ctx.beginPath();
        ctx.moveTo(-s2, -s4);
        ctx.bezierCurveTo(s3, -4.5*s, s6, -s3, s8, 0);
        ctx.bezierCurveTo(s6,  s3,    s3,  4.5*s, -s2, s4);
        ctx.lineTo(-2.5*s, 0); ctx.fill();

        // Eyes
        const drawEye = (x, y, r) => {
            const ex = x * s, ey = y * s;
            ctx.fillStyle = "#000";
            ctx.beginPath(); ctx.arc(ex, ey, r * s, 0, TWO_PI); ctx.fill();
            ctx.fillStyle = "#aaff00";
            ctx.beginPath(); ctx.arc(ex, ey, r * 0.6 * s, 0, TWO_PI); ctx.fill();
        };
        drawEye(4, -2, 1); drawEye(4, 2, 1);
        drawEye(2.5, -3.5, 0.6); drawEye(2.5, 3.5, 0.6);

        ctx.restore(); // head
        ctx.restore(); // body

        // Health bar (unrotated)
        ctx.save();
        ctx.translate(this.x, this.y);

        const barY = -(20 * s);
        const barW = 100;
        const hpPct = this.hp / this.maxHp;

        ctx.fillStyle = "rgba(0,0,0,0.8)";
        ctx.beginPath(); ctx.roundRect(-50, barY, barW, 8, 3); ctx.fill();

        const barGrad = ctx.createLinearGradient(-50, 0, 50, 0);
        barGrad.addColorStop(0, "#ff3300");
        barGrad.addColorStop(1, "#ccff00");
        ctx.fillStyle = barGrad;
        ctx.beginPath();
        ctx.roundRect(-49, barY + 1, Math.max(0, 98 * hpPct), 6, 2);
        ctx.fill();

        ctx.fillStyle = "#fff";
        ctx.font = "bold 12px Arial";
        ctx.textAlign = "center";
        ctx.fillText("HIVE QUEEN", 0, barY - 5);

        ctx.restore();
    }
}

function spawnBoss() {
    let boss = new BossEnemy();
    enemies.push(boss);
    
    // Optional: Announcement text
    currentAnnouncement = {
        text: "WARNING: BOSS DETECTED",
        life: 180,
        color: "#ff0000",
        update: function(dt) { this.life--; if(this.life<=0) this.active=false; },
        draw: function() {
            if(this.life > 0) {
                ctx.fillStyle = this.color;
                ctx.font = "bold 40px Segoe UI";
                ctx.textAlign = "center";
                ctx.fillText(this.text, canvas.width/2, 100);
            }
        },
        active: true
    };
}

class ShielderEnemy {
    constructor() {
        // --- SPAWN POSITION ---
        let boundW = (typeof VIRTUAL_WIDTH !== 'undefined') ? VIRTUAL_WIDTH : canvas.width;
        let boundH = (typeof VIRTUAL_HEIGHT !== 'undefined') ? VIRTUAL_HEIGHT : canvas.height;

        this.x = boundW + 20; 
        let playableHeight = boundH - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- STATS (Maintained Shielder Stats) ---
        this.radius = 16;            
        this.speed = 0.5;            
        this.hp = 400 + (wave * 25); 
        this.maxHp = this.hp;
        this.bounty = 40;
        
        // Initial Velocity
        this.vx = -0.5; 
        this.vy = 0;

        // --- COOLDOWNS ---
        this.attackCooldown = 0; 
        this.wallDamageCooldown = 0;

        // --- SHIELD ABILITY ---
        this.shieldRadius = 140;
        this.isShieldActive = true;
        
        // Timer (Frames)
        this.frameTimer = 0;
        this.onDuration = 300; 
        this.offDuration = 180;
        this.totalCycle = this.onDuration + this.offDuration;

        // --- VISUALS (Stag Beetle) ---
        this.angle = Math.PI; 
        this.animTimer = Math.random() * 10; 
        
        this.colors = {
            shell: "#1a1a2e", highlight: "#303045", core: "#00d2ff", legs: "#111"
        };
    }

    update(dt) {
        // --- 1. SHIELD TIMER LOGIC ---
        this.frameTimer+=dt;
        if (this.frameTimer >= this.totalCycle) this.frameTimer = 0;
        this.isShieldActive = (this.frameTimer < this.onDuration);

        // --- 2. MOVEMENT & WALL LOGIC (Updated to match your snippet) ---
        
        // Animation speed
        this.animTimer += 0.3 * dt; 

        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);

        let isBlocked = sharedMovement(this, col, row);
        
        // Wall Destruction Logic (Matches provided snippet)
        if (isBlocked) {
            sharedDestroyWalls(this, col, row, 2, 10);
        }

        if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
            this.angle = Math.atan2(this.vy, this.vx);
        }

        this.x += this.vx;
        this.y += this.vy;

        // Separation & Collision
        if (typeof enemies !== 'undefined') separate(this, enemies, 0.5); 
        if (typeof allies !== 'undefined') separate(this, allies, 0.8);
        
        // This ensures they don't walk through walls
        resolveWallCollision(this);

        // Base Damage Logic
        if (this.attackCooldown > 0) this.attackCooldown -= dt;
        
        if (typeof playerBase !== 'undefined') {
            let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
            let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
            if (Math.hypot(dx, dy) < 30) { 
                takeDamage(5); // Damage the player
                this.hp = 0;   // Suicide attack
            }
        }

        // --- 3. SHIELD EFFECT ---
        if (this.isShieldActive && typeof enemies !== 'undefined') {
            for (let e of enemies) {
                if (e === this) continue; 
                if (Math.hypot(e.x - this.x, e.y - this.y) < this.shieldRadius) {
                    e.isInvincible = true;
                    // Visual link
                    if (Math.random() < 0.05) {
                         particles.push({
                            x: e.x, y: e.y, 
                            vx: (this.x - e.x)*0.02, vy: (this.y - e.y)*0.02,
                            life: 15, color: this.colors.core, size: 1
                        });
                    }
                }
            }
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // --- DRAW SHIELD ---
        if (this.isShieldActive) {
            ctx.beginPath();
            ctx.arc(0, 0, this.shieldRadius, 0, Math.PI*2);
            ctx.strokeStyle = "rgba(0, 210, 255, 0.5)";
            ctx.lineWidth = 2;
            ctx.setLineDash([20, 15]);
            ctx.stroke();
            ctx.setLineDash([]); 
            ctx.fillStyle = "rgba(0, 210, 255, 0.05)";
            ctx.fill();
        } else {
            let pct = (this.frameTimer - this.onDuration) / this.offDuration; 
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI * 2 * (1-pct));
            ctx.strokeStyle = "#ff4444";
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // --- DRAW BODY (Maintained Stag Beetle Visuals) ---
        ctx.rotate(this.angle);

        // 1. LEGS
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        const drawLeg = (ox, oy, restX, restY, phase, side) => {
            let cycle = this.animTimer + phase;
            let footX = ox + restX + (Math.cos(cycle) * 3);
            let footY = oy + restY + (Math.abs(Math.sin(cycle)) * -2.0 * side);
            let kneeX = (ox + footX) / 2 - 2;
            let kneeY = (oy + footY) / 2 + (side * 6); 

            ctx.strokeStyle = "#000"; ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(kneeX, kneeY); ctx.lineTo(footX, footY); ctx.stroke();
            ctx.strokeStyle = "#333"; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(kneeX, kneeY); ctx.lineTo(footX, footY); ctx.stroke();
            ctx.fillStyle = this.colors.core; ctx.beginPath(); ctx.arc(kneeX, kneeY, 1.5, 0, Math.PI*2); ctx.fill();
        };

        drawLeg(4, -5,  4, -10, 0, -1);
        drawLeg(4,  5,  4,  10, Math.PI, 1);
        drawLeg(-2, -6, -2, -12, Math.PI, -1);
        drawLeg(-2,  6, -2,  12, 0, 1);
        drawLeg(-8, -5, -6, -10, 0, -1);
        drawLeg(-8,  5, -6,  10, Math.PI, 1);

        // 2. SEGMENTED BODY
        ctx.fillStyle = this.colors.shell;
        ctx.strokeStyle = this.colors.highlight;
        ctx.lineWidth = 2;

        // Rear
        ctx.beginPath(); ctx.moveTo(-6, -5); ctx.lineTo(-14, -3); ctx.lineTo(-18, 0); ctx.lineTo(-14, 3); ctx.lineTo(-6, 5); ctx.fill(); ctx.stroke();
        // Mid
        ctx.beginPath(); ctx.moveTo(2, -8); ctx.lineTo(-8, -7); ctx.lineTo(-10, 0); ctx.lineTo(-8, 7); ctx.lineTo(2, 8); ctx.fill(); ctx.stroke();
        // Vents
        ctx.fillStyle = "#111"; ctx.beginPath(); ctx.moveTo(-4, -4); ctx.lineTo(-2, -4); ctx.lineTo(-2, 4); ctx.lineTo(-4, 4); ctx.fill(); ctx.fillStyle = this.colors.shell; 
        // Front
        ctx.beginPath(); ctx.moveTo(10, -5); ctx.lineTo(8, -11); ctx.lineTo(0, -9); ctx.lineTo(-2, -6); ctx.lineTo(-2, 6); ctx.lineTo(0, 9); ctx.lineTo(8, 11); ctx.lineTo(10, 5); ctx.fill(); ctx.stroke();

        // 3. CORE
        let coreColor = this.isShieldActive ? this.colors.core : "#444";
        ctx.shadowBlur = this.isShieldActive ? 15 : 0;
        ctx.shadowColor = coreColor;
        ctx.fillStyle = coreColor;
        ctx.beginPath(); ctx.moveTo(2, -4); ctx.lineTo(7, 0); ctx.lineTo(2, 4); ctx.lineTo(-3, 0); ctx.fill();
        ctx.shadowBlur = 0; 

        // 4. HEAD
        ctx.fillStyle = "#0a0a10"; 
        ctx.beginPath();
        ctx.moveTo(8, -4); ctx.quadraticCurveTo(16, -8, 22, -3); ctx.lineTo(18, -1); ctx.quadraticCurveTo(14, -4, 8, -2);
        ctx.moveTo(8, 4); ctx.quadraticCurveTo(16, 8, 22, 3); ctx.lineTo(18, 1); ctx.quadraticCurveTo(14, 4, 8, 2); 
        ctx.fill();

        ctx.fillStyle = this.colors.shell;
        ctx.strokeStyle = this.colors.highlight;
        ctx.beginPath();
        ctx.moveTo(6, -6); ctx.lineTo(14, -3); ctx.lineTo(14, 3); ctx.lineTo(6, 6);
        ctx.fill(); ctx.stroke();

        ctx.fillStyle = "#ff0044"; 
        ctx.shadowBlur = 5; ctx.shadowColor = "#ff0044";
        ctx.beginPath(); ctx.moveTo(10, -5); ctx.lineTo(12, -4); ctx.lineTo(12, -2); ctx.lineTo(10, -3); ctx.fill();
        ctx.beginPath(); ctx.moveTo(10, 5); ctx.lineTo(12, 4); ctx.lineTo(12, 2); ctx.lineTo(10, 3); ctx.fill();
        ctx.shadowBlur = 0;

        ctx.restore();

        // --- HEALTH BAR ---
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class SwordTroop {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.radius = 11; 
        this.type = "SWORD_ALLY";
        
        // STATS
        this.hp = 250; this.maxHp = 250; 
        this.range = 45; 
        this.damage = 50 + (hasSkill('sword_dmg') ? 20 : 0); 
        this.lifeTimer = 1800; // 30s

        // MOVEMENT
        this.speed = 2.2 * (hasSkill('sword_move_spd') ? 1.2 : 1); 
        this.vx = 0; this.vy = 0;
        this.friction = 0.12;
        this.angle = 0; 

        // ANIMATION STATE
        this.cooldown = 0;
        this.maxCooldown = 50 * (hasSkill('sword_atk_spd') ? 0.85 : 1); 
        this.swingState = "IDLE"; 
        this.swingProgress = 0;
        
        // Animation Variables
        this.swordAngle = 0.5; 
        this.bodyLean = 0; 
        this.impactAlpha = 0;

        // AI VARS
        this.pathTimer = Math.random() * 30;
        this.pathRefreshRate = 20; 
        this.currentPath = [];
        this.nodeReachThreshold = 15;
        this.target = null;
        this.walkCycle = 0;
    }

    update(dt) {
        this.lifeTimer--;
        if (this.lifeTimer <= 0) this.hp = 0;

        // --- TARGETING ---
        if (!this.target || this.target.hp <= 0 || Math.random() < 0.05) {
            let nearest = null;
            let minDist = Infinity;
            for (let e of enemies) {
                let d = (e.x - this.x)**2 + (e.y - this.y)**2;
                if (d < minDist) { minDist = d; nearest = e; }
            }
            this.target = nearest;
        }

        let moving = false;

        if (this.target) {
            let dx = this.target.x - this.x;
            let dy = this.target.y - this.y;
            let distToTarget = Math.hypot(dx, dy);

            // COMBAT
            if (distToTarget < this.range) {
                this.vx *= 0.5; this.vy *= 0.5;
                this.angle = Math.atan2(dy, dx);

                if (this.cooldown <= 0 && this.swingState === "IDLE") {
                    this.swingState = "LIFT";
                    this.swingProgress = 0;
                    this.cooldown = this.maxCooldown;
                }
            }
            // MOVEMENT
            else {
                let moveX = this.target.x;
                let moveY = this.target.y;
                let usingPath = false;
                let canSee = typeof hasLineOfSight === 'function' ? hasLineOfSight(this.x, this.y, this.target.x, this.target.y) : true;

                if (!canSee && typeof findPath === 'function') {
                    this.pathTimer--;
                    if (this.pathTimer <= 0) {
                        this.currentPath = findPath(this, this.target);
                        this.pathTimer = this.pathRefreshRate;
                    }
                    if (this.currentPath && this.currentPath.length > 0) {
                        let nextNode = this.currentPath[0];
                        moveX = nextNode.x;
                        moveY = nextNode.y;
                        usingPath = true;
                        if (Math.hypot(nextNode.x - this.x, nextNode.y - this.y) < this.nodeReachThreshold) this.currentPath.shift();
                    }
                }
                if (!usingPath && canSee) this.currentPath = [];

                let mdx = moveX - this.x;
                let mdy = moveY - this.y;
                let mDist = Math.hypot(mdx, mdy);

                if (mDist > 1) {
                    let dirX = mdx / mDist;
                    let dirY = mdy / mDist;
                    this.vx += (dirX * this.speed - this.vx) * this.friction;
                    this.vy += (dirY * this.speed - this.vy) * this.friction;
                    moving = true;
                    if (Math.hypot(this.vx, this.vy) > 0.5) this.angle = Math.atan2(this.vy, this.vx);
                }
            }
        }

        if (!moving) { this.vx *= 0.8; this.vy *= 0.8; }
        if (this.cooldown > 0) this.cooldown--;
        if (this.impactAlpha > 0) this.impactAlpha -= 0.15; 

        if (moving) this.walkCycle += 0.35; else this.walkCycle = 0;

        this.updateNewAnimation();

        this.x += this.vx * dt;
        this.y += this.vy * dt;

        if(typeof separate === 'function') { separate(this, allies, 0.6); separate(this, enemies, 0.4); }
        if(typeof resolveWallCollision === 'function') resolveWallCollision(this);
    }

    updateNewAnimation() {
        let baseAngle = 0.4; 

        if (this.swingState !== "IDLE") {
            this.swingProgress++;

            // --- PHASE 1: LIFT (Two-handed wind up) ---
            if (this.swingState === "LIFT") {
                let duration = 12;
                let t = this.swingProgress / duration;
                let ease = t * t; 
                
                this.swordAngle = baseAngle - (ease * 2.6); 
                this.bodyLean = -3 * ease;

                if (this.swingProgress >= duration) {
                    this.swingState = "CHOP";
                    this.swingProgress = 0;
                }
            }
            // --- PHASE 2: CHOP ---
            else if (this.swingState === "CHOP") {
                let duration = 6;
                let t = this.swingProgress / duration;
                
                this.swordAngle = -2.2 + (t * 4.2); 
                this.bodyLean = -3 + (t * 8);

                if (this.swingProgress === 3) {
                     this.impactAlpha = 1.0;
                     if (this.target) {
                        let d = Math.hypot(this.target.x - this.x, this.target.y - this.y);
                        if (d < this.range + 15) {
                            this.target.hp -= this.damage;
                            if(typeof createParticles === 'function') {
                                createParticles(this.target.x, this.target.y, "#ffffff", 8);
                                createParticles(this.target.x, this.target.y, "#aa00ff", 6);
                            }
                            this.target.vx += Math.cos(this.angle) * 5;
                            this.target.vy += Math.sin(this.angle) * 5;
                        }
                    }
                }

                if (this.swingProgress >= duration) {
                    this.swingState = "RECOVER";
                    this.swingProgress = 0;
                }
            }
            // --- PHASE 3: RECOVER ---
            else if (this.swingState === "RECOVER") {
                let duration = 15;
                let t = this.swingProgress / duration;
                let ease = 1 - Math.pow(1 - t, 3);
                
                this.swordAngle = 2.0 - (ease * 1.6); 
                this.bodyLean = 5 * (1 - ease);

                if (this.swingProgress >= duration) {
                    this.swingState = "IDLE";
                    this.swordAngle = baseAngle;
                    this.bodyLean = 0;
                }
            }
        } else {
            this.bodyLean = 0;
            this.swordAngle = baseAngle + Math.sin(Date.now() / 250) * 0.05;
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // --- SHADOW ---
        ctx.fillStyle = "rgba(0,0,0,0.8)";
        ctx.beginPath();
        ctx.ellipse(-2 + (this.bodyLean * 0.5), 2, 11, 8, 0, 0, Math.PI*2);
        ctx.fill();

        // --- LEGS ---
        let leftLeg = Math.sin(this.walkCycle) * 5;
        let rightLeg = Math.sin(this.walkCycle + Math.PI) * 5;
        
        ctx.fillStyle = "#2a2a2a"; 
        ctx.beginPath(); ctx.arc(-4 + leftLeg + (this.bodyLean * 0.3), -5, 4, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(-4 + rightLeg + (this.bodyLean * 0.3), 5, 4, 0, Math.PI*2); ctx.fill();
        
        ctx.fillStyle = "#4a4a55"; 
        ctx.fillRect(-6 + leftLeg + (this.bodyLean * 0.3), -7, 6, 4);
        ctx.fillRect(-6 + rightLeg + (this.bodyLean * 0.3), 3, 6, 4);
        ctx.strokeStyle = "#888"; ctx.lineWidth = 0.5;
        ctx.strokeRect(-6 + leftLeg + (this.bodyLean * 0.3), -7, 6, 4);
        ctx.strokeRect(-6 + rightLeg + (this.bodyLean * 0.3), 3, 6, 4);

        // --- BODY ---
        ctx.save();
        ctx.translate(this.bodyLean, 0); 

        // Chest
        let chestGrad = ctx.createLinearGradient(-5, -5, 10, 5);
        chestGrad.addColorStop(0.0, "#666"); 
        chestGrad.addColorStop(0.4, "#222"); 
        chestGrad.addColorStop(1.0, "#444"); 
        
        ctx.fillStyle = chestGrad;
        ctx.beginPath();
        ctx.moveTo(-6, -7); ctx.lineTo(6, -7);
        ctx.lineTo(8, 0); ctx.lineTo(6, 7);
        ctx.lineTo(-6, 7);
        ctx.fill();
        ctx.strokeStyle = "#a0a0b0"; ctx.lineWidth = 1; ctx.stroke();

        // Shoulders
        let shoulderGrad = ctx.createRadialGradient(-2, -9, 0, 0, -7, 6);
        shoulderGrad.addColorStop(0, "#fff"); shoulderGrad.addColorStop(1, "#111");
        ctx.fillStyle = shoulderGrad;
        ctx.beginPath(); ctx.arc(0, -7, 5, 0, Math.PI*2); ctx.fill(); 
        ctx.beginPath(); ctx.arc(0, 7, 5, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#8899aa"; ctx.stroke(); ctx.beginPath(); ctx.arc(0, 7, 5, 0, Math.PI*2); ctx.stroke(); 

        // Head
        ctx.save();
        ctx.translate(2, 0); 
        ctx.fillStyle = "#222"; ctx.beginPath(); ctx.arc(0, 0, 5.5, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#aaa"; ctx.lineWidth = 1; ctx.stroke();
        ctx.fillStyle = "rgba(255,255,255,0.4)"; ctx.beginPath(); ctx.ellipse(-2, -2, 2, 1, Math.PI/-4, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#fff"; ctx.shadowColor = "#aa00ff"; ctx.shadowBlur = 10;
        ctx.beginPath(); ctx.fillRect(2, -3, 3, 6); ctx.shadowBlur = 0;
        ctx.restore();

        // --- TWO-HANDED SWORD GRIP ---
        ctx.save();
        ctx.translate(0, 0); // Rotate from center of body/shoulders
        ctx.rotate(this.swordAngle); 

        // 1. LEFT ARM (The supporting arm, underneath)
        // Reaches slightly shorter than the right arm
        ctx.fillStyle = "#222"; 
        ctx.fillRect(0, 4, 8, 4); // Arm segment
        ctx.strokeRect(0, 4, 8, 4);

        // 2. RIGHT ARM (The main arm, on top)
        // Reaches further out
        ctx.fillStyle = "#333"; 
        ctx.fillRect(0, -4, 11, 4); // Arm segment
        ctx.strokeRect(0, -4, 11, 4);

        // 3. HANDS (Gauntlets)
        // Left Hand (Closer to body)
        ctx.fillStyle = "#111"; 
        ctx.translate(8, 6); // Move to Left Hand pos
        ctx.beginPath(); ctx.arc(0, 0, 3.5, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = "#888"; ctx.stroke();
        
        // Right Hand (Further out)
        ctx.translate(4, -8); // Move relative to Left Hand to get to Right Hand pos
        ctx.fillStyle = "#111";
        ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = "#aaa"; ctx.stroke();

        // 4. THE SWORD (Held by both hands)
        // We are now at the Right Hand position.
        // Rotate 90 degrees so sword points out
        ctx.rotate(Math.PI / 2); 

        // Hilt (Extended for two hands)
        // Goes "down" (backwards) to reach the Left hand
        ctx.fillStyle = "#444";
        ctx.fillRect(-2, -4, 4, 16); // Longer handle
        ctx.fillStyle = "#888"; 
        ctx.fillRect(-4, 10, 8, 2); // Pommel (at the bottom/back)

        // --- SWOOSH TRAIL ---
        if (this.swingState === "CHOP") {
            ctx.save();
            ctx.beginPath();
            ctx.arc(-8, -6, 40, Math.PI, 0, false); 
            ctx.strokeStyle = "rgba(200, 150, 255, 0.5)";
            ctx.lineWidth = 12;
            ctx.lineCap = "round";
            ctx.shadowColor = "#d000ff";
            ctx.shadowBlur = 15;
            ctx.stroke();
            ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
            ctx.lineWidth = 4;
            ctx.stroke();
            ctx.restore();
        }

        // Blade
        ctx.shadowColor = "#d000ff"; ctx.shadowBlur = 15;
        let bladeGrad = ctx.createLinearGradient(0, -6, 0, -45);
        bladeGrad.addColorStop(0, "#ffffff"); bladeGrad.addColorStop(0.3, "#e0c0ff"); bladeGrad.addColorStop(1, "#8800ff");
        ctx.fillStyle = bladeGrad;
        ctx.beginPath();
        ctx.moveTo(-2, -6); ctx.lineTo(-2, -42); ctx.lineTo(0, -46); ctx.lineTo(2, -42); ctx.lineTo(2, -6);
        ctx.fill();
        ctx.shadowBlur = 0; 

        ctx.restore(); // End Arm/Sword Group
        ctx.restore(); // End Body
        
        // --- GROUND IMPACT FLASH ---
        if (this.impactAlpha > 0.01) {
            ctx.globalAlpha = this.impactAlpha;
            ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
            ctx.translate(30, 0); 
            ctx.beginPath();
            for(let i=0; i<8; i++) {
                let ang = (i/8)*Math.PI*2;
                let r = (i%2==0) ? 25 : 10;
                ctx.lineTo(Math.cos(ang)*r, Math.sin(ang)*r);
            }
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }

        ctx.restore(); // End Global

        // HP BAR
        if (this.hp < this.maxHp) {
            const barW = 24; const barH = 4;
            const barX = this.x - (barW / 2); const barY = this.y - 28;
            const pct = Math.max(0, this.hp / this.maxHp);
            const hue = (pct * pct) * 120; 
            ctx.fillStyle = "#000"; ctx.fillRect(barX, barY, barW, barH);
            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`; ctx.fillRect(barX, barY, barW * pct, barH);
            ctx.strokeStyle = "#fff"; ctx.lineWidth = 1; ctx.strokeRect(barX, barY, barW, barH);
        }
    }
}

class ShieldSoldier {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.radius = 15; 
        this.type = "SHIELD_ALLY";
        
        // --- STATS ---
        this.hp = 600 + (hasSkill('shield_hp') ? 200 : 0);      
        this.maxHp = 600 + (hasSkill('shield_hp') ? 200 : 0);
        this.range = 45;     
        this.damage = 15;   
        this.lifeTimer = 1800; 

        // --- MOVEMENT ---
        this.speed = 1.6;    
        this.vx = 0; this.vy = 0;
        this.friction = 0.12;
        this.angle = 0;

        // --- COMBAT / ANIMATION ---
        this.cooldown = 0;
        this.maxCooldown = 50; 
        this.pushState = "IDLE"; 
        this.pushProgress = 0;
        this.shieldOffset = 18; 

        // --- AI VARS ---
        this.pathTimer = Math.random() * 30; 
        this.pathRefreshRate = 30; 
        this.currentPath = [];
        this.nodeReachThreshold = 15; 
        
        // --- VISUAL PALETTE ---
        this.walkCycle = 0;
        this.colors = {
            armorDark:  "#1c2630", 
            armorLight: "#2e3d4d", 
            vest:       "#111820", 
            skin:       "#eebb99",
            energyCore: "rgba(0, 220, 255, 0.4)",
            energyEdge: "#00ffff",
            emitter:    "#111"
        };
    }

    update(dt) {
        this.lifeTimer--;
        if (this.lifeTimer <= 0) this.hp = 0;

        // --- TARGETING ---
        let nearest = null;
        let minDist = Infinity;
        if (typeof enemies !== 'undefined') {
            for (let e of enemies) {
                let d = (e.x - this.x)**2 + (e.y - this.y)**2;
                if (d < minDist) { minDist = d; nearest = e; }
            }
        }
        
        let moving = false;

        if (nearest) {
            let distToEnemy = Math.sqrt(minDist);
            let canSeeEnemy = typeof hasLineOfSight === 'function' ? hasLineOfSight(this.x, this.y, nearest.x, nearest.y) : true;

            // 1. COMBAT: Stop and Bash if closest enemy is in range
            if (distToEnemy < this.range && canSeeEnemy) {
                this.vx *= 0.5; this.vy *= 0.5;
                this.angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);

                if (this.cooldown <= 0 && this.pushState === "IDLE") {
                    this.pushState = "WINDUP";
                    this.pushProgress = 0;
                    this.cooldown = this.maxCooldown;
                }
            } 
            // 2. MOVEMENT (Pathfinding)
            else {
                let targetX = nearest.x;
                let targetY = nearest.y;
                let usingPath = false;

                if (!canSeeEnemy && typeof findPath === 'function') {
                    this.pathTimer--;
                    if (this.pathTimer <= 0) {
                        this.currentPath = findPath(this, nearest);
                        this.pathTimer = this.pathRefreshRate;
                    }
                    if (this.currentPath && this.currentPath.length > 0) {
                        let nextNode = this.currentPath[0];
                        targetX = nextNode.x;
                        targetY = nextNode.y;
                        usingPath = true;
                        if (Math.hypot(nextNode.x - this.x, nextNode.y - this.y) < this.nodeReachThreshold) {
                            this.currentPath.shift(); 
                        }
                    }
                }
                
                if (!usingPath && canSeeEnemy) this.currentPath = []; 

                let dx = targetX - this.x;
                let dy = targetY - this.y;
                let dist = Math.hypot(dx, dy);

                if (dist > 5) {
                    let dirX = dx / dist;
                    let dirY = dy / dist;
                    this.vx += (dirX * this.speed - this.vx) * this.friction;
                    this.vy += (dirY * this.speed - this.vy) * this.friction;
                    moving = true;
                    if (Math.hypot(this.vx, this.vy) > 0.1) this.angle = Math.atan2(this.vy, this.vx);
                }
            }
        } else {
            this.vx *= 0.8; this.vy *= 0.8;
        }

        if (this.cooldown > 0) this.cooldown--;
        if (moving) this.walkCycle += 0.3; else this.walkCycle = 0;
        
        this.updateAnimation(); 
        
        this.x += this.vx;
        this.y += this.vy;
        
        if(typeof separate === 'function') { separate(this, allies || [], 0.6); separate(this, enemies || [], 0.4); }
        if(typeof resolveWallCollision === 'function') resolveWallCollision(this);
    }

    updateAnimation() {
        if (this.pushState !== "IDLE") {
            this.pushProgress++;
            
            // --- WINDUP ---
            if (this.pushState === "WINDUP") {
                this.shieldOffset = 18 - (this.pushProgress / 10) * 10; 
                if (this.pushProgress >= 10) { this.pushState = "SLAM"; this.pushProgress = 0; }
            } 
            // --- SLAM (DAMAGE FRAME) ---
            else if (this.pushState === "SLAM") {
                this.shieldOffset = 8 + (this.pushProgress / 5) * 22; 
                
                // ** AOE DAMAGE LOGIC **
                if (this.pushProgress === 2) {
                    if (typeof enemies !== 'undefined') {
                        for (let e of enemies) {
                            // 1. Distance Check
                            let dx = e.x - this.x;
                            let dy = e.y - this.y;
                            let dist = Math.hypot(dx, dy);
                            
                            // Hit everything slightly further than normal range (Reach bonus)
                            if (dist < this.range + 35) {
                                
                                // 2. Angle Check (Are they in front?)
                                let angleToEnemy = Math.atan2(dy, dx);
                                let angleDiff = angleToEnemy - this.angle;
                                
                                // Normalize angle to -PI to PI to prevent wrapping errors
                                while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2;
                                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;

                                // If within ~60 degrees left/right (1.0 radians), HIT
                                if (Math.abs(angleDiff) < 1.0) {
                                    e.hp -= this.damage;
                                    // Knockback is applied based on Shield Facing, not relative angle
                                    // This pushes everyone uniformly away
                                    e.vx += Math.cos(this.angle) * 15;
                                    e.vy += Math.sin(this.angle) * 15;
                                }
                            }
                        }
                    }
                }
                
                if (this.pushProgress >= 8) { this.pushState = "RECOVER"; this.pushProgress = 0; }
            } 
            // --- RECOVER ---
            else if (this.pushState === "RECOVER") {
                this.shieldOffset = 30 - (this.pushProgress / 15) * 12;
                if (this.pushProgress >= 15) { this.pushState = "IDLE"; this.shieldOffset = 18; }
            }
        } else {
            this.shieldOffset = 18 + Math.sin(Date.now() / 300) * 0.5; 
        }
    }


    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // Legs
        let legL = Math.sin(this.walkCycle) * 5;
        let legR = Math.sin(this.walkCycle + Math.PI) * 5;
        ctx.fillStyle = "#111"; 
        ctx.beginPath(); ctx.roundRect(-6 + legL, -9, 6, 4, 2); ctx.fill();
        ctx.beginPath(); ctx.roundRect(-6 + legR, 5, 6, 4, 2); ctx.fill();
        ctx.fillStyle = this.colors.armorLight;
        ctx.beginPath(); ctx.arc(-4 + legL, -7, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(-4 + legR, 7, 2.5, 0, Math.PI*2); ctx.fill();

        // Body
        ctx.fillStyle = this.colors.armorDark;
        ctx.beginPath(); ctx.roundRect(-9, -11, 16, 22, 5); ctx.fill();
        ctx.fillStyle = this.colors.vest;
        ctx.fillRect(-5, -8, 9, 16);
        ctx.strokeStyle = "#333"; ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-4, -4); ctx.lineTo(3, -4);
        ctx.moveTo(-4, 0); ctx.lineTo(3, 0);
        ctx.moveTo(-4, 4); ctx.lineTo(3, 4);
        ctx.stroke();

        // Helmet
        ctx.fillStyle = this.colors.skin;
        ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI*2); ctx.fill();
        let helmGrad = ctx.createRadialGradient(-2, -2, 1, 0, 0, 8);
        helmGrad.addColorStop(0, this.colors.armorLight);
        helmGrad.addColorStop(1, this.colors.armorDark);
        ctx.fillStyle = helmGrad;
        ctx.beginPath(); ctx.arc(0, 0, 7.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#222"; 
        ctx.fillRect(-2, -8.5, 5, 2); ctx.fillRect(-2, 6.5, 5, 2);  
        ctx.fillStyle = "#111"; 
        ctx.beginPath(); ctx.roundRect(3, -5, 3, 10, 2); ctx.fill();
        ctx.fillStyle = "#0ff"; 
        ctx.globalAlpha = 0.6; ctx.fillRect(4, -3, 1, 3); ctx.globalAlpha = 1.0;

        // --- ARMS (Always Centered) ---
        let handleX = this.shieldOffset - 3;
        let handleY = 0; 

        // Right Arm
        ctx.save();
        ctx.translate(3, 10); 
        let rAngle = Math.atan2(handleY - 10, handleX - 3);
        let rDist = Math.hypot(handleX - 3, handleY - 10);
        ctx.rotate(rAngle);
        ctx.fillStyle = this.colors.vest;
        ctx.beginPath(); ctx.roundRect(0, -2, rDist/2, 4, 2); ctx.fill();
        ctx.fillStyle = this.colors.armorLight;
        ctx.beginPath(); ctx.roundRect(rDist/2, -2.5, rDist/2, 5, 2); ctx.fill();
        ctx.fillStyle = "#111";
        ctx.beginPath(); ctx.arc(rDist, 0, 3, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = this.colors.armorDark;
        ctx.beginPath(); ctx.arc(0, 0, 5.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = this.colors.armorLight;
        ctx.beginPath(); ctx.arc(0, 0, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.restore();

        // Left Arm
        ctx.save();
        ctx.translate(3, -10); 
        let lAngle = Math.atan2(handleY - (-10), handleX - 3);
        let lDist = Math.hypot(handleX - 3, handleY - (-10));
        ctx.rotate(lAngle);
        ctx.fillStyle = this.colors.vest;
        ctx.beginPath(); ctx.roundRect(0, -2, lDist/2, 4, 2); ctx.fill();
        ctx.fillStyle = this.colors.armorLight;
        ctx.beginPath(); ctx.roundRect(lDist/2, -2.5, lDist/2, 5, 2); ctx.fill();
        ctx.fillStyle = "#111";
        ctx.beginPath(); ctx.arc(lDist, 0, 3.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = this.colors.armorDark;
        ctx.beginPath(); ctx.arc(0, 0, 5.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = this.colors.armorLight;
        ctx.beginPath(); ctx.arc(0, 0, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.restore();

        // --- SHIELD ---
        ctx.save();
        ctx.translate(this.shieldOffset, 0);
        ctx.fillStyle = this.colors.emitter;
        ctx.fillRect(0, -22, 4, 44); 
        ctx.fillStyle = this.colors.energyEdge;
        ctx.fillRect(1, -21, 2, 2); 
        ctx.fillRect(1, 19, 2, 2); 
        ctx.fillStyle = "#222";
        ctx.fillRect(-4, -6, 4, 12); 

        let glowIntensity = (this.pushState === "SLAM") ? 20 : 8;
        let energyAlpha = (this.pushState === "SLAM") ? 0.7 : 0.35;

        ctx.shadowColor = this.colors.energyEdge;
        ctx.shadowBlur = glowIntensity;
        let eGrad = ctx.createLinearGradient(0, -25, 0, 25);
        eGrad.addColorStop(0, `rgba(0, 200, 255, ${energyAlpha/2})`);
        eGrad.addColorStop(0.5, `rgba(200, 255, 255, ${energyAlpha})`); 
        eGrad.addColorStop(1, `rgba(0, 200, 255, ${energyAlpha/2})`);
        ctx.fillStyle = eGrad;
        ctx.strokeStyle = this.colors.energyEdge;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(4, -22);
        ctx.quadraticCurveTo(8, 0, 4, 22); 
        ctx.lineTo(2, 22);
        ctx.quadraticCurveTo(6, 0, 2, -22); 
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.shadowBlur = 0; 
        ctx.strokeStyle = "rgba(100, 255, 255, 0.3)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i = -16; i < 16; i+=8) {
             ctx.moveTo(3, i); ctx.lineTo(7, i+4);
             ctx.moveTo(3, i); ctx.lineTo(7, i-4);
        }
        ctx.stroke();
        ctx.restore(); 

        ctx.restore(); 

        if (typeof drawHealth === 'function') drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class BardTroop {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 12;
        this.color = "#d633ff"; 
        this.hp = 100 + (hasSkill('bard_durability') ? 100 : 0);
        this.maxHp = 100 + (hasSkill('bard_durability') ? 100 : 0);

        // --- STATS ---
        this.lifeTimer = 600; 
        this.tauntRange = 160 * (hasSkill('bard_range') ? 1.3 : 1.0);
        this.fleeThreshold = 120; 

        // --- PATHFINDING & PHYSICS ---
        this.speed = 1;         
        this.vx = 0; 
        this.vy = 0;
        this.friction = 0.12;  
        
        this.pathTimer = Math.random() * 30; 
        this.pathRefreshRate = 30; 
        this.currentPath = [];
        this.nodeReachThreshold = 15;

        // --- ANIMATION ---
        this.angle = 0;      
        this.walkCycle = 0;  
        this.targetAngle = 0;
    }

    update(dt) {
        if (typeof dt === 'undefined') dt = 1;

        this.lifeTimer--;
        if (this.lifeTimer <= 0) this.hp = 0;

        // 1. SCAN ENVIRONMENT
        let nearest = null;
        let minDist = Infinity;
        let fleeCount = 0;

        for (let e of enemies) {
            let d = (e.x - this.x)**2 + (e.y - this.y)**2;
            let dist = Math.sqrt(d);

            // A. SEEKING: Track nearest enemy (even through walls)
            if (d < minDist) { minDist = d; nearest = e; }

            // B. INTERACTION: Check Line of Sight for Taunt/Flee
            let canSee = true;
            if (typeof hasLineOfSight === 'function') {
                canSee = hasLineOfSight(this.x, this.y, e.x, e.y);
            }

            if (canSee) {
                if (dist < this.tauntRange) e.tauntTarget = this;
                if (dist < this.fleeThreshold) fleeCount++;
            }
        }

        // 2. DETERMINE TARGET DESTINATION
        let targetX = this.x;
        let targetY = this.y;
        let moving = false;
        let mode = 'IDLE';

        if (fleeCount > 0) {
            // --- MODE: FLEE (RUN TO RIGHT SIDE) ---
            mode = 'FLEE';
            
            // Target the far right edge of the map
            // We assume COLS global exists, otherwise fallback to a large number
            const rightEdge = (typeof COLS !== 'undefined') ? (COLS * CELL_SIZE) - 25 : 2000;
            
            targetX = rightEdge;
            targetY = this.y; // Maintain current height, run straight right
            
        } else if (nearest) {
            // --- MODE: SEEK ---
            mode = 'SEEK';
            targetX = nearest.x;
            targetY = nearest.y;
        }

        // 3. APPLY PATHFINDING
        if (mode !== 'IDLE') {
            let usingPath = false;
            
            // Check Line of Sight to TARGET DESTINATION
            let canSeeTarget = true;
            if (typeof hasLineOfSight === 'function') {
                 canSeeTarget = hasLineOfSight(this.x, this.y, targetX, targetY);
            }

            // If target blocked (by wall), use Pathfinding
            if (!canSeeTarget && typeof findPath === 'function') {
                this.pathTimer--;

                if (this.pathTimer <= 0) {
                    this.currentPath = findPath(this, {x: targetX, y: targetY});
                    this.pathTimer = this.pathRefreshRate;
                }

                if (this.currentPath && this.currentPath.length > 0) {
                    let nextNode = this.currentPath[0];
                    targetX = nextNode.x;
                    targetY = nextNode.y;
                    usingPath = true;

                    let dNode = Math.hypot(nextNode.x - this.x, nextNode.y - this.y);
                    if (dNode < this.nodeReachThreshold) {
                        this.currentPath.shift();
                    }
                }
            }

            if (!usingPath && canSeeTarget) {
                this.currentPath = [];
            }

            // 4. PHYSICS MOVEMENT
            let dx = targetX - this.x;
            let dy = targetY - this.y;
            let dist = Math.hypot(dx, dy);

            if (dist > 5) {
                let dirX = dx / dist;
                let dirY = dy / dist;
                
                // Flee slightly faster
                let currentSpeed = (mode === 'FLEE') ? this.speed * 1.2 : this.speed;

                this.vx += (dirX * currentSpeed - this.vx) * this.friction;
                this.vy += (dirY * currentSpeed - this.vy) * this.friction;
                moving = true;

                if (Math.hypot(this.vx, this.vy) > 0.1) {
                    let desiredAngle = Math.atan2(this.vy, this.vx);
                    let diff = desiredAngle - this.angle;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    this.angle += diff * 0.15;
                }
            }
        }

        if (!moving) {
            this.vx *= 0.8;
            this.vy *= 0.8;
        }

        if (moving) this.walkCycle += 0.25;
        else this.walkCycle = 0;

        this.x += this.vx * dt;
        this.y += this.vy * dt;

        if(typeof separate === 'function') { separate(this, allies, 0.5); } 
        if(typeof resolveWallCollision === 'function') resolveWallCollision(this);
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // Animation Variables
        const bounce = Math.abs(Math.sin(this.walkCycle)) * 2;
        const sway = Math.sin(this.walkCycle) * 0.15; 
        const featherLag = Math.sin(this.walkCycle - 1.5) * 0.4; 

        // --- 1. SOFT SHADOW ---
        let shadowGrad = ctx.createRadialGradient(0, 4, 2, 0, 4, 10);
        shadowGrad.addColorStop(0, "rgba(0,0,0,0.5)");
        shadowGrad.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = shadowGrad;
        ctx.beginPath();
        ctx.scale(1, 0.6);
        ctx.arc(0, 7, 10 - (bounce * 0.5), 0, Math.PI*2);
        ctx.fill();
        ctx.scale(1, 1 / 0.6); 

        // --- 2. LEGS & BOOTS ---
        let lPhase = Math.sin(this.walkCycle);
        let rPhase = Math.sin(this.walkCycle + Math.PI);
        
        ctx.fillStyle = "#2d1b0e"; 
        
        const drawBoot = (x, y, phase) => {
            ctx.save();
            ctx.translate(x, y + (phase * 3)); 
            ctx.rotate(phase * 0.2); 
            ctx.beginPath();
            ctx.ellipse(0, 0, 3.5, 2.5, 0, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = "#4e342e";
            ctx.beginPath();
            ctx.ellipse(1, -1, 1.5, 1, 0, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        };

        drawBoot(-4, 0, lPhase);
        drawBoot(4, 0, rPhase);

        // --- APPLY BODY BOUNCE & SWAY ---
        ctx.translate(0, -bounce);
        ctx.rotate(sway);

        // --- 3. BODY ---
        let bodyGrad = ctx.createLinearGradient(-6, -6, 6, 6);
        bodyGrad.addColorStop(0, "#e056fd"); 
        bodyGrad.addColorStop(1, "#8e24aa"); 
        
        ctx.fillStyle = bodyGrad;
        ctx.beginPath();
        ctx.roundRect(-6, -6, 12, 12, 4);
        ctx.fill();
        
        ctx.strokeStyle = "#FFD700";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-6, 6); ctx.lineTo(6, 6); 
        ctx.stroke();

        ctx.fillStyle = "#3e2723";
        ctx.fillRect(-6.5, 0, 13, 2.5);
        ctx.fillStyle = "#ffb300";
        ctx.fillRect(-2, -0.5, 4, 3.5);
        ctx.fillStyle = "#000"; 
        ctx.fillRect(-1, 0.5, 2, 1.5);

        // --- 4. THE LUTE ---
        ctx.save();
        ctx.translate(5, 2); 
        ctx.rotate(0.3); 

        let luteGrad = ctx.createRadialGradient(-2, -2, 1, 0, 0, 8);
        luteGrad.addColorStop(0, "#D2691E"); 
        luteGrad.addColorStop(1, "#5D4037"); 
        ctx.fillStyle = luteGrad;
        
        ctx.beginPath();
        ctx.ellipse(0, 0, 7.5, 6, 0, 0, Math.PI*2); 
        ctx.fill();

        ctx.fillStyle = "#DEB887";
        ctx.beginPath(); ctx.ellipse(0, -0.5, 6.5, 5, 0, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = "#3e2723";
        ctx.beginPath(); ctx.arc(0, -1, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#8d6e63"; ctx.lineWidth = 0.5;
        ctx.beginPath(); ctx.moveTo(-2.5, -1); ctx.lineTo(2.5, -1); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, -3.5); ctx.lineTo(0, 1.5); ctx.stroke();

        ctx.fillStyle = "#3e2723";
        ctx.fillRect(-3, 3, 6, 1.5);

        ctx.save();
        ctx.rotate(-0.1); 
        
        ctx.fillStyle = "#1a1a1a"; 
        ctx.fillRect(-16, -2, 12, 3.5);
        
        ctx.strokeStyle = "#888";
        ctx.lineWidth = 0.5;
        for(let i=0; i<4; i++) {
            let fx = -6 - (i*2.5);
            ctx.beginPath(); ctx.moveTo(fx, -2); ctx.lineTo(fx, 1.5); ctx.stroke();
        }

        ctx.translate(-16, -0.5); 
        ctx.rotate(-1.2); 
        ctx.fillStyle = "#5D4037";
        ctx.fillRect(0, -2, 6, 4); 
        
        ctx.fillStyle = "#fff";
        ctx.beginPath(); ctx.arc(2, -2, 1, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(4, -2, 1, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(2, 2, 1, 0, Math.PI*2); ctx.fill();
        ctx.restore(); 

        ctx.strokeStyle = "rgba(255,255,255,0.7)";
        ctx.lineWidth = 0.4;
        ctx.beginPath();
        ctx.moveTo(-16, -1); ctx.lineTo(0, -1);
        ctx.moveTo(-16, 0); ctx.lineTo(0, 0);
        ctx.moveTo(-16, 1); ctx.lineTo(0, 1);
        ctx.stroke();

        // --- RIGHT HAND ---
        let strumSpeed = Math.sin(Date.now() / 60) * 2; 
        
        ctx.save();
        ctx.translate(1, 1); 
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(-2, -2, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.rotate(0.5 + (strumSpeed * 0.2)); 
        ctx.fillStyle = "#ffcc80"; 
        ctx.beginPath();
        ctx.ellipse(0, 0, 2.5, 2, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = "#e6b975"; 
        ctx.beginPath();
        ctx.ellipse(1, -1, 1.5, 0.8, 0.5, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.moveTo(1, 0); ctx.lineTo(4, 1); ctx.lineTo(2, 2); ctx.fill();
        ctx.restore(); 

        // --- LEFT HAND ---
        ctx.save();
        ctx.translate(-10, -1); 
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(2, 4, 3, 0, Math.PI*2); ctx.fill(); 
        ctx.fillStyle = "#dcbfa6"; 
        ctx.beginPath(); ctx.arc(0, 0, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#ffcc80"; 
        ctx.beginPath(); ctx.roundRect(-1, -2.5, 1.5, 3, 1); ctx.fill();
        ctx.beginPath(); ctx.roundRect(0.5, -2.2, 1.5, 3, 1); ctx.fill();
        ctx.beginPath(); ctx.roundRect(2, -1.8, 1.5, 2.5, 1); ctx.fill();
        ctx.restore(); 
        ctx.restore(); 


        // --- 5. HEAD & HAT ---
        ctx.save();
        ctx.translate(0, -5); 
        ctx.rotate(sway * 0.5); 
        
        let faceGrad = ctx.createRadialGradient(-1, -2, 1, 0, 0, 6);
        faceGrad.addColorStop(0, "#ffcc80"); 
        faceGrad.addColorStop(1, "#e6b975"); 
        ctx.fillStyle = faceGrad;
        ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI*2); ctx.fill();
        
        ctx.fillStyle = "#3e2723";
        ctx.beginPath(); ctx.arc(-1.5, 1, 5.5, 0, Math.PI*2); ctx.fill();
        
        ctx.fillStyle = "#2e7d32";
        ctx.beginPath();
        ctx.moveTo(-6, -2); ctx.quadraticCurveTo(0, -7, 6, -2); ctx.lineTo(7, 0); ctx.quadraticCurveTo(0, -2, -7, 0); ctx.fill();
        
        ctx.save();
        ctx.translate(-3, -3); 
        ctx.rotate(featherLag); 
        ctx.fillStyle = "#d32f2f"; 
        ctx.beginPath();
        ctx.moveTo(0, 0); ctx.quadraticCurveTo(-4, -6, -8, -2); ctx.quadraticCurveTo(-4, -2, 0, 0); ctx.fill();
        ctx.strokeStyle = "#b71c1c";
        ctx.lineWidth = 0.5;
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-6, -3); ctx.stroke();
        ctx.restore();
        ctx.restore(); 

        ctx.restore(); 

        // --- 6. HP BAR ---
        if (typeof drawHealth === 'function') {
            drawHealth(this.x, this.y, this.hp, this.maxHp);
        }
    }
}

class Soldier {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.radius = 9; 
        this.range = 250;
        this.damage = 15;

        // MOVEMENT
        this.speed = 1.8;
        this.vx = 0; this.vy = 0;
        this.friction = 0.12;
        this.angle = 0; 
        
        // ATTACK
        this.cooldown = 0;
        this.maxCooldown = 90;
        this.hp = 50; this.maxHp = 50;
        this.lifeTimer = 1200;

        // --- IMPROVED AI VARS ---
        this.pathTimer = Math.random() * 30; // Randomize start to spread CPU load
        this.pathRefreshRate = 30; // Re-calculate path every 30 frames (0.5s)
        this.currentPath = [];
        this.nodeReachThreshold = 15; // How close to a node before moving to the next
        
        // VISUALS
        this.walkCycle = 0; 
        this.hairColor = Math.random() > 0.5 ? "#4a3b2a" : (Math.random() > 0.5 ? "#2a2a2a" : "#e6bc2d");
        this.skinColor = "#ffdbac"; 
    }

    update(dt) {
        this.lifeTimer--;

        // --- TARGETING ---
        let nearest = null;
        let minDist = Infinity;
        for (let e of enemies) {
            let d = (e.x - this.x)**2 + (e.y - this.y)**2;
            if (d < minDist) { minDist = d; nearest = e; }
        }

        let moving = false;

        if (nearest) {
            let distToEnemy = Math.sqrt(minDist);
            // Check Line of Sight (LOS)
            let canSeeEnemy = typeof hasLineOfSight === 'function' ? hasLineOfSight(this.x, this.y, nearest.x, nearest.y) : true;

            // 1. COMBAT STATE: If inside range and we can see them, stop and shoot.
            if (distToEnemy < this.range && canSeeEnemy) {
                // Slow down quickly when shooting
                this.vx *= 0.5; this.vy *= 0.5;
                this.angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);

                if (this.cooldown <= 0) {
                    let gunOffsetX = Math.cos(this.angle) * 20 - Math.sin(this.angle) * 6;
                    let gunOffsetY = Math.sin(this.angle) * 20 + Math.cos(this.angle) * 6;
                    
                    if(typeof Bullet !== 'undefined') {
                        projectiles.push(new Bullet(this.x + gunOffsetX, this.y + gunOffsetY, nearest, this.damage));
                    }
                    this.cooldown = this.maxCooldown;
                }
            }
            
            // 2. MOVEMENT STATE
            else {
                let targetX = nearest.x;
                let targetY = nearest.y;
                let usingPath = false;

                // If blocked, use Pathfinding
                if (!canSeeEnemy && typeof findPath === 'function') {
                    this.pathTimer--;

                    // A. Calculate Path (Periodically)
                    if (this.pathTimer <= 0) {
                        // Assuming findPath returns array of objects {x, y} in WORLD coordinates
                        this.currentPath = findPath(this, nearest);
                        this.pathTimer = this.pathRefreshRate;
                    }

                    // B. Follow Path (Waypoint Consumption)
                    if (this.currentPath && this.currentPath.length > 0) {
                        let nextNode = this.currentPath[0];
                        targetX = nextNode.x;
                        targetY = nextNode.y;
                        usingPath = true;

                        // Check distance to the current waypoint
                        let dNode = Math.hypot(nextNode.x - this.x, nextNode.y - this.y);
                        
                        // If we are close enough to the node, remove it and target the next one immediately
                        if (dNode < this.nodeReachThreshold) {
                            this.currentPath.shift(); // Remove first element
                        }
                    }
                }
                
                // If we see the enemy, or pathfinding failed, or path is empty, we go Direct
                if (!usingPath && canSeeEnemy) {
                    this.currentPath = []; // Clear path if we can see target directly
                }

                // C. Apply Physics
                let dx = targetX - this.x;
                let dy = targetY - this.y;
                let dist = Math.hypot(dx, dy);

                if (dist > 5) {
                    let dirX = dx / dist;
                    let dirY = dy / dist;
                    this.vx += (dirX * this.speed - this.vx) * this.friction;
                    this.vy += (dirY * this.speed - this.vy) * this.friction;
                    moving = true;
                    
                    // Only rotate if moving significantly
                    if (Math.hypot(this.vx, this.vy) > 0.1) {
                         this.angle = Math.atan2(this.vy, this.vx);
                    }
                }
            }
        }

        if (!moving) { this.vx *= 0.8; this.vy *= 0.8; }
        if (this.cooldown > 0) this.cooldown--;
        
        // Animate Legs
        if (moving) this.walkCycle += 0.25;
        else this.walkCycle = 0;

        this.x += this.vx *dt;
        this.y += this.vy *dt;

        // Collision
        if(typeof separate === 'function') { separate(this, allies, 0.5); separate(this, enemies, 0.5); }
        if(typeof resolveWallCollision === 'function') resolveWallCollision(this);
    }

    // ... DRAW METHOD REMAINS EXACTLY THE SAME AS YOUR INPUT ...
    draw() {
        // (Paste your existing draw code here)
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // --- 0. RECOIL PHYSICS MATH (Kept your logic) ---
        let timeSinceFire = this.maxCooldown - this.cooldown;
        let kick = 0; 
        let lift = 0; 

        // Frame 0-3: SNAP BACK
        if (timeSinceFire >= 0 && timeSinceFire < 4) {
            kick = 8;       
            lift = -0.25;   
        } 
        // Frame 4-8: RECOVERY
        else if (timeSinceFire >= 4 && timeSinceFire < 10) {
            kick = 4;       
            lift = -0.1;    
        }

        // --- 1. SHADOW (Slightly more dynamic) ---
        ctx.fillStyle = "rgba(0,0,0,0.4)";
        ctx.beginPath();
        // Shadow moves slightly opposite to lift to ground the unit
        ctx.ellipse(0 - kick/2, 2, 9, 7, 0, 0, Math.PI*2);
        ctx.fill();

        // --- 2. LEGS (Standardized colors) ---
        let leftLeg = Math.sin(this.walkCycle) * 4;
        let rightLeg = Math.sin(this.walkCycle + Math.PI) * 4;
        
        // Pants
        ctx.fillStyle = "#2e3b2a"; 
        ctx.beginPath(); ctx.arc(-4 + leftLeg, -5, 4, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(-4 + rightLeg, 5, 4, 0, Math.PI*2); ctx.fill();
        // Boots with treads
        ctx.fillStyle = "#0a0a0a";
        ctx.beginPath(); ctx.arc(-3 + leftLeg, -5, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(-3 + rightLeg, 5, 2.5, 0, Math.PI*2); ctx.fill();

        // --- 3. ARMS (Adjusted for new Gun Bulk) ---
        // Create a slight gradient for skin to look rounder
        let skinGrad = ctx.createRadialGradient(0,0,0, 0,0, 4);
        skinGrad.addColorStop(0, this.skinColor);
        skinGrad.addColorStop(1, "#dcb"); // Highlight

        ctx.fillStyle = this.skinColor;
        
        // Left Arm (Support Hand - holding the handguard)
        ctx.save();
        ctx.translate(5 - kick, -4); // Moved forward to grab the new handguard
        ctx.rotate(0.4 + lift); 
        ctx.fillRect(0, -2.5, 14, 5); 
        ctx.beginPath(); ctx.arc(14, 0, 3.5, 0, Math.PI*2); ctx.fill(); // Hand
        ctx.restore();

        // Right Arm (Trigger Hand)
        ctx.save();
        ctx.translate(-2 - kick, 6); 
        ctx.rotate(-0.3 + lift); 
        ctx.fillRect(0, -2.5, 10, 5); 
        ctx.beginPath(); ctx.arc(10, 0, 3.5, 0, Math.PI*2); ctx.fill(); // Hand
        ctx.restore();

        // --- 4. THE HIGH-DETAIL RIFLE ---
        ctx.save();
        ctx.translate(6 - kick, 4); 
        ctx.rotate(lift); 
        
        // -- A. DEFINE GRADIENTS --
        // Gun Metal (Dark Grey to Light Grey to Dark)
        let metalGrad = ctx.createLinearGradient(0, -5, 0, 5);
        metalGrad.addColorStop(0, "#1a1a1a");
        metalGrad.addColorStop(0.4, "#555"); // Highlight on top ridge
        metalGrad.addColorStop(1, "#111");

        // Polymer/Plastic (Matte Black)
        let polyGrad = ctx.createLinearGradient(0, -5, 0, 5);
        polyGrad.addColorStop(0, "#222");
        polyGrad.addColorStop(1, "#000");

        // -- B. STOCK (Tactical Skeletal Stock) --
        ctx.fillStyle = polyGrad;
        ctx.beginPath();
        ctx.moveTo(-10, -3);
        ctx.lineTo(-4, -3); // Connect to body
        ctx.lineTo(-4, 3);
        ctx.lineTo(-10, 5); // Angled bottom
        ctx.lineTo(-12, 4); // Buttpad bottom
        ctx.lineTo(-12, -2); // Buttpad top
        ctx.fill();
        // Stock Cheek Rest
        ctx.fillStyle = "#333";
        ctx.fillRect(-11, -3, 6, 2);

        // -- C. MAGAZINE (Curved Banana Clip) --
        ctx.save();
        ctx.translate(2, 2);
        ctx.rotate(0.3); // Angle the mag forward
        ctx.fillStyle = "#151515";
        // Draw Curved Mag shape
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(5,0);
        ctx.lineTo(4, 8); // Taper in
        ctx.quadraticCurveTo(2.5, 9, 1, 8); // Curved bottom
        ctx.lineTo(0,0);
        ctx.fill();
        // Mag Ribs (Texture)
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(1, 2); ctx.lineTo(4, 2);
        ctx.moveTo(1.5, 4); ctx.lineTo(3.5, 4);
        ctx.moveTo(2, 6); ctx.lineTo(3, 6);
        ctx.stroke();
        ctx.restore();

        // -- D. MAIN BODY (Receiver) --
        ctx.fillStyle = metalGrad;
        ctx.beginPath();
        // Receiver shape with mag well dip
        ctx.moveTo(-4, -4);
        ctx.lineTo(8, -4);
        ctx.lineTo(8, 2); // Mag well front
        ctx.lineTo(2, 2); // Mag well back
        ctx.lineTo(-2, 4); // Grip area
        ctx.lineTo(-4, 4);
        ctx.fill();

        // Ejection Port (Grey detail on side)
        ctx.fillStyle = "#444";
        ctx.fillRect(0, -2, 4, 2);
        ctx.fillStyle = "#000"; // Bolt line
        ctx.fillRect(1, -1.5, 2, 1);

        // -- E. HANDGUARD & BARREL --
        // Handguard (Rails)
        ctx.fillStyle = "#2a2a2a";
        ctx.fillRect(8, -3, 10, 5);
        
        // Cooling Vents (Holes in handguard)
        ctx.fillStyle = "#000";
        for(let i=0; i<3; i++) {
            ctx.beginPath();
            ctx.arc(10 + (i*3), -0.5, 1, 0, Math.PI*2);
            ctx.fill();
        }

        // Exposed Barrel
        ctx.fillStyle = "#111";
        ctx.fillRect(18, -1.5, 4, 2);

        // Muzzle Brake (The tip)
        ctx.fillStyle = "#333";
        ctx.fillRect(22, -2, 3, 3); // Thicker tip

        // -- F. ATTACHMENTS --
        
        // Laser Sight Module (Side)
        ctx.fillStyle = "#111";
        ctx.fillRect(14, 2, 4, 2);
        // Laser Beam (Faint red line)
        ctx.strokeStyle = "rgba(255, 0, 0, 0.4)";
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(18, 3);
        ctx.lineTo(100, 3); // Shoots far out
        ctx.stroke();

        // Holographic Sight (Top)
        ctx.fillStyle = "#222";
        ctx.fillRect(0, -6, 6, 2); // Mount
        ctx.fillStyle = "#000";
        ctx.fillRect(0, -9, 1, 3); // Rear post
        ctx.fillRect(5, -9, 1, 3); // Front post
        ctx.fillStyle = "rgba(0, 255, 255, 0.3)"; // Blue Glass
        ctx.fillRect(1, -8, 4, 2);
        // Red Dot inside glass
        ctx.fillStyle = "red";
        ctx.beginPath(); ctx.arc(3, -7, 0.8, 0, Math.PI*2); ctx.fill();


        // -- G. MUZZLE FLASH (Enhanced) --
        if (timeSinceFire < 3) {
            // Inner Core (White)
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.moveTo(25, -0.5);
            ctx.lineTo(50, -3); 
            ctx.lineTo(50, 2);
            ctx.fill();

            // Star Burst (Orange)
            ctx.fillStyle = "rgba(255, 200, 50, 0.7)";
            ctx.beginPath();
            const flashX = 25;
            const flashY = -0.5;
            // Draw a spiky shape
            for (let i = 0; i < 8; i++) {
                let angle = (i / 8) * Math.PI * 2;
                let r = (i % 2 === 0) ? 15 : 8; // Spike length varies
                ctx.lineTo(flashX + Math.cos(angle) * r, flashY + Math.sin(angle) * r);
            }
            ctx.fill();
            
            // Smoke puff (Grey)
            ctx.fillStyle = "rgba(100, 100, 100, 0.3)";
            ctx.beginPath();
            ctx.arc(35, -5, 6, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.restore(); // End Rifle transform

        // --- 5. SHOULDERS & VEST (Tactical Armor) ---
        ctx.fillStyle = "#2f3a25"; // Vest Color
        ctx.beginPath(); ctx.ellipse(-2, -6, 5, 4, 0, 0, Math.PI*2); ctx.fill(); // L Shoulder
        ctx.beginPath(); ctx.ellipse(-2, 6, 5, 4, 0, 0, Math.PI*2); ctx.fill(); // R Shoulder
        
        // Vest Body
        ctx.fillRect(-6, -5, 10, 10);
        // Vest Plate Detail
        ctx.fillStyle = "#1e2b1a";
        ctx.fillRect(-4, -3, 6, 6);

        // --- 6. HEAD (With Helmet option or Hair) ---
        let headShake = (kick > 0) ? (Math.random() * 2 - 1) : 0;

        // Skin (Neck)
        ctx.fillStyle = this.skinColor;
        ctx.beginPath(); ctx.arc(-2 + headShake, 0, 3.5, 0, Math.PI*2); ctx.fill();

        // Helmet / Hair
        ctx.fillStyle = this.hairColor; // Or make this a helmet color like #222
        ctx.beginPath();
        ctx.arc(-1 + headShake, 0, 5.5, 0, Math.PI*2); 
        ctx.fill();
        
        // If NOT wearing a helmet, draw skin face area
        ctx.fillStyle = this.skinColor; 
        ctx.beginPath();
        // Slightly offset ellipse for top-down face look
        ctx.ellipse(2 + headShake, 0, 3, 4, 0, 0, Math.PI*2); 
        ctx.fill();

        ctx.restore(); // End Player transform

        // --- HP BAR (Cleaned up) ---
        if (this.hp < this.maxHp) {
            const barW = 24;
            const barH = 4;
            const yOffset = 28;

            const barX = this.x - (barW / 2);
            const barY = this.y - yOffset;

            const pct = Math.max(0, Math.min(1, this.hp / this.maxHp));
            const hue = (pct * pct) * 120;

            ctx.fillStyle = "#333333";
            ctx.fillRect(barX, barY, barW, barH);

            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
            ctx.fillRect(barX, barY, barW * pct, barH);

            ctx.strokeStyle = "#000000";
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barW, barH);
        }
    }
}

    // -- BUILDINGS --

    class Barracks {
    constructor(col, row) {
        this.col = col;
        this.row = row;
        this.timer = 0;
        this.spawnRate = 600 * (hasSkill('barracks_speed') ? 0.8 : 1); // Keeps 600 (approx 10 sec at 60fps baseline)
        
        // Animation Variables
        this.angleOuter = 0;
        this.angleInner = 0;
        this.pistonOffset = 0;
    }

    update(dt) {
        // 1. INCREMENT TIMER BY DT
        // Since dt is roughly 1.0, this counts up exactly like before,
        // but compensates for lag.
        this.timer += dt; 
        
        let progress = this.timer / this.spawnRate;

        // 2. DYNAMIC ROTATION
        // Multiply "speed" by dt so rotation is smooth regardless of framerate
        let speed = 0.02 + (progress * 0.15); 
        this.angleOuter += speed * dt;
        this.angleInner -= (speed * 1.5) * dt; 

        // 3. PISTON ANIMATION
        // We don't multiply by dt inside Math.sin because 'this.timer' 
        // has already been adjusted by dt above.
        this.pistonOffset = Math.sin(this.timer * 0.1) * 3;

        // 4. SPAWN LOGIC
        if (this.timer >= this.spawnRate) {
            this.timer = 0;
            
            let sx = this.col * CELL_SIZE + CELL_SIZE/2;
            let sy = this.row * CELL_SIZE + CELL_SIZE/2;
            
            // Check if allies array exists before pushing
            if (typeof allies !== 'undefined') {
                allies.push(new Soldier(sx, sy));
            }
            
            // SPAWN EFFECTS
            if (typeof createParticles !== 'undefined') {
                createParticles(sx, sy, "#00ffff", 12); 
                createParticles(sx, sy, "#ffffff", 6);
            }
        }
    }

    draw() {
        let x = this.col * CELL_SIZE;
        let y = this.row * CELL_SIZE;
        let cx = x + CELL_SIZE / 2;
        let cy = y + CELL_SIZE / 2;
        let size = CELL_SIZE - 4;

        ctx.save();
        ctx.translate(cx, cy);

        // --- TECH BASE ---
        ctx.fillStyle = "#1a1a2e"; 
        this.drawOctagon(ctx, 0, 0, size/2 + 2);
        
        ctx.strokeStyle = "#16213e";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-size/2, -size/2); ctx.lineTo(size/2, size/2);
        ctx.moveTo(size/2, -size/2); ctx.lineTo(-size/2, size/2);
        ctx.stroke();

        // --- PISTONS ---
        ctx.fillStyle = "#444";
        for (let i = 0; i < 4; i++) {
            ctx.save();
            ctx.rotate((Math.PI / 2) * i); 
            
            ctx.fillRect(-6, -size/2, 12, 10);
            
            let py = -size/2 + 8 + this.pistonOffset;
            ctx.fillStyle = "#888"; 
            ctx.fillRect(-3, py, 6, 8);
            
            ctx.strokeStyle = "#222";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, -size/2 + 5);
            ctx.lineTo(0, py);
            ctx.stroke();
            
            ctx.restore();
        }

        // --- REACTOR CORE ---
        let pct = Math.min(this.timer / this.spawnRate, 1);
        let glowSize = 5 + (pct * 10); 
        
        ctx.shadowBlur = 15 + (pct * 20); 
        ctx.shadowColor = "#00d2ff";
        ctx.fillStyle = `rgba(0, 210, 255, ${0.2 + pct * 0.8})`;
        
        ctx.beginPath();
        ctx.arc(0, 0, glowSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0; 

        // --- PLASMA RINGS ---
        // Outer
        ctx.save();
        ctx.rotate(this.angleOuter);
        ctx.strokeStyle = "#00d2ff"; 
        ctx.lineWidth = 2;
        ctx.setLineDash([10, 8]); 
        ctx.beginPath();
        ctx.arc(0, 0, size/2 - 6, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();

        // Inner
        ctx.save();
        ctx.rotate(this.angleInner);
        ctx.strokeStyle = "#ff00ff"; 
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]); 
        ctx.beginPath();
        ctx.arc(0, 0, size/2 - 12, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
        
        // --- HOLOGRAPHIC PROJECTION ---
        if (pct > 0.5) {
            ctx.save();
            if (Math.random() > 0.1) {
                ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
                ctx.fillRect(-2, -2, 4, 4);
                
                // Hologram Scan Line
                // Use timer directly (it's now a float, but modulo works on floats in JS)
                let scanY = -10 + (20 * ((this.timer % 40)/40));
                
                ctx.strokeStyle = "rgba(0, 255, 0, 0.8)";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(-8, scanY);
                ctx.lineTo(8, scanY);
                ctx.stroke();
            }
            ctx.restore();
        }

        ctx.restore();
    }

    drawOctagon(ctx, x, y, radius) {
        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            let angle = (Math.PI / 4) * i;
            ctx.lineTo(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius);
        }
        ctx.closePath();
        ctx.fill();
    }
}

   class Mortar {
    constructor(col, row) {
        this.col = col;
        this.row = row;

        // --- Stats ---
        this.timer = 0;
        this.cooldown = 200;
        this.range = 550;
        this.shellSpeed = 3.5;

        // --- Visual State ---
        this.recoil = 0;
        this.smoke = [];

        // --- Palette: Industrial Grays ---
        this.cMatteDark = "#2b2b2b";
        this.cMatteMid  = "#4a4a4a";
        this.cChrome    = "#a0a0a0";
        this.cCarbon    = "#1a1a1a";
        this.cAccent    = "#ffffff";
    }

    update(dt) {
        if (this.timer > 0) this.timer--;
        
        // Mechanical Recoil Recovery
        this.recoil = Math.max(0, this.recoil * 0.9);

        // Update Smoke
        for (let i = this.smoke.length - 1; i >= 0; i--) {
            let p = this.smoke[i];
            p.x += p.vx; p.y += p.vy;
            p.size += 0.3; p.life -= 0.02;
            if (p.life <= 0) this.smoke.splice(i, 1);
        }

        // Firing Logic
        if (this.timer <= 0) {
            let target = this.findTarget();
            if (target) {
                const cx = this.col * CELL_SIZE + CELL_SIZE / 2;
                const cy = this.row * CELL_SIZE + CELL_SIZE / 2;

                // --- TUNED PREDICTION ALGORITHM ---
                
                // 1. Get Enemy Velocity
                let tvx = target.vx || 0;
                let tvy = target.vy || 0;

                // 2. Calculate "Perfect" Time to Impact
                // We use the iterative method to find the exact flight time
                let t = 0;
                let predX = target.x;
                let predY = target.y;
                
                // Iteration 1: Simple distance check
                let dist = Math.hypot(target.x - cx, target.y - cy);
                t = dist / this.shellSpeed;

                // Iteration 2: Refine based on movement
                let futureX = target.x + tvx * t;
                let futureY = target.y + tvy * t;
                dist = Math.hypot(futureX - cx, futureY - cy);
                t = dist / this.shellSpeed;

                // 3. APPLY DAMPENING (The Fix)
                // Instead of shooting EXACTLY where they will be in 't' frames,
                // we only lead them by a percentage. This prevents overshooting 
                // when enemies turn corners.
                const PREDICTION_FACTOR = 0.6; // 0.0 = At enemy, 1.0 = Full Lead, 0.6 = Balanced
                
                let finalX = target.x + (tvx * t * PREDICTION_FACTOR);
                let finalY = target.y + (tvy * t * PREDICTION_FACTOR);

                projectiles.push(new MortarShell(cx, cy, finalX, finalY));

                this.timer = this.cooldown;
                this.recoil = 30; 

                // Smoke Logic
                const tipY = cy - (CELL_SIZE * 0.8) + this.recoil; 
                for (let i = 0; i < 12; i++) {
                    let angle = (Math.random() - 0.5) * 1.5;
                    let speed = 2 + Math.random() * 4;
                    this.smoke.push({
                        x: cx,
                        y: tipY,
                        vx: Math.sin(angle) * speed,
                        vy: -Math.cos(angle) * speed,
                        size: 4 + Math.random() * 6,
                        life: 1.0,
                        color: Math.random() > 0.5 ? 'rgba(200,200,200,' : 'rgba(80,80,80,'
                    });
                }
            }
        }
    }

    findTarget() {
        const cx = this.col * CELL_SIZE + CELL_SIZE / 2;
        const cy = this.row * CELL_SIZE + CELL_SIZE / 2;
        let closest = null;
        let recordDist = Infinity;
        for (let e of enemies) {
            let d = Math.hypot(e.x - cx, e.y - cy);
            if (d < this.range && d < recordDist) {
                recordDist = d; closest = e;
            }
        }
        return closest;
    }

    draw() {
        const cx = this.col * CELL_SIZE + CELL_SIZE / 2;
        const cy = this.row * CELL_SIZE + CELL_SIZE / 2;
        const size = CELL_SIZE;

        ctx.save();
        ctx.translate(cx, cy);

        // --- LAYER 1: Industrial Base ---
        ctx.fillStyle = this.cMatteDark;
        ctx.beginPath();
        for(let i=0; i<8; i++){
            let ang = i * Math.PI / 4;
            ctx.lineTo(size*0.45 * Math.cos(ang), size*0.45 * Math.sin(ang));
        }
        ctx.fill();
        
        ctx.strokeStyle = this.cMatteMid;
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(0,0, size*0.35, 0, Math.PI*2); ctx.stroke();
        
        ctx.fillStyle = "#111";
        [0, 2, 4, 6].forEach(i => {
            let a = i * Math.PI / 4;
            ctx.beginPath(); 
            ctx.rect(size*0.38*Math.cos(a)-2, size*0.38*Math.sin(a)-2, 4, 4); 
            ctx.fill();
        });

        // --- LAYER 2: THE BARREL (Sandwiched) ---
        ctx.save();
        ctx.translate(0, size * 0.1); 

        const totalLen = size * 0.9;
        
        // 2a. Breech Block
        const breechW = size * 0.42;
        const breechH = size * 0.25;
        this.drawMachinedBlock(0, 0, breechW, breechH, this.cMatteDark);
        
        // 2b. Segment 1: Outer Shielding
        const seg1W = size * 0.34;
        const seg1H = totalLen * 0.3;
        this.drawCylinder(0, -breechH, seg1W, seg1H, this.cMatteMid, this.cCarbon);

        // 2c. Segment 2: Polished Hydraulic Piston
        const seg2W = size * 0.26;
        const seg2H = totalLen * 0.3;
        const r2 = this.recoil * 0.5;
        this.drawCylinder(0, -breechH - seg1H + r2, seg2W, seg2H, "#ffffff", "#888888"); 

        // 2d. Segment 3: Magnetic Rail / Tip
        const seg3W = size * 0.18;
        const seg3H = totalLen * 0.4;
        const r3 = this.recoil;
        const tipY = -breechH - seg1H - seg2H + r3;
        
        this.drawCylinder(0, tipY, seg3W, seg3H, this.cMatteMid, "#000");
        
        // Muzzle Flash
        if (this.recoil > 15) {
            ctx.globalCompositeOperation = 'lighter';
            ctx.shadowBlur = 30;
            ctx.shadowColor = "#ff3300"; 
            ctx.fillStyle = "rgba(255, 60, 30, 0.6)";
            ctx.beginPath();
            ctx.ellipse(0, tipY - seg3H - 15, size/2.5, size/2, 0, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.globalCompositeOperation = 'source-over';
        }
        ctx.restore();

        // --- LAYER 3: HEAVY SIDE PLATING ---
        const mountW = size * 0.14;
        const mountH = size * 0.5;
        const spread = size * 0.24;
        
        this.drawHeavyMount(-spread, 0, mountW, mountH, size);
        this.drawHeavyMount(spread, 0, mountW, mountH, size);

        // --- LAYER 4: The Axle ---
        ctx.fillStyle = "#111";
        ctx.fillRect(-spread, -4, spread*2, 8);
        this.drawHex( -spread - 2, 0, 5, "#333");
        this.drawHex( spread + 2, 0, 5, "#333");

        ctx.restore();

        // --- LAYER 5: Smoke ---
        for (let p of this.smoke) {
            ctx.fillStyle = `${p.color} ${p.life * 0.5})`; 
            ctx.beginPath();
            ctx.arc(p.x - cx, p.y - cy, p.size, 0, Math.PI*2);
            ctx.fill();
        }
    }

    drawMachinedBlock(x,y,w,h, color) {
        ctx.save();
        ctx.translate(x,y);
        ctx.fillStyle = color;
        ctx.fillRect(-w/2, -h, w, h);
        ctx.fillStyle = "rgba(255,255,255,0.1)";
        ctx.fillRect(-w/2, -h, 2, h); 
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.fillRect(w/2 - 2, -h, 2, h); 
        ctx.fillStyle = "#111";
        ctx.fillRect(-w/4, -h/2, w/2, 2);
        ctx.fillRect(-w/4, -h/2 + 4, w/2, 2);
        ctx.restore();
    }

    drawCylinder(x, y, w, h, cLight, cDark) {
        ctx.save();
        ctx.translate(x, y);
        let grad = ctx.createLinearGradient(-w/2, 0, w/2, 0);
        grad.addColorStop(0, cDark);
        grad.addColorStop(0.2, cDark);
        grad.addColorStop(0.4, cLight); 
        grad.addColorStop(0.5, cLight);
        grad.addColorStop(0.8, cDark);
        grad.addColorStop(1.0, "#000");
        ctx.fillStyle = grad;
        ctx.fillRect(-w/2, -h, w, h);
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(-w/2, -h, w, 1);
        ctx.restore();
    }
    
    drawHeavyMount(x, y, w, h, size) {
        ctx.save();
        ctx.translate(x, y);
        ctx.fillStyle = this.cMatteMid;
        ctx.strokeStyle = "#111";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-w/2, size/4); 
        ctx.lineTo(-w/2, -h/4);   
        ctx.lineTo(0, -h/2);      
        ctx.lineTo(w/2, -h/4);    
        ctx.lineTo(w/2, size/4);  
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = this.cMatteDark;
        ctx.beginPath();
        ctx.arc(0, size/5, 3, 0, Math.PI*2); 
        ctx.fill();
        ctx.fillStyle = this.cAccent; 
        ctx.fillRect(-2, -h/3, 4, 4);
        ctx.restore();
    }
    
    drawHex(x, y, r, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        for(let i=0; i<6; i++) {
            ctx.lineTo(x + r*Math.cos(i*Math.PI/3), y + r*Math.sin(i*Math.PI/3));
        }
        ctx.fill();
    }
}

    // -- PROJECTILES --

    class HealingVomit {
    constructor(startX, startY, target, healAmount) {
        this.x = startX;
        this.y = startY;
        this.target = target;
        this.healAmount = healAmount;
        this.speed = 8; // Faster projectile to catch running targets
        this.active = true;
        this.radius = 4;
        this.trail = [];
    }

    update(dt) {
        if (!this.target || this.target.hp <= 0) {
            this.active = false;
            return;
        }

        let dx = this.target.x - this.x;
        let dy = this.target.y - this.y;
        let dist = Math.hypot(dx, dy);

        // SAFETY FIX: If target has no radius, assume 15
        let hitDist = (this.target.radius || 15) + 10; 

        if (dist < hitDist) {
            this.target.hp = Math.min(this.target.maxHp, this.target.hp + this.healAmount);
            if(typeof createParticles === 'function') createParticles(this.target.x, this.target.y, "#00ffcc", 5);
            this.active = false;
        } else {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
            this.trail.push({x: this.x, y: this.y, r: Math.random() * 3 + 1});
            if(this.trail.length > 5) this.trail.shift();
        }
    }

    draw() {
        ctx.save();
        ctx.fillStyle = "#00ffcc";
        for(let t of this.trail) {
            ctx.globalAlpha = 0.5;
            ctx.beginPath(); ctx.arc(t.x, t.y, t.r, 0, Math.PI*2); ctx.fill();
        }
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 6; ctx.shadowColor = "#00ffcc";
        ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0; ctx.restore();
    }
}

class MinigunBullet {
    constructor(x, y, angle, damage, speed) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.damage = damage;
        this.speed = speed;
        this.active = true;
        this.life = 140; 
        
        // VISUALS: Size 0.7 as requested
        this.size = 0.7; 
    }

    update(dt) {
        // Move in straight line
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        
        this.life -= dt;
        if (this.life <= 0) this.active = false;

        // --- CUSTOM COLLISION LOGIC ---
        for (let e of enemies) {
            let dist = Math.hypot(e.x - this.x, e.y - this.y);
            
            // Hitbox check
            if (dist < e.radius + 10) {
                // --- NEW SHIELD LOGIC ---
                if (e.isInvincible) {
                    // BLOCKED! Blue particles indicate shield hit
                    if (typeof createParticles === 'function') {
                        createParticles(this.x, this.y, "#00d2ff", 4); 
                    }
                } else {
                    // NORMAL HIT: Apply damage
                    e.hp -= this.damage;
                    
                    // Visual Hit Effect (Orange/Gold)
                    if (typeof createParticles === 'function') {
                        createParticles(this.x, this.y, "#ffaa00", 3);
                    }
                }

                this.active = false; // Bullet is destroyed either way
                break; // Hit one enemy per bullet
            }
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // Glowing Tracer Round
        ctx.shadowBlur = 8;
        ctx.shadowColor = "#ffaa00";
        ctx.fillStyle = "#ffffaa";

        ctx.fillRect(-5, -1, 10, 2); 

        ctx.restore();
    }
}


    class Bullet {
    constructor(x, y, target, damage, size = 1) {
        this.x = x; this.y = y;
        this.target = target;
        this.damage = damage;
        this.size = size; 
        
        this.speed = 12;
        this.active = true;
        this.type = 'bullet';
        
        this.angle = 0;
    }

    update(dt) {
        if (!this.target || this.target.hp <= 0) {
            this.active = false;
            return;
        }

        let dx = this.target.x - this.x;
        let dy = this.target.y - this.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        
        // Update angle to face the target
        this.angle = Math.atan2(dy, dx);

        // HIT CHECK:
        if (dist < this.speed + (this.size * 4)) {
            
            // --- NEW SHIELD LOGIC ---
            if (this.target.isInvincible) {
                // BLOCKED! Blue particles
                if (typeof createParticles === 'function') {
                    createParticles(this.target.x, this.target.y, "#00d2ff", 6 * this.size);
                }
            } else {
                // NORMAL HIT
                this.target.hp -= this.damage;
                
                // Death check
                if(this.target.hp <= 0 && this.target.hp > -100) {
                    createParticles(this.target.x, this.target.y, "#ffaa00", 6 * this.size);
                    this.target.hp = -999; 
                }
            }
            
            this.active = false; // Bullet destroyed
        } else {
            this.x += (dx/dist) * this.speed;
            this.y += (dy/dist) * this.speed;
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        ctx.scale(this.size, this.size);
        ctx.globalCompositeOperation = "lighter";

        // Trail
        let grad = ctx.createLinearGradient(0, 0, -25, 0);
        grad.addColorStop(0, "rgba(255, 200, 50, 0.8)"); 
        grad.addColorStop(1, "rgba(255, 50, 0, 0)");     
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.moveTo(2, 0);    
        ctx.lineTo(-4, 2);    
        ctx.lineTo(-25, 0);   
        ctx.lineTo(-4, -2);   
        ctx.fill();

        // Core
        ctx.shadowColor = "#ffaa00";
        ctx.shadowBlur = 10; 
        ctx.fillStyle = "#ffffff";
        
        ctx.beginPath();
        ctx.ellipse(0, 0, 6, 1.5, 0, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
    }
}
    
    class MortarShell {
    constructor(x, y, tx, ty) {
        this.x = x; 
        this.y = y;
        this.tx = tx; 
        this.ty = ty;
        
        // 1. Calculate Geometry
        this.startDist = Math.hypot(tx - x, ty - y);
        // Yaw is the angle across the ground (2D plane)
        this.yaw = Math.atan2(ty - y, tx - x); 
        
        // 2. Flight Logic
        const flightTime = 60; // Frames to reach target
        this.speed = this.startDist / flightTime;
        // Enforce minimum speed to prevent floating shells
        if (this.speed < 2) this.speed = 2; 

        this.active = true;
        
        // 3. Stats (Passed to explosion)
        this.damage = 50 + (hasSkill('mortar_dmg') ? 30 : 0);
        this.blastRadius = 150 * (hasSkill('mortar_area') ? 1.25 : 1);

        // 4. Visuals
        this.z = 0; // Height off ground
        this.trail = []; 
    }

    update(dt) {
        if (!dt) dt = 1;

        let dx = this.tx - this.x;
        let dy = this.ty - this.y;
        let dist = Math.sqrt(dx*dx + dy*dy);

        // --- Trail Logic ---
        // Only spawn trail particles while moving
        if (dist > this.speed) {
             this.trail.push({x: this.x, y: this.y - this.z, alpha: 1.0});
             if(this.trail.length > 25) this.trail.shift(); 
        }
        // Fade out existing trail segments
        for(let p of this.trail) p.alpha -= 0.04;

        // --- Target Reached Logic ---
        if (dist <= this.speed) {
            this.active = false;
            
            // DAMAGE TRIGGER:
            // We pass this shell's specific damage and radius to the global function
            if (typeof createExplosion === 'function') {
                createExplosion(this.tx, this.ty, this.damage, this.blastRadius);
            }
        } else {
            // Move towards target
            this.x += (dx/dist) * this.speed * dt;
            this.y += (dy/dist) * this.speed * dt;
        }
    }

    // Helper: Calculates how high the shell is based on distance traveled
    getArcHeight(distTraveled) {
        let progress = distTraveled / this.startDist;
        // Clamp progress between 0 and 1
        progress = Math.max(0, Math.min(1, progress));
        
        // Parabola height logic
        let maxArcHeight = 50 + (this.startDist * 0.15); 
        return Math.sin(progress * Math.PI) * maxArcHeight;
    }

    draw() {
        // --- 1. Calculate Physics State ---
        let distRemaining = Math.hypot(this.tx - this.x, this.ty - this.y);
        let distTraveled = this.startDist - distRemaining;
        this.z = this.getArcHeight(distTraveled);

        // --- 2. Calculate Visual Rotation ---
        // Predict where the shell will be in the next frame to point it correctly
        let lookAhead = this.speed; 
        let nextDistTraveled = distTraveled + lookAhead;
        
        // Future ground position
        let nextX = this.x + Math.cos(this.yaw) * lookAhead;
        let nextY = this.y + Math.sin(this.yaw) * lookAhead;
        
        // Future screen position (Y - Z)
        let nextZ = this.getArcHeight(nextDistTraveled);
        
        // Angle between current screen pos and next screen pos
        let currentScreenY = this.y - this.z;
        let nextScreenY = nextY - nextZ;
        
        let visualRotation = Math.atan2(nextScreenY - currentScreenY, nextX - this.x);

        // --- 3. Draw Shadow (Ground Level) ---
        let scale = 1.0 + (this.z / 300); // Slight size increase with height
        let shadowSize = 6 * (1 - (this.z / 200)); 
        let shadowAlpha = 0.4 * (1 - (this.z / 150));
        
        if (shadowSize > 0) {
            ctx.save();
            ctx.fillStyle = `rgba(0,0,0,${Math.max(0, shadowAlpha)})`;
            ctx.beginPath();
            // Shadow stays on the ground, rotated by Yaw
            ctx.ellipse(this.x, this.y, shadowSize * 1.5, shadowSize * 0.8, this.yaw, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        }

        // --- 4. Draw Trail ---
        ctx.lineWidth = 3 * scale;
        ctx.lineCap = "round";
        // Draw segments connecting trail points
        for (let i = 0; i < this.trail.length - 1; i++) {
            let p1 = this.trail[i];
            let p2 = this.trail[i+1];
            if(p1.alpha <= 0) continue;
            
            ctx.strokeStyle = `rgba(200, 200, 200, ${p1.alpha * 0.5})`;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        // --- 5. Draw Shell Sprite ---
        ctx.save();
        
        // Translate to actual visual position (Ground Y - Height Z)
        ctx.translate(this.x, this.y - this.z);
        ctx.rotate(visualRotation);
        ctx.scale(scale, scale); 

        // Shell Body Shape
        ctx.fillStyle = "#333";
        ctx.beginPath();
        ctx.moveTo(14, 0);   // Nose
        ctx.lineTo(-8, 4.5);  // Back Bottom
        ctx.lineTo(-8, -4.5); // Back Top
        ctx.fill();

        // Driving Band (Copper ring detail)
        ctx.fillStyle = "#b87333"; 
        ctx.fillRect(-5, -4.5, 4, 9);

        // Metallic Highlight
        ctx.fillStyle = "rgba(255,255,255,0.4)";
        ctx.fillRect(-7, -1.5, 18, 3);

        // Engine/Thruster Glow
        ctx.shadowBlur = 8;
        ctx.shadowColor = "#ff5500";
        ctx.fillStyle = "#ff5500";
        ctx.beginPath(); 
        ctx.arc(-8, 0, 3, 0, Math.PI*2); 
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.restore();
    }
}

function drawBlueprint() {
    let col = Math.floor(mouseX / CELL_SIZE);
    let row = Math.floor(mouseY / CELL_SIZE);

    if (currentTool === 'wall') {
        // ... (Existing Wall Logic) ...
        // 1. Grid Snap Calculations
        let col = Math.floor(mouseX / CELL_SIZE);
        let row = Math.floor(mouseY / CELL_SIZE);

        // Ensure we are inside the grid
        if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {

            // 2. Setup Colors (Simulate 100% Health)
            let hpPct = 1.0; 
            let gray = Math.floor(60 + (60 * hpPct)); // 120
            let colMain = `rgb(${gray}, ${gray}, ${gray})`;
            let colLight = `rgb(${gray + 40}, ${gray + 40}, ${gray + 40})`;
            let colDark = `rgb(${gray - 40}, ${gray - 40}, ${gray - 40})`;
            let colDetail = `rgb(${gray - 20}, ${gray - 20}, ${gray - 20})`;

            // 3. Check Neighbors (To draw connections)
            let nUp = (row > 0 && grid[col][row - 1].wall);
            let nDown = (row < ROWS - 1 && grid[col][row + 1].wall);
            let nLeft = (col > 0 && grid[col - 1][row].wall);
            let nRight = (col < COLS - 1 && grid[col + 1][row].wall);

            // 4. Geometry Calculations
            let drawX = col * CELL_SIZE;
            let drawY = row * CELL_SIZE;
            let coreSize = CELL_SIZE * 0.85; 
            let offset = (CELL_SIZE - coreSize) / 2;
            
            let cX = drawX + offset;
            let cY = drawY + offset;
            let cW = coreSize;
            let cH = coreSize;

            // --- DRAWING ---

            // A. Base Layer (Main Block + Arms)
            ctx.fillStyle = colMain;
            ctx.fillRect(cX, cY, cW, cH); // Center
            
            if (nUp) ctx.fillRect(cX, drawY, cW, offset);
            if (nDown) ctx.fillRect(cX, cY + cH, cW, offset);
            if (nLeft) ctx.fillRect(drawX, cY, offset, cH);
            if (nRight) ctx.fillRect(cX + cW, cY, offset, cH);

            // B. Grip Lines (Texture on the arms only)
            ctx.fillStyle = colDark;
            let lineSpace = 4;
            if (nUp) for(let i = drawY + 2; i < cY; i+=lineSpace) ctx.fillRect(cX + 2, i, cW - 4, 1);
            if (nDown) for(let i = cY + cH + 2; i < drawY + CELL_SIZE; i+=lineSpace) ctx.fillRect(cX + 2, i, cW - 4, 1);
            if (nLeft) for(let i = drawX + 2; i < cX; i+=lineSpace) ctx.fillRect(i, cY + 2, 1, cH - 4);
            if (nRight) for(let i = cX + cW + 2; i < drawX + CELL_SIZE; i+=lineSpace) ctx.fillRect(i, cY + 2, 1, cH - 4);

            // C. 3D Bevels (Outer Edges)
            let drawLine = (x1, y1, x2, y2, color) => {
                ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = 2;
                ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
            };
            
            drawLine(cX, cY, cX + cW, cY, colLight);       // Top Highlight
            drawLine(cX, cY, cX, cY + cH, colLight);       // Left Highlight
            drawLine(cX + cW, cY, cX + cW, cY + cH, colDark); // Right Shadow
            drawLine(cX, cY + cH, cX + cW, cY + cH, colDark); // Bottom Shadow

            // D. Inner Reinforced Plate (Clean Square)
            let pad = 6;
            ctx.fillStyle = colDetail;
            ctx.fillRect(cX + pad, cY + pad, cW - pad*2, cH - pad*2);
            
            // Inner Shadow (Inset look)
            ctx.strokeStyle = colDark;
            ctx.lineWidth = 1;
            ctx.strokeRect(cX + pad, cY + pad, cW - pad*2, cH - pad*2);
        }
    }
    else if (currentTool === 'barracks') {
        if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
            const x = col * CELL_SIZE + CELL_SIZE / 2;
            const y = row * CELL_SIZE + CELL_SIZE / 2;
            const size = CELL_SIZE - 4;
            
            const isOccupied = grid[col][row].occupied || grid[col][row].wall;
            const canAfford = money >= 200; // Adjust to match your UI cost

            ctx.save();
            ctx.translate(x, y);
            ctx.globalAlpha = 0.5; // Transparent "Ghost" mode

            // --- 1. TECH BASE ---
            // Draw Octagon inline to avoid dependency issues
            ctx.fillStyle = "#1a1a2e"; 
            ctx.beginPath();
            for (let i = 0; i < 8; i++) {
                let angle = (Math.PI / 4) * i;
                let rad = size/2 + 2;
                ctx.lineTo(Math.cos(angle) * rad, Math.sin(angle) * rad);
            }
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = "#16213e";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-size/2, -size/2); ctx.lineTo(size/2, size/2);
            ctx.moveTo(size/2, -size/2); ctx.lineTo(-size/2, size/2);
            ctx.stroke();

            // --- 2. PISTONS (Static) ---
            ctx.fillStyle = "#444";
            for (let i = 0; i < 4; i++) {
                ctx.save();
                ctx.rotate((Math.PI / 2) * i); 
                
                // Base
                ctx.fillRect(-6, -size/2, 12, 10);
                
                // Rod (Static position)
                let py = -size/2 + 8;
                ctx.fillStyle = "#888"; 
                ctx.fillRect(-3, py, 6, 8);
                
                // Wire
                ctx.strokeStyle = "#222";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, -size/2 + 5);
                ctx.lineTo(0, py);
                ctx.stroke();
                
                ctx.restore();
            }

            // --- 3. REACTOR CORE ---
            // Static moderate glow
            ctx.shadowBlur = 15; 
            ctx.shadowColor = "#00d2ff";
            ctx.fillStyle = `rgba(0, 210, 255, 0.6)`;
            
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0; 

            // --- 4. PLASMA RINGS ---
            // Outer Ring
            ctx.strokeStyle = "#00d2ff"; 
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 8]); 
            ctx.beginPath();
            ctx.arc(0, 0, size/2 - 6, 0, Math.PI * 2);
            ctx.stroke();

            // Inner Ring
            ctx.strokeStyle = "#ff00ff"; 
            ctx.setLineDash([5, 5]); 
            ctx.beginPath();
            ctx.arc(0, 0, size/2 - 12, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]); // Reset dash

            ctx.restore();
        }
    }
    else if (currentTool === 'wall_turret') {
        // ... (Existing Turret Logic) ...
        // --- 1. CALCULATE GRID SNAP ---
        let col = Math.floor(mouseX / CELL_SIZE);
        let row = Math.floor(mouseY / CELL_SIZE);
        
        // Center the blueprint on the grid cell
        let snapX = col * CELL_SIZE + CELL_SIZE / 2;
        let snapY = row * CELL_SIZE + CELL_SIZE / 2;

        // --- 2. DRAW RANGE CONE (Centered on Snap) ---
        ctx.save();
        ctx.translate(snapX, snapY); 
        
        ctx.beginPath();
        ctx.fillStyle = "rgba(0, 255, 0, 0.1)";
        ctx.strokeStyle = "rgba(0, 255, 0, 0.5)";
        ctx.moveTo(0, 0);
        // Note: Adjusted radius to 210 to match the new turret range
        ctx.arc(0, 0, 210 * (hasSkill('turret_range') ? 1.4 : 1), buildRotation - Math.PI / 3, buildRotation + Math.PI / 3);
        ctx.lineTo(0, 0);
        ctx.fill();
        ctx.stroke();
        ctx.restore();

        // --- 3. DRAW TURRET VISUALS (Updated to Match New Class) ---
        ctx.save();
        ctx.translate(snapX, snapY); 
        ctx.rotate(buildRotation);

        // A. Industrial Hex Base
        ctx.fillStyle = "#263238"; 
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            ctx.lineTo(15 * Math.cos(i * Math.PI / 3), 15 * Math.sin(i * Math.PI / 3));
        }
        ctx.fill();
        ctx.strokeStyle = "#37474f"; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI*2); ctx.stroke();

        // B. The Heavy Cannon
        // Breech
        ctx.fillStyle = "#1c1c1c"; ctx.fillRect(0, -7, 12, 14);
        // Barrel
        ctx.fillStyle = "#455a64"; ctx.fillRect(10, -5, 30, 10);
        // Thermal Sleeve
        ctx.fillStyle = "#37474f"; ctx.fillRect(22, -6, 10, 12); 
        ctx.fillStyle = "#546e7a"; ctx.fillRect(26, -6, 2, 12);
        // Muzzle Brake
        ctx.fillStyle = "#212121";
        ctx.beginPath();
        ctx.moveTo(38, -8); ctx.lineTo(46, -8); 
        ctx.lineTo(48, -6); ctx.lineTo(48, 6);
        ctx.lineTo(46, 8);  ctx.lineTo(38, 8);
        ctx.closePath(); ctx.fill();
        // White Hot Tip
        ctx.fillStyle = "#ffffff"; 
        ctx.fillRect(47, -5, 2, 10);

        // C. Complex Triangular Housing
        // Lower Armor Plate (Darker)
        ctx.fillStyle = "#37474f"; 
        ctx.beginPath();
        ctx.moveTo(16, 0);       // Nose
        ctx.lineTo(0, -10);      // Shoulder
        ctx.lineTo(-10, -18);    // Wing Tip
        ctx.lineTo(-14, -12);    // Cut
        ctx.lineTo(-18, 0);      // Rear
        ctx.lineTo(-14, 12);     // Cut
        ctx.lineTo(-10, 18);     // Wing Tip
        ctx.lineTo(0, 10);       // Shoulder
        ctx.closePath();
        ctx.fill();

        // Upper Armor Plate (Lighter)
        ctx.fillStyle = "#546e7a"; 
        ctx.beginPath();
        ctx.moveTo(14, 0);       
        ctx.lineTo(-12, -8);     
        ctx.lineTo(-16, 0);      
        ctx.lineTo(-12, 8);      
        ctx.closePath();
        ctx.fill();

        // Spine Detail
        ctx.strokeStyle = "rgba(0,0,0,0.2)";
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(-16, 0); ctx.lineTo(14, 0); ctx.stroke();

        // Optics / Status Light
        ctx.fillStyle = "#00e676"; 
        ctx.fillRect(-10, -3, 4, 6);

        ctx.restore();
    }
    else if (currentTool === 'mortar') {
        // ... (Existing Mortar Logic) ...
        // 1. Grid Snap Calculations
        let col = Math.floor(mouseX / CELL_SIZE);
        let row = Math.floor(mouseY / CELL_SIZE);
        
        let x = col * CELL_SIZE; 
        let y = row * CELL_SIZE;
        let centerX = x + CELL_SIZE / 2;
        let centerY = y + CELL_SIZE / 2;
        let size = CELL_SIZE;

        // 2. Range Circle (Kept Green as requested)
        ctx.beginPath();
        ctx.fillStyle = "rgba(0, 255, 0, 0.1)";
        ctx.strokeStyle = "rgba(0, 255, 0, 0.5)";
        ctx.arc(centerX, centerY, 550, 0, Math.PI * 2); // Match stats range (550)
        ctx.fill();
        ctx.stroke();

        // 3. Mortar Visuals (Ported from Class)
        ctx.save();
        ctx.translate(centerX, centerY);

        // --- Palette ---
        const cMatteDark = "#2b2b2b";
        const cMatteMid  = "#4a4a4a";
        const cCarbon    = "#1a1a1a";
        const cAccent    = "#ffffff";

        // --- LAYER 1: Industrial Base ---
        ctx.fillStyle = cMatteDark;
        ctx.beginPath();
        for(let i=0; i<8; i++){
            let ang = i * Math.PI / 4;
            ctx.lineTo(size*0.45 * Math.cos(ang), size*0.45 * Math.sin(ang));
        }
        ctx.fill();
        
        ctx.strokeStyle = cMatteMid;
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(0,0, size*0.35, 0, Math.PI*2); ctx.stroke();
        
        // Bolts
        ctx.fillStyle = "#111";
        [0, 2, 4, 6].forEach(i => {
            let a = i * Math.PI / 4;
            ctx.beginPath(); 
            ctx.rect(size*0.38*Math.cos(a)-2, size*0.38*Math.sin(a)-2, 4, 4); 
            ctx.fill();
        });

        // --- LAYER 2: THE BARREL ---
        // We simulate the helper functions here locally
        ctx.save();
        ctx.translate(0, size * 0.1); // Pivot offset

        const totalLen = size * 0.9;
        const breechW = size * 0.42;
        const breechH = size * 0.25;

        // 2a. Breech Block
        ctx.fillStyle = cMatteDark;
        ctx.fillRect(-breechW/2, -breechH, breechW, breechH);
        
        // 2b. Barrel Segments (Helper logic inlined for gradients)
        const drawGradCyl = (gx, gy, w, h, c1, c2) => {
            let grad = ctx.createLinearGradient(gx-w/2, 0, gx+w/2, 0);
            grad.addColorStop(0, c2); grad.addColorStop(0.4, c1); 
            grad.addColorStop(0.5, c1); grad.addColorStop(1.0, "#000");
            ctx.fillStyle = grad;
            ctx.fillRect(gx-w/2, gy-h, w, h);
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.fillRect(gx-w/2, gy-h, w, 1); // Segment line
        };

        const seg1W = size * 0.34; const seg1H = totalLen * 0.3;
        const seg2W = size * 0.26; const seg2H = totalLen * 0.3;
        const seg3W = size * 0.18; const seg3H = totalLen * 0.4;

        // Draw segments (No recoil in preview)
        drawGradCyl(0, -breechH, seg1W, seg1H, cMatteMid, cCarbon);
        drawGradCyl(0, -breechH - seg1H, seg2W, seg2H, "#ffffff", "#888888");
        const tipY = -breechH - seg1H - seg2H;
        drawGradCyl(0, tipY, seg3W, seg3H, cMatteMid, "#000");

        // Muzzle Device
        ctx.fillStyle = cCarbon;
        ctx.fillRect(-seg3W/2 - 2, tipY - seg3H, seg3W + 4, 10);
        ctx.fillStyle = cAccent;
        ctx.fillRect(-2, tipY - seg3H + 4, 4, 2); 

        ctx.restore(); // End Barrel

        // --- LAYER 3: HEAVY SIDE PLATING ---
        const mountW = size * 0.14;
        const mountH = size * 0.5;
        const spread = size * 0.24;

        const drawMount = (mx) => {
            ctx.save();
            ctx.translate(mx, 0);
            ctx.fillStyle = cMatteMid;
            ctx.strokeStyle = "#111";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-mountW/2, size/4); 
            ctx.lineTo(-mountW/2, -mountH/4);   
            ctx.lineTo(0, -mountH/2);       
            ctx.lineTo(mountW/2, -mountH/4);    
            ctx.lineTo(mountW/2, size/4);   
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Bolt
            ctx.fillStyle = cMatteDark;
            ctx.beginPath(); ctx.arc(0, size/5, 3, 0, Math.PI*2); ctx.fill();
            // Light
            ctx.fillStyle = cAccent; ctx.fillRect(-2, -mountH/3, 4, 4);
            ctx.restore();
        };

        drawMount(-spread);
        drawMount(spread);

        // --- LAYER 4: The Axle ---
        ctx.fillStyle = "#111";
        ctx.fillRect(-spread, -4, spread*2, 8);

        ctx.restore(); // End Translation
    }
    else if (currentTool === 'trap') {
        // ... (Existing Trap Logic) ...
        // 1. Grid Snap Calculations
        let col = Math.floor(mouseX / CELL_SIZE);
        let row = Math.floor(mouseY / CELL_SIZE);
        let snapX = col * CELL_SIZE + CELL_SIZE / 2;
        let snapY = row * CELL_SIZE + CELL_SIZE / 2;

        ctx.save();
        ctx.translate(snapX, snapY);

        // 2. Trigger Radius (Visual Aid)
        ctx.beginPath();
        ctx.fillStyle = "rgba(255, 50, 50, 0.2)";
        ctx.strokeStyle = "rgba(255, 50, 50, 0.6)";
        ctx.arc(0, 0, 22, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // 3. Trap Visuals (Ready State - Retracted)
        const size = CELL_SIZE - 4;
        const half = size / 2;

        // --- A. Base Plate ---
        ctx.beginPath();
        ctx.moveTo(-half + 6, -half);
        ctx.lineTo(half - 6, -half);
        ctx.lineTo(half, -half + 6);
        ctx.lineTo(half, half - 6);
        ctx.lineTo(half - 6, half);
        ctx.lineTo(-half + 6, half);
        ctx.lineTo(-half, half - 6);
        ctx.lineTo(-half, -half + 6);
        ctx.closePath();

        // Gradient: Titanium/Slate
        let baseGrad = ctx.createLinearGradient(-half, -half, half, half);
        baseGrad.addColorStop(0, "#6a6a70"); 
        baseGrad.addColorStop(1, "#3a3a40"); 
        ctx.fillStyle = baseGrad;
        ctx.fill();
        
        ctx.strokeStyle = "#889"; 
        ctx.lineWidth = 1;
        ctx.stroke();

        // Inner Panel
        ctx.fillStyle = "#222"; 
        ctx.fillRect(-half + 5, -half + 5, size - 10, size - 10);
        ctx.strokeStyle = "#111";
        ctx.strokeRect(-half + 5, -half + 5, size - 10, size - 10);

        // --- B. Spike Housings (Empty/Retracted) ---
        const spikeOffset = 9;
        const spikePositions = [
            {x: -spikeOffset, y: -spikeOffset}, 
            {x: spikeOffset, y: -spikeOffset},  
            {x: -spikeOffset, y: spikeOffset},  
            {x: spikeOffset, y: spikeOffset}    
        ];

        for(let pos of spikePositions) {
            let isBack = pos.y < 0;
            // Draw the empty hole
            ctx.fillStyle = "#111"; 
            ctx.beginPath(); ctx.arc(pos.x, pos.y, 4.5, 0, Math.PI*2); ctx.fill();
            // Draw the rim
            ctx.strokeStyle = isBack ? "#555" : "#777";
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // --- C. Center Light (Green for Ready) ---
        ctx.fillStyle = "#111";
        ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = "#00ff00"; 
        ctx.beginPath(); ctx.arc(0, 0, 1.5, 0, Math.PI*2); ctx.fill();
        ctx.shadowColor = "#0f0";
        ctx.shadowBlur = 8;
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.restore();
    }
    else if (currentTool === 'minigun') {
        if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
            const x = col * CELL_SIZE + CELL_SIZE / 2;
            const y = row * CELL_SIZE + CELL_SIZE / 2;
            const isOccupied = grid[col][row].occupied || grid[col][row].wall;
            const canAfford = money >= 400; // Cost matches UI

            ctx.save();
            ctx.translate(x, y);
            ctx.globalAlpha = 0.65; // Ghost transparency

            // --- 1. INDUSTRIAL BASE ---
            // Drop shadow
            ctx.fillStyle = "rgba(0,0,0,0.3)";
            ctx.beginPath(); ctx.arc(2, 2, 22, 0, Math.PI * 2); ctx.fill();

            // Main X-Stand
            ctx.fillStyle = "#1a1a1a";
            
            for(let i=0; i<4; i++) {
                ctx.save(); 
                ctx.rotate((Math.PI/4) + (i * Math.PI/2));
                
                // Leg Strut
                ctx.fillRect(-6, -6, 12, 24); 
                
                // Foot Pad
                ctx.fillStyle ="#333";
                ctx.beginPath();
                ctx.moveTo(-8, 18); ctx.lineTo(8, 18);
                ctx.lineTo(10, 24); ctx.lineTo(-10, 24);
                ctx.fill();
                
                // Bolt
                ctx.fillStyle = "#555";
                ctx.beginPath(); ctx.arc(0, 12, 2, 0, Math.PI*2); ctx.fill();
                
                ctx.restore();
            }

            // Central Bearing Ring
            ctx.fillStyle = "#222";
            ctx.beginPath(); ctx.arc(0,0, 16, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = "#444"; ctx.lineWidth = 2; ctx.stroke();
            
            // Rivets
            ctx.fillStyle = "#666";
            for(let i=0; i<8; i++){
                let ra = i * (Math.PI*2)/8;
                ctx.beginPath(); ctx.arc(Math.cos(ra)*12, Math.sin(ra)*12, 1.5, 0, Math.PI*2); ctx.fill();
            }

            // --- 2. AMMO SYSTEM ---
            const ammoX = -28;
            const ammoY = 18;
            const angle = 0; // Static angle for blueprint
            
            let feedPortX = Math.cos(angle - 0.5) * 8; 
            let feedPortY = Math.sin(angle - 0.5) * 8;

            // Belt Curve
            ctx.beginPath();
            ctx.moveTo(ammoX, ammoY);
            ctx.quadraticCurveTo(ammoX, ammoY - 25, feedPortX, feedPortY);
            
            ctx.lineWidth = 7; ctx.strokeStyle = "#111"; ctx.stroke(); 
            ctx.lineWidth = 4; ctx.strokeStyle = "#d4af37"; ctx.setLineDash([2, 3]); ctx.stroke(); 
            ctx.setLineDash([]);

            // Ammo Box
            ctx.fillStyle = "#2f3f2f";
            ctx.fillRect(ammoX - 10, ammoY - 10, 24, 20);
            ctx.fillStyle = "#4a5b4a"; 
            ctx.fillRect(ammoX - 8, ammoY - 12, 20, 4);

            // --- 3. TURRET HEAD (Static) ---
            ctx.rotate(angle);

            // Rear Motor Housing
            ctx.fillStyle = "#222";
            ctx.beginPath();
            ctx.arc(-12, 0, 11, Math.PI/2, -Math.PI/2); 
            ctx.fill();
            ctx.fillRect(-12, -11, 10, 22);

            // Main Receiver Body
            ctx.fillStyle = "#3a3a3a"; 
            ctx.beginPath();
            ctx.moveTo(-5, -10);
            ctx.lineTo(15, -10);
            ctx.lineTo(15, 10);
            ctx.lineTo(-5, 10);
            ctx.fill();
            
            ctx.fillStyle = "#1a1a1a";
            ctx.fillRect(-2, -11, 6, 22);

            // Barrel Bundle
            const bW = 46; const bH = 14; const bX = 15; const bY = -bH/2;
            ctx.fillStyle = "#050505";
            ctx.fillRect(bX, bY, bW, bH);

            // Static Barrels (No heat color)
            ctx.fillStyle = "#444"; 
            const spacing = 5;
            for(let i = -spacing; i < bH + spacing; i += spacing) {
                let yPos = bY + i;
                if(yPos < bY + bH && yPos > bY) {
                     ctx.fillRect(bX, yPos, bW, 2);
                }
            }

            // Barrel Details
            ctx.fillStyle = "#222";
            ctx.fillRect(bX + 20, bY - 1, 4, bH + 2); // Clamp
            ctx.fillStyle = "#111";
            ctx.fillRect(bX + bW - 2, bY - 1, 3, bH + 2); // Muzzle

            ctx.restore();

            // --- 4. RANGE INDICATOR ---
            ctx.beginPath();
            ctx.arc(x, y, 280, 0, Math.PI * 2); // Range matches class stats (280)
            ctx.strokeStyle ="rgba(255, 255, 255, 0.5)";
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }
    else if (currentTool === 'money_farm') {
        // ... (Existing Money Farm Logic) ...
        if (col >= 0 && col < COLS - 1 && row >= 0 && row < ROWS - 1) {
            // Calculate center coordinates based on the grid column/row
            let x = col * CELL_SIZE;
            let y = row * CELL_SIZE;
            let cx = x + CELL_SIZE;
            let cy = y + CELL_SIZE;
            let radius = CELL_SIZE - 5;

            ctx.save(); // Save context to handle transparency safely
            ctx.globalAlpha = 0.7; // Make the whole preview slightly transparent

            // --- 1. BASE PAD (Static) ---
            ctx.fillStyle = "#1a1a22";
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fill();

            // --- 2. TECH PATTERNS (Static) ---
            ctx.strokeStyle = "#330066";
            ctx.lineWidth = 2;
            ctx.beginPath();
            // Inner rings
            ctx.arc(cx, cy, radius * 0.8, 0, Math.PI * 2);
            ctx.arc(cx, cy, radius * 0.5, 0, Math.PI * 2);
            // Spokes
            for (let i = 0; i < 8; i++) {
                let angle = (Math.PI / 4) * i;
                ctx.moveTo(cx + Math.cos(angle) * (radius * 0.5), cy + Math.sin(angle) * (radius * 0.5));
                ctx.lineTo(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius);
            }
            ctx.stroke();

            // --- 3. GAUGE TRACK (Empty/Static) ---
            // Just drawing the background track, no progress fill
            let gaugeRadius = radius * 0.75;
            ctx.strokeStyle = "rgba(100, 0, 200, 0.4)";
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.arc(cx, cy, gaugeRadius, 0, Math.PI * 2);
            ctx.stroke();

            // --- 4. THE PLANT (Static/No Rotation) ---
            let plantSize = radius * 0.4;
            
            // Outer Petals
            ctx.fillStyle = "#7700aa"; // Static dark crystal color
            ctx.beginPath();
            for (let i = 0; i < 8; i += 2) {
                let angle = (Math.PI * 2 / 8) * i; // Fixed angle (no rotation)
                ctx.moveTo(cx, cy);
                ctx.lineTo(cx + Math.cos(angle - 0.3) * plantSize, cy + Math.sin(angle - 0.3) * plantSize);
                ctx.lineTo(cx + Math.cos(angle) * plantSize * 1.2, cy + Math.sin(angle) * plantSize * 1.2);
                ctx.lineTo(cx + Math.cos(angle + 0.3) * plantSize, cy + Math.sin(angle + 0.3) * plantSize);
            }
            ctx.fill();

            // Inner Core (Static size, no pulse)
            ctx.fillStyle = "#ff00aa"; // Static magenta
            ctx.beginPath();
            let coreSize = plantSize * 0.5;
            for (let i = 0; i < 6; i++) {
                let angle = (Math.PI * 2 / 6) * i;
                let px = cx + Math.cos(angle) * coreSize;
                let py = cy + Math.sin(angle) * coreSize;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.fill();

            // --- 5. SELECTION BORDER ---
            // Keeps the user aware of the 2x2 footprint
            ctx.strokeStyle = "rgba(0, 255, 255, 0.5)";
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, CELL_SIZE * 2, CELL_SIZE * 2);

            ctx.restore(); // Restore context to remove transparency
        }
    }
    else if (currentTool === 'drill') {
        if (col >= 0 && col < COLS - 1 && row >= 0 && row < ROWS - 1) {
            let x = col * CELL_SIZE;
            let y = row * CELL_SIZE;
            let cx2 = x + CELL_SIZE;
            let cy2 = y + CELL_SIZE;
            ctx.save();
            ctx.globalAlpha = 0.7;
            ctx.fillStyle   = "#1c1a14";
            ctx.strokeStyle = "rgba(245,197,24,0.5)";
            ctx.lineWidth   = 2;
            ctx.beginPath();
            ctx.roundRect(x + 3, y + 3, CELL_SIZE*2 - 6, CELL_SIZE*2 - 6, 6);
            ctx.fill(); ctx.stroke();
            ctx.strokeStyle = "#7a6e3e";
            ctx.lineWidth   = 3;
            ctx.beginPath();
            ctx.moveTo(cx2 - 22, cy2 + 20); ctx.lineTo(cx2, cy2 - 22);
            ctx.moveTo(cx2 + 22, cy2 + 20); ctx.lineTo(cx2, cy2 - 22);
            ctx.moveTo(cx2 - 16, cy2 - 4);  ctx.lineTo(cx2 + 16, cy2 - 4);
            ctx.stroke();
            ctx.fillStyle = "#e8d44d";
            ctx.beginPath(); ctx.moveTo(cx2-4,cy2+2); ctx.lineTo(cx2+4,cy2+2); ctx.lineTo(cx2,cy2+12); ctx.closePath(); ctx.fill();
            ctx.strokeStyle = "rgba(245,197,24,0.6)";
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, CELL_SIZE * 2, CELL_SIZE * 2);
            ctx.restore();
        }
    }
    else if (currentTool === 'bounty') {
        let col = Math.floor(mouseX / CELL_SIZE);
        let row = Math.floor(mouseY / CELL_SIZE);
        let snapX = col * CELL_SIZE + CELL_SIZE / 2;
        let snapY = row * CELL_SIZE + CELL_SIZE / 2;

        // Range indicator
        ctx.save();
        ctx.translate(snapX, snapY);
        ctx.beginPath();
        ctx.fillStyle = "rgba(0, 210, 255, 0.06)";
        ctx.strokeStyle = "rgba(0, 210, 255, 0.35)";
        ctx.lineWidth = 1;
        ctx.setLineDash([5, 5]);
        ctx.arc(0, 0, 160, 0, Math.PI * 2);
        ctx.fill(); ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();

        // Draw the tower exactly as placed, just semi-transparent
        ctx.globalAlpha = 0.75;
        drawBountyTowerVisuals(
            snapX, snapY,
            10, 0,   // crusherX, crusherY
            -10, 0,  // armBaseX, armBaseY
            snapX + 10 + 20, snapY - 50,  // arm world position (idle/rest)
            0, 0, "IDLE"
        );
        ctx.globalAlpha = 1.0;
    }
    else if (currentTool === 'cryo_tower') {
        if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
            const x = col * CELL_SIZE + CELL_SIZE / 2;
            const y = row * CELL_SIZE + CELL_SIZE / 2;
            const isOccupied = grid[col][row].occupied || grid[col][row].wall;
            const canAfford = money >= 150; // Adjust cost to match your UI

            ctx.save();
            ctx.translate(x, y);
            ctx.globalAlpha = 0.5; // Transparent "Ghost" mode

            // Note: We do NOT tint it red for invalid placement, 
            // keeping natural colors as requested.

            // --- 1. FROST AURA FLOOR ---
            const r = 160 * (hasSkill('cryo_range') ? 1.25 : 1); // Range
            let grad = ctx.createRadialGradient(0, 0, 10, 0, 0, r * 0.7);
            grad.addColorStop(0, "rgba(200, 240, 255, 0.1)");
            grad.addColorStop(1, "rgba(0, 0, 0, 0)");
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();

            // --- 2. STATIC BASE ---
            // Tech Rune Ring
            ctx.strokeStyle = "rgba(0, 225, 255, 0.3)";
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]); 
            ctx.beginPath(); ctx.arc(0, 0, 25, 0, Math.PI*2); ctx.stroke();
            ctx.setLineDash([]); 

            // Ice Floor Cracks
            ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
            for(let i=0; i<8; i++) {
                ctx.save();
                ctx.rotate((i / 8) * Math.PI * 2);
                ctx.beginPath();
                ctx.moveTo(6, 0); 
                ctx.lineTo(18, 0); 
                ctx.stroke();
                ctx.restore();
            }

            // Mechanical Base Legs
            ctx.fillStyle = "#546e7a"; 
            for (let i = 0; i < 3; i++) {
                ctx.save();
                ctx.rotate((i * Math.PI * 2) / 3);
                ctx.beginPath();
                ctx.moveTo(-3, 5); ctx.lineTo(3, 5);
                ctx.lineTo(5, 14); ctx.lineTo(-5, 14);
                ctx.fill();
                ctx.fillStyle = "#00e5ff";
                ctx.fillRect(-1.5, 10, 3, 2); 
                ctx.fillStyle = "#546e7a";
                ctx.restore();
            }

            // --- 3. THE CRYSTAL (Floating) ---
            ctx.translate(0, -12); // Static hover height

            // Glow (Simple radial, no heavy shadowBlur)
            let glow = ctx.createRadialGradient(0, 0, 0, 0, 0, 20);
            glow.addColorStop(0, `rgba(0, 255, 255, 0.3)`);
            glow.addColorStop(1, "rgba(0, 255, 255, 0)");
            ctx.fillStyle = glow;
            ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI*2); ctx.fill();

            // Crystal Shape
            // Re-create gradient locally for the blueprint
            let crystalGrad = ctx.createLinearGradient(-6, -12, 6, 12);
            crystalGrad.addColorStop(0, "#e0f7fa");
            crystalGrad.addColorStop(0.5, "#00bcd4"); 
            crystalGrad.addColorStop(1, "#006064");
            ctx.fillStyle = crystalGrad;

            ctx.beginPath();
            ctx.moveTo(0, -14); ctx.lineTo(7, 0); ctx.lineTo(0, 14); ctx.lineTo(-7, 0);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = "rgba(255,255,255,0.9)";
            ctx.lineWidth = 1;
            ctx.stroke();

            // Inner Core
            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            ctx.rect(-3.5, -3.5, 7, 7); 
            ctx.fill();

            // Orbit Ring
            ctx.save();
            ctx.scale(1, 0.35); 
            ctx.strokeStyle = `rgba(0, 229, 255, 0.6)`;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI*2); 
            ctx.stroke();
            ctx.restore();

            ctx.restore(); // Restore main context

            // --- 4. RANGE INDICATOR ---
            // Only the range line indicates validity (Red/White)
            ctx.beginPath();
            ctx.arc(x, y, 160, 0, Math.PI * 2);
            ctx.strokeStyle ="rgba(255, 255, 255, 0.5)";
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }
    else if (currentTool === 'flamethrower') {
        let col = Math.floor(mouseX / CELL_SIZE);
        let row = Math.floor(mouseY / CELL_SIZE);
        let snapX = col * CELL_SIZE + CELL_SIZE / 2;
        let snapY = row * CELL_SIZE + CELL_SIZE / 2;

        // Range cone indicator
        ctx.save();
        ctx.translate(snapX, snapY);
        let bpAngle = typeof buildRotation !== 'undefined' ? buildRotation : 0;
        ctx.rotate(bpAngle);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.arc(0, 0, 190, -0.38, 0.38);
        ctx.closePath();
        ctx.fillStyle = "rgba(255,80,0,0.1)";
        ctx.strokeStyle = "rgba(255,100,0,0.45)";
        ctx.lineWidth = 1;
        ctx.setLineDash([4,4]);
        ctx.fill(); ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();

        ctx.globalAlpha = 0.78;
        drawFlamethrowerHardware(snapX, snapY, bpAngle, 0.55, false);
        ctx.globalAlpha = 1.0;
    }
    else if (currentTool === 'tripwire') {
        let col = Math.floor(mouseX / CELL_SIZE);
        let row = Math.floor(mouseY / CELL_SIZE);
        let snapX = col * CELL_SIZE + CELL_SIZE / 2;
        let snapY = row * CELL_SIZE + CELL_SIZE / 2;

        // Show connection radius
        ctx.save();
        ctx.translate(snapX, snapY);
        ctx.setLineDash([4, 4]);
        ctx.strokeStyle = "rgba(0,200,255,0.35)";
        ctx.fillStyle   = "rgba(0,200,255,0.04)";
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(0, 0, TripwirePylon.CONNECT_RADIUS, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        ctx.setLineDash([]);

        // Show potential connections to nearby pylons
        for (let s of structures) {
            if (!(s instanceof TripwirePylon)) continue;
            let d = Math.hypot(s.x - snapX, s.y - snapY);
            if (d <= TripwirePylon.CONNECT_RADIUS && d > 0) {
                ctx.strokeStyle = "rgba(0,220,255,0.7)";
                ctx.lineWidth = 1.5;
                ctx.setLineDash([]);
                ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(s.x - snapX, s.y - snapY); ctx.stroke();
            }
        }
        ctx.restore();

        // Draw ghost pylon
        ctx.globalAlpha = 0.75;
        drawTripwirePylonVisuals(snapX, snapY, false);
        ctx.globalAlpha = 1.0;
    }
    else if (currentTool === 'tesla') {
        let col = Math.floor(mouseX / CELL_SIZE);
        let row = Math.floor(mouseY / CELL_SIZE);
        let snapX = col * CELL_SIZE + CELL_SIZE / 2;
        let snapY = row * CELL_SIZE + CELL_SIZE / 2;

        // Range indicator
        ctx.save();
        ctx.translate(snapX, snapY);
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.strokeStyle = "rgba(255, 215, 0, 0.4)";
        ctx.fillStyle   = "rgba(255, 215, 0, 0.05)";
        ctx.lineWidth = 1;
        ctx.arc(0, 0, 200, 0, Math.PI * 2);
        ctx.fill(); ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();

        // Draw exactly as the placed tower (idle state)
        let sf = (CELL_SIZE * 0.95) / 80;
        ctx.globalAlpha = 0.75;
        drawTeslaVisuals(snapX, snapY, sf, true, 0);
        ctx.globalAlpha = 1.0;
    }
    else if (currentTool === 'railgun') {
        let angle = typeof buildRotation !== 'undefined' ? buildRotation : 0;
        let isHorizontal = Math.abs(Math.sin(angle)) < 0.1;
        let wCells = isHorizontal ? 3 : 2;
        let hCells = isHorizontal ? 2 : 3;
        let col = Math.floor(mouseX / CELL_SIZE);
        let row = Math.floor(mouseY / CELL_SIZE);
        let snapX = col * CELL_SIZE + (wCells * CELL_SIZE) / 2;
        let snapY = row * CELL_SIZE + (hCells * CELL_SIZE) / 2;
        let bw = 3 * CELL_SIZE;
        let bh = 2 * CELL_SIZE;

        // Footprint highlight
        ctx.save();
        ctx.globalAlpha = 0.3;
        ctx.strokeStyle = "rgba(0,255,255,0.6)";
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.strokeRect(col * CELL_SIZE, row * CELL_SIZE, wCells * CELL_SIZE, hCells * CELL_SIZE);
        ctx.setLineDash([]);
        ctx.globalAlpha = 1;
        ctx.restore();

        // Build idle paths and draw exactly as placed tower
        let paths = buildRailgunPaths(bw, bh);
        let idleAnim = {
            outerSpread:0, outerTravel:0, outerAngle:0,
            mainSpread:0,  mainTravel:0,  mainAngle:0,
            innerSpread:0, innerTravel:0, innerAngle:0,
            finAngle:0,    finTravel:0,
            accelTravel:0, accelSpread:0
        };
        ctx.globalAlpha = 0.75;
        drawRailgunVisuals(snapX, snapY, angle, angle, paths, idleAnim,
            bw, bh, 0, 600, 0, 0, 350, 0, 0, 0, null, null);
        ctx.globalAlpha = 1.0;
    }
}

function createExplosion(x, y, damage = 50, blastRadius = 60) {
    // 1. VISUALS
    // Add a simple particle burst if you have a particle system, otherwise just the circle
    if (typeof particles !== 'undefined') {
        // Example: Orange sparks
        for(let i=0; i<8; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
                life: 20, color: "orange"
            });
        }
    }
    
    // Draw the blast circle (flash)
    ctx.fillStyle = "rgba(255, 100, 0, 0.5)";
    ctx.beginPath();
    ctx.arc(x, y, blastRadius, 0, Math.PI * 2); 
    ctx.fill();

    // 2. DAMAGE LOGIC
    if (typeof enemies === 'undefined') return;

    for (let enemy of enemies) {
        // Safety Check
        if (!enemy || enemy.hp <= 0) continue;

        let dist = Math.hypot(enemy.x - x, enemy.y - y);

        // Check if inside explosion range
        if (dist < blastRadius) {
            if (enemy.isInvincible) {
                // BLOCKED!
                if (typeof createParticles === 'function') {
                    createParticles(enemy.x, enemy.y, "#00d2ff", 5); 
                }
            } else {
                // FIXED: Use the argument 'damage', not 'this.damage'
                enemy.hp -= damage;
            }
        }
    }
}

class Trap {
    constructor(x, y) {
        this.col = Math.floor(x / CELL_SIZE);
        this.row = Math.floor(y / CELL_SIZE);
        this.x = this.col * CELL_SIZE + CELL_SIZE / 2;
        this.y = this.row * CELL_SIZE + CELL_SIZE / 2;

        this.type = "TRAP";
        this.hp = 150;
        this.damage = 80 * (hasSkill('spike_dmg') ? 1.5 : 1.0);
        this.radius = 22;
        
        this.state = "READY";
        this.cooldown = 0;
        this.maxCooldown = 160;
    }

    update(dt) {
        if (this.state === "COOLDOWN") {
            this.cooldown--;
            if (this.cooldown <= 0) {
                this.state = "READY";
            }
        } 
        else if (this.state === "READY") {
            for (let e of enemies) {
                let d = Math.hypot(e.x - this.x, e.y - this.y);
                if (d < this.radius) {
                    this.trigger();
                    break; 
                }
            }
        }
    }

    trigger() {
        this.state = "COOLDOWN";
        this.cooldown = this.maxCooldown;

        if(typeof createParticles === 'function') {
            createParticles(this.x, this.y, "#ffffff", 8);
            createParticles(this.x, this.y, "#888888", 6);
        }

        for (let e of enemies) {
            let d = Math.hypot(e.x - this.x, e.y - this.y);
            if (d < this.radius + 8) { 
                e.hp -= this.damage;
                e.vx += (Math.random() - 0.5) * 10; 
                e.vy += (Math.random() - 0.5) * 10;
            }
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        // --- 1. TITANIUM BASE (Lighter for visibility) ---
        const size = CELL_SIZE - 4;
        const half = size / 2;

        // Base Plate Shape
        ctx.beginPath();
        ctx.moveTo(-half + 6, -half);
        ctx.lineTo(half - 6, -half);
        ctx.lineTo(half, -half + 6);
        ctx.lineTo(half, half - 6);
        ctx.lineTo(half - 6, half);
        ctx.lineTo(-half + 6, half);
        ctx.lineTo(-half, half - 6);
        ctx.lineTo(-half, -half + 6);
        ctx.closePath();

        // Gradient: Mid-Grey to Slate (Contrast against black BG)
        let baseGrad = ctx.createLinearGradient(-half, -half, half, half);
        baseGrad.addColorStop(0, "#6a6a70"); // Lighter top-left
        baseGrad.addColorStop(1, "#3a3a40"); // Darker bottom-right
        ctx.fillStyle = baseGrad;
        ctx.fill();

        // Bright Edge Highlight
        ctx.strokeStyle = "#889"; 
        ctx.lineWidth = 1;
        ctx.stroke();

        // Inner Panel (Darker but not black)
        ctx.fillStyle = "#222"; 
        ctx.fillRect(-half + 5, -half + 5, size - 10, size - 10);
        ctx.strokeStyle = "#111";
        ctx.strokeRect(-half + 5, -half + 5, size - 10, size - 10);

        // --- 2. SPIKE HOUSINGS ---
        const spikeOffset = 9;
        const spikePositions = [
            {x: -spikeOffset, y: -spikeOffset}, 
            {x: spikeOffset, y: -spikeOffset},  
            {x: -spikeOffset, y: spikeOffset},  
            {x: spikeOffset, y: spikeOffset}    
        ];

        for(let pos of spikePositions) {
            let isBack = pos.y < 0;

            // Housing Hole
            ctx.fillStyle = "#111"; // Not pure black
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 4.5, 0, Math.PI*2);
            ctx.fill();
            
            // Bright Rim (So holes are visible on the dark panel)
            ctx.strokeStyle = isBack ? "#555" : "#777";
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // --- 3. ANIMATION LOGIC ---
        let extension = 0;
        if (this.state === "COOLDOWN") {
            let pct = this.cooldown / this.maxCooldown;
            if (pct > 0.85) extension = (1 - pct) / 0.15; 
            else if (pct > 0.3) extension = 1.0;          
            else extension = pct / 0.3;                   
        }

        // --- 4. HIGH-CONTRAST SPIKES ---
        if (extension > 0.01) {
            const h = 24 * extension; 
            const w = 3;              

            for(let pos of spikePositions) {
                let sx = pos.x;
                let sy = pos.y;
                let tipY = sy - h;
                let isBack = sy < 0;

                // Shadow
                ctx.fillStyle = "rgba(0,0,0,0.6)";
                ctx.beginPath();
                ctx.ellipse(sx, sy + 3, w+1, w/1.5, 0, 0, Math.PI*2);
                ctx.fill();

                // Spike Gradient (Much brighter now)
                let steelGrad = ctx.createLinearGradient(sx - w, sy, sx + w, sy);
                
                if (isBack) {
                    // Back Row: Medium Steel
                    steelGrad.addColorStop(0.0, "#222");
                    steelGrad.addColorStop(0.2, "#444");
                    steelGrad.addColorStop(0.4, "#aaa"); // Highlight
                    steelGrad.addColorStop(0.7, "#666");
                    steelGrad.addColorStop(1.0, "#222");
                } else {
                    // Front Row: Bright Chrome
                    steelGrad.addColorStop(0.0, "#333");
                    steelGrad.addColorStop(0.2, "#666");
                    steelGrad.addColorStop(0.4, "#fff"); // Pure white shine
                    steelGrad.addColorStop(0.7, "#999");
                    steelGrad.addColorStop(1.0, "#333");
                }

                ctx.fillStyle = steelGrad;
                ctx.beginPath();
                ctx.moveTo(sx - w, sy);
                ctx.lineTo(sx + w, sy);
                ctx.lineTo(sx + w, tipY + 5); 
                ctx.lineTo(sx, tipY);       
                ctx.lineTo(sx - w, tipY + 5); 
                ctx.fill();
            }
        }

        // --- 5. CENTER INDICATOR (Bright LED) ---
        ctx.fillStyle = "#111";
        ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI*2); ctx.fill();

        // Neon Green or Bright Red
        let lightColor = (this.state === "READY") ? "#00ff00" : "#ff3333"; 
        ctx.fillStyle = lightColor;
        ctx.beginPath(); ctx.arc(0, 0, 1.5, 0, Math.PI*2); ctx.fill();
        
        if (this.state === "READY") {
            ctx.shadowColor = "#0f0";
            ctx.shadowBlur = 8; // Stronger glow
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        ctx.restore();
    }
}

class CryoTower {
    constructor(col, row) {
        this.col = col;
        this.row = row;
        this.x = col * CELL_SIZE + CELL_SIZE / 2;
        this.y = row * CELL_SIZE + CELL_SIZE / 2;
        this.type = "CRYO";
        this.range = 160 * (hasSkill('cryo_range') ? 1.25 : 1);
        this.slowFactor = 0.5 + (hasSkill('cryo_slow') ? 0.15 : 0);

        // Animation State
        this.hoverY = 0;
        this.hoverTime = Math.random() * 100;
        this.spin = 0;
        this.pulse = 0;
        this.isFiring = false; 

        // --- OPTIMIZATION 1: RENDER STATIC BASE ONCE (Per instance) ---
        this.cacheCanvas = document.createElement('canvas');
        this.cacheCanvas.width = this.range * 2;
        this.cacheCanvas.height = this.range * 2;
        this.cacheCtx = this.cacheCanvas.getContext('2d');
        this.renderStaticBase(); 

        // --- OPTIMIZATION 2: INIT SHARED ASSETS (Run once for the whole class) ---
        // We create the heavy "Frost Field" and "Crystal Gradient" only once.
        // All CryoTowers will share these images instead of recalculating them.
        if (!CryoTower.cachedField) {
            CryoTower.createSharedAssets(this.range);
        }
    }

    // This creates the heavy graphics once and stores them in static properties
    static createSharedAssets(range) {
        // A. Cache the Frost Field (The big blue circle)
        const size = range * 2;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        const cx = range; 
        const cy = range;

        // 1. The Outer Ring
        ctx.beginPath();
        ctx.arc(cx, cy, range - 2, 0, Math.PI * 2); // -2 to keep inside canvas
        ctx.strokeStyle = "rgb(100, 240, 255)"; // Base color, opacity handled in draw
        ctx.lineWidth = 2;
        ctx.stroke();

        // 2. The Inner Gradient
        let grad = ctx.createRadialGradient(cx, cy, 10, cx, cy, range);
        grad.addColorStop(0, "rgba(255, 255, 255, 0)"); 
        grad.addColorStop(0.6, "rgba(0, 200, 255, 0.1)");
        grad.addColorStop(1, "rgba(200, 240, 255, 0.25)");
        ctx.fillStyle = grad;
        ctx.fill();

        CryoTower.cachedField = canvas;

        // B. Cache the Crystal Gradient (The teal look)
        // We create a tiny canvas just to generate the gradient object or store the data
        // Actually, we can just store the gradient function logic or create it on a temp canvas
        const gCanvas = document.createElement('canvas');
        const gCtx = gCanvas.getContext('2d');
        let crystalGrad = gCtx.createLinearGradient(-6, -12, 6, 12);
        crystalGrad.addColorStop(0, "#e0f7fa");
        crystalGrad.addColorStop(0.5, "#00bcd4"); 
        crystalGrad.addColorStop(1, "#006064");
        CryoTower.cachedCrystalGrad = crystalGrad;
    }

    renderStaticBase() {
        const c = this.cacheCtx;
        const r = this.range;
        const cx = r; 
        const cy = r; 

        // 1. Frost Aura Floor
        let grad = c.createRadialGradient(cx, cy, 10, cx, cy, r * 0.7);
        grad.addColorStop(0, "rgba(200, 240, 255, 0.1)");
        grad.addColorStop(1, "rgba(0, 0, 0, 0)");
        c.fillStyle = grad;
        c.beginPath(); c.arc(cx, cy, r, 0, Math.PI*2); c.fill();

        // 2. Tech Rune Ring
        c.save();
        c.translate(cx, cy);
        c.strokeStyle = "rgba(0, 225, 255, 0.15)";
        c.lineWidth = 1;
        c.setLineDash([4, 4]); 
        c.beginPath(); c.arc(0, 0, 25, 0, Math.PI*2); c.stroke();
        c.setLineDash([]); 
        c.restore();

        // 3. Ice Floor Cracks
        c.strokeStyle = "rgba(255, 255, 255, 0.4)";
        c.lineWidth = 1; 
        for(let i=0; i<8; i++) {
            c.save();
            c.translate(cx, cy);
            c.rotate((i / 8) * Math.PI * 2);
            c.beginPath();
            c.moveTo(6, 0); 
            c.lineTo(18 + Math.random() * 5, (Math.random()-0.5) * 4); 
            c.stroke();
            c.restore();
        }

        // 4. Mechanical Base Legs
        c.translate(cx, cy);
        c.fillStyle = "#546e7a"; 
        for (let i = 0; i < 3; i++) {
            c.save();
            c.rotate((i * Math.PI * 2) / 3);
            c.beginPath();
            c.moveTo(-3, 5); c.lineTo(3, 5);
            c.lineTo(5, 14); c.lineTo(-5, 14);
            c.fill();
            c.fillStyle = "#00e5ff";
            c.fillRect(-1.5, 10, 3, 2); 
            c.fillStyle = "#546e7a";
            c.restore();
        }
    }

    update(dt) {
        if (this.hp <= 0) this.active = false;
        // Assuming 'grid' and 'enemies' are global variables
        if (!grid[this.col][this.row].occupied) this.active = false;
        this.hoverTime += 0.05 *dt;
        this.hoverY = Math.sin(this.hoverTime) * 3;
        
        let spinSpeed = this.isFiring ? 0.10 : 0.02;
        this.spin += spinSpeed;
        this.pulse = (Math.sin(this.hoverTime * 3) + 1) / 2; 

        this.isFiring = false; 

        // Optimization: Simple distance check
        for (let e of enemies) {
            // Pre-check rect collision (faster than hypot) to skip far enemies
            if (Math.abs(e.x - this.x) > this.range || Math.abs(e.y - this.y) > this.range) continue;

            let dist = Math.hypot(e.x - this.x, e.y - this.y);
            if (dist < this.range) {
                e.isSlowed = true;
                this.isFiring = true; 
                
                if (Math.random() < 0.05 && typeof createParticles === 'function') {
                    createParticles(e.x, e.y, "#caf0f8", 1); 
                }
            }
        }
    }

    drawFrostField() {
        if (!this.isFiring) return;

        // Optimization: Draw the Pre-rendered image instead of calculating gradient
        ctx.globalAlpha = 0.3 + (this.pulse * 0.2); // Pulse opacity
        ctx.drawImage(CryoTower.cachedField, this.x - this.range, this.y - this.range);
        ctx.globalAlpha = 1.0; // Reset
    }

    draw() {
        // 1. Static Base (Cached instance)
        ctx.drawImage(this.cacheCanvas, this.x - this.range, this.y - this.range);

        // 2. Frost Field (Cached shared)
        this.drawFrostField();

        // 3. The Crystal
        ctx.save();
        ctx.translate(this.x, this.y + this.hoverY - 12); 

        // OPTIMIZATION: "Fake" Glow using Radial Gradient instead of shadowBlur
        // shadowBlur is very laggy. This looks 95% the same but is instant.
        const glowSize = this.isFiring ? 30 : 20;
        const glowOpacity = this.isFiring ? 0.6 : 0.3;
        
        // Draw the glow *behind* the crystal
        let glow = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
        glow.addColorStop(0, `rgba(0, 255, 255, ${glowOpacity})`);
        glow.addColorStop(1, "rgba(0, 255, 255, 0)");
        ctx.fillStyle = glow;
        ctx.beginPath(); 
        ctx.arc(0, 0, glowSize, 0, Math.PI*2); 
        ctx.fill();

        ctx.globalCompositeOperation = "lighter"; 
        
        // Rotating Shell
        ctx.save();
        ctx.rotate(this.spin);
        
        // Use the SHARED Cached Gradient
        ctx.fillStyle = CryoTower.cachedCrystalGrad;
        
        ctx.beginPath();
        ctx.moveTo(0, -14); ctx.lineTo(7, 0); ctx.lineTo(0, 14); ctx.lineTo(-7, 0);
        ctx.closePath();
        ctx.fill();
        
        ctx.strokeStyle = "rgba(255,255,255,0.9)";
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();

        // Inner Core
        ctx.save();
        ctx.rotate(-this.spin * 1.5); 
        ctx.fillStyle = "#ffffff";
        ctx.globalAlpha = 0.8 + (this.pulse * 0.2); 
        ctx.beginPath();
        ctx.rect(-3.5, -3.5, 7, 7); 
        ctx.fill();
        ctx.restore();

        // Rings
        ctx.globalCompositeOperation = "source-over"; 
        // Removed shadowBlur here too
        
        ctx.save();
        ctx.scale(1, 0.35); 
        ctx.strokeStyle = `rgba(0, 229, 255, ${0.4 + this.pulse * 0.4})`;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(0, 0, 20, 0, Math.PI*2); 
        ctx.stroke();
        ctx.restore();

        ctx.restore();
    }
}

class WallTurret {
    constructor(col, row, angle) {
        // Positioning
        this.col = col;
        this.row = row;
        this.x = col * CELL_SIZE + CELL_SIZE / 2;
        this.y = row * CELL_SIZE + CELL_SIZE / 2;

        // Angles
        this.baseAngle = angle;    
        this.headAngle = angle;    
        this.fov = 120 * (Math.PI / 180); 

        // Combat Stats
        this.range = 400 * (hasSkill('turret_range') ? 1.4 : 1); 
        this.damage = 75 + (hasSkill('turret_dmg') ? 25 : 0); 
        this.cooldown = 0;
        this.maxCooldown = 90 * (hasSkill('turret_fire_rate') ? 0.8 : 1.0); 
        this.active = true;

        // Health
        this.hp = 300; 

        // Visual States
        this.recoil = 0;       
        this.flashTimer = 0;   
    }

    update(dt) {
        let cell = grid[this.col][this.row];

        // 1. DEATH CHECK
        if (!cell.wall) {
            this.active = false;
            createParticles(this.x, this.y, "#333", 12); 
            return;
        }

        this.hp = cell.wallHp;

        // 2. TIMERS
        if (this.cooldown > 0) this.cooldown--;
        if (this.recoil > 0) this.recoil -= 0.5; 
        if (this.flashTimer > 0) this.flashTimer--; 

        // 3. TARGETING
        let targetAngle = this.baseAngle; 
        
        for (let e of enemies) {
            let dx = e.x - this.x;
            let dy = e.y - this.y;
            let dist = Math.hypot(dx, dy);

            if (dist < this.range) {
                let angleToEnemy = Math.atan2(dy, dx);
                let diff = angleToEnemy - this.baseAngle;
                while (diff < -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;

                if (Math.abs(diff) < this.fov / 2) {
                    targetAngle = angleToEnemy; 

                    // FIRE LOGIC
                    if (this.cooldown <= 0) {
                        projectiles.push(new Bullet(this.x, this.y, e, this.damage, 1.8));
                        
                        this.cooldown = this.maxCooldown;
                        this.recoil = 14;     
                        this.flashTimer = 6; 
                        
                        // Muzzle debris
                        let tipX = this.x + Math.cos(this.headAngle) * 40;
                        let tipY = this.y + Math.sin(this.headAngle) * 40;
                        createParticles(tipX, tipY, "#ff9800", 6); 
                        createParticles(tipX, tipY, "#777", 4);    
                    }
                    break; 
                }
            }
        }

        // 4. SMOOTH ROTATION
        let rotDiff = targetAngle - this.headAngle;
        while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
        while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
        this.headAngle += rotDiff * 0.15; 
    }

    draw() {
        // --- LAYER 1: HEAVY MOUNT ---
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.baseAngle); 
        
        // Base Shadow
        ctx.fillStyle = "rgba(0,0,0,0.6)"; 
        ctx.beginPath(); ctx.arc(0, 0, 16, 0, Math.PI*2); ctx.fill();

        // Industrial Hex Base
        ctx.fillStyle = "#263238"; 
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            ctx.lineTo(15 * Math.cos(i * Math.PI / 3), 15 * Math.sin(i * Math.PI / 3));
        }
        ctx.fill();
        ctx.strokeStyle = "#37474f"; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI*2); ctx.stroke();
        ctx.restore();


        // --- LAYER 2: THE TRIANGULAR TANK KILLER ---
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.headAngle);

        // A. Laser Rangefinder (CHANGED TO WHITE)
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(this.range, 0);
        ctx.strokeStyle = "rgba(255, 255, 255, 0.3)"; // White beam
        ctx.lineWidth = 1;
        ctx.setLineDash([20, 20]); ctx.stroke(); ctx.setLineDash([]); 

        // B. Shadow 
        ctx.fillStyle = "rgba(0,0,0,0.5)"; 
        ctx.beginPath();
        ctx.moveTo(14, 0); ctx.lineTo(-12, -16); ctx.lineTo(-12, 16);
        ctx.fill();

        // C. RECOIL
        let kick = -this.recoil; 

        // --- D. THE HEAVY CANNON ---
        ctx.fillStyle = "#1c1c1c"; ctx.fillRect(0 + kick, -7, 12, 14); // Breech
        ctx.fillStyle = "#455a64"; ctx.fillRect(10 + kick, -5, 30, 10); // Barrel
        
        // Thermal Sleeve
        ctx.fillStyle = "#37474f"; ctx.fillRect(22 + kick, -6, 10, 12); 
        ctx.fillStyle = "#546e7a"; ctx.fillRect(26 + kick, -6, 2, 12);

        // Muzzle Brake
        ctx.fillStyle = "#212121";
        ctx.beginPath();
        ctx.moveTo(38 + kick, -8); ctx.lineTo(46 + kick, -8); 
        ctx.lineTo(48 + kick, -6); ctx.lineTo(48 + kick, 6);
        ctx.lineTo(46 + kick, 8);  ctx.lineTo(38 + kick, 8);
        ctx.closePath(); ctx.fill();
        
        // Heat Tip (CHANGED TO WHITE)
        ctx.fillStyle = "#ffffff"; // Pure White (White Hot Metal)
        ctx.shadowColor = "white"; 
        ctx.shadowBlur = 5;
        ctx.fillRect(47 + kick, -5, 2, 10);
        ctx.shadowBlur = 0; // Reset shadow

        // --- E. COMPLEX TRIANGULAR HOUSING ---
        
        // 1. Lower Armor Plate (Wide Delta Wing)
        ctx.fillStyle = "#37474f"; 
        ctx.beginPath();
        ctx.moveTo(16 + kick, 0);       
        ctx.lineTo(0 + kick, -10);      
        ctx.lineTo(-10 + kick, -18);    
        ctx.lineTo(-14 + kick, -12);    
        ctx.lineTo(-18 + kick, 0);      
        ctx.lineTo(-14 + kick, 12);     
        ctx.lineTo(-10 + kick, 18);     
        ctx.lineTo(0 + kick, 10);       
        ctx.closePath();
        ctx.fill();

        // 2. Upper Armor Plate (Raised Central Arrow)
        ctx.fillStyle = "#546e7a"; 
        ctx.beginPath();
        ctx.moveTo(14 + kick, 0);       
        ctx.lineTo(-12 + kick, -8);     
        ctx.lineTo(-16 + kick, 0);      
        ctx.lineTo(-12 + kick, 8);      
        ctx.closePath();
        ctx.fill();

        // 3. Central Spine
        ctx.strokeStyle = "rgba(0,0,0,0.2)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-16 + kick, 0); ctx.lineTo(14 + kick, 0);
        ctx.stroke();

        // 4. Side Vents
        ctx.fillStyle = "#263238"; 
        ctx.beginPath(); ctx.moveTo(-8 + kick, -14); ctx.lineTo(-4 + kick, -12); ctx.lineTo(-8 + kick, -10); ctx.fill();
        ctx.beginPath(); ctx.moveTo(-8 + kick, 14); ctx.lineTo(-4 + kick, 12); ctx.lineTo(-8 + kick, 10); ctx.fill();

        // 5. Optics (Status light changed to White for cooldown)
        ctx.fillStyle = this.cooldown > 0 ? "#ff0000" : "#00e676"; 
        ctx.fillRect(-10 + kick, -3, 4, 6);
        

        // F. MUZZLE FLASH
        if (this.flashTimer > 0) {
            ctx.fillStyle = "#fff";
            ctx.beginPath(); ctx.ellipse(50 + kick, 0, 10, 6, 0, 0, Math.PI*2); ctx.fill();
            
            ctx.fillStyle = `rgba(255, 160, 0, ${this.flashTimer / 5})`; 
            let size = 15 + Math.random() * 5;
            ctx.beginPath(); ctx.arc(52 + kick, 0, size, 0, Math.PI*2); ctx.fill();
            
            ctx.strokeStyle = `rgba(255, 200, 50, ${this.flashTimer / 5})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(48+kick, -5); ctx.lineTo(65+kick, -15);
            ctx.moveTo(48+kick, 5); ctx.lineTo(65+kick, 15);
            ctx.stroke();
        }
        ctx.restore();


        // --- LAYER 3: HEALTH BAR ---
        let maxHp = 300; 
        if (this.hp < maxHp && this.hp > 0) {
            let hpPct = Math.max(0, this.hp / maxHp);
            ctx.fillStyle = "#111"; ctx.fillRect(this.x - 16, this.y - 28, 32, 4);
            if (hpPct > 0.6) ctx.fillStyle = "#00e676";      
            else if (hpPct > 0.3) ctx.fillStyle = "#ffea00"; 
            else ctx.fillStyle = "#ff1744";                   
            ctx.fillRect(this.x - 15, this.y - 27, 30 * hpPct, 2);
        }
    }
}


// ‚îÄ‚îÄ Shared draw function for TeslaTower ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawTeslaVisuals(wx, wy, scaleFactor, isReady, pulse) {
    // draw the octagon helper inline
    function drawOctagon(size, s) {
        ctx.beginPath();
        ctx.moveTo(-size, -s); ctx.lineTo(-s, -size);
        ctx.lineTo(s, -size); ctx.lineTo(size, -s);
        ctx.lineTo(size, s); ctx.lineTo(s, size);
        ctx.lineTo(-s, size); ctx.lineTo(-size, s);
        ctx.closePath();
    }

    ctx.save();
    ctx.translate(wx, wy);
    ctx.scale(scaleFactor, scaleFactor);

    // 0. GROUND SHADOW
    ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
    ctx.beginPath(); ctx.arc(2, 2, 38, 0, TWO_PI); ctx.fill();

    // 1. HEAVY INDUSTRIAL BASE
    ctx.lineWidth = 3;
    ctx.fillStyle = "#1f1f1f"; ctx.strokeStyle = "#0a0a0a";
    drawOctagon(38, 15.2); ctx.fill(); ctx.stroke();
    ctx.fillStyle = "#2b2b2b";
    drawOctagon(30, 12); ctx.fill(); ctx.stroke();

    // 2. GLOWING VENTS
    ctx.fillStyle = isReady ? "#00ffff" : "#004444";
    if (isReady) { ctx.shadowBlur = 8; ctx.shadowColor = "#00ffff"; }
    ctx.beginPath();
    ctx.rect(-6, 22, 12, 4); ctx.rect(-6, -26, 12, 4);
    ctx.rect(22, -6, 4, 12); ctx.rect(-26, -6, 4, 12);
    ctx.fill();
    if (isReady) ctx.shadowBlur = 0;

    ctx.fillStyle = "#444"; ctx.strokeStyle = "#111"; ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-4, 18); ctx.lineTo(4, 18); ctx.lineTo(3, 34); ctx.lineTo(-3, 34);
    ctx.moveTo(-4, -18); ctx.lineTo(4, -18); ctx.lineTo(3, -34); ctx.lineTo(-3, -34);
    ctx.moveTo(18, -4); ctx.lineTo(18, 4); ctx.lineTo(34, 3); ctx.lineTo(34, -3);
    ctx.moveTo(-18, -4); ctx.lineTo(-18, 4); ctx.lineTo(-34, 3); ctx.lineTo(-34, -3);
    ctx.fill(); ctx.stroke();

    // 3. HIGH-VOLTAGE COILS
    const ringData = [
        { r: 20, line: "#704e03", c0: "#b8860b", c1: "#704e03" },
        { r: 15, line: "#8a6608", c0: "#daa520", c1: "#8a6608" },
        { r: 10, line: "#a87b00", c0: "#ffd700", c1: "#a87b00" }
    ];
    for (let rd of ringData) {
        let g = ctx.createRadialGradient(0, 0, rd.r*0.5, 0, 0, rd.r);
        g.addColorStop(0, rd.c0); g.addColorStop(1, rd.c1);
        ctx.fillStyle = g; ctx.strokeStyle = rd.line;
        ctx.beginPath(); ctx.arc(0, 0, rd.r, 0, TWO_PI); ctx.fill(); ctx.stroke();
    }

    // 4. EMITTER PRONGS
    ctx.fillStyle = "#555"; ctx.strokeStyle = "#111"; ctx.lineWidth = 1;
    ctx.save(); ctx.rotate(PI_4);
    ctx.beginPath();
    ctx.moveTo(-3, 6); ctx.lineTo(3, 6); ctx.lineTo(2, 14); ctx.lineTo(-2, 14);
    ctx.moveTo(6, -3); ctx.lineTo(6, 3); ctx.lineTo(14, 2); ctx.lineTo(14, -2);
    ctx.moveTo(-3, -6); ctx.lineTo(3, -6); ctx.lineTo(2, -14); ctx.lineTo(-2, -14);
    ctx.moveTo(-6, -3); ctx.lineTo(-6, 3); ctx.lineTo(-14, 2); ctx.lineTo(-14, -2);
    ctx.fill(); ctx.stroke(); ctx.restore();

    // 5. CENTRAL EMITTER BALL
    if (isReady) {
        let pulseSize = Math.sin((pulse || 0) * 3) * 2;
        ctx.shadowBlur = 12 + pulseSize; ctx.shadowColor = "#e6ac00";
    }
    ctx.fillStyle = "#ffdf00";
    ctx.beginPath(); ctx.arc(0, 0, 6, 0, TWO_PI); ctx.fill(); ctx.stroke();
    ctx.fillStyle = "#fff"; ctx.shadowBlur = 5; ctx.shadowColor = "#fff";
    ctx.beginPath(); ctx.arc(0, 0, 2, 0, TWO_PI); ctx.fill();

    ctx.restore();
}

// ‚îÄ‚îÄ Shared path builder for Railgun ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function buildRailgunPaths(bw, bh) {
    const paths = {
        baseShadow: new Path2D(), basePlate: new Path2D(), track: new Path2D(),
        teeth: new Path2D(), chassis: new Path2D(), railCore: new Path2D(),
        innerTop: new Path2D(), mainTop: new Path2D(), outerTop: new Path2D(), finTop: new Path2D(), accelTop: new Path2D(),
        innerBot: new Path2D(), mainBot: new Path2D(), outerBot: new Path2D(), finBot: new Path2D(), accelBot: new Path2D()
    };
    paths.baseShadow.roundRect(-bw/2 + 10, -bh/2 + 10, bw, bh, 15);
    paths.basePlate.roundRect(-bw/2 + 4, -bh/2 + 4, bw - 8, bh - 8, 15);
    paths.track.arc(-bw/6, 0, bh/2 - 5, 0, Math.PI * 2);
    for (let i = 0; i < 24; i++) {
        let gAng = i * (Math.PI / 12);
        paths.teeth.moveTo(-bw/6 + Math.cos(gAng) * (bh/2 - 15), Math.sin(gAng) * (bh/2 - 15));
        paths.teeth.lineTo(-bw/6 + Math.cos(gAng) * (bh/2 - 5), Math.sin(gAng) * (bh/2 - 5));
    }
    paths.chassis.moveTo(-bw/3, -20); paths.chassis.lineTo(-10, -36);
    paths.chassis.lineTo(bw/6, -22); paths.chassis.lineTo(bw/4, -12);
    paths.chassis.lineTo(bw/4, 12); paths.chassis.lineTo(bw/6, 22);
    paths.chassis.lineTo(-10, 36); paths.chassis.lineTo(-bw/3, 20); paths.chassis.closePath();
    paths.railCore.moveTo(0, -5); paths.railCore.lineTo(bw*1.22, -5);
    paths.railCore.lineTo(bw*1.28, 0); paths.railCore.lineTo(bw*1.22, 5);
    paths.railCore.lineTo(0, 5); paths.railCore.closePath();
    paths.finTop.moveTo(-bw*0.4, -15); paths.finTop.lineTo(-bw*0.6, -45);
    paths.finTop.lineTo(-10, -25); paths.finTop.lineTo(0, -15); paths.finTop.closePath();
    paths.finBot.moveTo(-bw*0.4, 15); paths.finBot.lineTo(-bw*0.6, 45);
    paths.finBot.lineTo(-10, 25); paths.finBot.lineTo(0, 15); paths.finBot.closePath();
    paths.outerTop.moveTo(5, -18); paths.outerTop.lineTo(25, -38);
    paths.outerTop.lineTo(50, -38); paths.outerTop.lineTo(55, -30);
    paths.outerTop.lineTo(bw*1.1, -30); paths.outerTop.lineTo(bw*1.15, -22);
    paths.outerTop.lineTo(40, -18); paths.outerTop.closePath();
    paths.outerBot.moveTo(5, 18); paths.outerBot.lineTo(25, 38);
    paths.outerBot.lineTo(50, 38); paths.outerBot.lineTo(55, 30);
    paths.outerBot.lineTo(bw*1.1, 30); paths.outerBot.lineTo(bw*1.15, 22);
    paths.outerBot.lineTo(40, 18); paths.outerBot.closePath();
    paths.mainTop.moveTo(15, -10); paths.mainTop.lineTo(25, -24);
    paths.mainTop.lineTo(bw*1.05, -24); paths.mainTop.lineTo(bw*1.18, -16);
    paths.mainTop.lineTo(bw*1.25, -10); paths.mainTop.lineTo(40, -10); paths.mainTop.closePath();
    paths.mainBot.moveTo(15, 10); paths.mainBot.lineTo(25, 24);
    paths.mainBot.lineTo(bw*1.05, 24); paths.mainBot.lineTo(bw*1.18, 16);
    paths.mainBot.lineTo(bw*1.25, 10); paths.mainBot.lineTo(40, 10); paths.mainBot.closePath();
    paths.accelTop.moveTo(bw*0.8, -8); paths.accelTop.lineTo(bw*1.3, -8);
    paths.accelTop.lineTo(bw*1.4, -4); paths.accelTop.lineTo(bw*0.8, -4); paths.accelTop.closePath();
    paths.accelBot.moveTo(bw*0.8, 8); paths.accelBot.lineTo(bw*1.3, 8);
    paths.accelBot.lineTo(bw*1.4, 4); paths.accelBot.lineTo(bw*0.8, 4); paths.accelBot.closePath();
    paths.innerTop.moveTo(0, -1); paths.innerTop.lineTo(bw*1.15, -1);
    paths.innerTop.lineTo(bw*1.35, -4); paths.innerTop.lineTo(bw*1.4, -1);
    paths.innerTop.lineTo(bw*1.4, 0); paths.innerTop.lineTo(0, 0); paths.innerTop.closePath();
    paths.innerBot.moveTo(0, 1); paths.innerBot.lineTo(bw*1.15, 1);
    paths.innerBot.lineTo(bw*1.35, 4); paths.innerBot.lineTo(bw*1.4, 1);
    paths.innerBot.lineTo(bw*1.4, 0); paths.innerBot.lineTo(0, 0); paths.innerBot.closePath();
    return paths;
}

// ‚îÄ‚îÄ Shared draw function for Railgun ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function drawRailgunVisuals(worldX, worldY, baseAngle, headAngle, paths, animState,
        bw, bh, windupTimer, maxWindup, laserTimer,
        cooldown, maxCooldown, recoil, coreRotation, tick,
        activeBeam, currentTarget) {

    let chargeRatio = windupTimer > 0 ? 1 - (windupTimer / maxWindup) : 0;
    let isFiring = laserTimer > 0;
    let heatRatio = (!isFiring && cooldown > 0) ? Math.min(1, cooldown / (maxCooldown * 0.8)) : 0;
    let a = animState;
    let tipDistance = (bw * 1.4) + Math.max(a.innerTravel, a.accelTravel) - recoil;

    // 1. Draw Beam First (Underneath gun)
    if (activeBeam) {
        let liveOx = worldX + Math.cos(headAngle) * tipDistance;
        let liveOy = worldY + Math.sin(headAngle) * tipDistance;
        // renderContinuousBeam is on the instance; skip for blueprint (activeBeam will be null)
    }

    ctx.save();
    ctx.translate(worldX, worldY);

    // 2. Static Base
    ctx.save();
    ctx.rotate(baseAngle);
    ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
    ctx.fill(paths.baseShadow);

    let baseGrad = ctx.createLinearGradient(-bw/2, -bh/2, bw/2, bh/2);
    baseGrad.addColorStop(0, "#2a2d33"); baseGrad.addColorStop(0.5, "#414750"); baseGrad.addColorStop(1, "#1c1e22");
    ctx.fillStyle = baseGrad; ctx.strokeStyle = "#111"; ctx.lineWidth = 5;
    ctx.fill(paths.basePlate); ctx.stroke(paths.basePlate);

    ctx.fillStyle = "#353a42"; ctx.strokeStyle = "#000"; ctx.lineWidth = 3;
    ctx.fill(paths.track); ctx.stroke(paths.track);
    ctx.strokeStyle = "#5a626d"; ctx.lineWidth = 5; ctx.stroke(paths.teeth);
    ctx.restore();

    // 3. Rotating Gun Head
    ctx.save();
    ctx.rotate(headAngle);

    let shakeX = 0, shakeY = 0;
    if (chargeRatio > 0.8 && !isFiring) {
        let severity = (chargeRatio - 0.8) * 60;
        shakeX = (Math.random() - 0.5) * severity;
        shakeY = (Math.random() - 0.5) * severity;
    }
    ctx.translate(-recoil + shakeX, shakeY);

    // Targeting Laser
    if (chargeRatio > 0.5 && !isFiring && currentTarget) {
        ctx.globalCompositeOperation = 'lighter';
        let laserAlpha = (chargeRatio - 0.5) / 0.5;
        ctx.strokeStyle = `rgba(255, 0, 80, ${laserAlpha * 0.9})`;
        ctx.lineWidth = 3;
        let dx = currentTarget.x - worldX, dy = currentTarget.y - worldY;
        let dist = Math.hypot(dx, dy);
        ctx.beginPath(); ctx.moveTo(tipDistance, 0); ctx.lineTo(dist, 0); ctx.stroke();
        ctx.globalCompositeOperation = 'source-over';
    }

    let railGrad = ctx.createLinearGradient(0, -bh, 0, bh);
    railGrad.addColorStop(0, "#9ea7b0"); railGrad.addColorStop(0.5, "#757d86"); railGrad.addColorStop(1, "#4b5158");

    const drawJawPiece = (path, travelX, spreadY, angleOffset, jawType, isTop) => {
        ctx.save();
        ctx.translate(travelX, spreadY);
        ctx.rotate(angleOffset * (isTop ? -1 : 1));
        ctx.fillStyle = railGrad; ctx.strokeStyle = "#222"; ctx.lineWidth = 2;
        ctx.fill(path); ctx.stroke(path);
        if (heatRatio > 0) {
            ctx.globalCompositeOperation = 'lighter';
            ctx.fillStyle = `rgba(255, 60, 0, ${heatRatio * 0.4})`;
            ctx.fill(path);
            ctx.globalCompositeOperation = 'source-over';
        }
        let dir = isTop ? -1 : 1;
        if (jawType === 'fin') {
            ctx.fillStyle = "#ffaa00";
            if (chargeRatio > 0 || isFiring) {
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = `rgba(0, 255, 255, ${chargeRatio || 1})`;
            }
            ctx.beginPath(); ctx.arc(-bw*0.3, 18 * dir, 3, 0, Math.PI*2); ctx.fill();
            ctx.globalCompositeOperation = 'source-over';
        } else if (jawType === 'main') {
            ctx.fillStyle = "#40464d"; ctx.lineWidth = 1.5;
            for (let f = 0; f < 6; f++) {
                ctx.beginPath(); ctx.rect(40 + (f * 14), isTop ? 24*dir - 4 : 24*dir, 8, 4);
                ctx.fill(); ctx.stroke();
            }
            for (let c = 0; c < 5; c++) {
                let cx2 = 35 + (c * 18), cy2 = 16 * dir;
                ctx.fillStyle = "#2a2d33";
                ctx.beginPath(); ctx.ellipse(cx2, cy2, 5, 7, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                if (chargeRatio > 0.4 || isFiring) {
                    ctx.globalCompositeOperation = 'lighter';
                    let glowAmt = isFiring ? 1 : (chargeRatio - 0.4) / 0.6;
                    ctx.fillStyle = `rgba(0, ${150 + glowAmt*105}, 255, ${glowAmt})`;
                    ctx.beginPath(); ctx.ellipse(cx2, cy2, 3, 5, 0, 0, Math.PI * 2); ctx.fill();
                    if (c < 4 && chargeRatio > 0.5) {
                        ctx.strokeStyle = `rgba(0, 255, 255, ${glowAmt * 0.9})`; ctx.lineWidth = 2;
                        ctx.beginPath(); ctx.moveTo(cx2 + 4, cy2); ctx.lineTo(cx2 + 18 - 4, cy2); ctx.stroke();
                    }
                    ctx.globalCompositeOperation = 'source-over';
                }
            }
        } else if (jawType === 'accel') {
            if (chargeRatio > 0.6 || isFiring) {
                ctx.globalCompositeOperation = 'lighter';
                let accGlow = isFiring ? 1 : (chargeRatio - 0.6) / 0.4;
                ctx.strokeStyle = `rgba(0, 255, 255, ${accGlow})`; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(bw*0.85, 6 * dir); ctx.lineTo(bw*1.35, 6 * dir); ctx.stroke();
                ctx.globalCompositeOperation = 'source-over';
            }
        } else if (jawType === 'inner') {
            ctx.fillStyle = (chargeRatio > 0.8 || isFiring) ? "#fff" : "#0ff";
            if (chargeRatio > 0.2 || isFiring) {
                ctx.globalCompositeOperation = 'lighter';
                ctx.beginPath(); ctx.arc(bw*1.35, 2 * dir, 4, 0, Math.PI*2); ctx.fill();
                ctx.globalCompositeOperation = 'source-over';
            }
        }
        ctx.restore();
    };

    // Background parts
    drawJawPiece(paths.finTop, a.finTravel, 0, a.finAngle, 'fin', true);
    drawJawPiece(paths.finBot, a.finTravel, 0, a.finAngle, 'fin', false);
    drawJawPiece(paths.outerTop, a.outerTravel, -a.outerSpread, a.outerAngle, 'outer', true);
    drawJawPiece(paths.outerBot, a.outerTravel, a.outerSpread, a.outerAngle, 'outer', false);

    // Main Chassis & Core
    ctx.fillStyle = "#33383e"; ctx.fill(paths.railCore);
    if (chargeRatio > 0 || isFiring) {
        ctx.globalCompositeOperation = 'lighter';
        let coreAlpha = isFiring ? 1 : chargeRatio;
        ctx.fillStyle = `rgba(0, 255, 255, ${coreAlpha})`;
        for (let i = 0; i < 12; i++) {
            if (chargeRatio > (i/12) || isFiring) ctx.fillRect(10 + (i * 12), -4, 5, 8);
        }
        ctx.strokeStyle = `rgba(255, 255, 255, ${coreAlpha * 0.8})`;
        ctx.lineWidth = 2; ctx.stroke(paths.railCore);
        ctx.globalCompositeOperation = 'source-over';
    }

    ctx.fillStyle = "#505761"; ctx.strokeStyle = "#111"; ctx.lineWidth = 3;
    ctx.fill(paths.chassis); ctx.stroke(paths.chassis);

    // Core Holographic Interface
    let rColor, rGlow;
    if (isFiring)              { rColor = "255,255,255"; rGlow = "0,255,255"; }
    else if (chargeRatio > 0.8){ rColor = "255,0,255";   rGlow = "255,0,100"; }
    else if (chargeRatio > 0.6){ rColor = "255,255,255"; rGlow = "0,255,255"; }
    else if (chargeRatio > 0.2){ rColor = "0,255,255";   rGlow = "0,170,255"; }
    else if (cooldown > 0)     { rColor = "255,80,0";    rGlow = "200,30,0"; }
    else                       { rColor = "0,255,100";   rGlow = "0,100,50"; }

    ctx.save();
    let uiAlpha = Math.min(1, 0.4 + chargeRatio);
    ctx.globalCompositeOperation = 'lighter';
    ctx.rotate(coreRotation);
    ctx.strokeStyle = `rgba(${rColor}, ${uiAlpha})`; ctx.lineWidth = 3;
    ctx.setLineDash([10, 8, 4, 8]);
    ctx.beginPath(); ctx.arc(0, 0, 22, 0, Math.PI*2); ctx.stroke();
    ctx.setLineDash([]); ctx.lineWidth = 2;
    ctx.strokeStyle = `rgba(${rGlow}, ${uiAlpha * 0.8})`;
    ctx.beginPath(); ctx.arc(0, 0, 14, 0, Math.PI*2); ctx.stroke();
    ctx.fillStyle = `rgba(${rGlow}, ${uiAlpha * 0.6})`;
    ctx.beginPath(); ctx.arc(0, 0, 8 + (chargeRatio * 8), 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = `rgba(${rColor}, ${uiAlpha})`;
    ctx.beginPath(); ctx.arc(0, 0, 4 + (chargeRatio * 4), 0, Math.PI * 2); ctx.fill();
    ctx.restore();

    // Foreground parts
    drawJawPiece(paths.mainTop, a.mainTravel, -a.mainSpread, a.mainAngle, 'main', true);
    drawJawPiece(paths.mainBot, a.mainTravel, a.mainSpread, a.mainAngle, 'main', false);
    drawJawPiece(paths.accelTop, a.accelTravel, -a.accelSpread, 0, 'accel', true);
    drawJawPiece(paths.accelBot, a.accelTravel, a.accelSpread, 0, 'accel', false);
    drawJawPiece(paths.innerTop, a.innerTravel, -a.innerSpread, a.innerAngle, 'inner', true);
    drawJawPiece(paths.innerBot, a.innerTravel, a.innerSpread, a.innerAngle, 'inner', false);

    // Phase 5 arcs
    if (chargeRatio > 0.8 && !isFiring) {
        ctx.globalCompositeOperation = 'lighter';
        ctx.strokeStyle = `rgba(255, 255, 255, ${chargeRatio})`;
        ctx.lineWidth = 2 + Math.random() * 3;
        let prongTipX = bw*1.35 + a.innerTravel;
        // inline jagged line
        function jagLine(x1,y1,x2,y2,jit){
            let ddx=x2-x1,ddy=y2-y1,dist=Math.sqrt(ddx*ddx+ddy*ddy);
            if(dist<10) return;
            let steps=Math.max(dist/40,4)|0;
            ctx.beginPath(); ctx.moveTo(x1,y1);
            for(let i=1;i<steps;i++){let t=i/steps;ctx.lineTo(x1+ddx*t+(Math.random()-.5)*jit*(Math.sin(t*Math.PI)),y1+ddy*t+(Math.random()-.5)*jit*(Math.sin(t*Math.PI)));}
            ctx.lineTo(x2,y2); ctx.stroke();
        }
        for (let i = 0; i < 3; i++) {
            jagLine(prongTipX-(Math.random()*20),-a.innerSpread,prongTipX-(Math.random()*20),a.innerSpread,15);
        }
        ctx.globalCompositeOperation = 'source-over';
    }

    // Accelerator rings & singularity
    if (chargeRatio > 0 || isFiring) {
        ctx.globalCompositeOperation = 'lighter';
        let ringAlpha = isFiring ? 1 : chargeRatio;
        if (chargeRatio > 0.4 || isFiring) {
            for (let i = 1; i <= 8; i++) {
                let pX = 20 + (i * 20) + (chargeRatio * 25);
                ctx.fillStyle = `rgba(0, 255, 255, ${ringAlpha * 0.4})`;
                ctx.beginPath(); ctx.ellipse(pX, 0, 8+(chargeRatio*12), Math.max(a.mainSpread,5)*2.5, 0, 0, Math.PI*2); ctx.fill();
            }
        }
        let trueTipX = (bw * 1.4) + Math.max(a.innerTravel, a.accelTravel);
        if (!isFiring) {
            if (chargeRatio > 0.6) {
                let haloDist = trueTipX + (chargeRatio - 0.6) * 100;
                ctx.strokeStyle = `rgba(0, 255, 255, ${(chargeRatio-0.6)*2})`; ctx.lineWidth = 4;
                ctx.beginPath(); ctx.ellipse(haloDist, 0, 10, 60, 0, 0, Math.PI*2); ctx.stroke();
                ctx.beginPath(); ctx.ellipse(haloDist+30, 0, 6, 40, 0, 0, Math.PI*2); ctx.stroke();
                if (chargeRatio > 0.8) {
                    let imp = (tick % 10) / 10;
                    let rr = 200 * (1 - imp);
                    ctx.strokeStyle = `rgba(255, 0, 255, ${imp * chargeRatio})`; ctx.lineWidth = 8;
                    ctx.beginPath(); ctx.ellipse(trueTipX, 0, rr/4, rr, 0, 0, Math.PI*2); ctx.stroke();
                    ctx.fillStyle = "rgba(0,0,0,0.9)"; ctx.beginPath(); ctx.arc(trueTipX, 0, 20, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = "rgba(255,255,255,1)"; ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.arc(trueTipX, 0, 20+Math.random()*5, 0, Math.PI*2); ctx.stroke();
                }
            }
            let orbPulse = 1 + Math.sin(tick * 0.5) * 0.3;
            ctx.fillStyle = "rgba(0, 255, 255, 0.4)";
            ctx.beginPath(); ctx.arc(trueTipX, 0, chargeRatio*60*orbPulse, 0, Math.PI*2); ctx.fill();
        } else {
            let alpha = laserTimer / 60;
            ctx.strokeStyle = `rgba(0,255,255,${alpha})`; ctx.lineWidth = 20*alpha;
            ctx.beginPath(); ctx.ellipse(trueTipX, 0, 200*(1-alpha), 500*(1-alpha), 0, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.ellipse(trueTipX, 0, 150*alpha, 400*alpha, 0, 0, Math.PI*2);
            ctx.fillStyle = `rgba(150,255,255,${alpha*0.9})`; ctx.fill();
            ctx.beginPath(); ctx.ellipse(trueTipX, 0, 60*alpha, 200*alpha, 0, 0, Math.PI*2);
            ctx.fillStyle = `rgba(255,255,255,${alpha})`; ctx.fill();
        }
        ctx.globalCompositeOperation = 'source-over';
    }

    ctx.restore(); // gun head
    ctx.restore(); // world translate
}

// --- NEW TOWER: TESLA COIL ---
const TWO_PI = Math.PI * 2;
const PI_4 = 0.785398; // 45 degrees in radians

class TeslaTower {
    constructor(col, row) {
        this.col = col;
        this.row = row;
        this.x = col * CELL_SIZE + CELL_SIZE / 2;
        this.y = row * CELL_SIZE + CELL_SIZE / 2;

        // Precalculate Scale & Ranges for fast math
        this.scaleFactor = (CELL_SIZE * 0.95) / 80;
        this.range = 180 * (hasSkill('tesla_range') ? 1.2 : 1);
        this.rangeSq = this.range * this.range; 
        this.chainRange = 180 * (hasSkill('tesla_range') ? 1.2 : 1);
        this.chainRangeSq = this.chainRange * this.chainRange;
        
        // Stats & Timing
        this.continuousDamage = 0.5; 
        this.chainLimit = 4 + (hasSkill('tesla_chain') ? 2 : 0);
        this.cooldown = 0;
        this.maxCooldown = 50;
        this.fireTimer = 0;
        this.maxFireDuration = 30; 

        // Visuals & Object Pooling (Optimization)
        this.targetCoords = []; // Flat array [x1, y1, x2, y2...] to prevent object allocation
        this.hitList = [];      // Reusable array to prevent new Set() allocations
        this.pulse = 0;
        this.ringGradients = null; 
        
        // Lightning Geometry Caching
        this.lightningPath = new Path2D(); 
        this.lightningTimer = 0;
    }

    update(dt) {
        if (this.cooldown > 0) this.cooldown--;
        this.pulse += 0.1;

        let primaryTarget = null;

        // Handle firing state
        if (this.fireTimer > 0) {
            this.fireTimer--;
            primaryTarget = this.getPrimaryTarget();
            
            if (primaryTarget) {
                this.executeChainLightning(primaryTarget);
            } else {
                this.fireTimer = 0; 
                this.targetCoords.length = 0; // Fast clear without reallocating
            }
        } 
        // Handle trigger state
        else if (this.cooldown <= 0) {
            primaryTarget = this.getPrimaryTarget();
            if (primaryTarget) {
                this.fireTimer = this.maxFireDuration;
                this.cooldown = this.maxCooldown + this.maxFireDuration; 
                this.executeChainLightning(primaryTarget); 
            }
        } else {
            this.targetCoords.length = 0; 
        }
    }

    getPrimaryTarget() {
        let primaryTarget = null;
        let minDistSq = this.rangeSq;
        
        // Cache properties locally to reduce property lookups in the loop
        const tx = this.x;
        const ty = this.y;
        const len = enemies.length; 

        for (let i = 0; i < len; i++) {
            let e = enemies[i];
            let dx = e.x - tx;
            let dy = e.y - ty;
            let distSq = dx * dx + dy * dy;

            if (distSq <= minDistSq) {
                minDistSq = distSq;
                primaryTarget = e;
            }
        }
        return primaryTarget;
    }

    executeChainLightning(firstEnemy) {
        let currentEnemy = firstEnemy;
        
        // Reuse hitList instead of allocating a new Set
        const hitList = this.hitList;
        hitList.length = 0; 
        hitList.push(firstEnemy);

        // Reuse targetCoords flat array instead of allocating {x, y} objects
        const coords = this.targetCoords;
        coords.length = 0;
        coords.push(this.x, this.y, currentEnemy.x, currentEnemy.y);

        currentEnemy.hp -= this.continuousDamage;

        const len = enemies.length;
        const chainRangeSq = this.chainRangeSq;

        for (let i = 0; i < this.chainLimit - 1; i++) {
            let nextEnemy = null;
            let closestDistSq = chainRangeSq;
            let cx = currentEnemy.x;
            let cy = currentEnemy.y;

            for (let j = 0; j < len; j++) {
                let e = enemies[j];
                
                // Array.includes is faster than Set.has for small limits (N <= 4)
                if (hitList.includes(e)) continue;

                let dx = e.x - cx;
                let dy = e.y - cy;
                let distSq = dx * dx + dy * dy;

                if (distSq <= closestDistSq) {
                    closestDistSq = distSq;
                    nextEnemy = e;
                }
            }

            if (nextEnemy) {
                nextEnemy.hp -= this.continuousDamage; 
                hitList.push(nextEnemy);
                coords.push(nextEnemy.x, nextEnemy.y);
                currentEnemy = nextEnemy;
            } else {
                break;
            }
        }
    }

    draw() {
        drawTeslaVisuals(this.x, this.y, this.scaleFactor, this.cooldown <= this.maxCooldown, this.pulse);
        if (this.fireTimer > 0 && this.targetCoords.length > 2) {
            this.renderLightning();
        }
    }
    drawOctagon(size, s) {
        ctx.beginPath();
        ctx.moveTo(-size, -s); ctx.lineTo(-s, -size);
        ctx.lineTo(s, -size); ctx.lineTo(size, -s);
        ctx.lineTo(size, s); ctx.lineTo(s, size);
        ctx.lineTo(-s, size); ctx.lineTo(-size, s);
        ctx.closePath();
    }

    renderLightning() {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        // Only recalculate the jagged lines every 4 frames to save CPU
        if (this.lightningTimer <= 0) {
            this.generateLightningPath();
            this.lightningTimer = 4; 
        }
        this.lightningTimer--;

        // --- FAKE GLOW (Extremely fast compared to shadowBlur) ---
        ctx.strokeStyle = "rgba(0, 255, 255, 0.35)"; 
        ctx.lineWidth = 8;
        ctx.stroke(this.lightningPath); 

        // --- INNER CORE (Solid White) ---
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        ctx.stroke(this.lightningPath);

        // --- SPARKS ---
        const coords = this.targetCoords;
        const len = coords.length;
        for (let i = 2; i < len; i += 2) { // Start at 2 to skip the tower itself
            this.drawSpark(coords[i], coords[i+1]);
        }

        ctx.restore();
    }

    generateLightningPath() {
        const coords = this.targetCoords;
        const len = coords.length;
        
        // Reset the path
        this.lightningPath = new Path2D(); 

        for (let i = 0; i < len - 2; i += 2) {
            let x1 = coords[i];
            let y1 = coords[i+1];
            let x2 = coords[i+2];
            let y2 = coords[i+3];

            let dx = x2 - x1;
            let dy = y2 - y1;
            
            // Fast approximate distance (Chebyshev / Octagonal)
            let absDx = Math.abs(dx);
            let absDy = Math.abs(dy);
            let dist = Math.max(absDx, absDy) + 0.4 * Math.min(absDx, absDy); 
            
            let steps = Math.max(dist * 0.1, 2) | 0; 
            let stepInv = 1 / steps; 

            this.lightningPath.moveTo(x1, y1);
            for (let j = 1; j < steps; j++) {
                let t = j * stepInv;
                let lx = x1 + dx * t;
                let ly = y1 + dy * t;
                
                // Jitter
                let ox = (Math.random() - 0.5) * 8;
                let oy = (Math.random() - 0.5) * 8;
                
                this.lightningPath.lineTo(lx + ox, ly + oy);
            }
            this.lightningPath.lineTo(x2, y2);
        }
    }

    drawSpark(x, y) {
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, TWO_PI); 
        ctx.fill();
        
        ctx.fillStyle = "rgba(0, 255, 255, 0.5)";
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, TWO_PI); 
        ctx.fill();
    }
}

class BountyTower {
    constructor(c, r) {
        this.col = c;
        this.row = r;
        this.x = c * CELL_SIZE + CELL_SIZE / 2;
        this.y = r * CELL_SIZE + CELL_SIZE / 2;
        
        this.range = 160; 
        this.roofOpenTimer = 0; 
        this.gearSpin = 0; 
        
        // --- ASYMMETRICAL OFFSETS ---
        this.armBaseX = -10; // Crane mounted on the left
        this.armBaseY = 0;
        this.crusherX = 10;  // Crusher on the right
        this.crusherY = 0;

        // --- PERSISTENT MAGNETIC ARM ---
        this.arm = {
            state: "IDLE", 
            x: this.x + this.crusherX + 20,
            y: this.y - 50,
            target: null
        };
    }

    update() {
        this.gearSpin += 0.1;

        if (this.roofOpenTimer > 0) {
            this.roofOpenTimer--;
        }

        let speed = 0.8; // Slow, heavy industrial crawl

        // Rest position: arm hangs naturally to the right of the tower (above the crusher)
        const restX = this.x + this.crusherX + 20;
        const restY = this.y - 50;

        if (this.arm.state === "IDLE" || this.arm.state === "RETURNING") {
            // Move smoothly back to rest position
            let dx = restX - this.arm.x;
            let dy = restY - this.arm.y;
            let dist = Math.hypot(dx, dy);

            if (dist > speed) {
                this.arm.x += (dx / dist) * speed;
                this.arm.y += (dy / dist) * speed;
            } else {
                this.arm.x = restX;
                this.arm.y = restY;
                this.arm.state = "IDLE";
            }

            // Only scan for new targets once fully at rest
            if (this.arm.state === "IDLE") {
                for (let corpse of corpses) {
                    if (!corpse.isTargeted && corpse.landed && corpse.active) {
                        let cDist = Math.hypot(corpse.x - this.x, corpse.y - this.y);
                        if (cDist <= this.range) {
                            corpse.isTargeted = true;
                            this.arm.target = corpse;
                            this.arm.state = "EXTENDING";
                            break; 
                        }
                    }
                }
            }
        } else {
            // Active Target Coordinates
            const grabOffset = 35; // How far above the gravestone top the claw hovers
            let tx = this.arm.target.x;
            let ty = this.arm.target.y - grabOffset;

            if (this.arm.state === "RETRACTING") {
                // Pull the gravestone to hover ABOVE the crusher hole
                tx = this.x + this.crusherX;
                ty = this.y + this.crusherY - 40; // High enough so gravestone hangs above, not in, the hole
                
                // Stick gravestone below the claw ‚Äî offset matches grabOffset so no teleport
                this.arm.target.x = this.arm.x;
                this.arm.target.y = this.arm.y + grabOffset + 20; // Hangs lower below the claw
                this.arm.target.dropY = -20; // Lifted off the ground
            }

            let dx = tx - this.arm.x;
            let dy = ty - this.arm.y;
            let dist = Math.hypot(dx, dy);

            if (dist < speed) {
                this.arm.x = tx;
                this.arm.y = ty;

                if (this.arm.state === "EXTENDING") {
                    this.arm.state = "RETRACTING";
                } else if (this.arm.state === "RETRACTING") {
                    // Release the gravestone above the crusher hole so it falls in
                    this.roofOpenTimer = 40; 
                    money += Math.ceil(this.arm.target.bounty / 2);

                    // Position gravestone above the crusher, release physics
                    let dropped = this.arm.target;
                    dropped.isTargeted = false;        // Re-enable physics
                    dropped.x = this.x + this.crusherX;
                    dropped.y = this.y + this.crusherY; // Ground level at crusher
                    dropped.dropY = -30;               // Start above the hole
                    dropped.velocity = 3;              // Falling downward fast
                    dropped.gravity = 1.5;             // Heavy drop into the hole
                    dropped.landed = false;
                    dropped.fallingIntoHole = true;    // Flag to skip bounce, sink into hole

                    this.arm.target = null;
                    this.arm.state = "RETURNING";
                }
            } else {
                this.arm.x += (dx / dist) * speed;
                this.arm.y += (dy / dist) * speed;
            }
        }
    }

    draw() {
        drawBountyTowerVisuals(this.x, this.y, this.crusherX, this.crusherY,
            this.armBaseX, this.armBaseY, this.arm.x, this.arm.y,
            this.gearSpin, this.roofOpenTimer, this.arm.state);
    }
}

// Shared draw function ‚Äî used by both the placed tower and the blueprint preview
function drawBountyTowerVisuals(worldX, worldY, crusherX, crusherY,
    armBaseX, armBaseY, armWorldX, armWorldY,
    gearSpin, roofOpenTimer, armState) {

    ctx.save();
    ctx.translate(worldX, worldY);

    // ==========================================
    // 1. HEAVY INDUSTRIAL CHASSIS & SHADOWS
    // ==========================================
    ctx.shadowColor = "rgba(0, 0, 0, 0.8)";
    ctx.shadowBlur = 10;
    ctx.shadowOffsetY = 3;

    ctx.fillStyle = "#16191e";
    ctx.strokeStyle = "#090a0c";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-22, -20);
    ctx.lineTo(8,  -22);
    ctx.lineTo(22, -14);
    ctx.lineTo(22,  14);
    ctx.lineTo(8,   22);
    ctx.lineTo(-22,  20);
    ctx.lineTo(-22, -20);
    ctx.closePath();
    ctx.fill();
    ctx.stroke();

    ctx.shadowBlur = 0;
    ctx.shadowOffsetY = 0;

    let baseGrad = ctx.createLinearGradient(-22, -20, 22, 20);
    baseGrad.addColorStop(0, "#2a3038");
    baseGrad.addColorStop(0.5, "#1b1f24");
    baseGrad.addColorStop(1, "#101216");
    ctx.fillStyle = baseGrad;
    ctx.fill();

    ctx.save();
    ctx.clip();
    ctx.lineWidth = 3;
    ctx.strokeStyle = "rgba(255, 150, 0, 0.6)";
    for (let i = -8; i < 28; i += 6) {
        ctx.beginPath(); ctx.moveTo(i, 8); ctx.lineTo(i - 12, 26); ctx.stroke();
    }
    ctx.restore();

    ctx.fillStyle = "#050608";
    for (let i = 0; i < 3; i++) {
        ctx.fillRect(-16 + (i * 5), 13, 3, 5);
    }

    ctx.fillStyle = "#404854";
    const rivets = [[-18, -14], [6, -17], [18, -8], [18, 10], [6, 16], [-18, 14]];
    for (let r of rivets) {
        ctx.beginPath(); ctx.arc(r[0], r[1], 1.5, 0, Math.PI * 2); ctx.fill();
    }

    // ==========================================
    // 2. THE PLASMA FUSION CRUSHER
    // ==========================================
    ctx.save();
    ctx.translate(crusherX, crusherY);

    let ringGrad = ctx.createRadialGradient(0, 0, 8, 0, 0, 16);
    ringGrad.addColorStop(0, "#1a1e24");
    ringGrad.addColorStop(1, "#0a0c0f");
    ctx.fillStyle = ringGrad;
    ctx.strokeStyle = "#30363d";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

    ctx.strokeStyle = "#404854";
    ctx.lineWidth = 1.5;
    for (let i = 0; i < 12; i++) {
        ctx.save();
        ctx.rotate((i * Math.PI) / 6 + gearSpin * 0.1);
        ctx.beginPath(); ctx.moveTo(15, 0); ctx.lineTo(18, 0); ctx.stroke();
        ctx.restore();
    }

    ctx.fillStyle = "#020203";
    ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI * 2); ctx.fill();

    ctx.save();
    ctx.clip(new Path2D(`M -12 -12 h 24 v 24 h -24 Z`));

    ctx.fillStyle = "#2c313a";
    ctx.strokeStyle = "#16191e";
    ctx.lineWidth = 1;

    ctx.save();
    ctx.translate(-5, 0);
    ctx.rotate(gearSpin * 1.5);
    for (let i = 0; i < 5; i++) {
        ctx.rotate((Math.PI * 2) / 5);
        ctx.beginPath(); ctx.moveTo(0, -2); ctx.lineTo(6, -1); ctx.lineTo(6, 1); ctx.lineTo(0, 2); ctx.fill(); ctx.stroke();
    }
    ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI * 2); ctx.fill();
    ctx.restore();

    ctx.save();
    ctx.translate(5, 0);
    ctx.rotate(-gearSpin * 1.5);
    for (let i = 0; i < 5; i++) {
        ctx.rotate((Math.PI * 2) / 5);
        ctx.beginPath(); ctx.moveTo(0, -2); ctx.lineTo(6, -1); ctx.lineTo(6, 1); ctx.lineTo(0, 2); ctx.fill(); ctx.stroke();
    }
    ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
    ctx.restore();

    let openPulse = roofOpenTimer > 0 ? 1 : 0.2;
    let timePulse = Math.abs(Math.sin(Date.now() / 100)) * 0.5;
    let pAlpha = (0.3 + timePulse) * openPulse;

    if (pAlpha > 0.05) {
        let coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 14);
        coreGrad.addColorStop(0, `rgba(0, 255, 255, ${pAlpha + 0.2})`);
        coreGrad.addColorStop(0.4, `rgba(0, 150, 255, ${pAlpha})`);
        coreGrad.addColorStop(1, "rgba(0, 50, 255, 0)");
        ctx.fillStyle = coreGrad;
        ctx.beginPath(); ctx.arc(0, 0, 14, 0, Math.PI * 2); ctx.fill();

        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 1;
        for (let i = 0; i < 3; i++) {
            let sparkAngle = Math.random() * Math.PI * 2;
            let sparkDist = Math.random() * 8;
            ctx.beginPath();
            ctx.moveTo(Math.cos(sparkAngle) * sparkDist, Math.sin(sparkAngle) * sparkDist);
            ctx.lineTo(Math.cos(sparkAngle) * (sparkDist + 4), Math.sin(sparkAngle) * (sparkDist + 4));
            ctx.stroke();
        }
    }
    ctx.restore();

    // ==========================================
    // 3. THE CRANE ARM & IK MATH
    // ==========================================
    ctx.save();
    ctx.translate(armBaseX, armBaseY);

    ctx.fillStyle = "#1b1f24";
    ctx.strokeStyle = "#404854";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(0, 0, 9, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

    ctx.fillStyle = "#0c0e12";
    ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI * 2); ctx.fill();

    ctx.fillStyle = "#00ffff";
    ctx.beginPath(); ctx.arc(0, -6, 1.5, 0, Math.PI * 2); ctx.fill();

    let targetX = (armWorldX - worldX) - armBaseX;
    let targetY = (armWorldY - worldY) - armBaseY;

    let maxReach = 165;
    let dist = Math.hypot(targetX, targetY);
    if (dist > maxReach) {
        targetX = (targetX / dist) * maxReach;
        targetY = (targetY / dist) * maxReach;
    }

    let L1 = 60, L2 = 55, L3 = 35;
    if (dist < 5) { targetX = 0; targetY = -0.1; }

    let pts = [
        {x: 0, y: 0},
        {x: targetX * 0.33, y: targetY * 0.33 - 45},
        {x: targetX * 0.66, y: targetY * 0.66 - 45},
        {x: targetX, y: targetY}
    ];

    for (let iter = 0; iter < 3; iter++) {
        pts[3] = {x: targetX, y: targetY};
        for (let i = 2; i >= 0; i--) {
            let dx = pts[i].x - pts[i+1].x; let dy = pts[i].y - pts[i+1].y;
            let d = Math.hypot(dx, dy) || 0.001; let L = (i === 2) ? L3 : (i === 1) ? L2 : L1;
            pts[i].x = pts[i+1].x + (dx / d) * L; pts[i].y = pts[i+1].y + (dy / d) * L;
        }
        pts[0] = {x: 0, y: 0};
        for (let i = 1; i <= 3; i++) {
            let dx = pts[i].x - pts[i-1].x; let dy = pts[i].y - pts[i-1].y;
            let d = Math.hypot(dx, dy) || 0.001; let L = (i === 3) ? L3 : (i === 2) ? L2 : L1;
            pts[i].x = pts[i-1].x + (dx / d) * L; pts[i].y = pts[i-1].y + (dy / d) * L;
        }
    }

    for (let i = 0; i < 3; i++) {
        let start = pts[i];
        let end = pts[i+1];
        let angle = Math.atan2(end.y - start.y, end.x - start.x);
        let length = Math.hypot(end.x - start.x, end.y - start.y);

        ctx.save();
        ctx.translate(start.x, start.y);
        ctx.rotate(angle);

        ctx.fillStyle = "#20252b";
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 1.5;
        ctx.beginPath(); ctx.arc(0, 0, (i === 0) ? 6 : (i === 1) ? 5 : 4, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

        if (i === 0) {
            let boomGrad = ctx.createLinearGradient(0, -6, 0, 6);
            boomGrad.addColorStop(0, "#4a5361");
            boomGrad.addColorStop(0.5, "#2f353e");
            boomGrad.addColorStop(1, "#1a1e24");
            ctx.fillStyle = boomGrad;
            ctx.beginPath();
            ctx.moveTo(0, -6); ctx.lineTo(length, -4); ctx.lineTo(length, 4); ctx.lineTo(0, 6);
            ctx.closePath();
            ctx.fill(); ctx.stroke();
            ctx.fillStyle = "#e6a100";
            ctx.fillRect(10, -2, length - 25, 4);
            ctx.fillStyle = "#222";
            for (let k = 12; k < length - 16; k += 6) ctx.fillRect(k, -2, 2, 4);
            ctx.fillStyle = "#111";
            ctx.fillRect(5, 6, length * 0.6, 2);
            ctx.fillStyle = "#a8b2bd";
            ctx.fillRect(5 + length * 0.6, 6.5, length * 0.2, 1);
        } else if (i === 1) {
            ctx.fillStyle = "#555d66";
            ctx.fillRect(0, -4, length, 2);
            ctx.fillRect(0, 2, length, 2);
            ctx.strokeStyle = "#00ffff";
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(length, 0); ctx.stroke();
            ctx.fillStyle = "#111";
            ctx.fillRect(length * 0.3, -5, 4, 10);
            ctx.fillRect(length * 0.7, -5, 4, 10);
        } else if (i === 2) {
            ctx.fillStyle = "#1b1f24";
            ctx.beginPath();
            ctx.moveTo(0, -3);
            ctx.lineTo(length - 5, -5);
            ctx.lineTo(length, -2);
            ctx.lineTo(length, 2);
            ctx.lineTo(length - 5, 5);
            ctx.lineTo(0, 3);
            ctx.closePath();
            ctx.fill(); ctx.stroke();
        }

        ctx.fillStyle = "#00ffff";
        ctx.shadowColor = "#00ffff";
        ctx.shadowBlur = 5;
        ctx.beginPath(); ctx.arc(0, 0, 1.5, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;

        ctx.restore();
    }

    // ==========================================
    // 4. THE PLASMA TALON
    // ==========================================
    ctx.save();
    ctx.translate(pts[3].x, pts[3].y);
    ctx.scale(0.6, 0.6);

    let isActive = (armState === "RETRACTING");
    let clamp = (armState === "EXTENDING") ? 0.85 : 0.1;

    ctx.fillStyle = "#1a1f27";
    ctx.strokeStyle = "#4a5261";
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(-10, -8); ctx.lineTo(10, -8); ctx.lineTo(12, 0);
    ctx.lineTo(10, 8);   ctx.lineTo(-10, 8); ctx.lineTo(-12, 0);
    ctx.closePath();
    ctx.fill(); ctx.stroke();

    ctx.fillStyle = "#555f6d";
    [[-8, -5], [8, -5], [-8, 5], [8, 5]].forEach(([bx, by]) => {
        ctx.beginPath(); ctx.arc(bx, by, 1.5, 0, Math.PI * 2); ctx.fill();
    });

    let coreIntensity = isActive ? 1 : 0.2;
    let coreGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, 6);
    coreGlow.addColorStop(0, `rgba(0, 255, 255, ${coreIntensity})`);
    coreGlow.addColorStop(1, `rgba(0, 100, 200, 0)`);
    ctx.fillStyle = coreGlow;
    ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI * 2); ctx.fill();

    ctx.fillStyle = isActive ? "#00ffff" : "#0a2a2a";
    ctx.strokeStyle = "#00ffff";
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

    // LEFT CLAW
    ctx.save();
    ctx.translate(-6, 6);
    ctx.rotate(-clamp);
    ctx.fillStyle = "#22282f"; ctx.strokeStyle = "#404854"; ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(0, 0); ctx.lineTo(-5, 5); ctx.lineTo(-7, 16); ctx.lineTo(-3, 28);
    ctx.lineTo(2, 20); ctx.lineTo(4, 10); ctx.lineTo(2, 0);
    ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.fillStyle = "#2e3540";
    ctx.beginPath();
    ctx.moveTo(0, 2); ctx.lineTo(-2, 8); ctx.lineTo(-1, 18); ctx.lineTo(2, 10); ctx.lineTo(1, 2);
    ctx.closePath(); ctx.fill();
    ctx.shadowColor = "#00ffff"; ctx.shadowBlur = isActive ? 10 : 3;
    ctx.strokeStyle = isActive ? "rgba(0,255,255,0.95)" : "rgba(0,180,180,0.4)"; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(-7, 16); ctx.lineTo(-3, 28); ctx.lineTo(2, 20); ctx.stroke();
    ctx.shadowBlur = 0;
    ctx.strokeStyle = "#00ffff"; ctx.lineWidth = 0.75; ctx.globalAlpha = 0.5;
    for (let s = 0; s < 4; s++) { let sy = 8 + s * 4; ctx.beginPath(); ctx.moveTo(-4, sy); ctx.lineTo(-2, sy + 2); ctx.stroke(); }
    ctx.globalAlpha = 1;
    ctx.restore();

    // RIGHT CLAW
    ctx.save();
    ctx.translate(6, 6);
    ctx.rotate(clamp);
    ctx.fillStyle = "#22282f"; ctx.strokeStyle = "#404854"; ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(0, 0); ctx.lineTo(5, 5); ctx.lineTo(7, 16); ctx.lineTo(3, 28);
    ctx.lineTo(-2, 20); ctx.lineTo(-4, 10); ctx.lineTo(-2, 0);
    ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.fillStyle = "#2e3540";
    ctx.beginPath();
    ctx.moveTo(0, 2); ctx.lineTo(2, 8); ctx.lineTo(1, 18); ctx.lineTo(-2, 10); ctx.lineTo(-1, 2);
    ctx.closePath(); ctx.fill();
    ctx.shadowColor = "#00ffff"; ctx.shadowBlur = isActive ? 10 : 3;
    ctx.strokeStyle = isActive ? "rgba(0,255,255,0.95)" : "rgba(0,180,180,0.4)"; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.moveTo(7, 16); ctx.lineTo(3, 28); ctx.lineTo(-2, 20); ctx.stroke();
    ctx.shadowBlur = 0;
    ctx.strokeStyle = "#00ffff"; ctx.lineWidth = 0.75; ctx.globalAlpha = 0.5;
    for (let s = 0; s < 4; s++) { let sy = 8 + s * 4; ctx.beginPath(); ctx.moveTo(4, sy); ctx.lineTo(2, sy + 2); ctx.stroke(); }
    ctx.globalAlpha = 1;
    ctx.restore();

    // CENTER FANG
    ctx.save();
    ctx.translate(0, 8);
    let fangDrop = (armState === "EXTENDING") ? 14 : 4;
    ctx.fillStyle = "#1b1f24"; ctx.strokeStyle = "#00ffff"; ctx.lineWidth = 1;
    ctx.shadowColor = "#00ffff"; ctx.shadowBlur = isActive ? 8 : 2;
    ctx.beginPath();
    ctx.moveTo(-3, 0); ctx.lineTo(-2, fangDrop * 0.6); ctx.lineTo(0, fangDrop);
    ctx.lineTo(2, fangDrop * 0.6); ctx.lineTo(3, 0);
    ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.shadowBlur = 0;
    ctx.restore();

    if (isActive) {
        ctx.shadowColor = "#00ffff"; ctx.shadowBlur = 14;
        let leftTipX = -Math.sin(clamp) * 14 - 6;
        let leftTipY = Math.cos(clamp) * 22 + 6;
        let rightTipX = Math.sin(clamp) * 14 + 6;
        let rightTipY = Math.cos(clamp) * 22 + 6;
        ctx.strokeStyle = "rgba(0, 255, 255, 0.9)"; ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(leftTipX, leftTipY);
        ctx.bezierCurveTo(leftTipX * 0.5 + Math.random() * 6 - 3, leftTipY + 4, rightTipX * 0.5 + Math.random() * 6 - 3, rightTipY + 4, rightTipX, rightTipY);
        ctx.stroke();
        ctx.strokeStyle = "rgba(100, 220, 255, 0.4)"; ctx.lineWidth = 0.75;
        ctx.beginPath();
        ctx.moveTo(leftTipX, leftTipY - 3);
        ctx.quadraticCurveTo(0, leftTipY + 8 + Math.random() * 4, rightTipX, rightTipY - 3);
        ctx.stroke();
        ctx.fillStyle = "rgba(0, 200, 255, 0.08)";
        ctx.beginPath();
        ctx.moveTo(-8, 4); ctx.lineTo(leftTipX, leftTipY);
        ctx.bezierCurveTo(leftTipX * 0.5, leftTipY + 8, rightTipX * 0.5, rightTipY + 8, rightTipX, rightTipY);
        ctx.lineTo(8, 4); ctx.closePath(); ctx.fill();
        ctx.shadowBlur = 0;
    }

    ctx.restore(); // End Talon
    ctx.restore(); // End Crane Arm
    ctx.restore(); // End root translate
}

class Railgun {
    constructor(col, row, buildRotation) {
        this.col = col;
        this.row = row;
        
        this.angle = buildRotation || 0;
        let isHorizontal = Math.abs(Math.sin(this.angle)) < 0.1;
        this.wCells = isHorizontal ? 3 : 2;
        this.hCells = isHorizontal ? 2 : 3;

        this.cellSize = typeof CELL_SIZE !== 'undefined' ? CELL_SIZE : 40;
        this.bw = 3 * this.cellSize;
        this.bh = 2 * this.cellSize;

        this.x = col * this.cellSize + (this.wCells * this.cellSize) / 2;
        this.y = row * this.cellSize + (this.hCells * this.cellSize) / 2;

        this.damage = 3000 * (hasSkill('railgun_damage') ? 1.5 : 1);       // Legendary Damage
        this.cooldown = 0;
        this.maxCooldown = 350;   
        this.maxWindup = 600;     // Extended windup to savor the 6-phase transformation
        this.fov = Math.PI / 2; 
        
        this.headAngle = this.angle; 
        this.currentTarget = null;
        this.windupTimer = 0;
        
        this.laserTimer = 0;
        this.pulse = 0;
        this.coreRotation = 0;
        this.recoil = 0; 
        this.tick = 0;

        // üöÄ LEGENDARY ANIMATION STATE (5 Moving Groups)
        this.animState = {
            outerSpread: 0, outerTravel: 0, outerAngle: 0, // Blast Shields
            mainSpread: 0,  mainTravel: 0,  mainAngle: 0,  // Induction Clamps
            innerSpread: 0, innerTravel: 0, innerAngle: 0, // Split Needle Prongs
            finAngle: 0,    finTravel: 0,                  // Rear Stabilizers (NEW)
            accelTravel: 0, accelSpread: 0                 // Ejecting Rails (NEW)
        };

        this.activeBeam = null;
        this.initPaths();
    }

    initPaths() {
        this.paths = buildRailgunPaths(this.bw, this.bh);
    }
    update(dt) {
        this.tick++; 

        if (this.activeBeam) {
            this.activeBeam.length = Math.min(this.activeBeam.maxLength, this.activeBeam.length + this.activeBeam.speed);
            
            // Beam originates from the furthest extended part
            let tipDistance = (this.bw * 1.4) + Math.max(this.animState.innerTravel, this.animState.accelTravel) - this.recoil; 
            let liveOx = this.x + Math.cos(this.headAngle) * tipDistance;
            let liveOy = this.y + Math.sin(this.headAngle) * tipDistance;
            
            let dirX = Math.cos(this.headAngle);
            let dirY = Math.sin(this.headAngle);

            for (let e of enemies) {
                if (!this.activeBeam.hitEnemies.has(e) && e.hp > 0) {
                    let dx = e.x - liveOx, dy = e.y - liveOy;
                    let proj = dx * dirX + dy * dirY; 
                    
                    if (proj > 0 && proj < this.activeBeam.length) {
                        let perpDist = Math.abs(-dirY * dx + dirX * dy);
                        if (perpDist < (this.activeBeam.width / 2) + 25) { 
                            e.hp -= this.damage;
                            this.activeBeam.hitEnemies.add(e);
                        }
                    }
                }
            }
            if (this.laserTimer <= 0) this.activeBeam = null;
        }

        if (this.laserTimer > 0) {
            this.laserTimer--;
            this.recoil = (this.laserTimer / 60) * 70; 
            this.coreRotation += 3.5; 
        } else {
            this.recoil = Math.max(0, this.recoil - 0.4); 
        }

        if (this.windupTimer > 0) {
            this.windupTimer--;
            if (this.currentTarget && this.currentTarget.hp > 0) {
                let dx = this.currentTarget.x - this.x;
                let dy = this.currentTarget.y - this.y;
                let targetAngle = Math.atan2(dy, dx);
                let angleDiff = this.normalizeAngle(targetAngle - this.headAngle);
                // Turns slower, it's a massive heavy weapon
                this.headAngle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), 0.012);
                this.headAngle = this.normalizeAngle(this.headAngle);
            } else {
                this.windupTimer = 0;
                this.currentTarget = null;
            }

            let chargeRatio = 1 - (this.windupTimer / this.maxWindup); 
            this.coreRotation += 0.05 + (chargeRatio * 2.0);

            if (this.windupTimer <= 0 && this.currentTarget) this.fire();
        } else if (this.cooldown > 0) {
            this.cooldown--;
            if (this.laserTimer <= 0) this.idleAnimation();
        } else if (this.laserTimer <= 0) {
            this.idleAnimation();
            let target = this.findTarget();
            if (target) {
                this.currentTarget = target;
                this.windupTimer = this.maxWindup; 
            }
        }

        // =======================================================
        // üåü THE LEGENDARY 6-PHASE TRANSFORMATION SEQUENCE
        // =======================================================
        let t_iSpread = 0, t_iTravel = 0, t_iAngle = 0;
        let t_mSpread = 0, t_mTravel = 0, t_mAngle = 0;
        let t_oSpread = 0, t_oTravel = 0, t_oAngle = 0;
        let t_fAngle = 0,  t_fTravel = 0;
        let t_aTravel = 0, t_aSpread = 0;

        let cr = this.windupTimer > 0 ? 1 - (this.windupTimer / this.maxWindup) : 0;

        if (this.windupTimer > 0) {
            // Slice the charge into 5 distinct phases
            let p1 = Math.min(1, Math.max(0, cr / 0.2));           // 0.0 - 0.2: Unlocking
            let p2 = Math.min(1, Math.max(0, (cr - 0.2) / 0.2));   // 0.2 - 0.4: Spooling & Fins
            let p3 = Math.min(1, Math.max(0, (cr - 0.4) / 0.2));   // 0.4 - 0.6: Clamping
            let p4 = Math.min(1, Math.max(0, (cr - 0.6) / 0.2));   // 0.6 - 0.8: Thrust & Eject
            let p5 = Math.min(1, Math.max(0, (cr - 0.8) / 0.2));   // 0.8 - 1.0: CRITICAL SPLIT

            // 1. Blast Shields
            t_oTravel = -25 * p1;                    
            t_oSpread = 12 * p1 + 8 * p3;            
            t_oAngle  = 0.3 * p1 + 0.15 * p3;        

            // 2. Rear Fins (Deploy to brace for impact)
            t_fAngle = 0.6 * p2;                     
            t_fTravel = -5 * p2;

            // 3. Induction Clamps
            t_mTravel = 25 * p2 - 10 * p4;           
            t_mSpread = 18 * p2;                     
            t_mAngle  = -0.18 * p3;                  

            // 4. Accelerator Rails (Violently eject forward)
            t_aTravel = 60 * p4 + 10 * p5;           
            t_aSpread = 4 * p4;

            // 5. Inner Needle (Pulls back, thrusts, then SPLITS open)
            t_iTravel = -35 * p2 + 85 * p4;          
            t_iSpread = 16 * p5;                     // The Legendary Singularity split
            t_iAngle  = 0.1 * p5;

        } else if (this.laserTimer > 0) {
            // PHASE 6: FIRING BLOWBACK
            t_oTravel = -45; t_oSpread = 35; t_oAngle = 0.7;  // Shields completely shattered open
            t_mTravel = -15; t_mSpread = 15; t_mAngle = 0.15; // Clamps blown backward
            t_iTravel = -55; t_iSpread = 25; t_iAngle = 0.2;  // Prongs forced incredibly wide
            t_fAngle  = 0.8; t_fTravel = -10;                 // Fins buckle under pressure
            t_aTravel = -20; t_aSpread = 10;                  // Rails snap all the way back into chassis
        }

        let lerp = (start, end, amt) => (1 - amt) * start + amt * end;
        let animSpeed = this.laserTimer > 0 ? 0.6 : (cr > 0.6 && cr < 0.8) ? 0.3 : (cr > 0.8) ? 0.4 : 0.12; 

        let a = this.animState;
        a.innerSpread = lerp(a.innerSpread, t_iSpread, animSpeed);
        a.innerTravel = lerp(a.innerTravel, t_iTravel, animSpeed);
        a.innerAngle  = lerp(a.innerAngle,  t_iAngle,  animSpeed);

        a.mainSpread  = lerp(a.mainSpread,  t_mSpread, animSpeed);
        a.mainTravel  = lerp(a.mainTravel,  t_mTravel, animSpeed);
        a.mainAngle   = lerp(a.mainAngle,   t_mAngle,  animSpeed);

        a.outerSpread = lerp(a.outerSpread, t_oSpread, animSpeed);
        a.outerTravel = lerp(a.outerTravel, t_oTravel, animSpeed);
        a.outerAngle  = lerp(a.outerAngle,  t_oAngle,  animSpeed);

        a.finAngle    = lerp(a.finAngle,    t_fAngle,  animSpeed);
        a.finTravel   = lerp(a.finTravel,   t_fTravel, animSpeed);

        a.accelTravel = lerp(a.accelTravel, t_aTravel, animSpeed);
        a.accelSpread = lerp(a.accelSpread, t_aSpread, animSpeed);
    }

    fire() {
        this.cooldown = this.maxCooldown;
        this.laserTimer = 60; 
        this.currentTarget = null; 

        this.activeBeam = {
            length: 0,
            speed: 50,      
            maxLength: 4000, 
            width: 220 * (hasSkill('railgun_width') ? 1.2 : 1),      
            hitEnemies: new Set()
        };
    }

    idleAnimation() {
        this.coreRotation += 0.01;
        this.pulse += 0.01;
        let angleDiff = this.normalizeAngle(this.angle - this.headAngle);
        this.headAngle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), 0.002);
    }

    findTarget() {
        let bestTarget = null, bestDistSq = Infinity;
        for (let i = 0; i < enemies.length; i++) {
            let e = enemies[i];
            let dx = e.x - this.x, dy = e.y - this.y;
            let angleToEnemy = Math.atan2(dy, dx);
            let angleDiff = Math.abs(this.normalizeAngle(angleToEnemy - this.angle));

            if (angleDiff <= this.fov / 2) {
                let distSq = dx * dx + dy * dy;
                if (distSq < bestDistSq) {
                    bestDistSq = distSq;
                    bestTarget = e;
                }
            }
        }
        return bestTarget;
    }

    normalizeAngle(a) {
        while (a > Math.PI) a -= Math.PI * 2;
        while (a < -Math.PI) a += Math.PI * 2;
        return a;
    }

    draw() {
        // Render beam first (underneath gun body)
        if (this.activeBeam) {
            let a = this.animState;
            let tipDistance = (this.bw * 1.4) + Math.max(a.innerTravel, a.accelTravel) - this.recoil;
            let ox = this.x + Math.cos(this.headAngle) * tipDistance;
            let oy = this.y + Math.sin(this.headAngle) * tipDistance;
            this.renderContinuousBeam(ox, oy, this.headAngle);
        }
        drawRailgunVisuals(this.x, this.y, this.angle, this.headAngle, this.paths, this.animState,
            this.bw, this.bh, this.windupTimer, this.maxWindup, this.laserTimer,
            this.cooldown, this.maxCooldown, this.recoil, this.coreRotation, this.tick,
            null, this.currentTarget);
    }
    renderContinuousBeam(ox, oy, angle) {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.lineCap = "round";
        
        let dirX = Math.cos(angle);
        let dirY = Math.sin(angle);
        
        let headX = ox + dirX * this.activeBeam.length;
        let headY = oy + dirY * this.activeBeam.length;

        let alpha = this.laserTimer / 60; 
        let width = this.activeBeam.width;

        // Massive deep blue aura
        ctx.strokeStyle = `rgba(0, 100, 255, ${alpha * 0.4})`;
        ctx.lineWidth = width + (Math.random() * 80); 
        ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(headX, headY); ctx.stroke();

        // Cyan core
        ctx.strokeStyle = `rgba(0, 255, 255, ${alpha * 0.9})`;
        ctx.lineWidth = width * 0.7;
        ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(headX, headY); ctx.stroke();

        // White hot center
        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.lineWidth = width * 0.3;
        ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(headX, headY); ctx.stroke();

        // Legendary Pink/Purple Lightning wrapping the beam
        ctx.strokeStyle = `rgba(255, 50, 255, ${alpha})`;
        ctx.lineWidth = 8;
        this.drawJaggedLine(ox, oy, headX, headY, width * 1.2); 
        
        ctx.lineWidth = 4;
        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
        this.drawJaggedLine(ox, oy, headX, headY, width * 0.5); 

        // Impact Explosion
        if (this.activeBeam.length > 50) {
            ctx.beginPath();
            ctx.ellipse(headX, headY, width * 1.2, width * 2.5, angle, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`; ctx.fill();
            
            ctx.beginPath();
            ctx.ellipse(headX + (dirX * 40), headY + (dirY * 40), width * 0.6, width * 3.5, angle, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(0, 255, 255, ${alpha * 0.7})`; ctx.fill();
        }

        ctx.restore();
    }

    drawJaggedLine(x1, y1, x2, y2, jitter) {
        let dx = x2 - x1, dy = y2 - y1;
        let dist = Math.sqrt(dx * dx + dy * dy); 
        if (dist < 10) return;

        let steps = Math.max(dist / 40, 4) | 0; 

        ctx.beginPath();
        ctx.moveTo(x1, y1);
        for (let i = 1; i < steps; i++) {
            let t = i / steps;
            let currentJitter = jitter * (Math.sin(t * Math.PI)); // Max jitter in middle of beam
            let ox = (Math.random() - 0.5) * currentJitter;
            let oy = (Math.random() - 0.5) * currentJitter;
            ctx.lineTo(x1 + dx * t + ox, y1 + dy * t + oy);
        }
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }
}



// ‚îÄ‚îÄ FlamethrowerTower ‚Äì particle-based flame system ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Tower hardware is drawn by drawFlamethrowerHardware(); the flame itself is
// a dedicated per-instance particle pool so it integrates with world-space
// physics (gravity, buoyancy, turbulence) rather than a static canvas shape.

function drawFlamethrowerHardware(wx, wy, angle, heatLevel, isFiring) {
    ctx.save();
    ctx.translate(wx, wy);

    // 0. Ground shadow
    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.beginPath(); ctx.arc(2, 3, 24, 0, Math.PI*2); ctx.fill();

    ctx.save();
    ctx.rotate(angle);

    // helper: octagon path
    function oct(r, s) {
        ctx.beginPath();
        ctx.moveTo(-r,-s); ctx.lineTo(-s,-r); ctx.lineTo(s,-r); ctx.lineTo(r,-s);
        ctx.lineTo(r,s);   ctx.lineTo(s,r);   ctx.lineTo(-s,r);  ctx.lineTo(-r,s);
        ctx.closePath();
    }

    // ‚îÄ‚îÄ 1. OCTAGONAL BASE ‚Äì exact same dark-steel palette as Tesla / Railgun ‚îÄ
    ctx.lineWidth = 3;
    ctx.fillStyle = "#1f1f1f"; ctx.strokeStyle = "#0a0a0a";
    oct(22, 9); ctx.fill(); ctx.stroke();

    ctx.lineWidth = 2;
    ctx.fillStyle = "#282828"; ctx.strokeStyle = "#111";
    oct(17, 7); ctx.fill(); ctx.stroke();

    // Vent slots ‚Äì cyan when idle (Tesla-matching), orange when hot
    let ventCol  = isFiring ? "#ff5500" : (heatLevel > 0.45 ? "#cc3300" : "#00aaaa");
    let ventGlow = isFiring ? "#ff3300" : "#00ffff";
    ctx.fillStyle = ventCol;
    ctx.shadowBlur = heatLevel > 0.15 ? 7 : 0;
    ctx.shadowColor = ventGlow;
    ctx.beginPath();
    ctx.rect(-3, 13, 6, 3); ctx.rect(-3,-16, 6, 3);
    ctx.rect(13,-3, 3, 6);  ctx.rect(-16,-3, 3, 6);
    ctx.fill(); ctx.shadowBlur = 0;

    // Support struts ‚Äì same geometry as Tesla
    ctx.fillStyle = "#383838"; ctx.strokeStyle = "#0f0f0f"; ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(-2,10); ctx.lineTo(2,10); ctx.lineTo(1.5,18); ctx.lineTo(-1.5,18);
    ctx.moveTo(-2,-10); ctx.lineTo(2,-10); ctx.lineTo(1.5,-18); ctx.lineTo(-1.5,-18);
    ctx.moveTo(10,-2); ctx.lineTo(10,2); ctx.lineTo(18,1.5); ctx.lineTo(18,-1.5);
    ctx.moveTo(-10,-2); ctx.lineTo(-10,2); ctx.lineTo(-18,1.5); ctx.lineTo(-18,-1.5);
    ctx.fill(); ctx.stroke();

    // ‚îÄ‚îÄ 2. ROTATION COLLAR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    ctx.strokeStyle = "#0d0d0d"; ctx.lineWidth = 6;
    ctx.beginPath(); ctx.arc(0,0,12,0,Math.PI*2); ctx.stroke();

    let cGrad = ctx.createLinearGradient(-12,-12,12,12);
    cGrad.addColorStop(0,"#38393e"); cGrad.addColorStop(0.5,"#4e5158"); cGrad.addColorStop(1,"#1e1f22");
    ctx.fillStyle = cGrad;
    ctx.beginPath(); ctx.arc(0,0,12,0,Math.PI*2); ctx.fill();

    let ringCol = isFiring
        ? `rgba(255,${Math.floor(60+heatLevel*80)},0,${0.45+heatLevel*0.55})`
        : "rgba(0,200,200,0.45)";
    if (isFiring) { ctx.shadowBlur = 9; ctx.shadowColor = "#ff4400"; }
    ctx.strokeStyle = ringCol; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.arc(0,0,12,0,Math.PI*2); ctx.stroke();
    ctx.shadowBlur = 0;

    ctx.fillStyle = "#141416";
    ctx.beginPath(); ctx.arc(0,0,4,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle = "#2a2a2e"; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.arc(0,0,4,0,Math.PI*2); ctx.stroke();
    ctx.fillStyle = "#50545e";
    for (let i=0;i<4;i++) {
        let ba = i*Math.PI/2+Math.PI/4;
        ctx.beginPath(); ctx.arc(Math.cos(ba)*8.5,Math.sin(ba)*8.5,1.5,0,Math.PI*2); ctx.fill();
    }

    // ‚îÄ‚îÄ 3. BARREL SADDLE (arc-shaped root that wraps around the collar) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Draw BEHIND the collar ‚Äì a D-shaped lug that physically hugs the ring
    ctx.save();
    // Clip to right half so the saddle only shows forward of center
    ctx.beginPath(); ctx.rect(0, -14, 20, 28); ctx.clip();

    // Outer D-shape: wide at the collar, tapering into the housing
    let sGrad = ctx.createLinearGradient(0,-11,0,11);
    sGrad.addColorStop(0,"#30333b"); sGrad.addColorStop(0.45,"#494e59"); sGrad.addColorStop(1,"#181a1e");
    ctx.fillStyle = sGrad; ctx.strokeStyle = "#0b0b0d"; ctx.lineWidth = 2;
    ctx.beginPath();
    // Arc around collar right side, then straight forward to housing width
    ctx.arc(0, 0, 13, -Math.PI*0.55, Math.PI*0.55);  // hug the collar
    ctx.lineTo(19, 7);
    ctx.lineTo(19, -7);
    ctx.closePath();
    ctx.fill(); ctx.stroke();

    // Inner groove / shadow line to suggest depth
    ctx.strokeStyle = "rgba(0,0,0,0.45)"; ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, 13.5, -Math.PI*0.4, Math.PI*0.4);
    ctx.stroke();

    // Specular highlight on top face of saddle
    ctx.strokeStyle = "rgba(255,255,255,0.07)"; ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(0, 0, 12.5, -Math.PI*0.48, -Math.PI*0.1);
    ctx.lineTo(19, -6);
    ctx.stroke();

    // Two clamping bolts on the saddle face
    ctx.fillStyle = "#4a4e58"; ctx.strokeStyle = "#111"; ctx.lineWidth = 1;
    [[13, -5],[13, 5]].forEach(([bx,by]) => {
        ctx.beginPath(); ctx.arc(bx, by, 2, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        // Bolt cross
        ctx.strokeStyle = "#222"; ctx.lineWidth = 0.8;
        ctx.beginPath(); ctx.moveTo(bx-1,by); ctx.lineTo(bx+1,by); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(bx,by-1); ctx.lineTo(bx,by+1); ctx.stroke();
        ctx.strokeStyle = "#111"; ctx.lineWidth = 1;
    });
    ctx.restore();

    // ‚îÄ‚îÄ 4. BARREL HOUSING (slots flush into saddle) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let hGrad = ctx.createLinearGradient(0,-7,0,7);
    hGrad.addColorStop(0,"#3c3f47"); hGrad.addColorStop(0.5,"#52565f"); hGrad.addColorStop(1,"#1e2023");
    ctx.fillStyle = hGrad; ctx.strokeStyle = "#0d0d0f"; ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(13,-7); ctx.lineTo(18,-7); ctx.lineTo(19,-5);
    ctx.lineTo(19,5);  ctx.lineTo(18,7);  ctx.lineTo(13,7);
    ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.strokeStyle = "rgba(255,255,255,0.05)"; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(14,-6); ctx.lineTo(18,-6); ctx.lineTo(18,6); ctx.lineTo(14,6); ctx.stroke();

    // ‚îÄ‚îÄ 5. MAIN BARREL TUBE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    let bGrad = ctx.createLinearGradient(0,-5,0,5);
    bGrad.addColorStop(0,"#484d57"); bGrad.addColorStop(0.3,"#686e7a"); bGrad.addColorStop(1,"#21242b");
    ctx.fillStyle = bGrad; ctx.strokeStyle = "#0c0c0e"; ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(19,-5); ctx.lineTo(28,-4); ctx.lineTo(29,-2.5);
    ctx.lineTo(29,2.5); ctx.lineTo(28,4); ctx.lineTo(19,5);
    ctx.closePath(); ctx.fill(); ctx.stroke();

    ctx.strokeStyle = "#161618"; ctx.lineWidth = 2;
    [22,26].forEach(x=>{ ctx.beginPath(); ctx.moveTo(x,-5); ctx.lineTo(x,5); ctx.stroke(); });
    ctx.strokeStyle = "rgba(255,255,255,0.06)"; ctx.lineWidth = 1;
    [22,26].forEach(x=>{ ctx.beginPath(); ctx.moveTo(x+0.5,-4); ctx.lineTo(x+0.5,4); ctx.stroke(); });

    // ‚îÄ‚îÄ 6. HEAT SHROUD FINS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    ctx.fillStyle = "#2c2f36"; ctx.strokeStyle = "#0f0f11"; ctx.lineWidth = 1;
    [19,22,25].forEach(x=>{
        ctx.beginPath(); ctx.moveTo(x,-5); ctx.lineTo(x+2,-5); ctx.lineTo(x+2,-8); ctx.lineTo(x,-7); ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(x,5);  ctx.lineTo(x+2,5);  ctx.lineTo(x+2,8);  ctx.lineTo(x,7);  ctx.closePath(); ctx.fill(); ctx.stroke();
    });
    if (heatLevel > 0.25) {
        let fa = (heatLevel - 0.25) * 0.45;
        ctx.fillStyle = `rgba(255,90,0,${fa})`;
        [19,22,25].forEach(x=>{ ctx.beginPath(); ctx.rect(x,-8,2,3); ctx.fill(); ctx.beginPath(); ctx.rect(x,5,2,3); ctx.fill(); });
    }

    // ‚îÄ‚îÄ 7. NOZZLE TIP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    ctx.fillStyle = "#18191c"; ctx.strokeStyle = "#090909"; ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(28,-4); ctx.lineTo(33,-2.5); ctx.lineTo(34,0);
    ctx.lineTo(33,2.5); ctx.lineTo(28,4);
    ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.strokeStyle = "rgba(255,255,255,0.06)"; ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(29,-3); ctx.lineTo(33,-1.5); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(29,3);  ctx.lineTo(33,1.5);  ctx.stroke();

    let nozA = 0.15 + heatLevel * 0.85;
    if (isFiring) { ctx.shadowBlur = 16; ctx.shadowColor = "#ff4400"; }
    let nGrad = ctx.createRadialGradient(34,0,0,34,0,6+heatLevel*5);
    nGrad.addColorStop(0,   `rgba(255,220,80,${nozA})`);
    nGrad.addColorStop(0.35,`rgba(255,100,0,${nozA*0.75})`);
    nGrad.addColorStop(1,   "rgba(180,30,0,0)");
    ctx.fillStyle = nGrad;
    ctx.beginPath(); ctx.arc(34,0,6+heatLevel*5,0,Math.PI*2); ctx.fill();
    ctx.shadowBlur = 0;

    ctx.restore(); // angle
    ctx.restore(); // world
}
class FlamethrowerTower {
    constructor(col, row) {
        this.col = col;
        this.row = row;
        this.x   = col * CELL_SIZE + CELL_SIZE / 2;
        this.y   = row * CELL_SIZE + CELL_SIZE / 2;

        // Combat
        this.range       = 190;
        this.damage      = 0.75; // Adjusted for per-frame application (was 3 damage every 4 frames)
        this.active      = true;
        this.hp          = 400;
        this.maxHp       = 400;

        // Aim
        this.angle       = 0;
        this.targetAngle = 0;

        // State
        this.isFiring  = false;
        this.heatLevel = 0;  // 0..1
        this.alwaysFire = true; // fires continuously, heat rises when enemies present

        // ‚îÄ‚îÄ Flame particle pool ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        this.flameParticles = [];
    }

    // Nozzle world-space position
    _nozzle() {
        let nx = this.x + Math.cos(this.angle) * 34;
        let ny = this.y + Math.sin(this.angle) * 34;
        return { x: nx, y: ny };
    }

    _spawnFlameParticles() {
        const SPREAD     = 0.32;   // half-angle of cone in radians
        const SPEED_MIN  = 4.5;
        const SPEED_MAX  = 9.5;
        const COUNT      = 4;      // new particles per frame while firing
        const MAX_PARTICLES = 200; // hard cap on pool size
        if (this.flameParticles.length >= MAX_PARTICLES) return;
        const noz        = this._nozzle();

        for (let i = 0; i < COUNT; i++) {
            let spreadBias = (Math.random() * Math.random()); 
            let dir        = this.angle + (Math.random() < 0.5 ? 1 : -1) * spreadBias * SPREAD;
            let speed      = SPEED_MIN + Math.random() * (SPEED_MAX - SPEED_MIN);

            let offPerp    = (Math.random() - 0.5) * 4;
            let px         = noz.x + Math.cos(this.angle + Math.PI/2) * offPerp;
            let py         = noz.y + Math.sin(this.angle + Math.PI/2) * offPerp;

            let maxLife    = (this.range / speed) * (0.75 + Math.random() * 0.5);

            this.flameParticles.push({
                x: px, y: py,
                vx: Math.cos(dir) * speed,
                vy: Math.sin(dir) * speed,
                life: maxLife,
                maxLife: maxLife,
                size: 3 + Math.random() * 3,
                type: 0 
            });
        }
    }

    _spawnPilotWisp() {
        const noz = this._nozzle();
        const dir = this.angle + (Math.random() - 0.5) * 0.15;
        const spd = 1.5 + Math.random() * 1.5;
        this.flameParticles.push({
            x: noz.x, y: noz.y,
            vx: Math.cos(dir) * spd,
            vy: Math.sin(dir) * spd,
            life: 10 + Math.random() * 8,
            maxLife: 18,
            size: 1.5 + Math.random() * 1.5,
            type: 0
        });
    }

    _updateParticles() {
        const GRAVITY    =  0.05; 
        const BUOYANCY   = -0.18; 
        const DRAG       =  0.97; 
        const GROWTH     =  0.55; 
        const SMOKE_PROB =  0.18; 

        for (let i = this.flameParticles.length - 1; i >= 0; i--) {
            let p = this.flameParticles[i];

            let agePct    = 1 - p.life / p.maxLife;   
            let buoy      = BUOYANCY * (0.3 + agePct * 0.7);
            let turbX     = (Math.random() - 0.5) * 0.35;
            let turbY     = (Math.random() - 0.5) * 0.35;

            p.vx = (p.vx + turbX) * DRAG;
            p.vy = (p.vy + buoy + GRAVITY + turbY) * DRAG;
            p.x += p.vx;
            p.y += p.vy;

            if (p.type === 0) {
                p.size += GROWTH * (1 + agePct);
            } else {
                p.size += 0.9;
            }

            p.life -= 1;

            if (p.type === 0 && p.life < p.maxLife * 0.28 && Math.random() < SMOKE_PROB
                && this.flameParticles.length < 140) {
                this.flameParticles.push({
                    x: p.x, y: p.y,
                    vx: p.vx * 0.5 + (Math.random()-0.5)*0.6,
                    vy: p.vy * 0.5 - Math.random()*0.8,
                    life: 12 + Math.random()*10,
                    maxLife: 22,
                    size: p.size * 0.7,
                    type: 1
                });
            }

            if (p.life <= 0) {
                this.flameParticles.splice(i, 1);
            }
        }
    }

    _drawParticles() {
        if (this.flameParticles.length === 0) return;
        ctx.save();

        ctx.globalCompositeOperation = 'lighter';
        for (let p of this.flameParticles) {
            if (p.type !== 0) continue;

            let agePct = 1 - p.life / p.maxLife;
            let alpha  = (1 - agePct) * (1 - agePct) * this.heatLevel;
            if (alpha < 0.008) continue;

            let r, g, b;
            if (agePct < 0.15) {
                r = 255; g = 240; b = 180;
            } else if (agePct < 0.40) {
                let t = (agePct - 0.15) / 0.25;
                r = 255; g = Math.floor(240 - t*160) | 0; b = Math.floor(180 * (1-t)) | 0;
            } else if (agePct < 0.70) {
                let t = (agePct - 0.40) / 0.30;
                r = 255; g = Math.floor(80 - t*70) | 0; b = 0;
            } else {
                let t = (agePct - 0.70) / 0.30;
                r = Math.floor(255 - t*130) | 0; g = 0; b = 0;
            }

            ctx.globalAlpha = alpha * 0.38;
            ctx.fillStyle = `rgb(${r},${g},${b})`;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.size * 1.5, 0, Math.PI*2); ctx.fill();

            ctx.globalAlpha = alpha * 0.82;
            ctx.beginPath(); ctx.arc(p.x, p.y, p.size * 0.6, 0, Math.PI*2); ctx.fill();
        }

        ctx.globalCompositeOperation = 'source-over';
        for (let p of this.flameParticles) {
            if (p.type !== 1) continue;
            let agePct = 1 - p.life / p.maxLife;
            let alpha  = (1 - agePct) * 0.10 * this.heatLevel;
            if (alpha < 0.005) continue;
            ctx.globalAlpha = alpha;
            ctx.fillStyle = '#1a1a1a';
            ctx.beginPath(); ctx.arc(p.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
        }

        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = 'source-over';
        ctx.restore();
    }

    update(dt) {
        if (!grid[this.col][this.row].occupied) { this.active = false; return; }
        if (this.hp <= 0) { this.active = false; return; }

        let nearest = null;
        let nearestDist = this.range; 
        
        for (let e of enemies) {
            let d = Math.hypot(e.x - this.x, e.y - this.y);
            if (d <= nearestDist) { 
                nearestDist = d; 
                nearest = e; 
            }
        }

        this.isFiring = (nearest !== null);

        if (nearest) {
            this.targetAngle = Math.atan2(nearest.y - this.y, nearest.x - this.x);
            let diff = this.targetAngle - this.angle;
            while (diff >  Math.PI) diff -= Math.PI*2;
            while (diff < -Math.PI) diff += Math.PI*2;
            
            this.angle += diff * 0.14; 
        }

        if (this.isFiring) {
            this.heatLevel = Math.min(1, this.heatLevel + 0.09);
        } else {
            this.heatLevel = Math.max(0, this.heatLevel - 0.022);
        }

        if (this.isFiring) {
            this._spawnFlameParticles();
        }

        this._updateParticles();

        // Damage cone: Now applies per-frame damage continuously 
        if (this.isFiring) {
            let spreadAngle = 0.38;
            for (let e of enemies) {
                let dx = e.x - this.x, dy = e.y - this.y;
                if (Math.hypot(dx, dy) > this.range) continue;
                let eA = Math.atan2(dy, dx);
                let aD = Math.abs(eA - this.angle);
                while (aD > Math.PI) aD = Math.abs(aD - Math.PI*2);
                if (aD <= spreadAngle) {
                    e.hp -= this.damage; // Applying continuous damage
                    
                    // Apply/refresh burn 
                    e.burnTimer = 180;   
                    e.burnDmg   = 3; // Kept burn tick the same since it's a DoT
                }
            }
        }
    }

    draw() {
        this._drawParticles();
        drawFlamethrowerHardware(this.x, this.y, this.angle, this.heatLevel, this.isFiring);
        
        if (this.hp < this.maxHp && this.hp > 0) {
            let pct = this.hp / this.maxHp;
            ctx.fillStyle = "#111";
            ctx.fillRect(this.x - 15, this.y - 28, 30, 4);
            ctx.fillStyle = pct > 0.6 ? "#00e676" : pct > 0.3 ? "#ffea00" : "#ff1744";
            ctx.fillRect(this.x - 14, this.y - 27, 28 * pct, 2);
        }
    }
}


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TESLA TRIPWIRE PYLONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function drawTripwirePylonVisuals(x, y, isLive) {
    ctx.save();
    ctx.translate(x, y);

    // Shadow
    ctx.fillStyle = "rgba(0,0,0,0.45)";
    ctx.beginPath(); ctx.ellipse(0, 6, 10, 4, 0, 0, Math.PI*2); ctx.fill();

    // Base foot ‚Äì small hexagonal pad
    ctx.fillStyle = "#1e2025"; ctx.strokeStyle = "#0a0a0c"; ctx.lineWidth = 1.5;
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        let a = (i/6)*Math.PI*2 - Math.PI/6;
        i === 0 ? ctx.moveTo(Math.cos(a)*10, Math.sin(a)*10)
                : ctx.lineTo(Math.cos(a)*10, Math.sin(a)*10);
    }
    ctx.closePath(); ctx.fill(); ctx.stroke();

    // Hex inner detail
    ctx.fillStyle = "#2a2d35";
    ctx.beginPath();
    for (let i = 0; i < 6; i++) {
        let a = (i/6)*Math.PI*2 - Math.PI/6;
        i === 0 ? ctx.moveTo(Math.cos(a)*7, Math.sin(a)*7)
                : ctx.lineTo(Math.cos(a)*7, Math.sin(a)*7);
    }
    ctx.closePath(); ctx.fill();

    // Vertical shaft
    let shaftGrad = ctx.createLinearGradient(-3, -22, 3, -22);
    shaftGrad.addColorStop(0, "#383c44"); shaftGrad.addColorStop(0.5, "#5a5f6a"); shaftGrad.addColorStop(1, "#1e2025");
    ctx.fillStyle = shaftGrad; ctx.strokeStyle = "#111"; ctx.lineWidth = 1.5;
    ctx.beginPath(); ctx.roundRect(-3, -22, 6, 22, 1); ctx.fill(); ctx.stroke();

    // Two tech rings on shaft
    ctx.strokeStyle = isLive ? "rgba(0,200,255,0.7)" : "#333"; ctx.lineWidth = 2;
    [-16, -8].forEach(ry => {
        ctx.beginPath(); ctx.moveTo(-3.5, ry); ctx.lineTo(3.5, ry); ctx.stroke();
    });

    // Emitter head ‚Äì the antenna tip
    let headCol = isLive ? "#00ccff" : "#2a4455";
    ctx.fillStyle = headCol; ctx.strokeStyle = "#0a0a0c"; ctx.lineWidth = 1.5;
    if (isLive) { ctx.shadowBlur = 10; ctx.shadowColor = "#00aaff"; }
    ctx.beginPath();
    ctx.moveTo(-5, -22); ctx.lineTo(5, -22);
    ctx.lineTo(3, -30); ctx.lineTo(-3, -30);
    ctx.closePath(); ctx.fill(); ctx.stroke();
    ctx.shadowBlur = 0;

    // Tip glow crystal
    let tipGrad = ctx.createRadialGradient(0, -31, 0, 0, -31, 5);
    tipGrad.addColorStop(0, isLive ? "rgba(0,255,255,0.9)" : "rgba(0,100,150,0.4)");
    tipGrad.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = tipGrad;
    ctx.beginPath(); ctx.arc(0, -31, 5, 0, Math.PI*2); ctx.fill();

    // Lateral conductors (two small arms)
    ctx.fillStyle = "#2a3038"; ctx.strokeStyle = "#111"; ctx.lineWidth = 1;
    [[-1,-1],[1,1]].forEach(([sx]) => {
        ctx.save(); ctx.scale(sx, 1);
        ctx.beginPath();
        ctx.moveTo(3, -25); ctx.lineTo(8, -23); ctx.lineTo(8, -21); ctx.lineTo(3, -19);
        ctx.closePath(); ctx.fill(); ctx.stroke();
        ctx.restore();
    });

    ctx.restore();
}

class TripwirePylon {
    static CONNECT_RADIUS = 210; // px ‚Äì 1 tile (50px) wider than before
    static WIRE_DAMAGE    = 10;
    static STUN_FRAMES    = 12;  // 0.2 sec at 60fps
    static COOLDOWN_MAX   = 500; // ~3 sec between zaps ‚Äì slow but punishing

    constructor(col, row) {
        this.col  = col;
        this.row  = row;
        this.x    = col * CELL_SIZE + CELL_SIZE / 2;
        this.y    = row * CELL_SIZE + CELL_SIZE / 2;
        this.hp   = 120;
        this.maxHp = 120;
        this.active = true;

        this._id  = TripwirePylon._nextId = (TripwirePylon._nextId || 0) + 1;

        // Plain objects instead of Maps ‚Äì faster property lookup
        this._cd       = {};
        this._zapFlash = {};

        // Spark pool ‚Äì fixed-size, tracked by count to avoid splice
        this._sparks     = [];
        this._sparkCount = 0;

        // Partner cache ‚Äì rebuilt only when structure count changes
        this._partnerCache     = null;
        this._lastStructureLen = -1;
    }

    cleanup() {
        let c = grid[this.col][this.row];
        c.occupied = false;
    }

    _partners() {
        if (this._partnerCache !== null && structures.length === this._lastStructureLen) {
            return this._partnerCache;
        }
        this._lastStructureLen = structures.length;
        const R2 = TripwirePylon.CONNECT_RADIUS * TripwirePylon.CONNECT_RADIUS;
        const out = [];
        for (let i = 0; i < structures.length; i++) {
            const s = structures[i];
            if (s === this || !(s instanceof TripwirePylon)) continue;
            const dx = s.x - this.x, dy = s.y - this.y;
            if (dx*dx + dy*dy <= R2) out.push(s);
        }
        this._partnerCache = out;
        return out;
    }

    update() {
        if (this.hp <= 0) { this.active = false; return; }

        const partners = this._partners();
        const pLen = partners.length;
        if (pLen === 0) return;

        const px = this.x, py = this.y;
        const myId = this._id;

        for (let pi = 0; pi < pLen; pi++) {
            const other = partners[pi];
            const key   = other._id;

            // Lower-id pylon owns each pair ‚Äì skip immediately if we're higher
            if (myId > key) continue;

            // Cooldown tick
            const cd = this._cd[key] || 0;
            if (cd > 0) { this._cd[key] = cd - 1; continue; }

            // Inline segment AB = (px,py)‚Üí(ox,oy)
            const ox = other.x, oy = other.y;
            const dx = ox - px, dy = oy - py;
            const lenSq = dx*dx + dy*dy;

            for (let ei = 0; ei < enemies.length; ei++) {
                const e = enemies[ei];
                if (e.hp <= 0) continue;

                // Inline point-to-segment distance squared
                let t = 0;
                if (lenSq > 0) {
                    t = ((e.x - px)*dx + (e.y - py)*dy) / lenSq;
                    if (t < 0) t = 0; else if (t > 1) t = 1;
                }
                const cx = px + t*dx - e.x;
                const cy = py + t*dy - e.y;
                const thresh = e.radius + 12;
                if (cx*cx + cy*cy < thresh*thresh) {
                    e.hp -= TripwirePylon.WIRE_DAMAGE;
                    e.stunTimer = TripwirePylon.STUN_FRAMES;
                    e.vx = 0; e.vy = 0;
                    createParticles(e.x, e.y, "#00eeff", 8);

                    const cdMax = TripwirePylon.COOLDOWN_MAX;
                    this._cd[key]   = cdMax;
                    other._cd[myId] = cdMax;
                    this._zapFlash[key]   = 8;
                    other._zapFlash[myId] = 8;

                    // Spark pool: reuse slots before pushing new objects
                    for (let k = 0; k < 5; k++) {
                        const t2 = Math.random();
                        let sp;
                        if (this._sparkCount < this._sparks.length) {
                            sp = this._sparks[this._sparkCount];
                        } else {
                            sp = {};
                            this._sparks.push(sp);
                        }
                        sp.x    = px + dx*t2;
                        sp.y    = py + dy*t2;
                        sp.vx   = (Math.random()-0.5)*3;
                        sp.vy   = (Math.random()-0.5)*3;
                        sp.life = (10 + Math.random()*8) | 0;
                        this._sparkCount++;
                    }
                    break; // one zap per wire per frame
                }
            }
        }

        // Decay zap flashes
        for (const k in this._zapFlash) {
            if (--this._zapFlash[k] <= 0) delete this._zapFlash[k];
        }

        // Update sparks ‚Äì swap-to-end removal avoids splice O(n)
        let sc = this._sparkCount;
        for (let i = sc - 1; i >= 0; i--) {
            const s = this._sparks[i];
            s.x += s.vx; s.y += s.vy;
            s.vx *= 0.85; s.vy *= 0.85;
            if (--s.life <= 0) {
                this._sparks[i] = this._sparks[--sc];
                this._sparks[sc] = s;
            }
        }
        this._sparkCount = sc;
    }

    _pointToSegDist(px, py, ax, ay, bx, by) {
        const dx = bx-ax, dy = by-ay;
        const lenSq = dx*dx + dy*dy;
        if (lenSq === 0) return Math.hypot(px-ax, py-ay);
        const t = Math.max(0, Math.min(1, ((px-ax)*dx + (py-ay)*dy) / lenSq));
        return Math.hypot(px - (ax+t*dx), py - (ay+t*dy));
    }

    draw() {
        const partners = this._partners();
        const isLive   = partners.length > 0;
        const myId     = this._id;

        for (let pi = 0; pi < partners.length; pi++) {
            const other = partners[pi];
            if (myId > other._id) continue;

            const key      = other._id;
            const flashing = (this._zapFlash[key] || 0) > 0;
            const hasCd    = (this._cd[key] || 0) > 0;

            ctx.save();
            ctx.lineCap = "round";

            if (flashing) {
                ctx.globalCompositeOperation = 'lighter';
                ctx.strokeStyle = "rgba(150,230,255,0.95)";
                ctx.lineWidth   = 3;
                ctx.shadowBlur  = 14;
                ctx.shadowColor = "#00eeff";
                ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(other.x, other.y); ctx.stroke();
                ctx.shadowBlur  = 0;
                ctx.strokeStyle = "rgba(255,255,255,0.9)";
                ctx.lineWidth   = 1;
                ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(other.x, other.y); ctx.stroke();
                ctx.globalCompositeOperation = 'source-over';
            } else if (hasCd) {
                ctx.strokeStyle = "rgba(0,150,200,0.25)";
                ctx.lineWidth   = 1;
                ctx.setLineDash([4,4]);
                ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(other.x, other.y); ctx.stroke();
                ctx.setLineDash([]);
            } else {
                ctx.strokeStyle = "rgba(0,200,255,0.55)";
                ctx.lineWidth   = 1.5;
                ctx.shadowBlur  = 5;
                ctx.shadowColor = "#00aaff";
                ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(other.x, other.y); ctx.stroke();
                ctx.shadowBlur  = 0;
                ctx.strokeStyle = "rgba(200,245,255,0.2)";
                ctx.lineWidth   = 0.8;
                ctx.setLineDash([6,8]);
                ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(other.x, other.y); ctx.stroke();
                ctx.setLineDash([]);
            }
            ctx.restore();
        }

        if (this._sparkCount > 0) {
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            for (let i = 0; i < this._sparkCount; i++) {
                const sp = this._sparks[i];
                const a  = sp.life / 18;
                ctx.fillStyle = `rgba(0,220,255,${(a*0.9).toFixed(2)})`;
                ctx.beginPath(); ctx.arc(sp.x, sp.y, 1.5, 0, Math.PI*2); ctx.fill();
            }
            ctx.globalCompositeOperation = 'source-over';
            ctx.restore();
        }

        drawTripwirePylonVisuals(this.x, this.y, isLive);

        if (this.hp < this.maxHp && this.hp > 0) {
            const pct = this.hp / this.maxHp;
            ctx.fillStyle = "#111";
            ctx.fillRect(this.x - 12, this.y - 38, 24, 3);
            ctx.fillStyle = pct > 0.5 ? "#00e5ff" : "#ff4444";
            ctx.fillRect(this.x - 12, this.y - 38, 24*pct, 2);
        }
    }
}
class SuckerTower {
    constructor(col, row) {
        this.col = col;
        this.row = row;
        this.x = col * CELL_SIZE + CELL_SIZE / 2;
        this.y = row * CELL_SIZE + CELL_SIZE / 2;

        // Precalculate Scale & Ranges for fast math
        this.scaleFactor = (CELL_SIZE * 0.95) / 80;
        this.range = 160 * (hasSkill('sucker_area') ? 1.15 : 1); 
        this.rangeSq = this.range * this.range; 
        this.minDist = 15; // Stop pulling if they get right to the center
        this.minDistSq = this.minDist * this.minDist;
        
        // Stats & Timing
        this.pullStrength = 2 * (hasSkill('sucker_strenght') ? 1.1 : 1); // How fast they are dragged in per frame
        this.cooldown = 0;
        this.maxCooldown = 300; // Wait time between sucks
        this.fireTimer = 0;
        this.maxFireDuration = 45; // How long the tornado lasts

        // Visuals
        this.rotation = 0; // Rotates the fan and tornado
        this.isFiring = false;
    }

    update(dt) {
        if (this.cooldown > 0) this.cooldown--;
        
        // Always spin the fan a little, but spin it fast when firing
        this.rotation += this.isFiring ? 0.3 : 0.05;

        // Handle firing (sucking) state
        if (this.fireTimer > 0) {
            this.fireTimer--;
            this.isFiring = true;
            this.executePull();
            
            if (this.fireTimer <= 0) {
                this.isFiring = false; // Turn off tornado
            }
        } 
        // Handle trigger state
        else if (this.cooldown <= 0) {
            // Check if there are any enemies in range to trigger the attack
            if (this.isEnemyInRange()) {
                this.fireTimer = this.maxFireDuration;
                this.cooldown = this.maxCooldown + this.maxFireDuration; 
                this.isFiring = true;
                this.executePull(); // Start pulling immediately
            }
        }
    }

    isEnemyInRange() {
        for (let i = 0; i < enemies.length; i++) {
            let e = enemies[i];
            let dx = e.x - this.x;
            let dy = e.y - this.y;
            if (dx * dx + dy * dy <= this.rangeSq) {
                return true;
            }
        }
        return false;
    }

    executePull() {
        // Pull ALL enemies currently within the radius
        for (let i = 0; i < enemies.length; i++) {
            let e = enemies[i];
            let dx = this.x - e.x; // Vector pointing TO the tower
            let dy = this.y - e.y;
            let distSq = dx * dx + dy * dy;

            if (distSq <= this.rangeSq && distSq > this.minDistSq) {
                // Optimization: Only do Math.sqrt if they are actually in range
                let dist = Math.sqrt(distSq);
                
                // Move enemy towards the tower (No damage applied)
                e.x += (dx / dist) * this.pullStrength;
                e.y += (dy / dist) * this.pullStrength;
            }
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Base visuals (scaled like the Tesla Tower)
        ctx.save();
        ctx.scale(this.scaleFactor, this.scaleFactor); 

        const isReady = this.cooldown <= this.maxCooldown; 

        // --- 0. GROUND SHADOW ---
        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        ctx.beginPath();
        ctx.arc(2, 2, 38, 0, Math.PI * 2); 
        ctx.fill();

        // --- 1. HEAVY INDUSTRIAL BASE (Slightly different colors for Wind/Vacuum theme) ---
        ctx.lineWidth = 3;
        
        ctx.fillStyle = "#1a242b"; // Dark blueish gray
        ctx.strokeStyle = "#0a0f12";
        this.drawOctagon(38, 15.2);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = "#2a3b47";
        this.drawOctagon(30, 12);
        ctx.fill();
        ctx.stroke();

        // --- 2. VACUUM INTAKE PIT ---
        ctx.fillStyle = "#05080a";
        ctx.beginPath();
        ctx.arc(0, 0, 22, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // --- 3. SPINNING TURBINE BLADES ---
        ctx.save();
        ctx.rotate(this.rotation);
        
        // Inner glowing core
        ctx.fillStyle = this.isFiring ? "#aaddff" : (isReady ? "#447799" : "#223344");
        ctx.shadowBlur = this.isFiring ? 15 : 0;
        ctx.shadowColor = "#aaddff";
        ctx.beginPath();
        ctx.arc(0, 0, 6, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.shadowBlur = 0;
        
        // Draw 5 turbine blades
        ctx.fillStyle = "#557788";
        ctx.strokeStyle = "#112233";
        ctx.lineWidth = 1;
        for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(20, -5);
            ctx.lineTo(20, 5);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.rotate((Math.PI * 2) / 5);
        }
        ctx.restore();
        ctx.restore(); // Restore scale to draw range effects accurately

        // --- 4. TORNADO EFFECT (Only draws when sucking) ---
        if (this.isFiring) {
            this.renderTornado();
        }

        ctx.restore(); 
    }

    // Reuse your octagon logic
    drawOctagon(size, s) {
        ctx.beginPath();
        ctx.moveTo(-size, -s); ctx.lineTo(-s, -size);
        ctx.lineTo(s, -size); ctx.lineTo(size, -s);
        ctx.lineTo(size, s); ctx.lineTo(s, size);
        ctx.lineTo(-s, size); ctx.lineTo(-size, s);
        ctx.closePath();
    }

    renderTornado() {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.lineCap = "round";

        // Draw multiple swirling wind arcs that expand outwards
        for (let i = 0; i < 4; i++) {
            // Calculate an expanding radius that loops back using modulo
            let age = (this.rotation * 15 + i * (this.range / 4));
            let radius = age % this.range;
            
            // Fade out as it reaches the edge of the range
            let alpha = 1 - (radius / this.range);
            
            ctx.strokeStyle = `rgba(180, 230, 255, ${alpha * 0.8})`;
            ctx.lineWidth = 3 + (radius * 0.05); // Gets thicker as it expands
            
            // Spin the angle
            let angle = this.rotation * 3 + (i * Math.PI / 2);
            
            ctx.beginPath();
            // Draw a half-circle arc that looks like a gust of wind
            ctx.arc(0, 0, Math.max(0.1, radius), angle, angle + Math.PI);
            ctx.stroke();
        }
        
        // Optional: draw a faint outer suction ring
        ctx.strokeStyle = "rgba(180, 230, 255, 0.1)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(0, 0, this.range, 0, Math.PI * 2);
        ctx.stroke();

        ctx.restore();
    }
}

class Minigun {
    constructor(col, row) {
        this.col = col;
        this.row = row;
        this.x = col * CELL_SIZE + CELL_SIZE / 2;
        this.y = row * CELL_SIZE + CELL_SIZE / 2;

        // --- STATS ---
        this.range = 280;
        this.damage = 3 + (hasSkill('minigun_dmg') ? 2 : 0);
        this.maxFireRate = 2 * (hasSkill('minigun_speed') ? 0.8 : 1);
        this.currentFireTimer = 0;
        this.maxHp = 500;
        this.hp = this.maxHp;
        this.active = true;

        // --- VISUALS ---
        this.angle = 0;
        this.spinSpeed = 0;
        this.heat = 0;
        this.recoil = 0;
        this.barrelScroll = 0;
        this.shells = [];
    }

    update(dt) {
        if (this.hp <= 0) this.active = false;
        // Assuming 'grid' and 'enemies' are global variables
        if (!grid[this.col][this.row].occupied) this.active = false;

        // 1. Target Finding
        let target = null;
        let minDist = this.range;
        for (let e of enemies) {
            let d = Math.hypot(e.x - this.x, e.y - this.y);
            if (d < minDist) {
                minDist = d;
                target = e;
            }
        }

        // 2. State Logic
        if (target) {
            let dx = target.x - this.x;
            let dy = target.y - this.y;
            let targetAngle = Math.atan2(dy, dx);

            // Aiming (Smooth)
            let angleDiff = targetAngle - this.angle;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            this.angle += angleDiff * 0.15;

            // Spool Up
            this.spinSpeed = Math.min(this.spinSpeed + 0.05, 1.0);

            // Fire Logic
            if (Math.abs(angleDiff) < 0.6 && this.spinSpeed > 0.8) {
                if (this.currentFireTimer <= 0) {
                    this.currentFireTimer = this.maxFireRate;
                    this.recoil = 4; // Slightly more visual recoil
                    this.heat = Math.min(this.heat + 0.04, 1.0);

                    // Muzzle Position logic
                    const barrelLen = 45 - this.recoil; // Longer visual barrel
                    const mx = this.x + Math.cos(this.angle) * barrelLen;
                    const my = this.y + Math.sin(this.angle) * barrelLen;

                    const spread = (Math.random() - 0.5) * 0.25;
                    const fireAngle = this.angle + spread;

                    // FIRE
                    projectiles.push(new MinigunBullet(mx, my, fireAngle, this.damage, 9));

                    // Flash
                    if (typeof createParticles === 'function') createParticles(mx, my, "#ffcc00", 2);

                    // Eject Shells
                    this.shells.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(this.angle - 1.8) * 3 + (Math.random() - 0.5), // Eject slightly back-right
                        vy: Math.sin(this.angle - 1.8) * 3 + (Math.random() - 0.5),
                        life: 20, angle: Math.random() * 6
                    });
                }
            }
        } else {
            // Spool Down
            this.spinSpeed *= 0.96;
            this.heat *= 0.97;
        }

        if (this.currentFireTimer > 0) this.currentFireTimer--;
        this.recoil *= 0.8;
        this.barrelScroll += this.spinSpeed * 3;

        // Update Shells
        for (let s of this.shells) { s.x += s.vx; s.y += s.vy; s.life--; s.vx *= 0.9; s.vy *= 0.9; }
        this.shells = this.shells.filter(s => s.life > 0);
    }

    draw() {
        // --- 0. SHELL CASINGS (On the floor) ---
        ctx.fillStyle = "#d4af37"; 
        for (let s of this.shells) {
            ctx.save();
            ctx.translate(s.x, s.y);
            ctx.rotate(s.angle);
            ctx.fillRect(-2, -1, 4, 2);
            ctx.restore();
        }

        ctx.save();
        ctx.translate(this.x, this.y);

        // --- 1. INDUSTRIAL BASE (New Shape) ---
        // Drop shadow for the base
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.beginPath(); ctx.arc(2, 2, 22, 0, Math.PI * 2); ctx.fill();

        // Main X-Stand
        ctx.fillStyle = "#1a1a1a"; // Dark Metal
        
        // Draw 4 distinct heavy legs
        for(let i=0; i<4; i++) {
            ctx.save(); 
            ctx.rotate((Math.PI/4) + (i * Math.PI/2)); // Rotate 45 deg for X shape
            
            // Leg Strut
            ctx.fillRect(-6, -6, 12, 24); 
            
            // Foot Pad (Chamfered look)
            ctx.fillStyle = "#333";
            ctx.beginPath();
            ctx.moveTo(-8, 18); ctx.lineTo(8, 18);
            ctx.lineTo(10, 24); ctx.lineTo(-10, 24);
            ctx.fill();
            
            // Bolt detail on leg
            ctx.fillStyle = "#555";
            ctx.beginPath(); ctx.arc(0, 12, 2, 0, Math.PI*2); ctx.fill();
            
            ctx.restore();
        }

        // Central Bearing Ring (The turret sits on this)
        ctx.fillStyle = "#222";
        ctx.beginPath(); ctx.arc(0,0, 16, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#444"; ctx.lineWidth = 2; ctx.stroke();
        
        // Rivets on the ring
        ctx.fillStyle = "#666";
        for(let i=0; i<8; i++){
            let ra = i * (Math.PI*2)/8;
            ctx.beginPath(); ctx.arc(Math.cos(ra)*12, Math.sin(ra)*12, 1.5, 0, Math.PI*2); ctx.fill();
        }

        // --- 2. AMMO SYSTEM (Calculated before rotation) ---
        const ammoX = -28;
        const ammoY = 18;
        
        // Calculate where the belt connects to the gun (The "Feed Port")
        // We project a point relative to the gun's angle
        let feedPortX = Math.cos(this.angle - 0.5) * 8; // Offset to the side of the gun
        let feedPortY = Math.sin(this.angle - 0.5) * 8;

        // Belt Curve
        ctx.beginPath();
        ctx.moveTo(ammoX, ammoY);
        // Control point moves slightly with gun to fake flexibility
        ctx.quadraticCurveTo(ammoX, ammoY - 25, feedPortX, feedPortY);
        
        ctx.lineWidth = 7; ctx.strokeStyle = "#111"; ctx.stroke(); // Belt Backing
        ctx.lineWidth = 4; ctx.strokeStyle = "#d4af37"; ctx.setLineDash([2, 3]); ctx.stroke(); // Bullets
        ctx.setLineDash([]);

        // Ammo Box (Green Metal)
        ctx.fillStyle = "#2f3f2f";
        ctx.fillRect(ammoX - 10, ammoY - 10, 24, 20);
        ctx.fillStyle = "#4a5b4a"; // Lid
        ctx.fillRect(ammoX - 8, ammoY - 12, 20, 4);

        // --- 3. ROTATING TURRET HEAD ---
        ctx.rotate(this.angle);
        const kick = -this.recoil;

        // -- Rear Motor Housing (Rounded back) --
        ctx.fillStyle = "#222";
        ctx.beginPath();
        ctx.arc(-12 + kick, 0, 11, Math.PI/2, -Math.PI/2); // Half circle back
        ctx.fill();
        ctx.fillRect(-12 + kick, -11, 10, 22); // Connect to body

        // -- Main Receiver Body --
        ctx.fillStyle = "#3a3a3a"; // Lighter grey for contrast
        // Top shape
        ctx.beginPath();
        ctx.moveTo(-5 + kick, -10);
        ctx.lineTo(15 + kick, -10);
        ctx.lineTo(15 + kick, 10);
        ctx.lineTo(-5 + kick, 10);
        ctx.fill();
        
        // Side mounting plate visual
        ctx.fillStyle = "#1a1a1a";
        ctx.fillRect(-2 + kick, -11, 6, 22);

        // -- BARREL BUNDLE --
        const bW = 46; // Length
        const bH = 14; // Width
        const bX = 15 + kick;
        const bY = -bH/2;

        ctx.fillStyle = "#050505"; // Very dark barrel base
        ctx.fillRect(bX, bY, bW, bH);

        // Spinning Animation (Clipped)
        ctx.save();
        ctx.beginPath(); ctx.rect(bX, bY, bW, bH); ctx.clip();

        // Heat Gradient
        // Calculate color based on heat: Black -> Red -> Orange -> White/Yellow
        let heatR = 60 + (this.heat * 195);
        let heatG = 60 + (this.heat * 140);
        let heatB = 60;
        ctx.fillStyle = `rgb(${heatR}, ${heatG}, ${heatB})`;

        const spacing = 5;
        const scroll = this.barrelScroll % spacing;
        
        // Draw horizontal lines representing the barrels spinning
        for(let i = -spacing; i < bH + spacing; i += spacing) {
            let yPos = bY + i + scroll;
            // Draw barrel tube
            ctx.fillRect(bX, yPos, bW, 2);
            // Highlight (shine)
            ctx.fillStyle = "rgba(255,255,255,0.3)";
            ctx.fillRect(bX, yPos, bW, 1);
            ctx.fillStyle = `rgb(${heatR}, ${heatG}, ${heatB})`; // Reset color
        }
        ctx.restore();

        // -- Barrel Details --
        // 1. Clamp Ring (Middle of barrel)
        ctx.fillStyle = "#222";
        ctx.fillRect(bX + 20, bY - 1, 4, bH + 2);
        
        // 2. Muzzle Plate (The very front tip)
        ctx.fillStyle = "#111";
        ctx.fillRect(bX + bW - 2, bY - 1, 3, bH + 2);
        // Little dots on muzzle plate to show holes
        ctx.fillStyle = "#000";
        ctx.beginPath(); ctx.arc(bX + bW, -3, 1, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(bX + bW, 3, 1, 0, Math.PI*2); ctx.fill();

        ctx.restore(); // End Rotation

        // --- 4. HEALTH BAR ---
        if(typeof drawHealth === 'function') drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class MoneyFarm {
    constructor(col, row) {
        this.col = col;
        this.row = row;
        this.x = col * CELL_SIZE;
        this.y = row * CELL_SIZE;
        
        // Stats
        this.amount = 50 + (hasSkill('farm_val') ? 25 : 0) + (hasSkill('farm_cap') ? 50 : 0);        // Money per wave
        this.active = true;
        
        // Wave Tracking
        this.lastPaidWave = wave; // Track the last wave we paid out for
        
        // Visual Animation
        this.spin = 0;
        this.visualTimer = 0; // Kept for animation loops
        
        // Popup Text Stats
        this.popupText = "";
        this.popupAlpha = 0;
        this.popupY = 0;
    }

    update(dt) {
        // 1. Check if base is still intact
        let isIntact = true;
        for(let i=0; i<2; i++) {
            for(let j=0; j<2; j++) {
                if (!grid[this.col+i][this.row+j].wall) {
                    isIntact = false;
                }
            }
        }

        if (!isIntact) {
            this.cleanup();
            let idx = structures.indexOf(this);
            if (idx !== -1) structures.splice(idx, 1);
            return;
        }

        // 2. Generate Money (Per Wave)
        if (wave > this.lastPaidWave) {
            // Payout
            money += this.amount;
            if (typeof achStats !== 'undefined') achStats.farmIncome += this.amount;
            this.lastPaidWave = wave;
            
            // Visual Popup Init
            this.popupText = "+$" + this.amount;
            this.popupAlpha = 1.0; // Fully visible
            this.popupY = this.y;  // Start at top of building
            
            // Update UI
            if(document.getElementById('money')) document.getElementById('money').innerText = Math.floor(money);
        }

        // 3. Update Visuals
        this.spin += 0.05;
        this.visualTimer += dt;
        
        // Handle Popup Animation (Float up and Fade out)
        if (this.popupAlpha > 0) {
            this.popupY -= 0.5; // Float up
            this.popupAlpha -= 0.01; // Fade out
            if (this.popupAlpha < 0) this.popupAlpha = 0;
        }
    }

    draw() {
        let cx = this.x + CELL_SIZE;
        let cy = this.y + CELL_SIZE;
        let radius = CELL_SIZE - 5;
       
        // We set pct to roughly 0.95 so it looks "active" and glowing, 
        // but keeps the colors interesting (Magenta -> Cyan).
        let pct = 1; 

        // --- 1. THE BASE PAD (Background) ---
        ctx.fillStyle = "#1a1a22"; 
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI*2);
        ctx.fill();

        ctx.save();
        ctx.strokeStyle = "#330066"; 
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cx, cy, radius * 0.8, 0, Math.PI*2);
        ctx.arc(cx, cy, radius * 0.5, 0, Math.PI*2);
        for(let i=0; i<8; i++) {
            let angle = (Math.PI/4) * i;
            ctx.moveTo(cx + Math.cos(angle)*(radius*0.5), cy + Math.sin(angle)*(radius*0.5));
            ctx.lineTo(cx + Math.cos(angle)*radius, cy + Math.sin(angle)*radius);
        }
        ctx.stroke();
        ctx.restore();


        // --- 2. THE PROGRESS RING (Circular Energy Gauge) ---
        let gaugeRadius = radius * 0.75;
        ctx.save();
        ctx.lineWidth = 8;
        ctx.lineCap = "round"; 

        // 2a. Background track
        ctx.strokeStyle = "rgba(100, 0, 200, 0.2)";
        ctx.beginPath();
        ctx.arc(cx, cy, gaugeRadius, 0, Math.PI*2);
        ctx.stroke();

        // 2b. The filling energy arc
        let startAngle = -Math.PI / 2;
        let endAngle = startAngle + (Math.PI * 2 * pct);
        
        let colorStart = "#aa00ff"; 
        let colorEnd = "#00eeff"; 

        let gaugeGrad = ctx.createLinearGradient(this.x, this.y, this.x + CELL_SIZE*2, this.y + CELL_SIZE*2);
        gaugeGrad.addColorStop(0, colorStart);
        gaugeGrad.addColorStop(1, colorEnd);

        ctx.strokeStyle = gaugeGrad;
        ctx.shadowColor = colorEnd;
        ctx.shadowBlur = 15;
        
        ctx.beginPath();
        ctx.arc(cx, cy, gaugeRadius, startAngle, endAngle, false);
        ctx.stroke();
        ctx.restore();


        // --- 3. THE CENTRAL XENO-CROP (Alien Crystal Plant) ---
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(Date.now() / 3000);
        
        let coreColor = "#ff00aa"; 
        let outerColor = "#7700aa";

        let plantSize = radius * 0.4;
        
        // Outer petals
        ctx.fillStyle = outerColor;
        ctx.beginPath();
        for(let i=0; i<8; i+=2) { 
             let angle = (Math.PI*2/8) * i;
             ctx.moveTo(0,0);
             ctx.lineTo(Math.cos(angle - 0.3) * plantSize, Math.sin(angle - 0.3) * plantSize);
             ctx.lineTo(Math.cos(angle) * plantSize * 1.2, Math.sin(angle) * plantSize * 1.2); 
             ctx.lineTo(Math.cos(angle + 0.3) * plantSize, Math.sin(angle + 0.3) * plantSize);
        }
        ctx.fill();

        // Inner Core 
        let pulse = Math.sin(Date.now() / 400) * 3;
        let coreSize = (plantSize * 0.5) + pulse;

        ctx.fillStyle = coreColor;
        ctx.shadowColor = coreColor;
        ctx.shadowBlur = 25; 
        ctx.beginPath();
        for(let i=0; i<6; i++) {
            let angle = (Math.PI*2/6) * i;
            let px = Math.cos(angle) * coreSize;
            let py = Math.sin(angle) * coreSize;
            if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();


        // --- 4. ORBITING HARVEST DRONES ---
        // I removed the (pct < 1) check so they are ALWAYS visible
        ctx.save();
        ctx.translate(cx, cy);
        let orbitSpeed = Date.now() / 600;
        let numParticles = 3;
        
        ctx.fillStyle = "#00ffff";
        ctx.shadowColor = "#ffffff";
        ctx.shadowBlur = 10;

        for(let i=0; i<numParticles; i++) {
            let angle = orbitSpeed + (Math.PI*2 / numParticles) * i;
            let px = Math.cos(angle) * gaugeRadius;
            let py = Math.sin(angle) * gaugeRadius;
            
            ctx.beginPath();
            ctx.arc(px, py, 3, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.restore();
        
        // --- 5. FLOATING MONEY TEXT ---
        if (this.popupAlpha > 0) {
            ctx.save();
            ctx.globalAlpha = this.popupAlpha;
            ctx.font = "bold 15px 'Segoe UI', sans-serif";
            ctx.fillStyle = "#ffd700"; // Gold color
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.textAlign = "center";
            
            // Draw Outline
            ctx.strokeText(this.popupText, cx, this.popupY);
            // Draw Fill
            ctx.fillText(this.popupText, cx, this.popupY);
            
            ctx.restore();
        }
    }

    cleanup() {
        for(let i=0; i<2; i++) {
            for(let j=0; j<2; j++) {
                if (this.col + i < COLS && this.row + j < ROWS) {
                    let c = grid[this.col+i][this.row+j];
                    c.occupied = false;
                    c.wall = false;
                    c.wallHp = 100;
                }
            }
        }
        updateFlowField(); 
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MOLE ENEMY ‚Äî Only spawns from Drill Tower holes. Never appears in normal waves.
// Alien burrower: huge spade claws, velvety brown hide, vestigial glowing eyes.
// Special ability: periodically dives underground and tunnels through everything.
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
class MoleEnemy {
    constructor(spawnX, spawnY) {
        this.x = spawnX || (VIRTUAL_WIDTH / 2);
        this.y = spawnY || (VIRTUAL_HEIGHT / 2);

        // --- STATS ---
        this.radius = 13;
        this.speed  = 1.0 + (Math.random() * 0.35);
        this.hp     = 70 + (wave * 9);
        this.maxHp  = this.hp;
        this.bounty = 14;

        this.vx = -1; this.vy = 0;
        this.wallDamageCooldown = 0;
        this.wallDmg = 9;

        // Drill immunity
        this.drillImmuneTimer = 180;

        // --- VISUALS / ANIM ---
        this.angle     = Math.PI;
        this.animTimer = Math.random() * 100;
        this.glowPhase = Math.random() * Math.PI * 2;

        // Emerge from the drill hole
        this.emergeTimer = 45;
        this.surfaceScale = 0.05; // scales up from ground

        // ‚îÄ‚îÄ BURROW ABILITY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // States: 'surface' ‚Üí 'diving' ‚Üí 'tunneling' ‚Üí 'rising' ‚Üí 'surface'
        this.burrowState    = 'surface';
        this.burrowCooldown = 180 + Math.random() * 120; // frames until next dive
        this.burrowDepth    = 0;    // 0 = fully above, 1 = fully underground
        this.burrowSpeed    = 0.04; // depth change per frame
        // Trail of dirt clumps left on the surface while tunneling
        this.tunnelTrail    = [];   // [{x,y,alpha}]
        this.tunnelTimer    = 0;    // emits a trail dot every N frames
    }

    update(dt) {
        this.animTimer += 0.3 * dt;
        this.glowPhase += 0.05 * dt;
        if (this.drillImmuneTimer > 0) this.drillImmuneTimer -= dt;

        // ‚îÄ‚îÄ EMERGE ANIMATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if (this.emergeTimer > 0) {
            this.emergeTimer  -= dt;
            this.surfaceScale  = Math.min(1, this.surfaceScale + 0.05 * dt);
            return;
        }
        this.surfaceScale = 1;

        // ‚îÄ‚îÄ BURROW STATE MACHINE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if (this.burrowState === 'surface') {
            // Normal surface movement
            let col = Math.floor(this.x / CELL_SIZE);
            let row = Math.floor(this.y / CELL_SIZE);
            let isBlocked = sharedMovement(this, col, row);

            if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
                let ta = Math.atan2(this.vy, this.vx);
                let diff = ta - this.angle;
                while (diff < -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI)  diff -= Math.PI * 2;
                this.angle += diff * 0.12;
            }
            if (isBlocked) sharedDestroyWalls(this, col, row, this.wallDmg, 10);

            this.x += this.vx;
            this.y += this.vy;
            separate(this, enemies, 0.6);
            separate(this, allies, 0.8);
            resolveWallCollision(this);

            // Count down to next burrow
            this.burrowCooldown -= dt;
            if (this.burrowCooldown <= 0) {
                this.burrowState = 'diving';
                if (typeof createParticles === 'function')
                    createParticles(this.x, this.y, "#8B5E3C", 12);
            }

        } else if (this.burrowState === 'diving') {
            // Sink into the ground
            this.burrowDepth += this.burrowSpeed * dt * 1.5;
            if (this.burrowDepth >= 1) {
                this.burrowDepth = 1;
                this.burrowState = 'tunneling';
                this.tunnelTimer = 0;
                // Lock angle toward base when going underground
                let bx = playerBase.x * CELL_SIZE + CELL_SIZE;
                let by = playerBase.y * CELL_SIZE + CELL_SIZE;
                this.angle = Math.atan2(by - this.y, bx - this.x);
            }
            // Still move during dive
            this.x += this.vx * 0.5;
            this.y += this.vy * 0.5;

        } else if (this.burrowState === 'tunneling') {
            // Underground: move fast in straight line toward base, ignore all walls
            let bx = playerBase.x * CELL_SIZE + CELL_SIZE;
            let by = playerBase.y * CELL_SIZE + CELL_SIZE;
            let dx = bx - this.x;
            let dy = by - this.y;
            let dist = Math.hypot(dx, dy);
            let tunnelSpeed = this.speed * 1.6;
            if (dist > 0) {
                this.vx = (dx / dist) * tunnelSpeed;
                this.vy = (dy / dist) * tunnelSpeed;
                this.angle = Math.atan2(this.vy, this.vx);
            }
            this.x += this.vx;
            this.y += this.vy;

            // Dirt trail
            this.tunnelTimer -= dt;
            if (this.tunnelTimer <= 0) {
                this.tunnelTrail.push({ x: this.x, y: this.y, alpha: 0.7 });
                this.tunnelTimer = 8;
            }
            // Fade trail
            for (let tr of this.tunnelTrail) tr.alpha -= 0.025 * dt;
            this.tunnelTrail = this.tunnelTrail.filter(tr => tr.alpha > 0);

            // Keep in map bounds (don't fly out the edge)
            this.x = Math.max(this.radius, Math.min(COLS * CELL_SIZE - this.radius, this.x));
            this.y = Math.max(this.radius, Math.min(ROWS * CELL_SIZE - this.radius, this.y));

            // Rise after traveling ~4 cells or being close to base
            if (dist < CELL_SIZE * 1.5) {
                this.burrowState = 'rising';
            } else {
                // Random chance to resurface each frame (after minimum travel)
                if (Math.random() < 0.003 * dt) this.burrowState = 'rising';
            }

        } else if (this.burrowState === 'rising') {
            this.burrowDepth -= this.burrowSpeed * dt * 1.2;
            this.x += this.vx * 0.3;
            this.y += this.vy * 0.3;
            if (this.burrowDepth <= 0) {
                this.burrowDepth  = 0;
                this.burrowState  = 'surface';
                this.burrowCooldown = 220 + Math.random() * 160;
                if (typeof createParticles === 'function')
                    createParticles(this.x, this.y, "#8B5E3C", 14);
            }
        }

        // Base damage check (all states)
        let dbx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE / 2);
        let dby = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE / 2);
        if (Math.hypot(dbx, dby) < 30) { takeDamage(12); this.hp = 0; }
    }

    draw() {
        const isBurrowed   = this.burrowState === 'tunneling';
        const isTransition = this.burrowState === 'diving' || this.burrowState === 'rising';

        // ‚îÄ‚îÄ TUNNEL TRAIL (always drawn, under everything) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if (this.tunnelTrail.length > 0) {
            ctx.save();
            for (let tr of this.tunnelTrail) {
                ctx.globalAlpha = tr.alpha;
                // Disturbed earth ring
                ctx.strokeStyle = "#6B4226";
                ctx.lineWidth   = 3;
                ctx.beginPath();
                ctx.arc(tr.x, tr.y, 6, 0, Math.PI * 2);
                ctx.stroke();
                // Inner dirt dot
                ctx.fillStyle = "#8B5E3C";
                ctx.beginPath();
                ctx.arc(tr.x, tr.y, 3, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        // ‚îÄ‚îÄ UNDERGROUND INDICATOR (ripple at position while tunneling) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if (isBurrowed) {
            ctx.save();
            let ripple = (Date.now() % 800) / 800; // 0‚Üí1 cycle
            ctx.globalAlpha = 0.5 * (1 - ripple);
            ctx.strokeStyle = "#A0522D";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(this.x, this.y, (10 + ripple * 18), (4 + ripple * 6), 0, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 1;
            ctx.restore();
            // Don't draw the body while fully tunneling
            drawHealth(this.x, this.y, this.hp, this.maxHp);
            return;
        }

        // ‚îÄ‚îÄ TRANSITION SCALE (diving/rising) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const scaleY = isTransition ? (1 - this.burrowDepth) : this.surfaceScale;
        if (scaleY < 0.05) return;

        ctx.save();

        // Ground shadow (bigger when on surface, fades on dive)
        ctx.globalAlpha = scaleY * 0.45;
        ctx.fillStyle   = "rgba(0,0,0,1)";
        ctx.beginPath();
        ctx.ellipse(this.x, this.y + 11, this.radius * 0.85, 4, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;

        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.scale(1, scaleY);

        const t    = this.animTimer;
        const glow = 0.5 + Math.sin(this.glowPhase) * 0.5;
        const isDigging = (this.burrowState === 'surface');

        // ‚îÄ‚îÄ PALETTE (earthy brown alien) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const cHide     = "#4A2C17";  // dark walnut brown ‚Äî main body
        const cFur      = "#7A4A28";  // warm mid-brown fur
        const cFurLight = "#A06840";  // lighter highlight on belly/nose
        const cClawBase = "#2E1A0E";  // near-black claw root
        const cClaw     = "#C8A87A";  // bone/ivory claw tines
        const cClawTip  = "#E8D0A0";  // bright ivory tip
        const cEye      = `rgba(255, ${Math.floor(100 + glow * 80)}, 20, ${0.8 + glow * 0.2})`; // amber-orange glowing eyes
        const cNose     = "#C06080";  // pink-mauve star nose

        // ‚îÄ‚îÄ HIND LEGS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const drawHindLeg = (side) => {
            let kick = isDigging ? Math.sin(t * 2.0 + side * Math.PI) * 5 : 0;
            // Upper leg
            ctx.strokeStyle = cFur;
            ctx.lineWidth = 4;
            ctx.lineCap = "round";
            ctx.beginPath();
            ctx.moveTo(-7, side * 5);
            ctx.lineTo(-13 + kick * 0.5, side * 10);
            ctx.stroke();
            // Lower leg
            ctx.lineWidth = 2.5;
            ctx.beginPath();
            ctx.moveTo(-13 + kick * 0.5, side * 10);
            ctx.lineTo(-10 + kick, side * 16);
            ctx.stroke();
            // Tiny foot pad
            ctx.fillStyle = cHide;
            ctx.beginPath();
            ctx.ellipse(-10 + kick, side * 16, 3, 2, 0.3 * side, 0, Math.PI * 2);
            ctx.fill();
        };
        drawHindLeg(1); drawHindLeg(-1);

        // ‚îÄ‚îÄ BODY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Dark underbelly gradient base
        ctx.fillStyle = cHide;
        ctx.beginPath();
        ctx.ellipse(0, 0, 13, 8.5, 0, 0, Math.PI * 2);
        ctx.fill();

        // Fur texture ‚Äî layered lighter oval on top (dorsal highlight)
        ctx.fillStyle = cFur;
        ctx.beginPath();
        ctx.ellipse(-1, -1.5, 10, 5.5, -0.15, 0, Math.PI * 2);
        ctx.fill();

        // Spine highlight
        ctx.strokeStyle = cFurLight;
        ctx.lineWidth = 1.5;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(-10, 0);
        for (let i = 0; i < 8; i++) {
            let rx = -10 + i * 2.8;
            let ry = -Math.abs(Math.sin(i * 0.9 + t * 1.8)) * 1.8;
            ctx.lineTo(rx, ry);
        }
        ctx.stroke();

        // Belly ‚Äî warm lighter stripe
        ctx.strokeStyle = cFurLight;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.moveTo(-9, 4); ctx.quadraticCurveTo(0, 7, 7, 4);
        ctx.stroke();
        ctx.globalAlpha = 1;

        // ‚îÄ‚îÄ FRONT DIGGING CLAWS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // These are the star feature ‚Äî wide spade-like paws
        const drawClaw = (side) => {
            // Phase offset so claws alternate (looks like actual digging)
            let phase  = isDigging ? Math.sin(t * 2.4 + side * Math.PI) : 0;
            let extend = 4 + phase * 5; // claws extend forward when digging
            let lift   = phase * 3;

            // Upper arm ‚Äî thick
            ctx.strokeStyle = cFur;
            ctx.lineWidth   = 5;
            ctx.lineCap     = "round";
            ctx.beginPath();
            ctx.moveTo(4, side * 4);
            ctx.lineTo(11 + extend * 0.4, side * (7 - lift));
            ctx.stroke();

            // Spade palm
            ctx.fillStyle = cClawBase;
            ctx.beginPath();
            ctx.ellipse(12 + extend * 0.5, side * (8 - lift), 5, 3.5, 0.4 * side, 0, Math.PI * 2);
            ctx.fill();

            // Three curved tines fanning out from the palm
            ctx.strokeStyle = cClaw;
            ctx.lineWidth   = 2;
            ctx.lineCap     = "round";
            for (let ci = -1; ci <= 1; ci++) {
                let fanAngle = (ci * 0.35) + (side < 0 ? -0.2 : 0.2);
                let tx0 = 12 + extend * 0.5 + Math.cos(fanAngle) * 3;
                let ty0 = side * (8 - lift) + Math.sin(fanAngle) * 3;
                let tx1 = tx0 + Math.cos(fanAngle) * (8 + extend * 0.5);
                let ty1 = ty0 + Math.sin(fanAngle) * (6 + extend * 0.5);
                ctx.beginPath();
                ctx.moveTo(tx0, ty0);
                ctx.quadraticCurveTo(
                    (tx0 + tx1) / 2 + ci * 1.5,
                    (ty0 + ty1) / 2 - lift,
                    tx1, ty1
                );
                ctx.stroke();
                // Bright ivory claw tip
                ctx.fillStyle = cClawTip;
                ctx.beginPath();
                ctx.arc(tx1, ty1, 1.2, 0, Math.PI * 2);
                ctx.fill();
            }
        };
        drawClaw(1); drawClaw(-1);

        // ‚îÄ‚îÄ HEAD ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Rounded wedge pointing forward
        ctx.fillStyle = cFur;
        ctx.beginPath();
        ctx.moveTo(5, -5.5);
        ctx.quadraticCurveTo(9, -4, 15, -1.5);
        ctx.quadraticCurveTo(18, 0, 15, 1.5);
        ctx.quadraticCurveTo(9, 4, 5, 5.5);
        ctx.closePath();
        ctx.fill();

        // Forehead stripe
        ctx.strokeStyle = cFurLight;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(6, -2.5); ctx.quadraticCurveTo(12, -2, 16, 0);
        ctx.stroke();

        // ‚îÄ‚îÄ STAR-NOSE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // 6 fleshy tendrils ringing the snout tip
        ctx.fillStyle = cNose;
        ctx.shadowColor = cNose;
        ctx.shadowBlur  = 3 + glow * 3;
        for (let ni = 0; ni < 6; ni++) {
            let na = (ni / 6) * Math.PI * 2 + t * 0.4;
            let nx = 17.5 + Math.cos(na) * 2.2;
            let ny = Math.sin(na) * 2.2;
            ctx.beginPath();
            ctx.ellipse(nx, ny, 1.1, 0.7, na, 0, Math.PI * 2);
            ctx.fill();
        }
        // Central nostril
        ctx.fillStyle = "#1A0A0A";
        ctx.beginPath(); ctx.arc(17.5, 0, 1, 0, Math.PI * 2); ctx.fill();
        ctx.shadowBlur = 0;

        // ‚îÄ‚îÄ EYES (vestigial amber glow) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        ctx.shadowColor = "#FF8C00";
        ctx.shadowBlur  = 6 + glow * 8;
        ctx.fillStyle   = cEye;
        [[9.5, -3], [9.5, 3]].forEach(([ex, ey]) => {
            ctx.beginPath(); ctx.arc(ex, ey, 2, 0, Math.PI * 2); ctx.fill();
            // Pupil
            ctx.fillStyle = "#1A0800";
            ctx.beginPath(); ctx.arc(ex + 0.5, ey, 0.8, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = cEye;
        });
        ctx.shadowBlur = 0;

        ctx.restore();

        // ‚îÄ‚îÄ DIRT PARTICLE TRAIL (surface) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if (this.burrowState === 'surface' && Math.random() < 0.12) {
            if (typeof createParticles === 'function')
                createParticles(
                    this.x - Math.cos(this.angle) * 12,
                    this.y - Math.sin(this.angle) * 12,
                    "#7A4A28", 1
                );
        }

        // ‚îÄ‚îÄ DRILL IMMUNITY RING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if (this.drillImmuneTimer > 0) {
            let alpha = Math.min(1, this.drillImmuneTimer / 60) * 0.45;
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.strokeStyle = "#D4913A";
            ctx.lineWidth = 2.5;
            ctx.shadowColor = "#D4913A";
            ctx.shadowBlur  = 10;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.radius + 5, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.restore();
        }

        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// DRILL TOWER ‚Äî Economy structure that mines ores and occasionally opens cave
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
class DrillTower {
    // ‚îÄ‚îÄ SHARED STATIC CACHE (one OffscreenCanvas for ALL drill instances) ‚îÄ‚îÄ‚îÄ‚îÄ
    // All drills look identical ‚Äî no reason to allocate N canvases.
    // Built lazily on the first draw, reused forever.
    static _sharedBody   = null;  // OffscreenCanvas
    static _sharedOriginX = 0;
    static _sharedOriginY = 0;
    static _sharedTipGrad = null; // tip gradient, built once on the shared ctx
    static _sharedShaftGrad = null;

    static _buildSharedBody() {
        const W = CELL_SIZE * 2, H = CELL_SIZE * 2;
        const hw = W / 2, hh = H / 2;
        const PAD_TOP = 90;
        const CW = W + 8, CH = H + PAD_TOP + 8;
        const OX = CW / 2, OY = PAD_TOP + hh;

        const oc  = new OffscreenCanvas(CW, CH);
        const occ = oc.getContext('2d');
        DrillTower._sharedBody    = oc;
        DrillTower._sharedOriginX = OX;
        DrillTower._sharedOriginY = OY;

        const TOWER_TOP = -75;
        const HX = 0, HY = 20, HRX = 22, HRY = 10;
        occ.translate(OX, OY);

        const drawGirder = (x1, y1, x2, y2, width, darkCol, lightCol) => {
            occ.lineWidth = width; occ.strokeStyle = darkCol; occ.lineCap = "butt";
            occ.beginPath(); occ.moveTo(x1, y1); occ.lineTo(x2, y2); occ.stroke();
            occ.lineWidth = width - 4; occ.strokeStyle = lightCol;
            occ.beginPath(); occ.moveTo(x1, y1); occ.lineTo(x2, y2); occ.stroke();
        };

        // Back legs
        drawGirder(-hw+16, -hh+16, -14, TOWER_TOP+8, 7, "#1a1a1d", "#33333a");
        drawGirder( hw-16, -hh+16,  14, TOWER_TOP+8, 7, "#1a1a1d", "#33333a");

        // Outer housing
        occ.fillStyle="#2b2d30"; occ.strokeStyle="#0a0a0a"; occ.lineWidth=3;
        occ.beginPath(); occ.roundRect(-hw+2, -hh+2, W-4, H-4, 6); occ.fill(); occ.stroke();

        // Inner armored panel
        let panG = occ.createLinearGradient(-hw,-hh,hw,hh);
        panG.addColorStop(0,"#404347"); panG.addColorStop(0.5,"#323438"); panG.addColorStop(1,"#1f2124");
        occ.fillStyle=panG; occ.strokeStyle="#111"; occ.lineWidth=2;
        occ.beginPath(); occ.roundRect(-hw+8, -hh+8, W-16, H-16, 4); occ.fill(); occ.stroke();

        // Corner bolts
        occ.fillStyle = "#050505";
        const bDist = 14;
        [-1, 1].forEach(dx => [-1, 1].forEach(dy => {
            occ.beginPath(); occ.arc(dx*(hw-bDist), dy*(hh-bDist), 2.5, 0, Math.PI*2); occ.fill();
            occ.fillStyle = "#666";
            occ.beginPath(); occ.arc(dx*(hw-bDist)-0.5, dy*(hh-bDist)-0.5, 1, 0, Math.PI*2); occ.fill();
            occ.fillStyle = "#050505";
        }));

        // Ventilation grilles
        occ.fillStyle = "#0a0a0a";
        for (let i = 0; i < 4; i++) {
            occ.fillRect(-hw+14, -hh+26 + i*7, 12, 3);
            occ.fillRect( hw-26, -hh+26 + i*7, 12, 3);
        }

        // Warning stripes
        occ.save();
        occ.beginPath(); occ.rect(-hw+8, hh-16, W-16, 8); occ.clip();
        for (let si = 0; si <= Math.ceil((W-16)/8); si++) {
            occ.fillStyle = si%2===0 ? "#ccaa00" : "#181818";
            occ.fillRect(-hw+8+si*8, hh-16, 8, 8);
        }
        occ.restore();
        occ.strokeStyle="#111"; occ.lineWidth=1; occ.strokeRect(-hw+8, hh-16, W-16, 8);

        // Hole interior
        occ.fillStyle = "#050505";
        occ.beginPath(); occ.ellipse(HX, HY, HRX, HRY, 0, 0, Math.PI*2); occ.fill();

        // Front legs + top housing
        drawGirder(-hw+18, hh-16, -18, TOWER_TOP+8, 9, "#2a2a2e", "#50505a");
        drawGirder( hw-18, hh-16,  18, TOWER_TOP+8, 9, "#2a2a2e", "#50505a");
        occ.fillStyle = "#222"; occ.strokeStyle = "#000"; occ.lineWidth = 2;
        occ.beginPath(); occ.roundRect(HX - 24, TOWER_TOP - 12, 48, 22, 4); occ.fill(); occ.stroke();
    }

    constructor(col, row) {
        this.col = col;
        this.row = row;
        this.bx = col * CELL_SIZE;
        this.by = row * CELL_SIZE;
        this.x  = this.bx + CELL_SIZE;
        this.y  = this.by + CELL_SIZE;
        this.type   = "DRILL";
        this.active = true;
        this.hp     = 300;
        this.maxHp  = 300;

        this.mineInterval = 480;
        this.mineTimer    = Math.floor(Math.random() * 240);
        this.caveChance   = 0.08;

        this.oreTable = [
            { name: "Coal",     color: "#888",    value: 8,   weight: 40 },
            { name: "Iron",     color: "#c0c0c0", value: 15,  weight: 30 },
            { name: "Copper",   color: "#b87333", value: 25,  weight: 15 },
            { name: "Gold",     color: "#ffd700", value: 50,  weight: 8  },
            { name: "Emerald",  color: "#00ff88", value: 100, weight: 4  },
            { name: "Diamond",  color: "#88ffff", value: 200, weight: 2  },
            { name: "Void Gem", color: "#cc44ff", value: 500, weight: 1  },
        ];
        this.totalWeight = this.oreTable.reduce((s, o) => s + o.weight, 0);

        this.drillPhase  = 0;
        this.drillDepth  = 0;
        this.maxDepth    = 70;
        this.drillSpeed  = 1.5;
        this.riseSpeed   = 6.0;
        this.spinAngle   = 0;
        this.isMining    = false;

        this.shakeX = 0;
        this.shakeY = 0;
        this.lastOreColor = "#ffd700";
        this.oreParticles = [];
        this.popupText  = "";
        this.popupColor = "#ffd700";
        this.popupAlpha = 0;
        this.popupY     = 0;

        // Per-instance cached values updated in update(), read in draw()
        this._fOffset   = 0;
        this._lastHeatQ = -1;
        this._heatColor = "rgb(60,60,60)";
        this._heatR = 60; this._heatG = 60; this._heatB = 60;
        this._glowBlur  = 0;

        // Last shadowBlur actually set ‚Äî lets us skip redundant shadowBlur=0 writes
        this._lastShadowBlur = 0;
    }

    _rollOre() {
        let r = Math.random() * this.totalWeight;
        for (let ore of this.oreTable) { r -= ore.weight; if (r <= 0) return ore; }
        return this.oreTable[0];
    }

    update(dt) {
        // Integrity check
        let intact = true;
        for (let i = 0; i < 2 && intact; i++)
            for (let j = 0; j < 2 && intact; j++)
                if (!grid[this.col+i][this.row+j].wall) intact = false;
        if (!intact) { this.active = false; return; }

        if (this.drillPhase !== 0) this.spinAngle += 0.35 * dt;

        this.mineTimer -= dt;
        if (this.mineTimer <= 0 && this.drillPhase === 0) {
            this.drillPhase = 1;
            this.isMining   = true;
        }

        if (this.drillPhase === 1) {
            this.drillDepth += this.drillSpeed * dt;
            this.shakeX = (Math.random() - 0.5) * 3.5;
            this.shakeY = (Math.random() - 0.5) * 3.5;
            if (this.drillDepth >= this.maxDepth) {
                this.drillDepth = this.maxDepth;
                this._doMine();
                this.drillPhase = 2;
                this.mineTimer  = this.mineInterval;
            }
        } else if (this.drillPhase === 2) {
            this.drillDepth -= this.riseSpeed * dt;
            this.shakeX = 0; this.shakeY = 0;
            if (this.drillDepth <= 0) {
                this.drillDepth = 0;
                this.drillPhase = 0;
                this.isMining   = false;
            }
        } else {
            this.shakeX = 0; this.shakeY = 0;
        }

        // fOffset: computed once here, not in draw()
        this._fOffset = (this.spinAngle * 16) % 9;

        // Heat values: quantised to 1% steps so string building is rare
        const heatQ = Math.round(this.drillDepth / this.maxDepth * 100) / 100;
        if (heatQ !== this._lastHeatQ) {
            this._lastHeatQ = heatQ;
            this._heatR     = Math.floor(60 + heatQ * 195);
            this._heatG     = Math.floor(60 + Math.max(0, heatQ - 0.3) * 195 * 1.5);
            this._heatB     = Math.floor(60 + Math.max(0, heatQ - 0.7) * 195 * 3.5);
            this._heatColor = `rgb(${this._heatR},${this._heatG},${this._heatB})`;
            this._glowBlur  = heatQ * 15;
        }

        // Ore particles: in-place compaction, no new array allocation
        const ops = this.oreParticles;
        let live = 0;
        for (let i = 0; i < ops.length; i++) {
            const p = ops[i];
            p.x  += p.vx;
            p.y  += p.vy;
            p.vy += 0.22;
            p.vx *= 0.97;
            p.life -= dt;
            if (p.life > 0) {
                p.alpha = p.life / 55;
                ops[live++] = p;
            }
        }
        ops.length = live;

        if (this.popupAlpha > 0) {
            this.popupY     -= 0.55;
            this.popupAlpha -= 0.013;
            if (this.popupAlpha < 0) this.popupAlpha = 0;
        }
    }

    _doMine() {
        const ore = this._rollOre();
        this.lastOreColor = ore.color;

        if (Math.random() < 0.05) {
            const _drillEnemyTypes = [
                TankEnemy, RunnerEnemy, BreacherEnemy, SniperEnemy,
                BroodmotherEnemy, LarvaEnemy, LeaperEnemy, ReviverEnemy,
                SkeletonEnemy, FlyingEnemy, MagnetEnemy, ShielderEnemy,
                MoleEnemy
            ];
            const _spawnCount = 1 + Math.floor(Math.random() * 5);
            const _holeX = this.x;
            const _holeY = this.by + this.maxDepth + 10;
            for (let _si = 0; _si < _spawnCount; _si++) {
                let _e;
                if (Math.random() < 0.4) {
                    _e = new MoleEnemy(_holeX, _holeY);
                } else {
                    const _EType = _drillEnemyTypes[Math.floor(Math.random() * (_drillEnemyTypes.length - 1))];
                    _e = new _EType();
                    _e.x = _holeX;
                    _e.y = _holeY;
                    _e.drillImmuneTimer = 180;
                }
                _e.sourceDrill = this;
                enemies.push(_e);
            }
            if (typeof createParticles === 'function') {
                createParticles(_holeX, _holeY, "#8B5E3C", 18);
                createParticles(_holeX, _holeY, "#D4913A", 8);
            }
        }

        money += ore.value;
        if (typeof achStats !== 'undefined') achStats.farmIncome += ore.value;
        if (document.getElementById('money'))
            document.getElementById('money').innerText = Math.floor(money);

        let count = 4 + Math.floor(Math.random() * 5);
        for (let i = 0; i < count; i++) {
            this.oreParticles.push({
                x:     this.x + (Math.random() - 0.5) * 10,
                y:     this.by + 20,
                vx:    (Math.random() - 0.5) * 6.5,
                vy:    -(6 + Math.random() * 6),
                color: ore.color,
                size:  6 + Math.random() * 6,
                value: ore.value,
                life:  50 + Math.random() * 30,
                alpha: 1
            });
        }

        if (Math.random() < this.caveChance) this._triggerCave();
    }

    _triggerCave() {
        let spawnEdge = Math.random() < 0.5 ? 0 : (COLS - 1) * CELL_SIZE;
        let spawnY    = CELL_SIZE + Math.random() * (ROWS - 2) * CELL_SIZE;
        let count     = 1 + Math.floor(Math.random() * 5);
        for (let i = 0; i < count; i++) {
            let ex = spawnEdge + (Math.random() - 0.5) * CELL_SIZE;
            let ey = spawnY    + (Math.random() - 0.5) * CELL_SIZE * 2;
            let e  = null;
            if      (typeof BasicEnemy !== 'undefined') e = new BasicEnemy(ex, ey);
            else if (typeof FastEnemy  !== 'undefined') e = new FastEnemy (ex, ey);
            if (e) enemies.push(e);
        }
        if (typeof createParticles === 'function') createParticles(this.x, this.y, "#ff4400", 20);
    }

    // Helper: only write ctx.shadowBlur when the value actually changes,
    // avoiding redundant GPU state flushes.
    _setShadow(color, blur) {
        if (blur !== this._lastShadowBlur) {
            ctx.shadowBlur  = blur;
            this._lastShadowBlur = blur;
        }
        if (blur > 0) ctx.shadowColor = color;
    }

    draw() {
        // Build shared body cache once for all instances
        if (!DrillTower._sharedBody) DrillTower._buildSharedBody();

        const W  = CELL_SIZE * 2, H  = CELL_SIZE * 2;
        const hw = W / 2,         hh = H / 2;
        const cx = this.x + this.shakeX;
        const cy = this.y + this.shakeY;

        const HX = 0, HY = 20, HRX = 22, HRY = 10;
        const TOWER_TOP = -75;
        const MOTOR_H = 14, COLLAR_H = 10, SHAFT_H = 28, TIP_H = 28;
        const fSpacing = 9;

        const heatRatio = this._lastHeatQ;
        const heatColor = this._heatColor;
        const r = this._heatR, g = this._heatG, b = this._heatB;
        const glowBlur  = this._glowBlur;
        const fOffset   = this._fOffset;
        const ventOn    = this.isMining;
        const hot       = heatRatio > 0.05;
        const veryHot   = heatRatio > 0.1;

        const currentTipY   = (HY - 5) + this.drillDepth;
        const shaftBottomY  = currentTipY - TIP_H;
        const collarBottomY = shaftBottomY - SHAFT_H;
        const motorBottomY  = collarBottomY - COLLAR_H;

        this._lastShadowBlur = 0; // reset tracker for this frame

        ctx.save();
        ctx.translate(cx, cy);

        // ‚îÄ‚îÄ 1. STATIC BODY: one drawImage replaces ~60 individual draw calls ‚îÄ‚îÄ
        ctx.drawImage(
            DrillTower._sharedBody,
            -DrillTower._sharedOriginX,
            -DrillTower._sharedOriginY
        );

        // ‚îÄ‚îÄ 2. DYNAMIC DRILL ASSEMBLY (clip to above-hole region) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        ctx.save();
        ctx.beginPath();
        ctx.moveTo(-W*2, -H*3); ctx.lineTo(W*2, -H*3); ctx.lineTo(W*2, HY);
        ctx.ellipse(HX, HY, HRX, HRY, 0, 0, Math.PI);
        ctx.lineTo(-W*2, HY); ctx.closePath(); ctx.clip();

        // A. Piston Rod
        ctx.fillStyle = "#778899"; ctx.strokeStyle = "#0a0a0a"; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.rect(HX-6, TOWER_TOP, 12, motorBottomY - TOWER_TOP); ctx.fill(); ctx.stroke();
        ctx.fillStyle = "#556677";
        ctx.fillRect(HX-3, TOWER_TOP, 6, motorBottomY - TOWER_TOP);

        // B. Motor Block
        ctx.fillStyle = "#ffaa00"; ctx.strokeStyle = "#332200"; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.roundRect(HX-18, motorBottomY - MOTOR_H, 36, MOTOR_H, 4); ctx.fill(); ctx.stroke();
        ctx.fillStyle = "#cc8800";
        ctx.fillRect(HX-14, motorBottomY - MOTOR_H + 3, 28, MOTOR_H - 6);

        // C. Collar
        ctx.fillStyle = "#444"; ctx.strokeStyle = "#0a0a0a"; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.roundRect(HX-15, collarBottomY - COLLAR_H, 30, COLLAR_H, 2); ctx.fill(); ctx.stroke();
        ctx.fillStyle = hot ? heatColor : "#222";
        this._setShadow(heatColor, hot ? glowBlur * 0.5 : 0);
        ctx.beginPath(); ctx.rect(HX-10, collarBottomY - COLLAR_H + 3, 20, COLLAR_H - 6); ctx.fill();
        this._setShadow("", 0);

        // D. Shaft ‚Äî shared gradient (built once, identical geometry across all drills)
        if (!DrillTower._sharedShaftGrad) {
            DrillTower._sharedShaftGrad = ctx.createLinearGradient(HX-12, 0, HX+12, 0);
            DrillTower._sharedShaftGrad.addColorStop(0,   "#555");
            DrillTower._sharedShaftGrad.addColorStop(0.5, "#9ba0a6");
            DrillTower._sharedShaftGrad.addColorStop(1,   "#444");
        }
        ctx.fillStyle = DrillTower._sharedShaftGrad; ctx.strokeStyle = "#0a0a0a"; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.rect(HX-12, shaftBottomY - SHAFT_H, 24, SHAFT_H); ctx.fill(); ctx.stroke();

        // Shaft helix lines ‚Äî batched into ONE path per pass (was one beginPath/stroke per line)
        ctx.save();
        ctx.beginPath(); ctx.rect(HX-12, shaftBottomY - SHAFT_H, 24, SHAFT_H); ctx.clip();
        if (veryHot) {
            ctx.globalCompositeOperation = "lighter";
            ctx.fillStyle = `rgba(${r},${g},${b},${heatRatio * 0.4})`;
            ctx.fillRect(HX-12, shaftBottomY - SHAFT_H, 24, SHAFT_H);
            ctx.globalCompositeOperation = "source-over";
        }
        ctx.strokeStyle = veryHot ? heatColor : "#333";
        this._setShadow(heatColor, veryHot ? glowBlur * 0.5 : 0);
        ctx.lineWidth = 3;
        ctx.beginPath(); // SINGLE path for all helix lines
        for (let fi = -2; fi < SHAFT_H / fSpacing + 2; fi++) {
            const fy = shaftBottomY - SHAFT_H + fi * fSpacing + fOffset;
            ctx.moveTo(HX-14, fy); ctx.lineTo(HX+14, fy + 7);
        }
        ctx.stroke();
        this._setShadow("", 0);
        ctx.restore();

        // E. Drill tip
        ctx.save();
        ctx.translate(HX, shaftBottomY);
        ctx.beginPath();
        ctx.moveTo(-12,0); ctx.lineTo(-17,6); ctx.lineTo(-7,18); ctx.lineTo(-2,TIP_H-4);
        ctx.lineTo(0,TIP_H); ctx.lineTo(2,TIP_H-4); ctx.lineTo(7,18); ctx.lineTo(17,6); ctx.lineTo(12,0);
        ctx.clip();

        // Tip gradient: shared static (same geometry for every drill)
        if (!DrillTower._sharedTipGrad) {
            DrillTower._sharedTipGrad = ctx.createLinearGradient(-17, 0, 17, 0);
            DrillTower._sharedTipGrad.addColorStop(0,   "#666");
            DrillTower._sharedTipGrad.addColorStop(0.5, "#b5bbc2");
            DrillTower._sharedTipGrad.addColorStop(1,   "#555");
        }
        ctx.fillStyle = DrillTower._sharedTipGrad;
        ctx.fillRect(-17, 0, 34, TIP_H);

        if (hot) {
            ctx.globalCompositeOperation = "lighter";
            ctx.fillStyle = `rgba(${r},${g},${b},${heatRatio * 0.7})`;
            ctx.fillRect(-17, 0, 34, TIP_H);
            ctx.globalCompositeOperation = "source-over";
        }

        // Tip helix pass 1 ‚Äî batched single path
        ctx.strokeStyle = hot ? heatColor : "#333";
        this._setShadow(heatColor, hot ? glowBlur : 0);
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        for (let fi = -2; fi < TIP_H / fSpacing + 2; fi++) {
            const fy = fi * fSpacing + fOffset;
            ctx.moveTo(-18, fy); ctx.lineTo(18, fy + 7);
        }
        ctx.stroke();

        // Tip helix pass 2 ‚Äî batched single path
        ctx.strokeStyle = hot ? `rgba(${r},${g},${b},0.7)` : "#222";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        for (let fi = -2; fi < TIP_H / (fSpacing * 0.8) + 2; fi++) {
            const fy = fi * (fSpacing * 0.8) - fOffset * 0.5;
            ctx.moveTo(-18, fy + 6); ctx.lineTo(18, fy);
        }
        ctx.stroke();
        this._setShadow("", 0);

        // Plasma core (only when really hot ‚Äî rare)
        if (heatRatio > 0.4) {
            ctx.globalCompositeOperation = "lighter";
            let coreG = ctx.createRadialGradient(0, TIP_H-2, 0, 0, TIP_H-2, 8 + heatRatio*6);
            coreG.addColorStop(0, "#ffffff");
            coreG.addColorStop(0.4, heatColor);
            coreG.addColorStop(1, "transparent");
            ctx.fillStyle = coreG;
            ctx.beginPath(); ctx.arc(0, TIP_H-2, 16, 0, Math.PI*2); ctx.fill();
            ctx.globalCompositeOperation = "source-over";
        }
        ctx.restore(); // tip translate
        ctx.restore(); // clip region

        // ‚îÄ‚îÄ 3. HOLE FRONT RIM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        ctx.strokeStyle = heatRatio > 0.2 ? `rgba(${r},${g},${b},${heatRatio})` : "#4e5158";
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.ellipse(HX, HY, HRX, HRY, 0, 0, Math.PI); ctx.stroke();
        ctx.strokeStyle = "#111"; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.ellipse(HX, HY, HRX+3, HRY+3, 0, 0, Math.PI); ctx.stroke();

        // ‚îÄ‚îÄ 4. STATUS LIGHT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const lightColor = ventOn ? heatColor : "#0044ff";
        ctx.fillStyle = lightColor;
        this._setShadow(lightColor, 10);
        ctx.beginPath(); ctx.arc(HX, TOWER_TOP-5, 4, 0, Math.PI*2); ctx.fill();
        this._setShadow("", 0);

        // ‚îÄ‚îÄ 5. HEALTH BAR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        if (this.hp < this.maxHp && this.hp > 0) {
            const pct = this.hp / this.maxHp;
            ctx.fillStyle = "#0a0a0a";
            ctx.fillRect(-hw+4, -hh-7, W-8, 5);
            ctx.fillStyle = pct > 0.6 ? "#00e676" : pct > 0.3 ? "#ffea00" : "#ff1744";
            ctx.fillRect(-hw+4, -hh-7, (W-8)*pct, 5);
        }

        ctx.restore(); // main translate

        // ‚îÄ‚îÄ 6. ORE CHUNKS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Each particle still needs its own rotate, but we hoist save/restore
        // out of the per-particle loop and skip shadow when alpha is low.
        const ops = this.oreParticles;
        if (ops.length > 0) {
            ctx.save();
            ctx.lineWidth = 1; ctx.strokeStyle = "#111";
            for (let i = 0; i < ops.length; i++) {
                const p = ops[i];
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.life * 0.1);
                ctx.globalAlpha = p.alpha;
                ctx.fillStyle   = p.color;
                // Only pay for shadow when particle is bright enough to see it
                if (p.alpha > 0.4) { ctx.shadowColor = p.color; ctx.shadowBlur = 8; }
                const s = p.size;
                ctx.beginPath();
                ctx.moveTo(-s/2, -s/2); ctx.lineTo(s/3, -s*0.7);
                ctx.lineTo(s/2, s/4);   ctx.lineTo(-s/4, s/2);
                ctx.closePath();
                ctx.fill(); ctx.stroke();
                if (p.alpha > 0.4) ctx.shadowBlur = 0;
                ctx.restore();
            }
            ctx.restore();
        }
    }
    cleanup() {
        for (let i = 0; i < 2; i++) {
            for (let j = 0; j < 2; j++) {
                if (this.col+i < COLS && this.row+j < ROWS) {
                    let c = grid[this.col+i][this.row+j];
                    c.occupied = false; c.wall = false; c.wallHp = 100;
                }
            }
        }
        updateFlowField();
    }
}
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Helper function for rounded rectangles (paste this outside the class or method)
function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

    /** CORE SYSTEMS **/
const VIRTUAL_WIDTH = COLS * CELL_SIZE; 
const VIRTUAL_HEIGHT = ROWS * CELL_SIZE;

let scale = 1;
let offsetX = 0;
let offsetY = 0;

// Calculates how to fit the game into the current window
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // 1. Determine Scale: Fit width OR height, whichever is smaller
    let scaleX = window.innerWidth / VIRTUAL_WIDTH;
    let scaleY = window.innerHeight / VIRTUAL_HEIGHT;
    scale = Math.min(scaleX, scaleY);

    // 2. Determine Centering (Letterboxing)
    // We calculate how much empty space is left and divide by 2 to center it
    offsetX = (window.innerWidth - (VIRTUAL_WIDTH * scale)) / 2;
    offsetY = (window.innerHeight - (VIRTUAL_HEIGHT * scale)) / 2;
}

    function init() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    
    // --- 1. SETUP SCALING ---
    // Apply initial size and event listener for future window resizing
    resize();
    window.addEventListener('resize', resize);

        
        // Init Grid
        for (let x = 0; x < COLS; x++) {
            grid[x] = [];
            for (let y = 0; y < ROWS; y++) {
                grid[x][y] = new Cell(x, y);
                grid[x][y].wallHp = 100;
            }
        }

        // --- BASE OCCUPANCY (2x2) ---
        // Mark the 4 cells covered by the base as occupied so nothing can be built there
        for(let i = 0; i < 2; i++) {
            for(let j = 0; j < 2; j++) {
                let bx = playerBase.x + i;
                let by = playerBase.y + j;
                if (bx >= 0 && bx < COLS && by >= 0 && by < ROWS) {
                    grid[bx][by].occupied = true; 
                }
            }
        }

         // --- 4. BORDERS ---
    // Wall off Top and Bottom
    for (let x = 0; x < COLS; x++) {
        grid[x][0].wall = true;
        grid[x][ROWS - 1].wall = true; 
    }
    // Wall off Left side
    for (let y = 0; y < ROWS; y++) {
        grid[0][y].wall = true;
    }

    // --- 5. INPUT LISTENERS (With Scaling Math) ---
    
    // Helper to calculate Game Coordinates from Screen Coordinates
    function updateMousePos(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        
        // 1. Get position relative to canvas element
        let rawX = clientX - rect.left;
        let rawY = clientY - rect.top;

        // 2. Subtract the black bars (offset) and divide by the zoom level (scale)
        mouseX = (rawX - offsetX) / scale;
        mouseY = (rawY - offsetY) / scale;
    }

        // --- INPUT LISTENERS ---
        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            updateMousePos(e.clientX, e.clientY);
            handleInput(); 
        });

        window.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        // Track mouse position AND handle dragging
        // (This is the correct one using getBoundingClientRect)
        window.addEventListener('mousemove', (e) => {
            updateMousePos(e.clientX, e.clientY);
            
            if (isMouseDown) {
                handleInput();
            }
        });

        window.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();

        // Tools
        if(key === '1') setTool('wall');
        if(key === '2') setTool('troop');
        if(key === '3') setTool('barracks');
        if(key === '4') setTool('mortar');
        if(key === '5') setTool('delete');
        if(key === '6') setTool('trap'); // Added trap back in if you have it
        if(key === '7') setTool('wall_turret');
        if(key === '8') setTool('money_farm');
        if(key === '9') setTool('sword_troop');
        if(key === 's') setTool('shield_troop');
        if(key === "t") setTool('tesla');        
        if(key === "f") setTool('flamethrower');
        if(key === "v") setTool('sucker');
        if(key === "y") setTool('bounty');
        if(key === "p") setTool('tripwire');
        if(key === "d") setTool('drill');
        
        // Rotation
        if (key === 'r') {
            buildRotation = (buildRotation + Math.PI / 2) % (Math.PI * 2);
        }
    });

        // --- GAME START ---
        updateFlowField();
        
        // NEW: Trigger the first wave + Animation immediately
        wave = 0; 
        startNextWave(); 

        requestAnimationFrame(gameLoop);
    }

   // ‚îÄ‚îÄ‚îÄ THREAT MAP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
   // Scores how dangerous each grid cell is based on nearby combat structures.
   // Used by Dijkstra to make enemies prefer unguarded routes.
   // Open corridor cells covered by flamethrowers/turrets cost more to traverse,
   // so enemies actively seek the least-defended gap.
   let _threatMap = null;
   const _THREAT_RADIUS = 5; // cells of influence per turret

   function _isTurretStructure(s) {
       return (s instanceof FlamethrowerTower || s instanceof Minigun ||
               s instanceof Mortar           || s instanceof WallTurret ||
               s instanceof CryoTower        || s instanceof TeslaTower ||
               s instanceof Railgun          || s instanceof BountyTower ||
               s instanceof SuckerTower);
   }

   function _buildThreatMap() {
       if (!_threatMap) _threatMap = new Float32Array(COLS * ROWS);
       else _threatMap.fill(0);

       for (let s of structures) {
           if (!_isTurretStructure(s)) continue;
           let sc = Math.floor(s.x / CELL_SIZE);
           let sr = Math.floor(s.y / CELL_SIZE);
           for (let dc = -_THREAT_RADIUS; dc <= _THREAT_RADIUS; dc++) {
               for (let dr = -_THREAT_RADIUS; dr <= _THREAT_RADIUS; dr++) {
                   let c = sc + dc, r = sr + dr;
                   if (c < 0 || c >= COLS || r < 0 || r >= ROWS) continue;
                   let d = Math.max(Math.abs(dc), Math.abs(dr));
                   _threatMap[c + r * COLS] += Math.max(0, _THREAT_RADIUS - d + 1);
               }
           }
       }
   }

   function updateFlowField() {
        // 1. Rebuild threat map
        _buildThreatMap();

        // 2. Reset grid
        for (let x = 0; x < COLS; x++) {
            for (let y = 0; y < ROWS; y++) {
                grid[x][y].distance = Infinity;
                grid[x][y].vecX = 0;
                grid[x][y].vecY = 0;
            }
        }

        // 3. Dijkstra flood-fill from base.
        //    Open cells cost 1. Walls cost a LOT (200 base + wallHp + threat bonus)
        //    so enemies strongly prefer open paths but will still eventually
        //    pick the weakest/least-defended wall when blocked.
        //    Uses a simple binary min-heap for O(n log n) performance.

        const _OPEN_COST    = 1;
        const _WALL_BASE    = 200;
        const _THREAT_SCALE = 12;

        // Binary min-heap
        let _heap = [];
        function _heapPush(item) {
            _heap.push(item);
            let i = _heap.length - 1;
            while (i > 0) {
                let p = (i - 1) >> 1;
                if (_heap[p].d <= _heap[i].d) break;
                let tmp = _heap[p]; _heap[p] = _heap[i]; _heap[i] = tmp;
                i = p;
            }
        }
        function _heapPop() {
            let top = _heap[0];
            let last = _heap.pop();
            if (_heap.length > 0) {
                _heap[0] = last;
                let i = 0;
                for (;;) {
                    let l = 2*i+1, r = 2*i+2, s = i;
                    if (l < _heap.length && _heap[l].d < _heap[s].d) s = l;
                    if (r < _heap.length && _heap[r].d < _heap[s].d) s = r;
                    if (s === i) break;
                    let tmp = _heap[i]; _heap[i] = _heap[s]; _heap[s] = tmp;
                    i = s;
                }
            }
            return top;
        }

        if (playerBase.x >= 0 && playerBase.x < COLS &&
            playerBase.y >= 0 && playerBase.y < ROWS) {
            let bc = grid[playerBase.x][playerBase.y];
            bc.distance = 0;
            _heapPush({ d: 0, cell: bc });
        }

        const _dirs4 = [{x:0,y:-1},{x:0,y:1},{x:-1,y:0},{x:1,y:0}];

        while (_heap.length > 0) {
            let { d, cell } = _heapPop();
            if (d > cell.distance) continue; // stale entry

            for (let n of _dirs4) {
                let nx = cell.x + n.x;
                let ny = cell.y + n.y;
                if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS) continue;

                let next = grid[nx][ny];
                let threat = _threatMap ? _threatMap[nx + ny * COLS] : 0;
                // Walls are very expensive; open cells in danger zones cost
                // proportionally more so enemies route around defended corridors.
                let cost = next.wall
                    ? _WALL_BASE + (next.wallHp || 100) + threat * _THREAT_SCALE
                    : _OPEN_COST + threat * 8;

                let nd = cell.distance + cost;
                if (nd < next.distance) {
                    next.distance = nd;
                    next.vecX = -n.x;
                    next.vecY = -n.y;
                    _heapPush({ d: nd, cell: next });
                }
            }
        }
    }

    function updateLockedButtons() {
    // 1. Define the Map: Button ID -> Skill ID needed
    const lockMap = {
        'btn-sword':      'unlock_sword',
        'btn-shield':     'unlock_shield',
        'btn-bard':       'unlock_bard',
        'btn-wallturret': 'unlock_wall_turret',
        'btn-trap':       'unlock_spikes',
        'btn-cryo':       'unlock_cryo',
        'btn-farm':       'unlock_farm',
        'btn-barracks':   'unlock_barracks',
        'btn-minigun':    'unlock_minigun',
        'btn-mortar':     'unlock_mortar',
        'btn-sucker':     'unlock_sucker',
        'btn-tesla':      'unlock_tesla',
        'btn-railgun':    'unlock_railgun'
    };

    // 2. Loop through every button
    for (const [btnId, skillId] of Object.entries(lockMap)) {
        const btn = document.getElementById(btnId);
        
        if (btn) {
            // Check if we have the skill
            if (playerProgress.unlocked.includes(skillId)) {
                // UNLOCKED: Remove the lock class
                btn.classList.remove('is-locked');
            } else {
                // LOCKED: Add the lock class
                btn.classList.add('is-locked');
            }
        }
    }
}

    // TOOL SELECTION FUNCTION
    function setTool(toolName) {
    // --- 1. CHECK IF LOCKED ---
    // Mapping Tool Names to Button IDs for checking the class
    let btnIdCheck = '';
    switch(toolName) {
        case 'sword_troop': btnIdCheck = 'btn-sword'; break;
        case 'shield_troop':btnIdCheck = 'btn-shield'; break;
        case 'bard_troop':  btnIdCheck = 'btn-bard'; break;
        case 'wall_turret': btnIdCheck = 'btn-wallturret'; break;
        case 'trap':        btnIdCheck = 'btn-trap'; break;
        case 'cryo_tower':  btnIdCheck = 'btn-cryo'; break;
        case 'money_farm':  btnIdCheck = 'btn-farm'; break;
        case 'barracks':    btnIdCheck = 'btn-barracks'; break;
        case 'minigun':     btnIdCheck = 'btn-minigun'; break;
        case 'mortar':      btnIdCheck = 'btn-mortar'; break;
        case 'sucker':      btnIdCheck = 'btn-sucker'; break;
        case 'railgun':     btnIdCheck = 'btn-railgun'; break;
        case 'bounty':      btnIdCheck = 'btn-bounty'; break; // <-- NEW BOUNTY TOWER ADDED HERE
        case 'tripwire':    btnIdCheck = 'btn-tripwire'; break;
        case 'drill':       btnIdCheck = 'btn-drill'; break;
    }

    // If the button exists and has the 'is-locked' class, STOP.
    const btnCheck = document.getElementById(btnIdCheck);
    if (btnCheck && btnCheck.classList.contains('is-locked')) {
        console.log("This item is locked.");
        return; 
    }

    // --- 2. NORMAL SELECTION LOGIC ---
    currentTool = toolName;
    
    const buttons = document.getElementsByClassName('tool-btn');
    for (let i = 0; i < buttons.length; i++) {
        buttons[i].classList.remove('active');
    }

    // Re-use the ID we found above to set active state
    if (btnIdCheck) {
        const btn = document.getElementById(btnIdCheck);
        if (btn) btn.classList.add('active');
    } else {
        // Handle special cases not in the lock list (like Wall or Delete)
        if (toolName === 'wall') document.getElementById('btn-wall').classList.add('active');
        if (toolName === 'delete') document.getElementById('btn-delete').classList.add('active');
    }
}


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ACHIEVEMENTS ENGINE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const ACHIEVEMENTS = [
    // ‚îÄ‚îÄ EASY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    { id:'ach_first_blood',  name:'First Blood',         icon:'ü©∏', rarity:'normal',
      desc:'Survive your first wave.',
      check: () => wave > 1 },

    { id:'ach_builder',      name:'Architect',           icon:'üèóÔ∏è', rarity:'normal',
      desc:'Place 10 structures in a single run.',
      check: () => achStats.structuresPlaced >= 10 },

    { id:'ach_cash_money',   name:'Deep Pockets',        icon:'üí∞', rarity:'normal',
      desc:'Accumulate $2,000 at once.',
      check: () => (typeof money !== 'undefined' && money >= 2000) },

    { id:'ach_scout',        name:'Field Intel',         icon:'üîç', rarity:'normal',
      desc:'Discover 5 different enemy types.',
      check: () => seenEnemies.size >= 5 },

    { id:'ach_wave_5',       name:'Holding the Line',    icon:'üõ°Ô∏è', rarity:'normal',
      desc:'Reach Wave 5.',
      check: () => wave >= 5 },

    { id:'ach_full_hp',      name:'Flawless',            icon:'‚ú®', rarity:'normal',
      desc:'Complete a wave without losing any HP.',
      check: () => achStats.flawlessWave },

    { id:'ach_wall_fan',     name:'Wall Fanatic',        icon:'üß±', rarity:'normal',
      desc:'Place 20 walls in a single run.',
      check: () => achStats.wallsPlaced >= 20 },

    { id:'ach_fire_starter', name:'Fire Starter',        icon:'üî•', rarity:'normal',
      desc:'Place a Flamethrower Tower.',
      check: () => achStats.flamethrowerPlaced },

    // ‚îÄ‚îÄ MEDIUM ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    { id:'ach_wave_15',      name:'Veteran Commander',   icon:'‚≠ê', rarity:'normal',
      desc:'Reach Wave 15.',
      check: () => wave >= 15 },

    { id:'ach_all_intel',    name:'Know Your Enemy',     icon:'üìñ', rarity:'normal',
      desc:'Discover all enemy types.',
      check: () => seenEnemies.size >= 14 },

    { id:'ach_electrician',  name:'Thunderstruck',       icon:'‚ö°', rarity:'normal',
      desc:'Place 3 Tesla Coils in one run.',
      check: () => achStats.teslaPlaced >= 3 },

    { id:'ach_economy',      name:'War Economy',         icon:'üè¶', rarity:'normal',
      desc:'Earn $500 from Money Farms in one run.',
      check: () => achStats.farmIncome >= 500 },

    // ‚îÄ‚îÄ HARD ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    { id:'ach_wave_25',      name:'Endless War',         icon:'üåë', rarity:'hard',
      desc:'Reach Wave 25.',
      check: () => wave >= 25 },

    { id:'ach_railgun',      name:'Railgun Commander',   icon:'üí•', rarity:'hard',
      desc:'Place a Titan Railgun.',
      check: () => achStats.railgunPlaced },

    { id:'ach_big_spender',  name:'Arms Dealer',         icon:'ü§ë', rarity:'hard',
      desc:'Spend $10,000 total in one run.',
      check: () => achStats.totalSpent >= 10000 },

    { id:'ach_genocide',     name:'Exterminator',        icon:'‚ò†Ô∏è', rarity:'hard',
      desc:'Kill 500 enemies in one run.',
      check: () => achStats.killsThisRun >= 500 },

    { id:'ach_fortress',     name:'Fortress',            icon:'üè∞', rarity:'hard',
      desc:'Have 5 different tower types active simultaneously.',
      check: () => achStats.uniqueTowerTypes >= 5 },

    // ‚îÄ‚îÄ LEGENDARY ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    { id:'ach_wave_40',      name:'The Last Stand',      icon:'üëë', rarity:'legendary',
      desc:'Reach Wave 40. A true commander.',
      check: () => wave >= 40 },

    { id:'ach_nightmare',    name:'Nightmare Survivor',  icon:'üíÄ', rarity:'legendary',
      desc:'Reach Wave 20 on Nightmare difficulty.',
      check: () => (typeof currentDifficulty !== 'undefined' && currentDifficulty === 'extreme' && wave >= 20) },

    { id:'ach_perfect_run',  name:'Untouchable',         icon:'üåü', rarity:'legendary',
      desc:'Reach Wave 10 without taking any base damage.',
      check: () => achStats.noDamageTaken && wave >= 10 },
];

// Per-run stats reset each game. Persistent stats live in playerProgress.
let achStats = {
    structuresPlaced: 0,
    wallsPlaced:      0,
    flamethrowerPlaced: false,
    teslaPlaced:      0,
    railgunPlaced:    false,
    killsThisRun:     0,
    totalSpent:       0,
    farmIncome:       0,
    flawlessWave:     false,
    noDamageTaken:    true,
    uniqueTowerTypes: 0,
};

// Ensure achievement save array exists
if (!playerProgress.achievements) playerProgress.achievements = [];

function _refreshUniqueTowers() {
    const types = new Set();
    for (let s of structures) {
        types.add(s.constructor.name);
    }
    achStats.uniqueTowerTypes = types.size;
}

function checkAchievements() {
    _refreshUniqueTowers();
    let anyNew = false;
    for (let a of ACHIEVEMENTS) {
        if (playerProgress.achievements.includes(a.id)) continue;
        try {
            if (a.check()) {
                playerProgress.achievements.push(a.id);
                saveProgress();
                showAchievementToast(a);
                anyNew = true;
            }
        } catch(e) {}
    }
    return anyNew;
}

let _achToastQueue = [];
let _achToastRunning = false;
function showAchievementToast(ach) {
    _achToastQueue.push(ach);
    if (!_achToastRunning) _runToastQueue();
}
function _runToastQueue() {
    if (_achToastQueue.length === 0) { _achToastRunning = false; return; }
    _achToastRunning = true;
    let a = _achToastQueue.shift();
    const toast = document.getElementById('ach-toast');
    document.getElementById('ach-toast-icon').textContent = a.icon;
    document.getElementById('ach-toast-name').textContent = a.name;
    toast.classList.add('show');
    setTimeout(() => {
        toast.classList.remove('show');
        setTimeout(_runToastQueue, 500);
    }, 3500);
}

function openAchievements() {
    const overlay = document.getElementById('achievements-overlay');
    const grid    = document.getElementById('ach-grid-container');
    const prog    = document.getElementById('ach-progress-label');
    const unlocked = playerProgress.achievements || [];
    prog.textContent = `${unlocked.length} / ${ACHIEVEMENTS.length} Unlocked`;

    grid.innerHTML = '';
    for (let a of ACHIEVEMENTS) {
        const isUnlocked = unlocked.includes(a.id);
        const item = document.createElement('div');
        item.className = 'ach-item ' + (isUnlocked ? 'unlocked' : 'locked');
        item.dataset.rarity = a.rarity;
        item.innerHTML = `
            <div class="ach-icon">${a.icon}</div>
            <div class="ach-text">
                <div class="ach-name">${isUnlocked ? a.name : '???'}</div>
                <div class="ach-desc">${isUnlocked ? a.desc : 'Not yet unlocked'}</div>
            </div>
            ${isUnlocked ? '<div class="ach-check">‚úî</div>' : ''}
        `;
        grid.appendChild(item);
    }
    overlay.style.display = 'flex';
}
function closeAchievements() {
    document.getElementById('achievements-overlay').style.display = 'none';
}

    function handleInput() {
        if (gameOver) return;

        // Calculate Grid Coordinates of the mouse
        let col = Math.floor(mouseX / CELL_SIZE);
        let row = Math.floor(mouseY / CELL_SIZE);

        // Bounds Check
        if (col < 0 || col >= COLS || row < 0 || row >= ROWS) return;

        let cell = grid[col][row];
        let didChange = false; 

        // --- WALL TOOL ---
        if (currentTool === 'wall') {
            if (!cell.wall && !cell.occupied && money >= 10) {
                cell.wall = true;
                cell.wallHp = 100;
                money -= 10;
                achStats.wallsPlaced++;
                achStats.structuresPlaced++;
                achStats.totalSpent += 10;
                checkAchievements();
                didChange = true;
            }
        }
        
        // --- DELETE TOOL (ROBUST FIX) ---
       else if (currentTool === 'delete') {
            let deletedSomething = false;

            // 1. Remove Traps
            for (let i = traps.length - 1; i >= 0; i--) {
                let t = traps[i];
                // Traps store grid coordinates (col, row)
                if (t.col === col && t.row === row) {
                    traps.splice(i, 1);
                    money += 20; // Refund half of $40
                    deletedSomething = true;
                    // Traps usually don't block paths, so didChange might not be needed, 
                    // but we set it just in case logic changes later.
                }
            }

            // 2. Remove Structures (Prioritize over walls to fix Wall Turret issue)
            // 2. Remove Structures (Prioritize over walls)
        for (let i = structures.length - 1; i >= 0; i--) {
            let s = structures[i];
            
            // Calculate center of structure for clicking
            // If it's a MoneyFarm, it's 2x2 (100x100px), else it's 1x1 (50x50px)
            let size = (s instanceof MoneyFarm) ? CELL_SIZE * 2 : CELL_SIZE;
            let sx = s.col * CELL_SIZE;
            let sy = s.row * CELL_SIZE;

            // Simple AABB collision for the mouse click
            if (mouseX >= sx && mouseX < sx + size &&
                mouseY >= sy && mouseY < sy + size) {
                
                // --- FIX STARTS HERE ---
                // 1. Check if the structure has a special cleanup method (like MoneyFarm)
                if (typeof s.cleanup === 'function') {
                    s.cleanup();
                } 
                // 2. Fallback for standard 1x1 structures
                else {
                    let c = grid[s.col][s.row];
                    c.occupied = false;
                    if (c.wall) {
                        c.wall = false;
                        c.wallHp = 100;
                    }
                    updateFlowField();
                }
                // --- FIX ENDS HERE ---

                structures.splice(i, 1); // Remove from array
                money += (s instanceof MoneyFarm) ? 175 : (s instanceof DrillTower) ? 125 : 100; // Refund (Example amounts)
                
                deletedSomething = true;
                didChange = true;
                break; 
            }
        }

            // 3. Remove Generic Walls (Only if no structure was found)
            // This handles standard walls that don't have buildings on them.
            if (!deletedSomething && cell.wall) {
                cell.wall = false;
                cell.wallHp = 100;
                money += 5;
                didChange = true;
            }
        }

        // --- PLACEMENT TOOLS ---
        else if (currentTool === 'bard_troop') {
             if (money >= 100) {
                 allies.push(new BardTroop(mouseX, mouseY));
                 money -= 100;
             }
        }
        else if (currentTool === 'troop') {
             if (money >= 10) {
                 allies.push(new Soldier(mouseX, mouseY));
                 money -= 10;
             }
        }
        else if (currentTool === 'sword_troop') {
            // Cost Check ($50)
            if (money >= 50) {
                // Spawn the ally at mouse position
                allies.push(new SwordTroop(mouseX, mouseY));
                money -= 50;
                
                // Optional: Particle effect on spawn
                createParticles(mouseX, mouseY, "#00ffff", 10);
            }
        }
        // Inside the tool placement logic (handleInput function)
        else if (currentTool === 'shield_troop') {
            if (money >= 75) {
                allies.push(new ShieldSoldier(mouseX, mouseY));
                money -= 75;
                // Optional spawn effect
                if(typeof createParticles === 'function') createParticles(mouseX, mouseY, "#0088aa", 10);
            }
        }
        else if (currentTool === 'barracks') {
            if (!cell.wall && !cell.occupied && money >= 200) {
                structures.push(new Barracks(col, row));
                cell.occupied = true;
                money -= 200;
                didChange = true; 
            }
        }
        else if (currentTool === 'mortar') {
            if (!cell.wall && !cell.occupied && money >= 200) {
                // Pass col/row as expected by your class
                structures.push(new Mortar(col, row));
                cell.occupied = true;
                money -= 200;
                didChange = true;
            }
        }
        else if (currentTool === 'trap') {
            if (!cell.wall && !cell.occupied && money >= 40) {
                traps.push(new Trap(mouseX, mouseY));
                cell.occupied = true; // Prevent building on top of it
                money -= 40;
                didChange = true;
            }
        }
        // Inside handleInput(x, y) ...

        else if (currentTool === 'wall_turret') {
            // Check if valid spot: Not occupied AND NOT a Wall
            if (!cell.occupied && !cell.wall && money >= 150) {
                // 1. Create the Turret (Pass buildRotation so it faces the right way!)
                let angle = (typeof buildRotation !== 'undefined') ? buildRotation : 0;
                structures.push(new WallTurret(col, row, angle));

                // 2. Make it a "Wall" in the grid
                cell.occupied = true;
                cell.wall = true;      // <--- Enemies still see it as a wall
                cell.wallHp = 300;     // <--- Sets HP to full (300/300)

                // 3. Update Enemy Pathfinding
                updateFlowField(); 
                money -= 150;
                didChange = true;
            }
        }
        else if (currentTool === 'flamethrower') {
            if (!cell.wall && !cell.occupied && money >= 350) {
                structures.push(new FlamethrowerTower(col, row));
                cell.occupied = true;
                cell.wall = true;
                cell.wallHp = 400;
                money -= 350;
                achStats.structuresPlaced++;
                achStats.flamethrowerPlaced = true;
                achStats.totalSpent += 350;
                checkAchievements();
                didChange = true;
                createParticles(mouseX, mouseY, "#ff4500", 20);
            }
        }
        else if (currentTool === 'tripwire') {
            if (!cell.wall && !cell.occupied && money >= 60) {
                const pylon = new TripwirePylon(col, row);
                structures.push(pylon);
                cell.occupied = true;
                cell.wall = true;
                cell.wallHp = 100;
                money -= 60;
                achStats.structuresPlaced++;
                achStats.totalSpent += 60;
                didChange = true;
                createParticles(mouseX, mouseY, "#00ddff", 12);
                // No didChange ‚Äî pylons don't block pathfinding
            }
        }
        else if (currentTool === 'tesla') {
            // Check constraints: Not on a wall, not occupied, have enough money
            if (!cell.wall && !cell.occupied && money >= 250) {
                structures.push(new TeslaTower(col, row));
                cell.occupied = true; // Mark spot as taken
                money -= 250;
                achStats.structuresPlaced++;
                achStats.teslaPlaced++;
                achStats.totalSpent += 250;
                checkAchievements();
                didChange = true;
            }
        }
        else if (currentTool === 'minigun') {
            if (!cell.wall && !cell.occupied && money >= 400) {
                cell.occupied = true;
                cell.wall = true;
                cell.wallHp = 300;
                money -= 400;
                achStats.structuresPlaced++;
                achStats.totalSpent += 400;
                checkAchievements();
                didChange = true;
                
                // Spawn Effect
                createParticles(mouseX, mouseY, "#ffff00", 15);
            }
        }
        else if (currentTool === 'cryo_tower') {
            if (!cell.wall && !cell.occupied && money >= 100) {
                structures.push(new CryoTower(col, row));
                cell.occupied = true;
                cell.wall = true;      // <--- Enemies still see it as a wall
                cell.wallHp = 300;
                money -= 100;
                didChange = true;
                
                // Spawn Effect
                createParticles(mouseX, mouseY, "#ffff00", 15);
            }
        } else if (currentTool === 'sucker') {
            if (!cell.wall && !cell.occupied && money >= 150) {
                structures.push(new SuckerTower(col, row));
                cell.occupied = true;
                cell.wall = true;      // Enemies must path around or attack it
                cell.wallHp = 150;     // Give it some health (adjust as needed)
                money -= 150;
                didChange = true;
                
                // Spawn Effect (Wind/Light Blue particles)
                createParticles(mouseX, mouseY, "#aaddff", 15);
            }
        } else if (currentTool === 'railgun') {
            if (money >= 1500) {
                // Determine dimensions based on current rotation (0 or PI = horizontal, PI/2 or 3PI/2 = vertical)
                let isHorizontal = Math.abs(Math.sin(buildRotation)) < 0.1;
                let wCells = isHorizontal ? 3 : 2;
                let hCells = isHorizontal ? 2 : 3;

                // Prevent placing out of bounds
                if (col + wCells > COLS || row + hCells > ROWS) return;

                // Check if ALL cells in the footprint are free
                let canPlace = true;
                for (let i = 0; i < wCells; i++) {
                    for (let j = 0; j < hCells; j++) {
                        if (grid[col + i][row + j].wall || grid[col + i][row + j].occupied) {
                            canPlace = false;
                            break;
                        }
                    }
                }

                if (canPlace) {
                    // Push the new railgun
                    structures.push(new Railgun(col, row, buildRotation));
                    
                    // Mark all grid cells in the footprint as occupied
                    for (let i = 0; i < wCells; i++) {
                        for (let j = 0; j < hCells; j++) {
                            grid[col + i][row + j].occupied = true;
                            grid[col + i][row + j].wall = true;
                            grid[col + i][row + j].wallHp = 1000; // Strong base health
                        }
                    }
                    money -= 1500;
                    achStats.structuresPlaced++;
                    achStats.railgunPlaced = true;
                    achStats.totalSpent += 1500;
                    checkAchievements();
                    didChange = true;
                    
                    // Optional spawn effect
                    if (typeof createParticles === 'function') createParticles(mouseX, mouseY, "#00ffff", 30);
                }
            }
        }
        else if (currentTool === 'money_farm') {
            let cost = 350;
            
            // Check bounds (needs 2x2 space)
            if (col + 1 >= COLS || row + 1 >= ROWS) return;

            // Check if area is clear (4 cells)
            let isClear = true;
            for(let i=0; i<2; i++) {
                for(let j=0; j<2; j++) {
                    let c = grid[col+i][row+j];
                    if (c.occupied || c.wall) isClear = false;
                }
            }

            if (isClear && money >= cost) {
                money -= cost;
                structures.push(new MoneyFarm(col, row));

                // Mark the 4 cells as "Walls" with LOW HP
                for(let i=0; i<2; i++) {
                    for(let j=0; j<2; j++) {
                        let c = grid[col+i][row+j];
                        c.occupied = true;
                        c.wall = true;
                        c.wallHp = 30; 
                    }
                }
                
                // --- FIX STARTS HERE ---
                // Force the enemies to recalculate their paths immediately
                updateFlowField(); 
                // --- FIX ENDS HERE ---

                didChange = true;
            }
        }
        else if (currentTool === 'drill') {
            let cost = 500;
            if (col + 1 >= COLS || row + 1 >= ROWS) return;
            let isClear = true;
            for (let i = 0; i < 2; i++) {
                for (let j = 0; j < 2; j++) {
                    let c = grid[col+i][row+j];
                    if (c.occupied || c.wall) isClear = false;
                }
            }
            const _drillCount = structures.filter(s => s instanceof DrillTower).length;
            if (isClear && money >= cost && _drillCount < 10) {
                money -= cost;
                achStats.totalSpent += cost;
                structures.push(new DrillTower(col, row));
                for (let i = 0; i < 2; i++) {
                    for (let j = 0; j < 2; j++) {
                        let c = grid[col+i][row+j];
                        c.occupied = true;
                        c.wall     = true;
                        c.wallHp   = 50;
                    }
                }
                achStats.structuresPlaced++;
                updateFlowField();
                createParticles(col*CELL_SIZE + CELL_SIZE, row*CELL_SIZE + CELL_SIZE, "#f5c518", 15);
                didChange = true;
            }
        }
        else if (currentTool === 'bounty') {
            if (!cell.wall && !cell.occupied && money >= 150) {
                structures.push(new BountyTower(col, row)); 
                cell.occupied = true;
                money -= 150;
                didChange = true;
            }
        }
        // --- OPTIMIZATION ---
        // Only recalculate paths if the map layout changed (Walls or Buildings)
        if (didChange) {
            updateFlowField();
        }
    }

    function takeDamage(amount) {
    playerBase.hp -= amount;
    // Track for achievements
    if (typeof achStats !== 'undefined') {
        achStats.noDamageTaken  = false;
        achStats._waveFlawless  = false;  // this wave is not flawless
    }
    
    if (playerBase.hp <= 0) {
        playerBase.hp = 0;
        gameOver = true;

        // --- NEW: Calculate Shards ---
        // 1 Shard per wave, plus a bonus 10 shards if you pass Wave 10
        let shardsEarned = Math.floor(wave)*difficultyMultiplier;

        // --- NEW: Save to Skill Tree ---
        if (typeof playerProgress !== 'undefined') {
            playerProgress.shards += shardsEarned;
            saveProgress(); // Saves to LocalStorage
        }

        // --- Show Game Over Screen ---
        const gameOverScreen = document.getElementById('game-over');
        gameOverScreen.style.display = 'flex';
        
        // Update Wave Count
        document.getElementById('final-wave').innerText = wave;

        // --- NEW: Show Shards Earned on UI ---
        // We try to find an element to show shards, or create one if it's missing
        let shardDisplay = document.getElementById('earned-shards-text');
        
        if (!shardDisplay) {
            // Dynamically create the text element if you haven't added it to HTML yet
            shardDisplay = document.createElement('div');
            shardDisplay.id = 'earned-shards-text';
            shardDisplay.style.color = '#a388ee'; // Void Purple
            shardDisplay.style.fontSize = '24px';
            shardDisplay.style.marginTop = '15px';
            shardDisplay.style.fontWeight = 'bold';
            
            // Append it to the game over content
            // Assuming the parent of 'final-wave' is the main box
            document.getElementById('final-wave').parentNode.appendChild(shardDisplay);
        }
        
        shardDisplay.innerText = `+${shardsEarned} Void Shards`;
    }
}

    function createParticles(x, y, color, count) {
        for(let i=0; i<count; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 6,
                vy: (Math.random() - 0.5) * 6,
                life: 20,
                color: color
            });
        }
    }

    // Physics: Soft Collision / Separation Logic
    // ‚îÄ‚îÄ SPATIAL HASH for separation ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Rebuilt once per frame before enemies update (called from the game loop
    // via _rebuildSpatialHash). Each cell covers SEP_CELL_SIZE px.
    const _SEP_CELL  = 40; // px per spatial bucket
    let _spatialHash = new Map();

    function _rebuildSpatialHash() {
        _spatialHash.clear();
        for (let e of enemies) {
            let bx = Math.floor(e.x / _SEP_CELL);
            let by = Math.floor(e.y / _SEP_CELL);
            let key = bx + ',' + by;
            if (!_spatialHash.has(key)) _spatialHash.set(key, []);
            _spatialHash.get(key).push(e);
        }
    }

    function separate(entity, neighbors, pushStrength) {
        // Use spatial hash for enemies (fast); fall back to linear for small lists
        let list = neighbors;
        if (neighbors === enemies && _spatialHash.size > 0) {
            list = [];
            let bx = Math.floor(entity.x / _SEP_CELL);
            let by = Math.floor(entity.y / _SEP_CELL);
            for (let dx2 = -1; dx2 <= 1; dx2++) {
                for (let dy2 = -1; dy2 <= 1; dy2++) {
                    let bucket = _spatialHash.get((bx+dx2) + ',' + (by+dy2));
                    if (bucket) for (let e of bucket) list.push(e);
                }
            }
        }

        // Apply separation as a velocity impulse, NOT a direct position change.
        // Direct position pushes cause frame-to-frame jitter and can bypass wall
        // collision. Velocity impulses are smoothed out by the physics and capped
        // so they can never fling an entity more than ~0.5px per frame.
        const MAX_SEP_IMPULSE = 0.5;

        for (let other of list) {
            if (entity === other) continue;
            let dx = entity.x - other.x;
            let dy = entity.y - other.y;
            let distSq = dx * dx + dy * dy;
            let minDist = (entity.radius + other.radius) * 1.05;
            if (distSq > 0 && distSq < minDist * minDist) {
                let dist = Math.sqrt(distSq);
                let overlap = (minDist - dist) / minDist; // 0..1, deeper = stronger
                let impulse = Math.min(overlap * pushStrength, MAX_SEP_IMPULSE);
                entity.vx += (dx / dist) * impulse;
                entity.vy += (dy / dist) * impulse;
            }
        }
    }

    function resolveWallCollision(entity) {
        // 1. Keep in bounds
        let mapWidth  = COLS * CELL_SIZE;
        let mapHeight = ROWS * CELL_SIZE;
        if (entity.x < entity.radius)             { entity.x = entity.radius;             if (entity.vx < 0) entity.vx = 0; }
        if (entity.y < entity.radius)             { entity.y = entity.radius;             if (entity.vy < 0) entity.vy = 0; }
        if (entity.x > mapWidth  - entity.radius) { entity.x = mapWidth  - entity.radius; if (entity.vx > 0) entity.vx = 0; }
        if (entity.y > mapHeight - entity.radius) { entity.y = mapHeight - entity.radius; if (entity.vy > 0) entity.vy = 0; }

        // 2. Grid wall collision ‚Äî SAT on separate axes + corner repulsion.
        //
        // CORNER REPULSION: enemies naturally hug wall corners because the
        // SAT push is axis-aligned and leaves them sitting exactly on the
        // corner edge. We add a small extra radius (CORNER_BUF) that only
        // applies when the entity is close to a wall corner, pushing them
        // off the corner and along the face instead.
        // CORNER_BUF scales with entity size but is capped so that
        // r + CORNER_BUF < CELL_SIZE/2, ensuring even the largest enemy
        // (radius 22) can still pass through a 1-cell (50px) gap.
        // Without the cap: r=22 ‚Üí rExt=28, 28+28=56 > 50 ‚Üí blocked forever.
        const CORNER_BUF = Math.min(6, CELL_SIZE * 0.5 - entity.radius - 1);
        if (CORNER_BUF <= 0) {
            // Entity is too large for corner repulsion ‚Äî skip it entirely,
            // just do standard face-only collision below.
        }

        let r = entity.radius;
        let rExt = r + Math.max(0, CORNER_BUF); // expanded radius for corner detection
        let minC  = Math.floor((entity.x - rExt) / CELL_SIZE);
        let maxC  = Math.floor((entity.x + rExt) / CELL_SIZE);
        let minRr = Math.floor((entity.y - rExt) / CELL_SIZE);
        let maxRr = Math.floor((entity.y + rExt) / CELL_SIZE);

        for (let c = minC; c <= maxC; c++) {
            for (let row = minRr; row <= maxRr; row++) {
                if (c < 0 || c >= COLS || row < 0 || row >= ROWS) continue;
                if (!grid[c][row].wall) continue;

                let wx0 = c   * CELL_SIZE;
                let wy0 = row * CELL_SIZE;
                let wx1 = wx0 + CELL_SIZE;
                let wy1 = wy0 + CELL_SIZE;

                // Find closest point on this wall cell to the entity center
                let closestX = Math.max(wx0, Math.min(entity.x, wx1));
                let closestY = Math.max(wy0, Math.min(entity.y, wy1));
                let distX    = entity.x - closestX;
                let distY    = entity.y - closestY;
                let distSq   = distX * distX + distY * distY;

                // Is the closest point a corner? (both axes contribute to distance)
                let isCorner = (closestX > wx0 && closestX < wx1)
                             ? false   // closest point is on top/bottom face ‚Äî not a corner
                             : (closestY > wy0 && closestY < wy1)
                             ? false   // closest point is on left/right face ‚Äî not a corner
                             : true;  // closest point is one of the 4 corners

                // For large entities (CORNER_BUF <= 0), skip corner repulsion
                // entirely so they can still pass through 1-cell gaps.
                let effectiveR = (isCorner && CORNER_BUF > 0) ? rExt : r;

                if (distSq >= effectiveR * effectiveR || distSq <= 0) continue;

                let dist    = Math.sqrt(distSq);
                let overlap = effectiveR - dist;
                let nx      = distX / dist;
                let ny      = distY / dist;

                if (isCorner && CORNER_BUF > 0) {
                    // Soft corner repulsion: push via velocity, not position snap.
                    let pushScale = overlap / CORNER_BUF; // 0..1, safe since CORNER_BUF > 0
                    entity.vx += nx * pushScale * 1.5;
                    entity.vy += ny * pushScale * 1.5;
                } else {
                    // Face collision: axis-aligned push (original SAT behavior).
                    // Push along the axis with the smaller penetration.
                    let overlapX = Math.min(entity.x + r, wx1) - Math.max(entity.x - r, wx0);
                    let overlapY = Math.min(entity.y + r, wy1) - Math.max(entity.y - r, wy0);
                    if (overlapX <= 0 || overlapY <= 0) continue;

                    if (overlapX < overlapY) {
                        if (entity.x < wx0 + CELL_SIZE * 0.5) {
                            entity.x -= overlapX;
                            if (entity.vx > 0) entity.vx = 0;
                        } else {
                            entity.x += overlapX;
                            if (entity.vx < 0) entity.vx = 0;
                        }
                    } else {
                        if (entity.y < wy0 + CELL_SIZE * 0.5) {
                            entity.y -= overlapY;
                            if (entity.vy > 0) entity.vy = 0;
                        } else {
                            entity.y += overlapY;
                            if (entity.vy < 0) entity.vy = 0;
                        }
                    }
                }
            }
        }
    }

    function collideWithRect(circle, rx, ry, rw, rh) {
        // Find the closest point on the rectangle to the circle's center
        let testX = circle.x;
        let testY = circle.y;

        if (circle.x < rx) testX = rx;
        else if (circle.x > rx + rw) testX = rx + rw;

        if (circle.y < ry) testY = ry;
        else if (circle.y > ry + rh) testY = ry + rh;

        let distX = circle.x - testX;
        let distY = circle.y - testY;
        let distance = Math.sqrt(distX*distX + distY*distY);

        // If closer than radius, we are inside! Push out.
        if (distance < circle.radius && distance > 0) {
            let overlap = circle.radius - distance;
            let nx = distX / distance;
            let ny = distY / distance;
            
            circle.x += nx * overlap;
            circle.y += ny * overlap;
        }
    }

    function getSmartVector(entity) {
    let col = Math.floor(entity.x / CELL_SIZE);
    let row = Math.floor(entity.y / CELL_SIZE);

    // Already at (or very near) base
    if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
        if (grid[col][row].distance === 0) {
            let cx2 = col * CELL_SIZE + CELL_SIZE / 2;
            let cy2 = row * CELL_SIZE + CELL_SIZE / 2;
            let dx2 = cx2 - entity.x, dy2 = cy2 - entity.y;
            if (Math.hypot(dx2, dy2) < 2) return { x: 0, y: 0 };
        }
    }

    // ‚îÄ‚îÄ NORMALISED-GRADIENT FLOW STEERING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // For each of the 8 neighbours we check whether it is strictly better
    // (lower Dijkstra distance) than the current cell.  We weight each
    // candidate purely by its *rank* improvement (1 = one step better,
    // not the raw distance difference), so Dijkstra's large wall costs
    // don't distort the direction vector.  The weighted average of the
    // unit directions gives a smooth, curved path.

    let wx = 0, wy = 0, totalW = 0;

    let myDist = (col >= 0 && col < COLS && row >= 0 && row < ROWS)
        ? grid[col][row].distance : Infinity;
    let isOnWall = (col >= 0 && col < COLS && row >= 0 && row < ROWS && grid[col][row].wall);

    // Find the single best (lowest-distance) open neighbour to use as
    // a normalisation reference so all weights stay in [0, 1].
    let bestNeighDist = Infinity;
    const _dirs8 = [
        {x: 0, y:-1}, {x: 0, y: 1}, {x:-1, y: 0}, {x: 1, y: 0},
        {x:-1, y:-1}, {x: 1, y:-1}, {x:-1, y: 1}, {x: 1, y: 1}
    ];
    for (let d of _dirs8) {
        let c = col + d.x, r = row + d.y;
        if (c < 0 || c >= COLS || r < 0 || r >= ROWS) continue;
        let nc = grid[c][r];
        if (nc.wall && !isOnWall) continue;
        if (nc.distance < myDist && nc.distance < bestNeighDist)
            bestNeighDist = nc.distance;
    }
    if (bestNeighDist === Infinity) {
        // Every neighbour is worse ‚Äî shouldn't happen with Dijkstra but safe fallback
        let bx = (playerBase.x * CELL_SIZE) + CELL_SIZE;
        let by = (playerBase.y * CELL_SIZE) + CELL_SIZE;
        let dd = Math.hypot(bx - entity.x, by - entity.y) || 1;
        return { x: (bx - entity.x) / dd, y: (by - entity.y) / dd };
    }

    for (let d of _dirs8) {
        let c = col + d.x, r = row + d.y;
        if (c < 0 || c >= COLS || r < 0 || r >= ROWS) continue;
        let nc = grid[c][r];

        // Must be strictly better than current cell
        if (nc.distance >= myDist) continue;
        // Skip walls (unless the enemy is already embedded in one)
        if (nc.wall && !isOnWall) continue;

        // Block corner-cutting: diagonal moves must have both cardinal neighbours open
        if (Math.abs(d.x) === 1 && Math.abs(d.y) === 1) {
            let ax = col + d.x, bx2 = col;
            let ay = row,       by2 = row + d.y;
            if (ax >= 0 && ax < COLS && ay >= 0 && ay < ROWS && grid[ax][ay].wall) continue;
            if (bx2 >= 0 && bx2 < COLS && by2 >= 0 && by2 < ROWS && grid[bx2][by2].wall) continue;
        }

        // Weight: normalise improvement to [0, 1] relative to the best neighbour.
        // Cells much closer to the base pull harder; ties are averaged.
        let improvement = myDist - nc.distance;          // always > 0 here
        let normImprove  = improvement / (myDist - bestNeighDist + 1); // 0..1
        // Diagonal directions get 1/‚àö2 unit contribution ‚Äî normalise here
        let dirLen = (d.x !== 0 && d.y !== 0) ? 0.7071 : 1.0;
        let w = normImprove * dirLen;

        wx += d.x * w;
        wy += d.y * w;
        totalW += w;
    }

    if (totalW > 0.0001) {
        let len = Math.hypot(wx, wy);
        if (len > 0.0001) return { x: wx / len, y: wy / len };
    }

    // Fallback: head toward map centre
    let fcx = (COLS * CELL_SIZE / 2) - entity.x;
    let fcy = (ROWS * CELL_SIZE / 2) - entity.y;
    let fcLen = Math.hypot(fcx, fcy) || 1;
    return { x: fcx / fcLen, y: fcy / fcLen };
}

    // BFS Pathfinding for Soldiers
    function findNextStep(startEntity, targetEntity) {
        let sx = Math.floor(startEntity.x / CELL_SIZE);
        let sy = Math.floor(startEntity.y / CELL_SIZE);
        let tx = Math.floor(targetEntity.x / CELL_SIZE);
        let ty = Math.floor(targetEntity.y / CELL_SIZE);

        // 1. If target is in the same or adjacent tile, move directly
        if (Math.abs(sx - tx) <= 1 && Math.abs(sy - ty) <= 1) {
             if (!grid[tx][ty].wall) return { x: targetEntity.x, y: targetEntity.y };
        }

        // 2. BFS Pathfinding
        let queue = [{ x: sx, y: sy, parent: null }];
        let visited = new Set();
        visited.add(sx + "," + sy);

        let iterations = 0;
        let maxIterations = 200; // Increased search range slightly

        // Track the tile that gets us closest to the enemy (in case we don't finish)
        let closestNode = null;
        let minDistanceToTarget = Infinity;
        
        while (queue.length > 0 && iterations < maxIterations) { 
            let current = queue.shift();
            iterations++;

            // Calculate distance to target from this node
            let dist = Math.abs(current.x - tx) + Math.abs(current.y - ty);
            if (dist < minDistanceToTarget) {
                minDistanceToTarget = dist;
                closestNode = current;
            }

            // If we found the target exactly
            if (current.x === tx && current.y === ty) {
                closestNode = current;
                break; // Stop searching, we found it
            }

            // Check Neighbors
            let neighbors = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}];

            for (let n of neighbors) {
                let nx = current.x + n.x;
                let ny = current.y + n.y;
                let key = nx + "," + ny;

                if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
                    if (!grid[nx][ny].wall && !visited.has(key)) {
                        visited.add(key);
                        queue.push({ x: nx, y: ny, parent: current });
                    }
                }
            }
        }

        // 3. Backtrack from the 'closestNode' found
        // If we found the target, this backtracks from the target.
        // If we ran out of time, this backtracks from the tile that got closest.
        if (closestNode) {
            let step = closestNode;
            // Walk back up the family tree until we find the Immediate Child of start
            while (step.parent && step.parent.parent !== null) {
                step = step.parent;
            }
            
            return { 
                x: step.x * CELL_SIZE + CELL_SIZE/2, 
                y: step.y * CELL_SIZE + CELL_SIZE/2 
            };
        }

        // Fallback (only happens if fully boxed in)
        return { x: startEntity.x, y: startEntity.y };
    }

function spawnEnemy() {
    let rand = Math.random();
    
    // --- CHANCE CONFIGURATION ---
    let tankChance = (wave > 8) ? 0.15 : (wave > 3 ? 0.1 : 0);
    let runnerChance = (wave > 2) ? 0.25 : (wave > 1 ? 0.2 : 0);
    let shielderChance = (wave > 12) ? 0.10 : 0;
    let leaperChance = (wave > 11) ? 0.10 : 0;
    let breacherChance = (wave > 7) ? 0.05 : 0; 
    let dasherChance = (wave > 6) ? 0.10 : 0; 
    let sniperChance = (wave > 8) ? 0.05 : 0;
    let broodChance = (wave > 10) ? 0.05 : 0; 
    let magnetChance = (wave > 18) ? 0.05 : 0;
    let reviverChance = (wave > 15) ? 0.05 : 0;
    let flyingChance = (wave > 9) ? 0.08 : 0;

    // --- SELECTION LOGIC ---
    let currentTotal = 0;
    
    // 1. DEFINE THE VARIABLE HERE
    let newEnemy = null; 

    // Check Tank
    currentTotal += tankChance;
    if (!newEnemy && rand < currentTotal) { newEnemy = new TankEnemy(); }
    
    // Check Runner
    currentTotal += runnerChance;
    if (!newEnemy && rand < currentTotal) { newEnemy = new RunnerEnemy(); }

    // Check Shielder
    currentTotal += shielderChance;
    if (!newEnemy && rand < currentTotal) { newEnemy = new ShielderEnemy(); }

    // Check Leaper
    currentTotal += leaperChance;
    if (!newEnemy && rand < currentTotal) { newEnemy = new LeaperEnemy(); }

    // Check Breacher
    currentTotal += breacherChance;
    if (!newEnemy && rand < currentTotal) { newEnemy = new BreacherEnemy(); }

    // Check Dasher
    currentTotal += dasherChance;
    if (!newEnemy && rand < currentTotal) { newEnemy = new DasherEnemy(); }
    
    // Check Sniper
    currentTotal += sniperChance;
    if (!newEnemy && rand < currentTotal) { newEnemy = new SniperEnemy(); }
    
    // Check Broodmother
    currentTotal += broodChance;
    if (!newEnemy && rand < currentTotal) { newEnemy = new BroodmotherEnemy(); }

    // Check Magnet
    currentTotal += magnetChance;
    if (!newEnemy && rand < currentTotal) { newEnemy = new MagnetEnemy(); }

    // Check Reviver
    currentTotal += reviverChance;
    if (!newEnemy && rand < currentTotal) { newEnemy = new ReviverEnemy(); }

    // Check Flying
    currentTotal += flyingChance;
    if (!newEnemy && rand < currentTotal) { newEnemy = new FlyingEnemy(); }

    // 2. FALLBACK (If nothing was picked, spawn basic enemy)
    if (!newEnemy) { 
        newEnemy = new Enemy(); 
    }

    // 3. PUSH TO GAME LOOP
    enemies.push(newEnemy);

    // 4. CHECK FOR INTEL CARD
    // Now 'newEnemy' is defined, so this will work!
    checkForNewEnemy(newEnemy);
}

    function startNextWave() {
    wave++;
    waveState = 'spawning';
    enemiesSpawned = 0;
    // Reset per-wave flawless flag
    if (typeof achStats !== 'undefined') achStats._waveFlawless = true;
    // Check wave-number achievements
    checkAchievements();

    // 1. Determine if this is a Boss Wave (Every 10th wave)
    const isBossWave = (wave % 10 === 0);

    // 2. Create the Cinematic Announcement
    if (isBossWave) {
        // Red, ominous text for Boss waves
        currentAnnouncement = new WaveAnnouncement(
            `WAVE ${wave}`,       // Title
            "‚ö† BOSS DETECTED ‚ö†", // Subtitle
            "#ff0044"             // Color (Red)
        );
    } else {
        // Standard White text for normal waves
        currentAnnouncement = new WaveAnnouncement(
            `WAVE ${wave}`,       // Title
            "INCOMING SWARM",     // Subtitle
            "#ffffff"             // Color (White)
        );
    }

    // 3. Calculate Difficulty (Scaling)
    // Number of enemies grows linearly
    enemiesToSpawn = 5 + wave;
    
    // Spawn rate gets faster (lower number = faster), capped at 20 frames minimum
    spawnRate = Math.max(20, 60 - (wave * 0.5));

    // 4. Spawn the Boss
    if (isBossWave) {
        let boss = new BossEnemy();
        enemies.push(boss); // Add boss immediately to the active field
        
        // Optional: Reduce the number of small enemies slightly during a boss fight 
        // so the player isn't totally overwhelmed.
        enemiesToSpawn = Math.floor(enemiesToSpawn * 0.8); 
    }
}

    // --- HELPER 1: LINE OF SIGHT ---
// --- HELPER: CHECK IF PATH IS CLEAR ---
// --- HELPER: THICK LINE OF SIGHT (Prevents Corner Clipping) ---
// --- 1. RAYCASTING (Vision) ---
function castRay(sx, sy, ex, ey) {
    let dx = ex - sx;
    let dy = ey - sy;
    let dist = Math.hypot(dx, dy);
    let steps = dist / (CELL_SIZE / 2); // Check twice per cell

    for (let i = 0; i <= steps; i++) {
        let t = i / steps;
        let cx = sx + dx * t;
        let cy = sy + dy * t;
        
        let col = Math.floor(cx / CELL_SIZE);
        let row = Math.floor(cy / CELL_SIZE);

        if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
            if (grid[col][row].wall) return false; // Hit a wall
        }
    }
    return true; // Clear path
}

// --- IMPROVED HELPER: Thick Raycast ---
// Checks 3 parallel lines to ensure the enemy's body actually fits
function hasLineOfSight(x0, y0, x1, y1, radius = 0) {
    let dx = x1 - x0;
    let dy = y1 - y0;
    let dist = Math.hypot(dx, dy);
    if (dist === 0) return true;

    // Calculate perpendicular offset vector for width
    let nx = -dy / dist; 
    let ny = dx / dist;
    
    // Check 3 Rays: Center, Left Edge, Right Edge
    // We add a tiny buffer (+2) to radius to prevent grazing
    let r = Math.max(0, radius + 2); 
    let offsets = [
        { x: 0, y: 0 },            // Center
        { x: nx * r, y: ny * r },  // Left side of body
        { x: -nx * r, y: -ny * r } // Right side of body
    ];

    for (let o of offsets) {
        let startX = x0 + o.x;
        let startY = y0 + o.y;
        let endX = x1 + o.x;
        let endY = y1 + o.y;

        // Check points along this specific ray
        let steps = Math.ceil(dist / (CELL_SIZE / 2));
        for (let i = 0; i <= steps; i++) {
            let t = i / steps;
            let cx = startX + (endX - startX) * t;
            let cy = startY + (endY - startY) * t;
            
            let col = Math.floor(cx / CELL_SIZE);
            let row = Math.floor(cy / CELL_SIZE);
            
            if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
                if (grid[col][row].wall) return false; // Blocked
            }
        }
    }
    return true; // Path is wide enough!
}
// --- 2. PATHFINDING (BFS) ---
// --- HELPER: PATHFINDING (BFS) ---
function findPath(unit, target) {
    let startCol = Math.floor(unit.x / CELL_SIZE);
    let startRow = Math.floor(unit.y / CELL_SIZE);
    let endCol = Math.floor(target.x / CELL_SIZE);
    let endRow = Math.floor(target.y / CELL_SIZE);

    if (startCol === endCol && startRow === endRow) return [];

    let queue = [{c: startCol, r: startRow}];
    let visited = new Set();
    let cameFrom = {}; 
    let startKey = `${startCol},${startRow}`;
    
    visited.add(startKey);
    cameFrom[startKey] = null;

    let found = false;
    let finalNode = null;

    while (queue.length > 0) {
        let current = queue.shift();

        if (current.c === endCol && current.r === endRow) {
            found = true;
            finalNode = current;
            break;
        }

        // Define neighbors (Straight & Diagonal)
        let directions = [
            // straight
            {x: 0, y: -1}, {x: 0, y: 1}, {x: -1, y: 0}, {x: 1, y: 0},
            // diagonal
            {x: -1, y: -1}, {x: 1, y: -1}, {x: -1, y: 1}, {x: 1, y: 1}
        ];

        for (let dir of directions) {
            let nc = current.c + dir.x;
            let nr = current.r + dir.y;

            if (nc >= 0 && nc < COLS && nr >= 0 && nr < ROWS) {
                // 1. Basic Wall Check
                if (grid[nc][nr].wall) continue;

                // 2. CORNER CUTTING PREVENTION
                // If moving diagonally (both x and y change), check adjacent straight tiles
                if (dir.x !== 0 && dir.y !== 0) {
                    if (grid[current.c + dir.x][current.r].wall || grid[current.c][current.r + dir.y].wall) {
                        continue; // Block this diagonal move
                    }
                }

                let key = `${nc},${nr}`;
                if (!visited.has(key)) {
                    visited.add(key);
                    cameFrom[key] = current;
                    queue.push({c: nc, r: nr});
                }
            }
        }
    }

    // Reconstruct path
    let path = [];
    if (found) {
        let curr = finalNode;
        while (curr) {
            if (curr.c === startCol && curr.r === startRow) break;
            path.push({
                x: curr.c * CELL_SIZE + CELL_SIZE/2,
                y: curr.r * CELL_SIZE + CELL_SIZE/2
            });
            let key = `${curr.c},${curr.r}`;
            curr = cameFrom[key];
        }
        path.reverse(); // Order: Start -> End
    }
    return path;
}

let lastTime = performance.now();
let gameFrame = 0;

function gameLoop(timestamp) {
    if (!timestamp) timestamp = performance.now();
    let deltaTime = timestamp - lastTime;
    lastTime = timestamp;

    if (deltaTime > 100) deltaTime = 100;
    const dt = deltaTime / (1000 / 60);

    if (!gameActive) {
        requestAnimationFrame(gameLoop);
        return;
    }

    if (gameOver) return;

    gameFrame++; // Increment frame counter for optimizations

    if (hasSkill('core_regen') && gameFrame % 300 === 0 && playerBase.hp < playerBase.maxHp) {
    playerBase.hp += 1;
    }

    // --- 1. CLEAR PHYSICAL SCREEN ---
    ctx.fillStyle = "#050505";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // --- 2. START SCALING SYSTEM ---
    ctx.save();
    ctx.translate(offsetX, offsetY); 
    ctx.scale(scale, scale);         

    // --- 3. DRAW GAME WORLD (Inside Virtual 64x36 Grid) ---
    
    // Background
    ctx.fillStyle = "#111";
    ctx.fillRect(0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);

    // Grid Lines
    ctx.strokeStyle = "#222";
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let x = 0; x <= COLS; x++) { ctx.moveTo(x*CELL_SIZE,0); ctx.lineTo(x*CELL_SIZE, VIRTUAL_HEIGHT); }
    for (let y = 0; y <= ROWS; y++) { ctx.moveTo(0,y*CELL_SIZE); ctx.lineTo(VIRTUAL_WIDTH, y*CELL_SIZE); }
    ctx.stroke();

    // --- SKILL CHECK: Wall Regeneration ---
    // We check if the player owns the skill inside the playerProgress object
    const hasWallRegen = (typeof playerProgress !== 'undefined' && playerProgress.unlocked.includes('wall_regen'));

    // Walls Logic
    for (let x = 0; x < COLS; x++) {
        for (let y = 0; y < ROWS; y++) {
            let cell = grid[x][y];
            if (cell.wall && !cell.occupied) {
                
                // SKILL TREE: Only regen if skill is unlocked
                if (hasWallRegen) {
                    if (cell.wallHp < 100) cell.wallHp += 0.05 * dt;
                    if (cell.wallHp > 100) cell.wallHp = 100;
                }

                // Colors
                let hpPct = cell.wallHp / 100;
                let gray = Math.floor(60 + (60 * hpPct)); 
                let colMain = `rgb(${gray}, ${gray}, ${gray})`;
                let colLight = `rgb(${gray + 40}, ${gray + 40}, ${gray + 40})`;
                let colDark = `rgb(${gray - 40}, ${gray - 40}, ${gray - 40})`;
                let colDetail = `rgb(${gray - 20}, ${gray - 20}, ${gray - 20})`;

                // Neighbors
                let nUp = (y > 0 && grid[x][y - 1].wall);
                let nDown = (y < ROWS - 1 && grid[x][y + 1].wall);
                let nLeft = (x > 0 && grid[x - 1][y].wall);
                let nRight = (x < COLS - 1 && grid[x + 1][y].wall);

                let drawX = x * CELL_SIZE;
                let drawY = y * CELL_SIZE;
                let coreSize = CELL_SIZE * 0.85; 
                let offset = (CELL_SIZE - coreSize) / 2;
                
                let cX = drawX + offset;
                let cY = drawY + offset;
                let cW = coreSize;
                let cH = coreSize;

                // Draw Base Block
                ctx.fillStyle = colMain;
                ctx.fillRect(cX, cY, cW, cH); 
                
                // Draw Connections
                if (nUp) ctx.fillRect(cX, drawY, cW, offset);
                if (nDown) ctx.fillRect(cX, cY + cH, cW, offset);
                if (nLeft) ctx.fillRect(drawX, cY, offset, cH);
                if (nRight) ctx.fillRect(cX + cW, cY, offset, cH);

                // Grip Lines
                ctx.fillStyle = colDark;
                let lineSpace = 4;
                if (nUp) for(let i = drawY + 2; i < cY; i+=lineSpace) ctx.fillRect(cX + 2, i, cW - 4, 1);
                if (nDown) for(let i = cY + cH + 2; i < drawY + CELL_SIZE; i+=lineSpace) ctx.fillRect(cX + 2, i, cW - 4, 1);
                if (nLeft) for(let i = drawX + 2; i < cX; i+=lineSpace) ctx.fillRect(i, cY + 2, 1, cH - 4);
                if (nRight) for(let i = cX + cW + 2; i < drawX + CELL_SIZE; i+=lineSpace) ctx.fillRect(i, cY + 2, 1, cH - 4);

                // 3D Bevels
                ctx.beginPath(); ctx.strokeStyle = colLight; ctx.lineWidth = 2;
                ctx.moveTo(cX, cY); ctx.lineTo(cX + cW, cY); ctx.stroke(); // Top
                ctx.moveTo(cX, cY); ctx.lineTo(cX, cY + cH); ctx.stroke(); // Left
                
                ctx.beginPath(); ctx.strokeStyle = colDark;
                ctx.moveTo(cX + cW, cY); ctx.lineTo(cX + cW, cY + cH); ctx.stroke(); // Right
                ctx.moveTo(cX, cY + cH); ctx.lineTo(cX + cW, cY + cH); ctx.stroke(); // Bottom

                // Inner Plate
                let pad = 6;
                ctx.fillStyle = colDetail;
                ctx.fillRect(cX + pad, cY + pad, cW - pad*2, cH - pad*2);
                ctx.strokeStyle = colDark; ctx.lineWidth = 1;
                ctx.strokeRect(cX + pad, cY + pad, cW - pad*2, cH - pad*2);
            }
        }
    }

    // --- VOID PORTAL (2x2) ---
    ctx.save();
    const bx = playerBase.x * CELL_SIZE;
    const by = playerBase.y * CELL_SIZE;
    const bSize = CELL_SIZE * 2;
    const centerBx = bx + CELL_SIZE;
    const centerBy = by + CELL_SIZE;
    const time = Date.now();
    const isHit = (Date.now() - (playerBase.lastHitTime || 0)) < 150;

    // Foundation
    ctx.fillStyle = "#1a1a1d"; 
    ctx.shadowColor = "#000"; ctx.shadowBlur = 15;
    ctx.beginPath();
    const cut = 15;
    ctx.moveTo(bx + cut, by); ctx.lineTo(bx + bSize - cut, by); ctx.lineTo(bx + bSize, by + cut);
    ctx.lineTo(bx + bSize, by + bSize - cut); ctx.lineTo(bx + bSize - cut, by + bSize);
    ctx.lineTo(bx + cut, by + bSize); ctx.lineTo(bx, by + bSize - cut); ctx.lineTo(bx, by + cut);
    ctx.closePath(); ctx.fill(); ctx.shadowBlur = 0;

    // Runes
    ctx.save();
    ctx.beginPath(); ctx.rect(bx, by, bSize, bSize); ctx.clip();
    ctx.strokeStyle = isHit ? "#ff0000" : "#a020f0"; ctx.lineWidth = 2;
    ctx.setLineDash([10, 25]); ctx.beginPath(); ctx.arc(centerBx, centerBy, CELL_SIZE * 0.8, 0, Math.PI * 2); ctx.stroke();
    ctx.setLineDash([5, 15]); ctx.beginPath(); ctx.arc(centerBx, centerBy, CELL_SIZE * 0.9, 0, Math.PI * 2); ctx.stroke();
    ctx.restore();

    // Portal Swirl
    const portalRadius = CELL_SIZE * 0.65;
    ctx.fillStyle = "#000";
    ctx.beginPath(); ctx.arc(centerBx, centerBy, portalRadius, 0, Math.PI * 2); ctx.fill();

    ctx.save();
    ctx.translate(centerBx, centerBy);
    ctx.globalCompositeOperation = 'lighter';
    ctx.rotate(time * 0.001);
    const grad1 = ctx.createRadialGradient(0, 0, 10, 0, 0, portalRadius);
    grad1.addColorStop(0, "rgba(0, 0, 0, 0)");
    grad1.addColorStop(0.4, isHit ? "rgba(255, 0, 0, 0.4)" : "rgba(75, 0, 130, 0.4)");
    grad1.addColorStop(0.8, isHit ? "rgba(255, 50, 0, 0.6)" : "rgba(138, 43, 226, 0.6)");
    grad1.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = grad1;
    ctx.beginPath();
    for (let i = 0; i < Math.PI * 2; i += 0.1) {
        let r = portalRadius * (0.9 + Math.sin(i * 5 + time * 0.002) * 0.05);
        ctx.lineTo(Math.cos(i) * r, Math.sin(i) * r);
    }
    ctx.fill();

    // Inner Spiral
    ctx.rotate(time * -0.003);
    const grad2 = ctx.createRadialGradient(0, 0, 5, 0, 0, portalRadius * 0.8);
    grad2.addColorStop(0, "#ffffff");
    grad2.addColorStop(0.2, isHit ? "#ff0000" : "#ff00ff");
    grad2.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = grad2;
    for (let i = 0; i < 3; i++) {
        ctx.rotate((Math.PI * 2) / 3);
        ctx.beginPath(); ctx.ellipse(20, 0, portalRadius * 0.6, portalRadius * 0.2, 0.5, 0, Math.PI * 2); ctx.fill();
    }
    ctx.restore();

    // --- SKILL INTEGRATION: Health Bar ---
    // Use playerBase.maxHp if it exists (from Skills), otherwise 100
    const maxHp = playerBase.maxHp || 100;
    const hpPct = Math.max(0, playerBase.hp / maxHp);
    
    const barW = bSize * 0.6;
    const barX = centerBx - barW / 2;
    const barY = by - 10;
    ctx.fillStyle = "rgba(0,0,0,0.8)"; ctx.fillRect(barX, barY, barW, 4);
    const hpColor = hpPct > 0.5 ? "#b042ff" : (hpPct > 0.2 ? "#ff00ff" : "#ff0000");
    ctx.fillStyle = hpColor; ctx.shadowColor = hpColor; ctx.shadowBlur = 5;
    ctx.fillRect(barX, barY, barW * hpPct, 4); ctx.shadowBlur = 0;
    ctx.restore();

    // Hover Ghost (Calculates using Scaled Mouse Coords)
    let gc = Math.floor(mouseX/CELL_SIZE);
    let gr = Math.floor(mouseY/CELL_SIZE);
    if (gc >= 0 && gc < COLS && gr >= 0 && gr < ROWS) {
        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx.strokeRect(gc*CELL_SIZE, gr*CELL_SIZE, CELL_SIZE, CELL_SIZE);
    }

    // --- GAME LOGIC ---

    if (waveState === 'spawning') {
        spawnTimer+=dt;
        if (spawnTimer > spawnRate) {
            spawnEnemy(); 
            enemiesSpawned++;
            spawnTimer = 0;
            if (enemiesSpawned >= enemiesToSpawn) waveState = 'fighting';
        }
    } else if (waveState === 'fighting') {
        if (enemies.length === 0) {
            money += 50;
            // Mark wave as survived flawlessly if no damage taken this wave
            if (typeof achStats !== 'undefined') {
                achStats.flawlessWave = achStats._waveFlawless === true;
                achStats._waveFlawless = true; // Reset for next wave
            }
            checkAchievements();
            startNextWave();
        }
    }
    
    // Structures - Update & Cleanup
    for (let i = structures.length - 1; i >= 0; i--) {
        let s = structures[i];
        if (s.update) s.update(dt);
        if ((s.active === false) || (s.hp !== undefined && s.hp <= 0)) {
            structures.splice(i, 1);
        }
    }

    // Structures - Depth Sort & Draw
    structures.sort((a, b) => a.row - b.row);

    for (let s of structures) {
        if (s.draw) s.draw();
    }

    // Draw corpses that are falling into the crusher hole ‚Äî must render above structures
    for (let i = corpses.length - 1; i >= 0; i--) {
        if (corpses[i].fallingIntoHole) corpses[i].draw();
    }

    // Traps
    for (let i = traps.length - 1; i >= 0; i--) {
        traps[i].update(dt);
        traps[i].draw();
        if (traps[i].hp <= 0) {
            grid[traps[i].col][traps[i].row].occupied = false;
            traps.splice(i, 1);
        }
    }

    // Spikes
    for (let i = spikes.length - 1; i >= 0; i--) {
        spikes[i].update(dt);
        spikes[i].draw();
        if (!spikes[i].active) spikes.splice(i, 1);
    }

    for (let i = corpses.length - 1; i >= 0; i--) {
        corpses[i].update();
        if (!corpses[i].fallingIntoHole) corpses[i].draw(); 
        if (!corpses[i].active) {
            corpses.splice(i, 1);
        }
    }

    // Enemies & Portal Damage
    let baseCenterX = (playerBase.x * CELL_SIZE) + CELL_SIZE;
    let baseCenterY = (playerBase.y * CELL_SIZE) + CELL_SIZE;

    // Rebuild spatial hash once per frame for fast O(1) separation lookups
    _rebuildSpatialHash();

    enemies.forEach(e => {
    e.isInvincible = false;
    });

    for (let i = enemies.length - 1; i >= 0; i--) {
        let e = enemies[i];
        e.update(dt);      

        let distToPortal = Math.hypot(e.x - baseCenterX, e.y - baseCenterY);
        if (distToPortal < CELL_SIZE * 0.6) {
            takeDamage(5); 
            playerBase.lastHitTime = Date.now();
            if(typeof createParticles === 'function') createParticles(e.x, e.y, "#a020f0", 8);
            enemies.splice(i, 1);
            continue; 
        }
        e.draw();

        // Burn overlay ‚Äì tiny fire flickers drawn on top of the enemy
        if (e.burnTimer > 0) {
            let bAlpha = Math.min(1, e.burnTimer / 60) * 0.85;
            ctx.save();
            ctx.globalCompositeOperation = 'lighter';
            let fr = e.radius || 8;
            // 3 small flame puffs at random offsets, refreshed each frame
            for (let fi = 0; fi < 3; fi++) {
                let fx = e.x + (Math.random() - 0.5) * fr * 1.4;
                let fy = e.y + (Math.random() - 0.5) * fr * 1.4;
                let fs = 3 + Math.random() * 4;
                ctx.globalAlpha = bAlpha * (0.5 + Math.random() * 0.5);
                ctx.fillStyle = Math.random() < 0.5 ? "#ff6600" : "#ffcc00";
                ctx.beginPath(); ctx.arc(fx, fy, fs, 0, Math.PI*2); ctx.fill();
            }
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1;
            ctx.restore();
        }
        
        if (e.hp <= 0) {
            // 1. Give the player the standard kill bounty
            money += e.bounty;
            if (typeof achStats !== 'undefined') {
                achStats.killsThisRun++;
                if (achStats.killsThisRun % 50 === 0) checkAchievements();
            }
            
            if (e.type !== "SKELETON_UNIT") {
                // 2. Spawn the corpse, but now PASS THE BOUNTY into it
                corpses.push(new Corpse(e.x, e.y, e.bounty)); 
            }
            
            if(typeof createParticles === 'function') {
                createParticles(e.x, e.y, "orange", 6);
            }
            
            enemies.splice(i, 1);
        }
    }

    // Allies
    for (let i = allies.length - 1; i >= 0; i--) {
        let a = allies[i];
        a.update(dt);
        a.draw();
        if (a.hp <= 0 || a.lifeTimer <= 0) {
            allies.splice(i, 1);
            createParticles(a.x, a.y, "#00d2ff", 5);
        }
    }

    // Projectiles
    for (let i = projectiles.length - 1; i >= 0; i--) {
        projectiles[i].update(dt);
        projectiles[i].draw();
        if (!projectiles[i].active) projectiles.splice(i, 1);
    }

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx * dt; 
        p.y += p.vy * dt; 
        p.life -= dt;
        ctx.fillStyle = p.color; ctx.globalAlpha = p.life/20;
        ctx.fillRect(p.x, p.y, 3, 3);
        ctx.globalAlpha = 1;
        if (p.life <= 0) particles.splice(i, 1);
    }

    // Blueprint
    drawBlueprint();

        // Announcement
    if (currentAnnouncement && currentAnnouncement.active) {
        currentAnnouncement.update(dt);
        currentAnnouncement.draw();
    }

    // --- 4. END SCALING SYSTEM ---
    ctx.restore();

    // --- 5. UI UPDATES ---
    document.getElementById('hp').innerText = Math.ceil(playerBase.hp);
    document.getElementById('money').innerText = Math.floor(money);
    document.getElementById('wave').innerText = wave;
    let remaining = (enemiesToSpawn - enemiesSpawned) + enemies.length;
    document.getElementById('enemy-count').innerText = remaining > 0 ? remaining : 0;

    requestAnimationFrame(gameLoop);
}

    let currentDifficulty = 'medium'; // Default
    updateLockedButtons();
    // 1. Hook into startGame to capture the chosen difficulty
    const _originalStartGame = startGame;
    startGame = function(mode) {
        currentDifficulty = mode; // Save difficulty for restart
        _originalStartGame(mode);
    }

    // 2. Patch the Game Loop to handle freezing
    const _originalGameLoop = gameLoop;
    gameLoop = function(timestamp) {
        // If paused, keep the loop alive but skip the update/draw logic
        // This freezes the last frame on the canvas behind the menu
        if (isPaused) {
            requestAnimationFrame(gameLoop);
            return;
        }
        _originalGameLoop(timestamp);
    }

    // 3. Toggle Pause Function
    function togglePause() {
        // Prevent pausing if game hasn't started or is over
        if (!gameActive || gameOver) return;

        isPaused = !isPaused;
        const menu = document.getElementById('pause-menu');
        menu.style.display = isPaused ? 'flex' : 'none';
    }

    // 4. Restart Game (Reloads page and auto-starts with same difficulty)
    function restartGame() {
        sessionStorage.setItem('swarm_restart_diff', currentDifficulty);
        location.reload();
    }

    // 5. Main Menu (Reloads page cleanly)
    function goToMainMenu() {
        sessionStorage.removeItem('swarm_restart_diff');
        location.reload();
    }

    // 6. Input Listener for 'P'
    window.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'p') {
            togglePause();
        }
    });

    // 7. Auto-Start Check (Runs on page load for "Restart" functionality)
    // Checks if we are restarting instantly
    const _restartDiff = sessionStorage.getItem('swarm_restart_diff');
    if (_restartDiff) {
        // FIX: Hide menu immediately to prevent flickering
        const menu = document.getElementById('main-menu');
        if (menu) menu.style.display = 'none';

        sessionStorage.removeItem('swarm_restart_diff');
        
        // Wait briefly for DOM to be ready, then start
        setTimeout(() => startGame(_restartDiff), 100);
    }
    init();



</script>

<!-- ‚ïê‚ïê‚ïê ACHIEVEMENTS OVERLAY ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
<div id="achievements-overlay">
  <div class="ach-modal">
    <div class="ach-header">
      <h2>‚¨° Achievements</h2>
      <div style="display:flex;align-items:center;gap:16px;">
        <span class="ach-count" id="ach-progress-label">0 / 20 Unlocked</span>
        <button class="ach-close-btn" onclick="closeAchievements()">‚úï</button>
      </div>
    </div>
    <div class="ach-grid" id="ach-grid-container"></div>
  </div>
</div>

<!-- Achievement unlock toast -->
<div id="ach-toast">
  <div class="toast-icon" id="ach-toast-icon">üèÜ</div>
  <div>
    <div class="toast-label">Achievement Unlocked</div>
    <div class="toast-name" id="ach-toast-name">‚Äî</div>
  </div>
</div>

</body>
