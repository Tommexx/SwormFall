<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swarm Defense: Heavy Artillery</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; }
        /* --- UI CONTAINER --- */
#ui {
    position: absolute;
    top: 20px;
    left: 20px;
    width: 340px; /* Fixed width for alignment */
    display: flex;
    flex-direction: column;
    gap: 15px;
    pointer-events: none; /* Allows clicking through gaps */
    font-family: 'Segoe UI', sans-serif;
}

/* --- PANELS --- */
.hud-panel {
    background: rgba(12, 12, 18, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
    border-radius: 12px;
    padding: 15px;
    pointer-events: auto;
    backdrop-filter: blur(10px);
}

/* --- STATS HEADER --- */
.stats-header {
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    margin-bottom: 10px;
    padding-bottom: 5px;
}
.stats-header h1 {
    font-size: 22px;
    color: #00d2ff;
    text-shadow: 0 0 10px rgba(0, 210, 255, 0.4);
    margin: 0;
    text-transform: uppercase;
    letter-spacing: 2px;
}
.stats-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 5px;
    font-size: 14px;
    color: #aab;
}
.stat-val { color: white; font-weight: bold; }

/* --- TABS SYSTEM --- */
.tab-nav {
    display: flex;
    background: rgba(0, 0, 0, 0.4);
    border-radius: 8px;
    padding: 4px;
    gap: 4px;
    margin-bottom: 12px;
}
.tab-btn {
    flex: 1;
    background: transparent;
    border: none;
    color: #667;
    padding: 8px 0;
    font-size: 12px;
    font-weight: 700;
    text-transform: uppercase;
    cursor: pointer;
    border-radius: 6px;
    transition: all 0.2s;
    text-align: center;
}
.tab-btn:hover { background: rgba(255, 255, 255, 0.05); color: #fff; }
.tab-btn.active-tab {
    background: rgba(0, 210, 255, 0.15);
    color: #00d2ff;
    box-shadow: 0 0 10px rgba(0, 210, 255, 0.1);
}

/* --- TOOL BUTTONS --- */
.tab-content { display: none; animation: slideIn 0.2s ease-out; }
.tab-content.active-content { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }

@keyframes slideIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

.tool-btn {
    background: linear-gradient(180deg, #2a2a35 0%, #1a1a20 100%);
    border: 1px solid #3a3a45;
    color: #ccc;
    padding: 10px;
    border-radius: 8px;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    position: relative;
    transition: all 0.2s;
    min-height: 50px;
}
.tool-btn:hover {
    border-color: #00d2ff;
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
}
/* Selected State (matches your JS logic) */
.tool-btn.active {
    background: linear-gradient(180deg, #00d2ff 0%, #0088aa 100%);
    border-color: #fff;
    color: #002233;
}
.tool-btn.active span { color: #004455; } /* Cost text on active */

.btn-label { font-size: 13px; font-weight: bold; margin-bottom: 2px; }
.btn-cost { font-size: 11px; color: #00ff88; font-family: monospace; }
.btn-hotkey { position: absolute; top: 6px; right: 8px; font-size: 10px; opacity: 0.4; font-weight: bold; }

/* Special Delete Button Styling */
.btn-delete { border-color: #ff4444; }
.btn-delete:hover { background: rgba(50, 10, 10, 1); border-color: #ff0000; }
.btn-delete .btn-cost { color: #ff8888; }
.tool-btn.active.btn-delete {
    background: linear-gradient(180deg, #ff4444 0%, #aa0000 100%);
    color: white;
}
        
        #game-over {
            display: none;
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 0, 0, 0.95);
            padding: 50px;
            text-align: center;
            color: white;
            border: 2px solid red;
            border-radius: 10px;
            z-index: 10;
        }

        /* --- MAIN MENU CONTAINER --- */
#main-menu {
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 200;
    font-family: 'Segoe UI', sans-serif;
}

#main-menu h1 {
    font-size: 72px;
    color: #fff;
    text-shadow: 0 0 10px rgba(0, 210, 255, 0.8), 0 0 40px rgba(0, 210, 255, 0.4);
    margin-bottom: 10px;
    letter-spacing: 4px;
    font-weight: 800;
    text-transform: uppercase;
}

#main-menu p {
    color: #889;
    font-size: 18px;
    margin-bottom: 60px;
    letter-spacing: 2px;
    text-transform: uppercase;
}

/* --- CARDS CONTAINER --- */
.difficulty-container {
    display: flex;
    gap: 25px;
    flex-wrap: wrap;
    justify-content: center;
    perspective: 1000px;
}

/* --- BASE CARD STYLE --- */
.diff-card {
    position: relative;
    width: 200px;
    height: 300px;
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    overflow: hidden;
    backdrop-filter: blur(10px);
}

/* Hover Effect: Lift and Glow */
.diff-card:hover {
    transform: translateY(-15px) scale(1.02);
    background: rgba(255, 255, 255, 0.08);
}

/* Content Styling */
.diff-card .icon {
    width: 60px;
    height: 60px;
    margin-bottom: 20px;
    transition: 0.4s;
}

.diff-card .title {
    font-size: 24px;
    font-weight: bold;
    text-transform: uppercase;
    margin-bottom: 5px;
    color: #fff;
    z-index: 2;
}

.diff-card .stats {
    font-size: 14px;
    opacity: 0.7;
    z-index: 2;
}

.diff-card .desc {
    font-size: 12px;
    color: #aaa;
    margin-top: 15px;
    text-align: center;
    padding: 0 15px;
    line-height: 1.4;
    z-index: 2;
}

/* --- UNIQUE CARD THEMES --- */

/* 1. EASY (Green/Safety) */
.card-easy { border-bottom: 4px solid #00ff88; }
.card-easy .icon svg { fill: #00ff88; filter: drop-shadow(0 0 5px #00ff88); }
.card-easy:hover { box-shadow: 0 0 30px rgba(0, 255, 136, 0.3); border-color: #00ff88; }
.card-easy .stats { color: #00ff88; }

/* 2. MEDIUM (Yellow/Industrial) */
.card-medium { border-bottom: 4px solid #ffcc00; }
.card-medium .icon svg { fill: #ffcc00; filter: drop-shadow(0 0 5px #ffcc00); }
.card-medium:hover { box-shadow: 0 0 30px rgba(255, 204, 0, 0.3); border-color: #ffcc00; }
.card-medium .stats { color: #ffcc00; }

/* 3. HARD (Orange/Warning) */
.card-hard { border-bottom: 4px solid #ff6600; }
.card-hard .icon svg { fill: #ff6600; filter: drop-shadow(0 0 5px #ff6600); }
.card-hard:hover { box-shadow: 0 0 30px rgba(255, 102, 0, 0.4); border-color: #ff6600; }
.card-hard .stats { color: #ff6600; }

/* 4. EXTREME (Red/Danger) */
.card-extreme { 
    border-bottom: 4px solid #ff0000; 
    box-shadow: inset 0 0 20px rgba(255, 0, 0, 0.1); /* Inner red tint */
}

/* The Skull Icon Style */
.card-extreme .icon svg { 
    fill: #ff0000; 
    /* Double shadow for intense glow */
    filter: drop-shadow(0 0 20px #ff0000) drop-shadow(0 0 20px #ff0000);
}

/* Hover Effects */
.card-extreme:hover { 
    box-shadow: 0 0 50px rgba(255, 0, 0, 0.6), inset 0 0 30px rgba(255, 0, 0, 0.2); 
    border-color: #ff0000; 
    animation: violent-shake 0.4s infinite; /* Aggressive jitter */
}
.card-extreme:hover .icon svg {
    filter: drop-shadow(0 0 15px #ff0000) drop-shadow(0 0 40px #ff0000);
    transform: scale(1.1);
}

.card-extreme .stats { color: #ff0000; font-weight: bold; text-shadow: 0 0 10px #ff0000; }

/* 5. CREATIVE (Cyan/GodMode) */
.card-creative { border-bottom: 4px solid #00d2ff; }
.card-creative .icon svg { fill: #00d2ff; filter: drop-shadow(0 0 10px #00d2ff); }
.card-creative:hover { box-shadow: 0 0 40px rgba(0, 210, 255, 0.5); border-color: #00d2ff; }
.card-creative .stats { color: #00d2ff; }

/* Subtle Grid Background on cards */
.diff-card::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background-image: 
        linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
    background-size: 20px 20px;
    opacity: 0.2;
    z-index: 1;
}

@keyframes violent-shake {
    0% { transform: translateY(-15px) rotate(0deg); }
    25% { transform: translateY(-15px) rotate(2deg); }
    50% { transform: translateY(-15px) rotate(-2deg); }
    75% { transform: translateY(-15px) rotate(2deg); }
    100% { transform: translateY(-15px) rotate(0deg); }
}

/* --- PAUSE MENU STYLES --- */
        #pause-menu {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 10, 0.85); /* Dark semi-transparent background */
            backdrop-filter: blur(8px);       /* Blur effect */
            z-index: 300;                     /* Above everything else */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', sans-serif;
        }

        #pause-menu h1 {
            font-size: 60px;
            color: white;
            margin-bottom: 40px;
            text-transform: uppercase;
            letter-spacing: 10px;
            text-shadow: 0 0 20px #00d2ff;
        }

        .pause-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .pause-btn {
            background: transparent;
            color: #00d2ff;
            border: 2px solid #00d2ff;
            padding: 15px 60px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s ease;
            text-align: center;
            width: 300px;
        }

        .pause-btn:hover {
            background: #00d2ff;
            color: #050505;
            box-shadow: 0 0 30px rgba(0, 210, 255, 0.6);
            transform: scale(1.05);
        }
    </style>
</head>
<body>

    <div id="main-menu">
    <h1>SWARM DEFENSE</h1>
    <p>System Initialized. Select Combat Simulation Level.</p>
    
    <div class="difficulty-container">
        
        <div class="diff-card card-easy" onclick="startGame('easy')">
            <div class="icon">
                <svg viewBox="0 0 24 24"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.12-3.28 7.79-7 8.94V12H5V6.3l7-3.11v8.8z"/></svg>
            </div>
            <div class="title">Recruit</div>
            <div class="stats">Enemy HP x0.5</div>
            <div class="desc">For new commanders. Enemies are weak and fall easily.</div>
        </div>

        <div class="diff-card card-medium" onclick="startGame('medium')">
            <div class="icon">
                <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v4h-2zm0 6h2v4h-2z"/></svg>
            </div>
            <div class="title">Soldier</div>
            <div class="stats">Enemy HP x1.0</div>
            <div class="desc">The standard experience. Balanced tactical combat.</div>
        </div>

        <div class="diff-card card-hard" onclick="startGame('hard')">
            <div class="icon">
                <svg viewBox="0 0 24 24"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>
            </div>
            <div class="title">Veteran</div>
            <div class="stats">Enemy HP x2.0</div>
            <div class="desc">Enemies are tough. Optimal layouts required to survive.</div>
        </div>

        <div class="diff-card card-extreme" onclick="startGame('extreme')">
            <div class="icon">
                <svg viewBox="0 0 24 24"><path d="M12 2c-4.97 0-9 4.03-9 9 0 4.97 9 13 9 13s9-8.03 9-13c0-4.97-4.03-9-9-9zm0 16c-1.1 0-2-.9-2-2h4c0 1.1-.9 2-2 2zm6-6c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-4 0c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-4 0c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-4 0c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"/></svg>
            </div>
            <div class="title">Nightmare</div>
            <div class="stats">Enemy HP x3.0</div>
            <div class="desc">Massive health pools. One mistake means death.</div>
        </div>

        <div class="diff-card card-creative" onclick="startGame('creative')">
            <div class="icon">
                <svg viewBox="0 0 24 24"><path d="M22.7 19l-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4z"/></svg>
            </div>
            <div class="title">Sandbox</div>
            <div class="stats">Infinite Money</div>
            <div class="desc">Test your defenses with unlimited resources.</div>
        </div>
        
    </div>
</div>

<div id="ui">
    <div class="hud-panel">
        <div class="stats-header">
            <h1>Swarm Defense V3</h1>
        </div>
        <div class="stats-grid">
            <span>HP: <span id="hp" class="stat-val" style="color:#0f0">100</span></span>
            <span>Wave: <span id="wave" class="stat-val">1</span></span>
            <span>Money: <span id="money" class="stat-val" style="color:gold">400</span></span>
            <span>Enemies: <span id="enemy-count" class="stat-val">0</span></span>
        </div>
    </div>
    
    <div class="hud-panel controls"> <div class="tab-nav">
            <button class="tab-btn active-tab" onclick="openTab(event, 'defense')">Defense</button>
            <button class="tab-btn" onclick="openTab(event, 'attack')">Attack</button>
            <button class="tab-btn" onclick="openTab(event, 'economy')">Economy</button>
        </div>

        <div id="tab-defense" class="tab-content active-content">
            <button id="btn-wall" class="tool-btn active" onclick="setTool('wall')">
                <span class="btn-label">Titan Wall</span>
                <span class="btn-cost">$10</span>
                <span class="btn-hotkey">[1]</span>
            </button>
            <button id="btn-cryo" class="tool-btn" onclick="setTool('cryo_tower')">
                <span class="btn-label">Cryo Tower</span>
                <span class="btn-cost">$100</span>
                <span class="btn-hotkey">[0]</span>
            </button>
            <button id="btn-trap" class="tool-btn" onclick="setTool('trap')">
                <span class="btn-label">Spike Trap</span>
                <span class="btn-cost">$40</span>
                <span class="btn-hotkey">[6]</span>
            </button>
            <button id="btn-wallturret" class="tool-btn" onclick="setTool('wall_turret')">
                <span class="btn-label">Wall Turret</span>
                <span class="btn-cost">$150</span>
                <span class="btn-hotkey">[7]</span>
            </button>
            <button id="btn-bard" class="tool-btn" onclick="setTool('bard_troop')">
                <span class="btn-label">Bard</span>
                <span class="btn-cost">$100</span>
                <span class="btn-hotkey">[B]</span>
            </button>
        </div>

        <div id="tab-attack" class="tab-content">
            <button id="btn-troop" class="tool-btn" onclick="setTool('troop')">
                <span class="btn-label">Soldier</span>
                <span class="btn-cost">$10</span>
                <span class="btn-hotkey">[2]</span>
            </button>
            <button id="btn-sword" class="tool-btn" onclick="setTool('sword_troop')">
                <span class="btn-label">Sword Soldier</span>
                <span class="btn-cost">$50</span>
                <span class="btn-hotkey">[9]</span>
            </button>
            <button id="btn-shield" class="tool-btn" onclick="setTool('shield_troop')">
                <span class="btn-label">Shield Guard</span>
                <span class="btn-cost">$75</span>
                <span class="btn-hotkey">[S]</span>
            </button>
            <button id="btn-barracks" class="tool-btn" onclick="setTool('barracks')">
                <span class="btn-label">Barracks</span>
                <span class="btn-cost">$200</span>
                <span class="btn-hotkey">[3]</span>
            </button>
            <button id="btn-mortar" class="tool-btn" onclick="setTool('mortar')">
                <span class="btn-label">Mortar</span>
                <span class="btn-cost">$200</span>
                <span class="btn-hotkey">[4]</span>
            </button>
            <button id="btn-minigun" class="tool-btn" onclick="setTool('minigun')">
                <span class="btn-label">Minigun</span>
                <span class="btn-cost">$400</span>
                <span class="btn-hotkey">[M]</span>
            </button>
        </div>

        <div id="tab-economy" class="tab-content">
            <button id="btn-farm" class="tool-btn" onclick="setTool('money_farm')">
                <span class="btn-label">Money Farm</span>
                <span class="btn-cost">$350</span>
                <span class="btn-hotkey">[8]</span>
            </button>
            <button id="btn-delete" class="tool-btn btn-delete" onclick="setTool('delete')">
                <span class="btn-label">Salvage</span>
                <span class="btn-cost">+50% Refund</span>
                <span class="btn-hotkey">[5]</span>
            </button>
        </div>

        <div style="font-size: 11px; color: #666; margin-top: 10px; text-align: center;">
            Press <strong>'R'</strong> to Rotate
        </div>
    </div>
</div>


    <div id="game-over">
        <h1 style="color: red; font-size: 50px;">BASE DESTROYED</h1>
        <p>You survived <span id="final-wave">0</span> waves.</p>
        <button onclick="location.reload()" style="margin-top: 20px; width:100%; text-align:center;">Try Again</button>
    </div>

    <div id="pause-menu" style="display: none;">
        <h1>PAUSED</h1>
        <div class="pause-buttons">
            <button class="pause-btn" onclick="togglePause()">RESUME</button>
            <button class="pause-btn" onclick="restartGame()">RESTART</button>
            <button class="pause-btn" onclick="goToMainMenu()">MAIN MENU</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>

    // Function to switch tabs
    function openTab(evt, tabName) {
        // 1. Hide all tab contents
        const contents = document.getElementsByClassName("tab-content");
        for (let i = 0; i < contents.length; i++) {
            contents[i].classList.remove("active-content");
        }

        // 2. Deactivate all tab buttons
        const tabs = document.getElementsByClassName("tab-btn");
        for (let i = 0; i < tabs.length; i++) {
            tabs[i].classList.remove("active-tab");
        }

        // 3. Show current tab and activate button
        document.getElementById('tab-' + tabName).classList.add("active-content");
        evt.currentTarget.classList.add("active-tab");
    }
    /** CONFIGURATION **/
    const CELL_SIZE = 50; 
    
    // Snap width/height to be multiples of CELL_SIZE (50)
    // This ensures the bottom and right walls are fully visible and not cut off
    const COLS = 41;
    const ROWS = 21;

    let canvas, ctx;
    let grid = [];
    let currentAnnouncement = null;
    let isPathBlocked = false;
    let difficultyMultiplier = 1.0; 
    let gameActive = false;
    let isPaused = false;
    this.lastTimer = 0;
    
    // Lists
    let enemies = [];
    let corpses = [];
    let allies = [];      
    let structures = []; 
    let projectiles = []; 
    let particles = [];
    let traps = [];
    let spikes = [];
    this.floaters = []; // Stores the floating money text particles
    
    // Place base in middle of rows
    let playerBase = { x: 2, y: Math.floor(ROWS/2), hp: 100 };
    let money = 200;
    let wave = 1;
    let waveState = 'spawning'; // Options: 'spawning', 'fighting', 'cooldown'
    
    let enemiesToSpawn = 10;    // Total enemies for this wave
    let enemiesSpawned = 0;     // How many have appeared so far
    
    let spawnRate = 60;         // Frames between spawns
    let spawnTimer = 0;
    
    let waveCooldown = 180;     // 3 Seconds rest between waves
    let cooldownTimer = 0;
    let gameOver = false;
    
    let currentTool = 'wall'; 
    let mouseX = 0;
    let mouseY = 0;
    let isMouseDown = false;
    let buildRotation = 0;

    function startGame(mode) {
        // 1. Set Multiplier based on mode
        switch(mode) {
            case 'easy':     difficultyMultiplier = 0.5; break;
            case 'medium':   difficultyMultiplier = 1.0; break;
            case 'hard':     difficultyMultiplier = 2.0; break;
            case 'extreme':  difficultyMultiplier = 3.0; break;
            case 'creative': 
                difficultyMultiplier = 1.0; 
                money = 99999999999; // Infinite money
                break;
        }
        updateFlowField();

        // 2. Update HUD immediately
        document.getElementById('money').innerText = Math.floor(money);

        // 3. Hide Menu
        document.getElementById('main-menu').style.display = 'none';

        // 4. Start the Game Logic
        gameActive = true;
        wave = 0; 
        startNextWave(); 
    }

    function drawHealth(x, y, hp, maxHp) {
    // Only draw if damaged
    if (hp < maxHp) {
        const barW = 24;
        const barH = 4;
        const yOffset = 28;

        const barX = x - (barW / 2);
        const barY = y - yOffset;

        const pct = Math.max(0, Math.min(1, hp / maxHp));
        // Curve the hue so it stays green longer, then quickly turns red
        const hue = (pct * pct) * 120;

        // Background
        ctx.fillStyle = "#333333";
        ctx.fillRect(barX, barY, barW, barH);

        // Health
        ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
        ctx.fillRect(barX, barY, barW * pct, barH);

        // Border
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barW, barH);
    }
}

    /** CLASSES **/

class Corpse {
    constructor(x, y) {
        this.x = x;
        this.y = y; // This is the "Ground" Y position
        
        this.life = 600; 
        this.maxLife = 600;
        this.active = true;
        
        // --- FALLING PHYSICS ---
        this.dropY = -60; // Spawns 60 pixels in the air
        this.velocity = 0;
        this.gravity = 0.8; // How fast it accelerates down
        this.landed = false;

        this.sizeMod = 0.8 + Math.random() * 0.4;
    }

    update() {
        // 1. FALLING LOGIC
        if (!this.landed) {
            this.velocity += this.gravity;
            this.dropY += this.velocity;

            // Hit the ground
            if (this.dropY >= 0) {
                this.dropY = 0;
                // If moving fast enough, do a small bounce
                if (Math.abs(this.velocity) > 2) {
                    this.velocity = -this.velocity * 0.3; // 30% energy return (Heavy stone feel)
                } else {
                    this.landed = true; // Stop simulating physics
                }
            }
        }

        // 2. LIFE LOGIC
        this.life--;
        if (this.life <= 0) this.active = false;
    }

    draw() {
        ctx.save();
        
        // Sinking logic (End of life)
        let sink = 0;
        if (this.life < 120) sink = (1 - (this.life / 120)) * 10;

        // Combine Falling (dropY) + Sinking (sink)
        ctx.translate(this.x, this.y + this.dropY + sink);
        ctx.scale(this.sizeMod, this.sizeMod);
        
        // Fade out
        ctx.globalAlpha = Math.min(1.0, (this.life / this.maxLife) * 3);

        // --- DRAWING THE CROSS ---
        
        // 1. SHADOW (Only visible when close to ground)
        if (this.dropY > -20) {
            let shadowAlpha = 1 - (Math.abs(this.dropY) / 20);
            ctx.fillStyle = `rgba(0, 0, 0, ${0.4 * shadowAlpha})`;
            ctx.beginPath();
            // Shadow grows as object gets closer
            let sScale = 1 - (Math.abs(this.dropY) / 40); 
            ctx.ellipse(0, 4, 10 * sScale, 5 * sScale, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // 2. THE CROSS (Stone Gray)
        const stoneDark = "#37474f";
        const stoneLight = "#546e7a";
        const stoneOutline = "#263238";

        ctx.strokeStyle = stoneOutline;
        ctx.lineWidth = 1.5;

        // Vertical Beam
        ctx.fillStyle = stoneDark;
        ctx.fillRect(-2.5, -16, 5, 20);
        ctx.strokeRect(-2.5, -16, 5, 20);

        // Horizontal Beam
        ctx.fillStyle = stoneLight;
        ctx.fillRect(-7, -11, 14, 4);
        ctx.strokeRect(-7, -11, 14, 4);

        // 3. CRACK DETAIL
        ctx.strokeStyle = "rgba(0, 0, 0, 0.4)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-1, -16); 
        ctx.lineTo(0, -13); 
        ctx.lineTo(-1, -11);
        ctx.stroke();

        ctx.restore();
    }
}

   class WaveAnnouncement {
    // Now accepts a title, a subtitle, and a color
    constructor(title, subTitle = "", color = "#ffffff") {
        this.text = title;
        this.subText = subTitle;
        this.baseColor = color;
        
        // Positioning
        this.x = VIRTUAL_WIDTH / 2;
        this.y = VIRTUAL_HEIGHT / 2;

        // Animation State
        this.life = 0;           // Frame counter
        this.maxLife = 180;      // Total duration (e.g., 3 seconds at 60fps)
        this.scale = 0;          // Starts invisible
        this.alpha = 0;
        this.active = true;
    }

    update(dt) {
        this.life++;

        // 1. Entrance (Frames 0-30): Fast Pop-in with overshoot
        if (this.life < 30) {
            this.alpha = Math.min(1, this.alpha + 0.1);
            // Elastic ease-out effect
            let t = this.life / 30; 
            this.scale = 1 + Math.sin(t * Math.PI) * 0.2; // Goes to 1.2 then back to 1
        } 
        // 2. Stay Phase (Frames 30-130): Slow drift
        else if (this.life < 130) {
            this.scale = 1.0;
            this.alpha = 1.0;
        } 
        // 3. Exit (Frames 130+): Fade out and scale up slightly
        else {
            this.alpha -= 0.02;
            this.scale += 0.005; // Gentle expansion while fading
        }

        if (this.life >= this.maxLife || this.alpha <= 0) {
            this.active = false;
        }
    }

    draw() {
        if (!this.active) return;

        ctx.save();
        
        // Center alignment
        ctx.translate(this.x, this.y);
        ctx.scale(this.scale, this.scale);
        ctx.globalAlpha = Math.max(0, this.alpha);

        // --- CINEMATIC BACKGROUND STRIP ---
        // Draws a black bar behind text to ensure legibility over chaotic game play
        ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
        // Draw rectangle centered on 0,0
        ctx.fillRect(-VIRTUAL_WIDTH / 2, -60, VIRTUAL_WIDTH, 120);
        
        // --- BORDERS ON STRIP ---
        ctx.beginPath();
        ctx.moveTo(-VIRTUAL_WIDTH / 2, -60);
        ctx.lineTo(VIRTUAL_WIDTH / 2, -60);
        ctx.moveTo(-VIRTUAL_WIDTH / 2, 60);
        ctx.lineTo(VIRTUAL_WIDTH / 2, 60);
        ctx.strokeStyle = this.baseColor;
        ctx.lineWidth = 2;
        ctx.stroke();

        // --- MAIN TEXT ---
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        
        // Glow Effect
        ctx.shadowColor = this.baseColor;
        ctx.shadowBlur = 20;
        
        // Text Style
        ctx.font = "900 80px 'Segoe UI', Verdana, sans-serif"; 
        ctx.fillStyle = this.baseColor;
        ctx.fillText(this.text, 0, -10); // Slightly up to make room for subtext

        // --- SUB TEXT (If provided) ---
        if (this.subText) {
            ctx.shadowBlur = 10; // Less glow for subtext
            ctx.font = "700 30px 'Segoe UI', Verdana, sans-serif";
            ctx.fillStyle = "#ffffff";
            ctx.letterSpacing = "4px"; // Spaced out looks cooler
            ctx.fillText(this.subText.toUpperCase(), 0, 40);
        }
        
        ctx.restore();
    }
}

    class Cell {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.wall = false;
            this.occupied = false; // Cannot build on top of other buildings
            this.distance = 9999; 
            this.vecX = 0; this.vecY = 0;
        }
    }

    function sharedDestroyWalls(enemy, col, row, damage, tickRate) {
    if (enemy.wallDamageCooldown > 0) {
        enemy.wallDamageCooldown--;
        return;
    }

    let damageDealt = false;
    for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
            let c = col + i;
            let r = row + j;
            if (c >= 0 && c < COLS && r >= 0 && r < ROWS) {
                let targetCell = grid[c][r];
                if (targetCell.wall) {
                    let wx = c * CELL_SIZE + CELL_SIZE/2;
                    let wy = r * CELL_SIZE + CELL_SIZE/2;
                    let dist = Math.hypot(enemy.x - wx, enemy.y - wy);

                    if (dist < enemy.radius + CELL_SIZE/1.5) {
                        targetCell.wallHp -= damage; 
                        createParticles(wx, wy, "#555", 1);
                        damageDealt = true;

                        if (targetCell.wallHp <= 0) {
                            targetCell.wall = false;
                            targetCell.wallHp = 100;
                            updateFlowField(); 
                        }
                    }
                }
            }
        }
    }
    if (damageDealt) enemy.wallDamageCooldown = tickRate;
}

// --- NEW HELPER: Raycast to check for clear path ---
    function hasLineOfSight(x0, y0, x1, y1) {
        let dx = x1 - x0;
        let dy = y1 - y0;
        let distance = Math.hypot(dx, dy);
        
        // Check points along the line every 25 pixels (half a cell)
        let steps = Math.ceil(distance / (CELL_SIZE / 2));
        
        for (let i = 0; i <= steps; i++) {
            let t = i / steps;
            let checkX = x0 + dx * t;
            let checkY = y0 + dy * t;
            
            let col = Math.floor(checkX / CELL_SIZE);
            let row = Math.floor(checkY / CELL_SIZE);
            
            // If we hit a wall, line of sight is blocked
            if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
                if (grid[col][row].wall) return false;
            }
        }
        return true; // No walls found
    }

function sharedMovement(enemy, col, row) {
    // --- 1. CALCULATE SPEED (Your Slow Logic) ---
    let speedMod = enemy.isSlowed ? 0.5 : 1.0; 
    let currentSpeed = enemy.speed * speedMod;
    enemy.isSlowed = false; // Reset flag

    // --- 2. TAUNT CHECK (New Logic) ---
    // If enemy is taunted by a living Bard, chase the Bard instead of the base
    if (enemy.tauntTarget) {
        if (enemy.tauntTarget.hp <= 0) {
            enemy.tauntTarget = null; // Bard is dead, stop chasing
        } else {
            // Move directly towards Bard
            let dx = enemy.tauntTarget.x - enemy.x;
            let dy = enemy.tauntTarget.y - enemy.y;
            let dist = Math.hypot(dx, dy);
            
            if (dist > 0) {
                // Steer towards bard
                enemy.vx += ((dx/dist) * currentSpeed - enemy.vx) * 0.1;
                enemy.vy += ((dy/dist) * currentSpeed - enemy.vy) * 0.1;
            }
            return false; // Skip normal pathfinding
        }
    }

    // --- 3. STANDARD BASE TARGETING ---
    let baseX = (playerBase.x * CELL_SIZE) + CELL_SIZE;
    let baseY = (playerBase.y * CELL_SIZE) + CELL_SIZE;
    
    // Check Line of Sight
    if (hasLineOfSight(enemy.x, enemy.y, baseX, baseY, enemy.radius)) {
        let dx = baseX - enemy.x;
        let dy = baseY - enemy.y;
        let dist = Math.hypot(dx, dy);
        
        if (dist > 0) {
            enemy.vx += ((dx/dist) * currentSpeed - enemy.vx) * 0.1;
            enemy.vy += ((dy/dist) * currentSpeed - enemy.vy) * 0.1;
        }
        return false; 
    }

    // Fallback to Grid Pathfinding
    let onGrid = (col >= 0 && col < COLS && row >= 0 && row < ROWS);
    let cell = onGrid ? grid[col][row] : null;

    if (onGrid && cell.distance !== Infinity) {
        let moveDir = getSmartVector(enemy);
        enemy.vx += (moveDir.x * currentSpeed - enemy.vx) * 0.1;
        enemy.vy += (moveDir.y * currentSpeed - enemy.vy) * 0.1;
        return false; 
    } else {
        // Blocked / Last Resort
        let dx = baseX - enemy.x;
        let dy = baseY - enemy.y;
        let dist = Math.hypot(dx, dy);
        
        if (dist > 0) {
            enemy.vx += ((dx/dist) * currentSpeed - enemy.vx) * 0.1;
            enemy.vy += ((dy/dist) * currentSpeed - enemy.vy) * 0.1;
        }
        return true;
    }
}

   class Enemy {
    constructor() {
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- STATS ---
        this.radius = 8; 
        this.speed = 0.8 + (Math.random() * 0.4);
        this.hp = 20 + (wave * 7);
        this.vx = -1; 
        this.vy = 0;
        this.maxHp = this.hp;
        
        // --- VISUALS ---
        this.angle = 0; 
        this.animTimer = Math.random() * 10; 
        
        this.attackCooldown = 0; 
        this.wallDamageCooldown = 0;
        this.bounty = 2;
    }

    update(dt) {
        // Animation speed
        this.animTimer += 0.3 * dt; 

        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);

        let isBlocked = sharedMovement(this, col, row);
        if (isBlocked) sharedDestroyWalls(this, col, row, 2, 10);

        if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
            this.angle = Math.atan2(this.vy, this.vx);
        }

        this.x += this.vx;
        this.y += this.vy;

        separate(this, enemies, 0.5); 
        separate(this, allies, 0.8);
        resolveWallCollision(this);

        if (this.attackCooldown > 0) this.attackcooldown-=dt;
        
        let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dx, dy) < 30) { takeDamage(5); this.hp = 0; }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        let pct = this.hp / this.maxHp;
        
        // --- PALETTE ---
        let armorColor = "#d8d0a0"; 
        let jointColor = "#4b5320"; 
        let coreColor = `rgba(255, ${Math.floor(50 * pct)}, 0, 1)`; 

        // --- 1. DRAW LEGS ---
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // Updated for Spider Walking Logic
        const drawLeg = (ox, oy, restX, restY, phase, side, widthMod, bendMod) => {
            let cycle = this.animTimer + phase;
            
            // WALKING LOGIC:
            // 1. Move parallel to body (X-axis) for the step.
            //    Math.cos(cycle) creates the Forward/Back stride.
            // 2. Slight In/Out motion (Y-axis) to simulate the arc of lifting the leg.
            //    -Math.sin(cycle) pulls leg in during the 'lift'.
            
            let strideRange = 2.5; // How far the foot steps forward/back
            
            // Calculate dynamic foot position based on resting position
            let footX = ox + restX + (Math.cos(cycle) * strideRange); 
            let footY = oy + restY + (Math.abs(Math.sin(cycle)) * -1.5 * side); // "Lift" effect

            let midX = (ox + footX) / 2;
            let midY = (oy + footY) / 2;
            
            // Knee projection
            let kneeX = midX - 1.5; 
            let kneeY = midY + (side * bendMod); 

            // Thin Outline
            ctx.strokeStyle = "#0f1405"; 
            ctx.lineWidth = 1.5 + widthMod;
            ctx.beginPath();
            ctx.moveTo(ox, oy);
            ctx.lineTo(kneeX, kneeY);
            ctx.lineTo(footX, footY);
            ctx.stroke();

            // Bone Armor
            ctx.strokeStyle = armorColor;
            ctx.lineWidth = 0.8 + widthMod;
            ctx.beginPath();
            ctx.moveTo(ox, oy);       
            ctx.lineTo(kneeX, kneeY); 
            ctx.lineTo(footX, footY); 
            ctx.stroke();

            // Joints
            ctx.fillStyle = jointColor;
            ctx.beginPath();
            ctx.arc(kneeX, kneeY, 1 + widthMod, 0, Math.PI*2);
            ctx.fill();
            
            // Tip
            ctx.fillStyle = "#8b0000"; 
            ctx.beginPath();
            ctx.arc(footX, footY, 0.8, 0, Math.PI*2);
            ctx.fill();
        };

        // --- LEG CONFIGURATION (Spider Gait) ---
        // Using alternating phases (0 vs PI) for adjacent legs creates the "Tripod" run.
        // Also adjusted 'restX' so front legs point forward and back legs point backward.

        // 1. BACK PAIR (Points Backward)
        // ox: -5, restX: -4 (Reaches behind)
        drawLeg(-5, -1.5, -4, -6, 0, -1, 0.5, 3);
        drawLeg(-5, 1.5, -4, 6, Math.PI, 1, 0.5, 3);
        
        // 2. MID-BACK PAIR (Points Slightly Back/Out)
        // ox: -2, restX: -2
        drawLeg(-2, -1.8, -2, -8, Math.PI, -1, 0.2, 5);
        drawLeg(-2, 1.8, -2, 8, 0, 1, 0.2, 5);
        
        // 3. MID-FRONT PAIR (Points Slightly Forward/Out)
        // ox: 1, restX: 2
        drawLeg(1, -1.8, 2, -7, 0, -1, 0.2, 4);
        drawLeg(1, 1.8, 2, 7, Math.PI, 1, 0.2, 4);
        
        // 4. FRONT PAIR (Points Forward)
        // ox: 4, restX: 4 (Reaches ahead)
        drawLeg(4, -1.2, 4, -4, Math.PI, -1, 0.5, 2);
        drawLeg(4, 1.2, 4, 4, 0, 1, 0.5, 2);


        // --- 2. ABDOMEN ---
        let pulse = 0.5 + Math.sin(this.animTimer * 0.5) * 0.1;
        
        ctx.fillStyle = "#2a2205"; 
        ctx.beginPath();
        ctx.ellipse(-4, 0, 9, 3.5, 0, 0, Math.PI * 2);
        ctx.fill();

        // Glowing Vents
        ctx.fillStyle = coreColor;
        ctx.shadowBlur = 6 * pulse;
        ctx.shadowColor = "red";
        for(let i = 0; i < 4; i++) { 
            let xOff = -2 - (i * 2.5);
            ctx.beginPath();
            ctx.ellipse(xOff, 0, 0.8, 2.5 - (i*0.4), 0, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.shadowBlur = 0;

        // --- 3. HEAD ---
        ctx.fillStyle = armorColor;
        ctx.beginPath();
        ctx.moveTo(1, -2.5);
        ctx.lineTo(5, -2);
        ctx.lineTo(9, 0); 
        ctx.lineTo(5, 2);
        ctx.lineTo(1, 2.5);
        ctx.fill();
        
        ctx.strokeStyle = jointColor;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(3, -1.5); ctx.lineTo(3, 1.5);
        ctx.stroke();

        // --- 4. EYES ---
        ctx.fillStyle = '#ccff00';
        ctx.shadowColor = '#ccff00';
        ctx.shadowBlur = 4;
        
        ctx.beginPath(); ctx.arc(7, -1, 1, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(7, 1, 1, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(6, -2, 0.8, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(6, 2, 0.8, 0, Math.PI*2); ctx.fill();
        
        ctx.shadowBlur = 0;

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class TankEnemy {
    constructor() {
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- TANK STATS ---
        this.radius = 22; // Increased size (was 16)
        this.baseSpeed = 0.3 + (Math.random() * 0.2);
        this.speed = this.baseSpeed;
        
        this.hp = 150 + (wave * 50); 
        this.maxHp = this.hp;
        this.bounty = 5;

        this.vx = -1; 
        this.vy = 0;
        this.angle = 0;
        
        this.attackCooldown = 0; 
        this.wallDamageCooldown = 0;
        
        this.animOffset = Math.random() * 10000;
        
        // Jagged Obsidian Body Shape
        this.bodyPoints = [];
        let segments = 7; 
        for (let i = 0; i < segments; i++) {
            this.bodyPoints.push(0.9 + Math.random() * 0.3); 
        }
    }

    update(dt) {
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);

        let isBlocked = sharedMovement(this, col, row);
        
        if (isBlocked) sharedDestroyWalls(this, col, row, 5, 15);

        if (Math.abs(this.vx) > 0.01 || Math.abs(this.vy) > 0.01) {
            this.angle = Math.atan2(this.vy, this.vx);
        }

        this.x += this.vx;
        this.y += this.vy;

        separate(this, enemies, 0.4); 
        separate(this, allies, 0.2);
        resolveWallCollision(this);

        if (this.attackCooldown > 0) this.attackcooldown-=dt;
        
        let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dx, dy) < 30 + this.radius) { takeDamage(20); this.hp = 0; }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        let time = Date.now() + this.animOffset;
        let breath = Math.sin(time * 0.005) * 1.5; // Deeper breath for bigger body

        // --- COLORS ---
        let hpPct = this.hp / this.maxHp;
        let colorBody   = '#151515'; 
        let colorArmor  = '#2a2a2a'; 
        let colorSpike  = '#404040';
        let colorGlow =  '#ff4500'; 

        // --- 1. REAR LEGS (Vestigial) ---
        // Pushed wider to match new body width
        ctx.fillStyle = colorBody;
        const drawLeg = (yOffset, phase) => {
            let kick = Math.sin(time * 0.005 + phase) * 3;
            ctx.beginPath();
            ctx.moveTo(-10, yOffset); // Shifted back
            ctx.lineTo(-16 + kick, yOffset + 4);
            ctx.lineTo(-16 + kick, yOffset - 4);
            ctx.fill();
        };
        drawLeg(-9, 0);       // Wider spacing
        drawLeg(9, Math.PI);

        // --- 2. MAIN BODY ---
        ctx.fillStyle = colorBody;
        ctx.beginPath();
        let segments = this.bodyPoints.length;
        for (let i = 0; i < segments; i++) {
            let theta = (i / segments) * Math.PI * 2;
            // Radius scales automatically here
            let r = (this.radius * 0.85 * this.bodyPoints[i]) + breath;
            let px = Math.cos(theta) * r;
            let py = Math.sin(theta) * r;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();

        // Glowing Cracks (Scaled up)
        ctx.strokeStyle = colorGlow;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-6, 0); ctx.lineTo(6, -3); ctx.lineTo(0, 6);
        ctx.stroke();

        // --- 3. ARMOR PLATES (Scaled positions) ---
        ctx.fillStyle = colorArmor;
        const drawSpikedPlate = (yDir) => {
            ctx.beginPath();
            // Pushed out yDir * 3 to fit bigger body
            ctx.translate(0, yDir * 3); 
            ctx.moveTo(-2, 2 * yDir);
            ctx.lineTo(8, 4 * yDir);
            ctx.lineTo(10, 10 * yDir);
            ctx.lineTo(-6, 12 * yDir);
            ctx.lineTo(-10, 6 * yDir);
            ctx.fill();

            // Spike
            ctx.fillStyle = colorSpike;
            ctx.beginPath();
            ctx.moveTo(0, 7 * yDir);
            ctx.lineTo(14, 14 * yDir); 
            ctx.lineTo(5, 5 * yDir);
            ctx.fill();
            
            // Reset translate
            ctx.translate(0, -yDir * 3);
            ctx.fillStyle = colorArmor;
        };
        drawSpikedPlate(-1);
        drawSpikedPlate(1);

        // --- 4. HEAD / VISOR (Moved forward) ---
        // Moved x from 8 to 12
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(12, 0, 5, 7, 0, 0, Math.PI*2);
        ctx.fill();
        
        ctx.shadowColor = colorGlow;
        ctx.shadowBlur = 10;
        ctx.fillStyle = colorGlow;
        ctx.beginPath();
        ctx.moveTo(12, -5); 
        ctx.lineTo(16, 0); 
        ctx.lineTo(12, 5);
        ctx.lineTo(11, 0); 
        ctx.fill();
        ctx.shadowBlur = 0;

        // --- 5. ARMS (Adjusted for Size) ---
        const drawArm = (side) => {
            let swingPhase = time * 0.003 + (side === 1 ? 0 : Math.PI); 
            let extension = Math.sin(swingPhase) * 5; 
            let rotation = Math.cos(swingPhase) * 0.3;

            ctx.save();
            // Shoulders moved: x (6->10), y (7->12) to clear the fat body
            ctx.translate(10, side * 12); 
            ctx.rotate(rotation);

            // ARM SHAPE: Thick and Short
            ctx.fillStyle = colorArmor;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            // Wrist
            ctx.lineTo(8 + extension, -side * 6); 
            ctx.lineTo(6 + extension, side * 10);
            // Armpit
            ctx.lineTo(-6, side * 7);
            ctx.fill();

            // FIST
            ctx.translate(8 + extension, 0); 
            ctx.rotate(side * 0.5); 
            
            ctx.fillStyle = colorBody;
            ctx.beginPath();
            ctx.moveTo(0, -7); 
            ctx.lineTo(9, -6); 
            ctx.lineTo(14, 0); // Knuckles
            ctx.lineTo(9, 6);
            ctx.lineTo(0, 7);
            ctx.fill();

            // Magma Spike
            ctx.fillStyle = colorGlow;
            ctx.beginPath();
            ctx.moveTo(9, -4); ctx.lineTo(16, 0); ctx.lineTo(9, 4);
            ctx.fill();

            ctx.restore();
        };

        drawArm(-1); 
        drawArm(1);  

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}
    
class RunnerEnemy {
    constructor() {
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- RUNNER STATS ---
        this.radius = 7; // Slightly larger visual presence, same collision feel
        this.baseSpeed = 2.2 + (Math.random() * 0.6); 
        this.speed = this.baseSpeed;
        
        this.hp = 10 + (wave * 3); 
        this.maxHp = this.hp;
        this.bounty = 2;

        this.vx = -1; 
        this.vy = 0;
        this.attackCooldown = 0; 
        
        // --- VISUALS ---
        this.wallDamageCooldown = 0;
        this.animTimer = Math.random() * 10; 
        this.angle = Math.PI; 
    }

    update(dt) {
        this.animTimer += 0.5*dt; // Rapid, jittery movement

        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);

        let isBlocked = sharedMovement(this, col, row);
        
        // Rotate to face velocity
        if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
            this.angle = Math.atan2(this.vy, this.vx);
        }

        if (isBlocked) sharedDestroyWalls(this, col, row, 0.5, 5);

        this.x += this.vx;
        this.y += this.vy;

        separate(this, enemies, 0.5); 
        separate(this, allies, 0.8);
        resolveWallCollision(this);

        if (this.attackCooldown > 0) this.attackcooldown-=dt;
        
        let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dx, dy) < 30) { takeDamage(2); this.hp = 0; }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle); 
        
        // Scale down slightly to fit the tile, but keep details chunky
        // No flip needed, this creature is radially symmetrical-ish
        
        let pct = this.hp / this.maxHp;
        
        // --- PALETTE: High Contrast for Small Scale ---
        // Dark Obsidian Armor
        let armorColor = "#0a0a12"; 
        // Hostile Neon Red/Magenta (Shifts to dull purple when dying)
        let energyColor = `rgb(255, ${50 * pct}, ${100 * pct})`; 
        // Bright core for visibility
        let coreColor = "#ffffff";

        // --- 1. THE LEGS (Scythe Blades) ---
        // Instead of thin lines, we use filled triangles/curves (Scythes).
        // These read much better at small sizes.
        
        ctx.fillStyle = energyColor;
        
        // Helper to draw a scythe leg
        // yOffset: Position on body
        // size: length of blade
        // phase: animation timing
        const drawScythe = (yOffset, size, phase, isRight) => {
            let cycle = Math.sin(this.animTimer + phase);
            let reach = cycle * 4; // How far forward/back it strikes
            let lift = Math.abs(Math.cos(this.animTimer + phase)) * 3; // Up/Down
            
            ctx.save();
            ctx.scale(1, isRight ? 1 : -1); // Mirror for other side
            
            ctx.beginPath();
            // Leg pivot point
            ctx.translate(0, yOffset);
            
            // Movement logic
            let rotation = (reach * 0.1); 
            ctx.rotate(rotation);

            // Draw Scythe Shape (Thick at base, sharp at tip)
            ctx.beginPath();
            ctx.moveTo(0, 0); 
            ctx.lineTo(size, -lift - 4); // The "Elbow"
            ctx.lineTo(size + 2, -lift + 4); // The Tip (stabbing ground)
            ctx.lineTo(2, 2); // Return to body
            ctx.fill();
            
            // Highlight on blade tip
            ctx.fillStyle = coreColor;
            ctx.beginPath();
            ctx.arc(size + 2, -lift + 4, 1, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = energyColor; // Reset

            ctx.restore();
        };

        // Draw 4 Scythe Legs (2 pairs)
        // Back Pair (Larger, bounding)
        drawScythe(2, 8, 0, true);
        drawScythe(2, 8, 0, false);
        
        // Front Pair (Smaller, stabbing)
        drawScythe(-2, 6, Math.PI, true);
        drawScythe(-2, 6, Math.PI, false);

        // --- 2. THE BODY (Exotic Carapace) ---
        // A sharp, diamond/arrowhead shape
        ctx.fillStyle = armorColor;
        ctx.strokeStyle = energyColor;
        ctx.lineWidth = 1.5;

        ctx.beginPath();
        ctx.moveTo(8, 0);   // Head tip (Sharp)
        ctx.lineTo(2, -4);  // Shoulder
        ctx.lineTo(-6, -2); // Rear
        ctx.lineTo(-8, 0);  // Tail tip
        ctx.lineTo(-6, 2);  // Rear
        ctx.lineTo(2, 4);   // Shoulder
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // --- 3. THE CORE (Visibility Anchor) ---
        // A glowing stripe down the back so you can see it in the dark
        ctx.shadowBlur = 6;
        ctx.shadowColor = energyColor;
        ctx.fillStyle = energyColor;
        
        ctx.beginPath();
        ctx.moveTo(4, 0);
        ctx.lineTo(-4, 0);
        ctx.lineWidth = 2;
        ctx.strokeStyle = energyColor;
        ctx.stroke();
        
        // Center "Eye" or "Reactor"
        ctx.fillStyle = coreColor;
        ctx.beginPath();
        ctx.arc(2, 0, 1.5, 0, Math.PI*2);
        ctx.fill();
        
        ctx.shadowBlur = 0; // Reset

        // --- 4. MANDIBLES (Hostility) ---
        // Tiny pincers at the front
        ctx.fillStyle = armorColor;
        ctx.beginPath();
        
        // Left Mandible
        ctx.moveTo(7, -1);
        ctx.lineTo(10, -2);
        ctx.lineTo(9, -0.5);
        
        // Right Mandible
        ctx.moveTo(7, 1);
        ctx.lineTo(10, 2);
        ctx.lineTo(9, 0.5);
        ctx.fill();

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}
class BreacherEnemy {
    constructor() {
        // --- SPAWN ---
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- STATS ---
        this.radius = 14; 
        this.speed = 0.8;       
        this.hp = 40 + (wave * 8); 
        this.maxHp = this.hp;
        this.bounty = 7;

        this.vx = -1; 
        this.vy = 0;
        
        // --- EXPLOSION LOGIC ---
        this.triggered = false;
        this.explodeTimer = 35; 
        this.explodeRadius = 70; 

        // --- VISUALS ---
        this.walkCycle = Math.random() * 10;
        this.antennaTimer = 0;
    }

    update(dt) {
        this.antennaTimer += 0.2*dt;

        // --- 1. ANIMATION SPEED ---
        if (!this.triggered) {
            this.walkCycle += 0.3; 
        } else {
            this.walkCycle += 0.8; 
        }

        // --- 2. TRIGGER LOGIC (COUNTDOWN) ---
        if (this.triggered) {
            this.explodeTimer--;
            this.vx *= 0.85; 
            this.vy *= 0.85;
            
            if (Math.random() < 0.2) createParticles(this.x, this.y, "#ff4500", 1);
            if (this.explodeTimer <= 0) this.detonate();
            return; 
        }

        // --- 3. MOVEMENT & TARGETING ---
        let moveDir = {x:0, y:0};
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);
        
        // Check grid boundaries
        let onGrid = (col >= 0 && col < COLS && row >= 0 && row < ROWS);
        let cell = onGrid ? grid[col][row] : null;
        let hasPath = (onGrid && cell.distance !== Infinity);

        if (hasPath) {
            moveDir = getSmartVector(this);
        } else {
            // Fallback: Move straight to base if no path found
            let dx = (playerBase.x * CELL_SIZE + CELL_SIZE/2) - this.x;
            let dy = (playerBase.y * CELL_SIZE + CELL_SIZE/2) - this.y;
            let dist = Math.hypot(dx, dy);
            if (dist > 0) moveDir = {x: dx/dist, y: dy/dist};
        }

        this.vx += (moveDir.x * this.speed - this.vx) * 0.15;
        this.vy += (moveDir.y * this.speed - this.vy) * 0.15;

        this.x += this.vx;
        this.y += this.vy;

        separate(this, enemies, 0.4); 
        resolveWallCollision(this);

        // --- 4. IMPROVED WALL DETECTION ---
        
        // A. Check Current Cell (Did user place a wall ON me?)
        if (onGrid && grid[col][row].wall) {
            this.triggered = true;
        }

        // B. Check Forward Collision (Am I walking INTO a wall?)
        // We look slightly ahead in the direction of movement + radius
        let lookAheadDist = this.radius + 4;
        let checkX = this.x + (moveDir.x * lookAheadDist);
        let checkY = this.y + (moveDir.y * lookAheadDist);
        let checkCol = Math.floor(checkX / CELL_SIZE);
        let checkRow = Math.floor(checkY / CELL_SIZE);

        if (checkCol >= 0 && checkCol < COLS && checkRow >= 0 && checkRow < ROWS) {
            if (grid[checkCol][checkRow].wall) {
                this.triggered = true;
            }
        }

        // C. Check Base Collision
        let dxBase = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dyBase = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dxBase, dyBase) < 30) this.triggered = true;
        
        // D. Check Ally Collision
        for (let ally of allies) {
            if (Math.hypot(this.x - ally.x, this.y - ally.y) < this.radius + ally.radius + 4) {
                this.triggered = true;
                break;
            }
        }
    }

    detonate() {
        // Visuals
        for(let i=0; i<25; i++) {
            createParticles(this.x, this.y, (Math.random()>0.5 ? "#ff4500" : "#ffff00"), 4);
        }

        // Damage Allies
        for (let i = allies.length - 1; i >= 0; i--) {
            let ally = allies[i];
            if (Math.hypot(this.x - ally.x, this.y - ally.y) < this.explodeRadius) {
                ally.hp -= 80; 
                createParticles(ally.x, ally.y, "red", 3);
            }
        }

        // Damage Walls
        let range = Math.ceil(this.explodeRadius / CELL_SIZE);
        let centerCol = Math.floor(this.x / CELL_SIZE);
        let centerRow = Math.floor(this.y / CELL_SIZE);

        for (let i = -range; i <= range; i++) {
            for (let j = -range; j <= range; j++) {
                let c = centerCol + i;
                let r = centerRow + j;
                if (c >= 0 && c < COLS && r >= 0 && r < ROWS) {
                    let cell = grid[c][r];
                    if (cell.wall) {
                        let wx = c * CELL_SIZE + CELL_SIZE/2;
                        let wy = r * CELL_SIZE + CELL_SIZE/2;
                        // Calculate distance to wall center
                        if (Math.hypot(this.x - wx, this.y - wy) < this.explodeRadius) {
                            cell.wallHp -= 150; 
                            if(cell.wallHp <= 0) {
                                cell.wall = false; 
                                createParticles(wx, wy, "#666", 4);
                            }
                            // Important: Recalculate paths if a wall breaks
                            updateFlowField();
                        }
                    }
                }
            }
        }

        // Damage Base
        let baseDist = Math.hypot(this.x - (playerBase.x * CELL_SIZE), this.y - (playerBase.y * CELL_SIZE));
        if (baseDist < this.explodeRadius + 20) takeDamage(40);

        this.hp = 0; // Enemy dies
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        let angle = Math.atan2(this.vy, this.vx);
        if (Math.abs(this.vx) + Math.abs(this.vy) < 0.1) angle = Math.PI;
        ctx.rotate(angle);

        // --- PALETTE ---
        let legColor = "#dddddd"; 
        let jointColor = "#ffffff"; 
        let bodyColor = "#8b0000"; 
        let headColor = "#a52a2a"; 
        
        // Trigger Effects
        let swell = 0;
        let buttColor = "#ff4500"; 
        if (this.triggered) {
            swell = Math.sin(Date.now() / 30) * 2; 
            buttColor = (Math.floor(Date.now() / 40) % 2 === 0) ? "#ffffff" : "#ff4500";
        } else {
            swell = Math.sin(Date.now() / 200) * 0.5;
        }

        // --- 1. ABDOMEN ---
        ctx.fillStyle = buttColor;
        ctx.beginPath();
        ctx.arc(-11, 0, 10 + swell, 0, Math.PI*2);
        ctx.fill();
        
        ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        ctx.beginPath();
        ctx.arc(-11, 0, 7 + swell, 0, Math.PI*2);
        ctx.fill();

        // --- 2. LEGS ---
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        const drawLeg = (ox, oy, restX, restY, phase, side, widthMod, bendMod) => {
            let cycle = this.walkCycle + phase;
            let strideRange = 3.5;
            
            let footX = ox + restX + (Math.cos(cycle) * strideRange); 
            let footY = oy + restY + (Math.abs(Math.sin(cycle)) * -2.0 * side); 

            let midX = (ox + footX) / 2;
            let midY = (oy + footY) / 2;
            
            let kneeX = midX - 1.5; 
            let kneeY = midY + (side * bendMod); 

            ctx.strokeStyle = "#111"; 
            ctx.lineWidth = 1.5 + widthMod;
            ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(kneeX, kneeY); ctx.lineTo(footX, footY); ctx.stroke();

            ctx.strokeStyle = legColor;
            ctx.lineWidth = 0.8 + widthMod;
            ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(kneeX, kneeY); ctx.lineTo(footX, footY); ctx.stroke();

            ctx.fillStyle = jointColor;
            ctx.beginPath(); ctx.arc(kneeX, kneeY, 1 + widthMod, 0, Math.PI*2); ctx.fill();
            
            ctx.fillStyle = "#ff0000"; 
            ctx.beginPath(); ctx.arc(footX, footY, 0.8, 0, Math.PI*2); ctx.fill();
        };

        // --- LEG CONFIGURATION ---
        drawLeg(-2, -4, -2, -8, Math.PI, -1, 0.2, 5);
        drawLeg(-2, 4, -2, 8, 0, 1, 0.2, 5);
        drawLeg(3, -4, 2, -7, 0, -1, 0.2, 4);
        drawLeg(3, 4, 2, 7, Math.PI, 1, 0.2, 4);
        drawLeg(7, -3, 4, -4, Math.PI, -1, 0.5, 2);
        drawLeg(7, 3, 4, 4, 0, 1, 0.5, 2);


        // --- 3. THORAX ---
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.ellipse(0, 0, 8, 4.5, 0, 0, Math.PI*2);
        ctx.fill();

        // Thorax Armor Plate
        ctx.fillStyle = "rgba(255,255,255,0.1)";
        ctx.beginPath();
        ctx.ellipse(0, -1, 5, 2, 0, 0, Math.PI*2);
        ctx.fill();

        // --- 4. HEAD ---
        ctx.fillStyle = headColor;
        ctx.beginPath();
        ctx.arc(10, 0, 4.5, 0, Math.PI*2);
        ctx.fill();

        // Mandibles
        ctx.fillStyle = "#eee";
        ctx.beginPath();
        ctx.moveTo(13, -2); ctx.lineTo(17, -3); ctx.lineTo(14, -1);
        ctx.moveTo(13, 2); ctx.lineTo(17, 3); ctx.lineTo(14, 1);
        ctx.fill();

        // Eyes
        ctx.fillStyle = this.triggered ? "#fff" : "#ffff00";
        ctx.beginPath(); ctx.arc(11, -2, 1.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(11, 2, 1.5, 0, Math.PI*2); ctx.fill();

        // Antennae
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 1;
        let twitch = Math.sin(this.antennaTimer) * 1;
        ctx.beginPath(); ctx.moveTo(12, -2); ctx.lineTo(19, -8 + twitch); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(12, 2); ctx.lineTo(19, 8 - twitch); ctx.stroke();

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

    class DasherEnemy {
    constructor() {
        // --- STANDARD SPAWN LOGIC ---
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- DASHER STATS ---
        this.radius = 8; // Much smaller hitbox (was 12)
        this.hp = 25 + (wave * 5); // Slightly less HP due to size
        this.maxHp = this.hp;
        this.bounty = 4;
        
        // Speed Setup
        this.baseSpeed = 0.7; // Slightly faster base speed because small = fast
        this.dashSpeed = 6.0; 
        this.speed = this.baseSpeed;
        
        this.vx = -1; 
        this.vy = 0;
        this.attackCooldown = 0; 
        this.wallDamageCooldown = 0;

        // --- DASH SPECIFIC LOGIC ---
        this.dashTimer = 0;
        this.dashThreshold = 120; // Frames until dash
        this.isDashing = false;

        // --- VISUAL VARS ---
        this.wobbleOffset = Math.random() * 1000;
        this.glowColorHex = "#ff4500"; 
    }

    update(dt) {
        // --- 1. DASH MECHANIC ---
        this.dashTimer++;

        // State A: NOT Dashing (Normal Behavior)
        if (!this.isDashing) {
            // Trigger Dash
            if (this.dashTimer > this.dashThreshold) { 
                this.isDashing = true;
                this.dashTimer = 0;
                
                let currentSpeed = Math.hypot(this.vx, this.vy);
                
                // Calculate dash vector
                if (currentSpeed > 0.01) {
                    this.vx = (this.vx / currentSpeed) * 8; 
                    this.vy = (this.vy / currentSpeed) * 8;
                } else {
                    let dx = (playerBase.x * CELL_SIZE + CELL_SIZE/2) - this.x;
                    let dy = (playerBase.y * CELL_SIZE + CELL_SIZE/2) - this.y;
                    let dist = Math.hypot(dx, dy);
                    this.vx = (dx / dist) * 8;
                    this.vy = (dy / dist) * 8;
                }
                
                // Big burst of particles on the "Flap"
                createParticles(this.x, this.y, this.glowColorHex, 8);
            }
        } 
        // State B: CURRENTLY DASHING
        else {
            if (this.dashTimer > 20) {
                this.isDashing = false;
                this.dashTimer = 0;
                this.vx *= 0.2; // Brake
                this.vy *= 0.2;
            }
        }

        // --- 2. MOVEMENT & WALLS ---
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);

        if (!this.isDashing) {
            let isBlocked = sharedMovement(this, col, row);
            if (isBlocked) sharedDestroyWalls(this, col, row, 1, 8);
        } else {
            let onGrid = (col >= 0 && col < COLS && row >= 0 && row < ROWS);
            let cell = onGrid ? grid[col][row] : null;
            let pathExists = (onGrid && cell.distance !== Infinity);

            if (!pathExists) {
                sharedDestroyWalls(this, col, row, 8, 2);
            }
        }

        // --- 3. PHYSICS ---
        this.x += this.vx;
        this.y += this.vy;

        separate(this, enemies, 0.4); 
        separate(this, allies, 0.6);
        resolveWallCollision(this);

        // --- 4. ATTACK ALLIES ---
        if (this.attackCooldown > 0) this.attackcooldown-=dt;

        for (let ally of allies) {
            let dist = Math.hypot(ally.x - this.x, ally.y - this.y);
            if (dist < this.radius + ally.radius + 5) {
                if (this.attackCooldown <= 0) {
                    ally.hp -= (this.damage || 4); 
                    this.attackCooldown = 60; 
                    createParticles(ally.x, ally.y, "red", 3);
                }
                if (!this.isDashing) {
                    this.vx *= 0.5;
                    this.vy *= 0.5;
                }
            }
        }
        
        // --- 5. ATTACK BASE ---
        let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dx, dy) < 20) { 
            takeDamage(5); 
            this.hp = 0;    
            createParticles(this.x, this.y, this.glowColorHex, 10);
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        // Rotate towards movement
        let angle = Math.atan2(this.vy, this.vx);
        if (Math.abs(this.vx) + Math.abs(this.vy) < 0.1) angle = Math.PI;
        ctx.rotate(angle);

        let time = Date.now() / 100 + this.wobbleOffset;

        // --- PALETTE ---
        const chitinDark = "#1a0505";   
        const chitinMid = "#5c0a0a";    
        const wingColor = "#a31414";  
        const glowColor = this.glowColorHex; 

        // --- WING ANIMATION LOGIC ---
        let wingAngle = 0.5; // Default angle (radians)

        if (this.isDashing) {
            // DASHING: Wings snapped back tight (aerodynamic)
            // They stay back for the duration of the dash
            wingAngle = 2.8; 
        } 
        else {
            // NOT DASHING
            let timeUntilDash = this.dashThreshold - this.dashTimer;
            
            if (timeUntilDash < 30) {
                // WIND-UP PHASE (Last 0.5s before dash):
                // Wings spread WIDE open to prepare for the stroke
                // Lerp from normal flutter to wide open (approx PI/2)
                let percent = 1 - (timeUntilDash / 30);
                wingAngle = 0.5 + (percent * 1.5); // Opens up to ~2.0 rads
                
                // Add a violent shake just before launch
                wingAngle += Math.sin(time * 50) * 0.1; 
            } else {
                // IDLE: Gentle flutter
                wingAngle = 0.4 + Math.sin(time * 0.8) * 0.2;
            }
        }

        // --- DRAW WINGS (Under Body) ---
        // Top Wing
        ctx.save();
        ctx.fillStyle = wingColor;
        ctx.rotate(-wingAngle);
        ctx.beginPath();
        // Sharp, aggressive insect wing shape
        ctx.moveTo(0, 0); 
        ctx.lineTo(8, -8); // Wing tip (scaled down)
        ctx.lineTo(12, -2); 
        ctx.lineTo(2, 2); 
        ctx.fill();
        ctx.restore();

        // Bottom Wing (Mirrored)
        ctx.save();
        ctx.fillStyle = wingColor;
        ctx.rotate(wingAngle);
        ctx.beginPath();
        ctx.moveTo(0, 0); 
        ctx.lineTo(8, 8); 
        ctx.lineTo(12, 2); 
        ctx.lineTo(2, -2); 
        ctx.fill();
        ctx.restore();


        // --- DRAW BODY (Scaled Down) ---
        // Tail (Engine)
        ctx.save();
        ctx.translate(-6, 0); 
        ctx.fillStyle = chitinDark;
        ctx.beginPath();
        ctx.moveTo(0, -3); ctx.lineTo(-6, 0); ctx.lineTo(0, 3);
        ctx.fill();
        // Engine Glow
        if(this.isDashing || this.dashTimer > 100) {
            ctx.fillStyle = glowColor;
            ctx.globalAlpha = (this.isDashing) ? 1 : 0.5;
            ctx.beginPath(); ctx.arc(-4, 0, 2, 0, Math.PI*2); ctx.fill();
            ctx.globalAlpha = 1;
        }
        ctx.restore();

        // Thorax (Middle)
        ctx.fillStyle = chitinMid;
        ctx.beginPath();
        ctx.ellipse(0, 0, 5, 3, 0, 0, Math.PI*2);
        ctx.fill();

        // Head
        ctx.save();
        ctx.translate(5, 0);
        ctx.fillStyle = chitinDark;
        ctx.beginPath();
        ctx.moveTo(-2, -3); ctx.lineTo(4, -1); ctx.lineTo(4, 1); ctx.lineTo(-2, 3);
        ctx.fill();

        // Glowing Eyes
        ctx.fillStyle = glowColor;
        if(this.isDashing) {
            ctx.shadowBlur = 5; ctx.shadowColor = glowColor;
        }
        ctx.beginPath(); ctx.arc(2, -1.5, 1, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(2, 1.5, 1, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;

        // Mandibles (Tiny)
        ctx.strokeStyle = chitinMid;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(4, -1); ctx.lineTo(7, -0.5); // Top
        ctx.moveTo(4, 1); ctx.lineTo(7, 0.5);   // Bottom
        ctx.stroke();

        ctx.restore(); // Head Restore
        ctx.restore(); // Main Restore
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class SniperEnemy {
    constructor() {
        // --- POSITION ---
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- STATS ---
        this.radius = 15; // Increased radius for bulkier appearance
        this.hp = 20 + (wave * 5);
        this.maxHp = this.hp;
        this.bounty = 10;
        this.damage = 100; 
        
        // --- MOVEMENT ---
        this.speed = 0.7;
        this.vx = -1; 
        this.vy = 0;
        
        // --- COMBAT ---
        this.range = 450;        
        this.shootCooldown = 60;
        this.shootTimer = 0;
        this.isAiming = false;
        this.currentTarget = null;
        
        // --- VISUALS ---
        this.angle = 0;
        this.animTimer = Math.random() * 100;
        this.laserTargetX = null;
        this.laserTargetY = null;
        this.laserAlpha = 0;
    }

    update(dt) {
        this.animTimer += 0.1*dt;

        // 1. TARGETING
        let baseX = playerBase.x * CELL_SIZE + CELL_SIZE/2;
        let baseY = playerBase.y * CELL_SIZE + CELL_SIZE/2;
        
        let foundTarget = null;
        let minDist = this.range;

        // A. Base Check
        let distToBase = Math.hypot(this.x - baseX, this.y - baseY);
        if (distToBase <= this.range) {
            foundTarget = { x: baseX, y: baseY, isBase: true };
            minDist = distToBase;
        }

        // B. Soldier Check
        if (typeof allies !== 'undefined') {
            for (let ally of allies) {
                let d = Math.hypot(this.x - ally.x, this.y - ally.y);
                if (d < minDist) {
                    minDist = d;
                    foundTarget = ally;
                }
            }
        }

        // 2. STATE MACHINE
        if (foundTarget) {
            // ATTACK
            this.currentTarget = foundTarget;
            this.isAiming = true;
            this.shootTimer++;

            this.vx *= 0.5; this.vy *= 0.5;
            this.angle = Math.atan2(foundTarget.y - this.y, foundTarget.x - this.x);

            if (this.shootTimer >= this.shootCooldown) {
                this.fire(foundTarget);
                this.shootTimer = 0; 
            }

        } else {
            // MOVE
            this.isAiming = false;
            this.shootTimer = Math.max(0, this.shootTimer - 2); 
            this.currentTarget = null;

            let col = Math.floor(this.x / CELL_SIZE);
            let row = Math.floor(this.y / CELL_SIZE);
            let isBlocked = sharedMovement(this, col, row);
            if (isBlocked) sharedDestroyWalls(this, col, row, 10, 40);

            this.x += this.vx;
            this.y += this.vy;

            if (Math.abs(this.vx) > 0.05 || Math.abs(this.vy) > 0.05) {
                this.angle = Math.atan2(this.vy, this.vx);
            }
        }

        // 3. PHYSICS
        separate(this, enemies, 0.6); 
        resolveWallCollision(this);
    }

    fire(target) {
        this.laserTargetX = target.x;
        this.laserTargetY = target.y;
        this.laserAlpha = 1.0; 
        
        createParticles(target.x, target.y, "#ff4500", 8); 
        createParticles(this.x + Math.cos(this.angle)*25, this.y + Math.sin(this.angle)*25, "#ffffaa", 5); 

        if (target.isBase) takeDamage(this.damage); 
        else target.hp -= this.damage; 
    }

    draw() {
        ctx.save();
        
        // --- ANIMATION VALUES ---
        let progress = Math.min(1, this.shootTimer / this.shootCooldown);
        
        // Phase 1: Jaws Open (0% to 30%)
        let jawOpenPct = Math.min(1, Math.max(0, progress / 0.3));
        
        // Phase 2: Barrel Slides Out (20% to 80%)
        let barrelSlidePct = Math.min(1, Math.max(0, (progress - 0.2) / 0.6));
        
        // Phase 3: Vibration (80%+)
        let shake = (progress > 0.8) ? (Math.random() - 0.5) * 2 : 0;
        let kick = (this.shootTimer < 5 && this.isAiming) ? 6 : 0;

        // --- 1. LASER ---
        if (this.laserAlpha > 0) {
            ctx.globalAlpha = this.laserAlpha;
            ctx.lineCap = "round";
            ctx.shadowBlur = 20; ctx.shadowColor = "#ff2200";
            ctx.strokeStyle = `rgba(255, 69, 0, ${this.laserAlpha})`; 
            ctx.lineWidth = 6 + Math.random() * 4; 
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.laserTargetX, this.laserTargetY); ctx.stroke();
            ctx.shadowBlur = 0;
            ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; 
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.laserTargetX, this.laserTargetY); ctx.stroke();
            ctx.globalAlpha = 1.0;
            this.laserAlpha -= 0.08; 
        }

        // --- TRANSFORM ---
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.translate(-kick, 0); 

        // --- 2. LEGS ---
        ctx.fillStyle = "#111"; 
        ctx.strokeStyle = "#444"; ctx.lineWidth = 0.5;
        for(let i = -1; i <= 1; i+=2) {
             let offset = (i===-1) ? 0 : Math.PI; 
             let walk = Math.sin(this.animTimer + offset) * 3;
             ctx.beginPath(); ctx.ellipse(-6 + walk, i * 8, 4, 2, Math.PI/4 * i, 0, Math.PI*2); ctx.fill(); ctx.stroke();
             ctx.beginPath(); ctx.ellipse(4 - walk, i * 7, 3, 2, -Math.PI/4 * i, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        }

        // ===============================================
        // === ROBUST JAWS & HEAVY BARREL ===
        // ===============================================

        // -- PART A: BOTTOM JAW (Heavy Armor) --
        ctx.save();
        let jawAngle = 0.5 * jawOpenPct; 
        ctx.rotate(jawAngle);
        
        // Main Jaw Structure
        ctx.fillStyle = "#111"; // Dark metal
        ctx.beginPath();
        ctx.moveTo(-2, 1);    // Hinge Inner
        ctx.lineTo(2, 9);     // Heavy Base Down
        ctx.lineTo(16, 7);    // Mid Armor Angle
        ctx.lineTo(24, 4);    // Blunt Tip Bottom
        ctx.lineTo(24, 2);    // Blunt Tip Top
        ctx.lineTo(20, 1);    // Inner Tooth
        ctx.lineTo(6, 1);     // Inner Grip Surface
        ctx.lineTo(-2, 1);    // Back to Hinge
        ctx.fill();

        // Armor Plate Highlight (The "Chin")
        ctx.fillStyle = "#222"; 
        ctx.beginPath(); ctx.moveTo(2, 9); ctx.lineTo(16, 7); ctx.lineTo(12, 3); ctx.lineTo(4, 3); ctx.fill();
        
        // Edge Highlight
        ctx.strokeStyle = "#666"; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(-2, 1); ctx.lineTo(2, 9); ctx.lineTo(16, 7); ctx.lineTo(24, 4); ctx.stroke();
        ctx.restore();

        // -- PART B: TOP JAW (Heavy Armor) --
        ctx.save();
        ctx.rotate(-jawAngle);
        
        // Main Jaw Structure
        ctx.fillStyle = "#111"; 
        ctx.beginPath();
        ctx.moveTo(-2, -1);   // Hinge Inner
        ctx.lineTo(2, -9);    // Heavy Base Up
        ctx.lineTo(16, -7);   // Mid Armor Angle
        ctx.lineTo(24, -4);   // Blunt Tip Top
        ctx.lineTo(24, -2);   // Blunt Tip Bottom
        ctx.lineTo(20, -1);   // Inner Tooth
        ctx.lineTo(6, -1);    // Inner Grip Surface
        ctx.lineTo(-2, -1);   // Back to Hinge
        ctx.fill();

        // Armor Plate Highlight
        ctx.fillStyle = "#222"; 
        ctx.beginPath(); ctx.moveTo(2, -9); ctx.lineTo(16, -7); ctx.lineTo(12, -3); ctx.lineTo(4, -3); ctx.fill();

        // Edge Highlight
        ctx.strokeStyle = "#666"; 
        ctx.beginPath(); ctx.moveTo(-2, -1); ctx.lineTo(2, -9); ctx.lineTo(16, -7); ctx.lineTo(24, -4); ctx.stroke();
        ctx.restore();

        // -- PART C: THE HEAVY BARREL (Slides Out) --
        if (jawOpenPct > 0.1) {
            let slide = barrelSlidePct * barrelSlidePct * (3 - 2 * barrelSlidePct); 
            let extension = slide * 16; 
            
            // 1. Heavy Rail Housing
            let grad = ctx.createLinearGradient(0, -6, 0, 6);
            grad.addColorStop(0, "#1a1a1a");
            grad.addColorStop(0.5, "#444");
            grad.addColorStop(1, "#1a1a1a");
            ctx.fillStyle = grad;
            ctx.fillRect(4, -5, 12 + extension, 10);
            
            // 2. Vents
            ctx.fillStyle = "#000";
            for(let i=0; i<3; i++) ctx.fillRect(8 + (i*4) + (extension*0.5), -4, 2, 8);

            // 3. Magma Core
            let heatColor = progress > 0.7 ? "#ffff00" : "#ff4500";
            ctx.fillStyle = heatColor;
            ctx.shadowColor = heatColor; ctx.shadowBlur = 10 * progress;
            ctx.fillRect(6, -1.5, 10 + extension, 3); 
            ctx.shadowBlur = 0;

            // 4. Muzzle
            let headX = 16 + extension; 
            ctx.fillStyle = "#2a2a2a";
            ctx.beginPath();
            ctx.moveTo(headX, -5); ctx.lineTo(headX + 4, -6); ctx.lineTo(headX + 6, -3);
            ctx.lineTo(headX + 6, 3); ctx.lineTo(headX + 4, 6); ctx.lineTo(headX, 5);
            ctx.fill();

            // 5. Charge
            if (progress > 0.6) {
                ctx.fillStyle = `rgba(255, 255, 255, ${progress})`;
                ctx.shadowColor = "#ffaa00"; ctx.shadowBlur = 20;
                ctx.beginPath(); ctx.arc(headX + 6, 0, 3 * progress + Math.random(), 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;
            }
        }
        
        // -- PART D: MECHANICAL HINGE (Pivot Point) --
        // Draws a mechanical circle where the jaws meet the body
        ctx.fillStyle = "#333";
        ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#000"; ctx.lineWidth = 1; ctx.stroke();
        ctx.fillStyle = "#555"; ctx.beginPath(); ctx.arc(0, 0, 2, 0, Math.PI*2); ctx.fill();

        // ===============================================

        // --- 3. MAIN BODY ---
        ctx.fillStyle = "#180505"; 
        ctx.beginPath(); ctx.ellipse(-4, 0, 11, 9, 0, 0, Math.PI*2); ctx.fill();
        
        // Pulsing Core
        let pulse = Math.sin(this.animTimer * 0.5) * 1.5;
        let coreColor = progress > 0.8 ? "#fff" : (progress > 0.4 ? "#ff8800" : "#a00");
        ctx.shadowBlur = 10 + (progress * 15); ctx.shadowColor = "#f00";
        ctx.fillStyle = coreColor;
        ctx.beginPath(); ctx.ellipse(-5 + shake, 0 + shake, 6 + (pulse*0.2), 4 + (pulse*0.2), 0, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;

        // Armor Shell
        ctx.fillStyle = "#222"; 
        ctx.beginPath(); ctx.moveTo(-2, -5); ctx.lineTo(-8, -8); ctx.lineTo(-13, -3); ctx.fill(); 
        ctx.beginPath(); ctx.moveTo(-2, 5); ctx.lineTo(-8, 8); ctx.lineTo(-13, 3); ctx.fill();
        ctx.strokeStyle = "#555"; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(-2, -5); ctx.lineTo(-8, -8); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-2, 5); ctx.lineTo(-8, 8); ctx.stroke();

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class BroodmotherEnemy {
    constructor() {
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // STATS
        this.radius = 18; // Slightly larger hitbox for the new body
        this.hp = 100 + (wave * 20); 
        this.maxHp = this.hp;
        this.bounty = 20; 
        
        this.speed = 0.5; 
        this.vx = -0.5; 
        this.vy = 0;
        
        this.wallDamageCooldown = 0;

        // SUMMONING STATS
        this.state = "MOVING"; 
        this.spawnTimer = 0;
        this.spawnCooldown = 240; 
        this.spawnDuration = 60; 
        
        // Animation
        this.walkCycle = 0;
    }

    update() {
        this.walkCycle += 0.1; // Animate legs

        // 1. Spawning Mechanic
        this.spawnTimer = (this.spawnTimer || 0) + 1;
        if (this.spawnTimer > 180) { 
            this.spawnTimer = 0;
            // Spawn 2 Larvae
            for(let i=0; i<2; i++) {
                enemies.push(new LarvaEnemy(this.x - 10, this.y + Math.random()*20-10));
            }
            createParticles(this.x, this.y, "#adff2f", 15); // Goo explosion
        }

        // 2. Movement
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);

        let isBlocked = sharedMovement(this, col, row);

        if (isBlocked) sharedDestroyWalls(this, col, row, 5, 20);

        this.x += this.vx;
        this.y += this.vy;

        // 3. Physics
        separate(this, enemies, 0.2); 
        separate(this, allies, 0.1);
        resolveWallCollision(this);

        // 4. Base Damage
        let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dx, dy) < 40) { 
            takeDamage(2); 
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // 1. CALCULATE ROTATION
        // Standard Math: 0 radians = Facing Right.
        let angle = Math.atan2(this.vy, this.vx);
        
        // If the enemy is barely moving, force it to face Left (towards player base usually)
        // But since we draw Facing Right, we need Math.PI to face Left.
        if (Math.abs(this.vx) + Math.abs(this.vy) < 0.1) angle = Math.PI; 
        
        ctx.rotate(angle);

        let pct = this.hp / this.maxHp;

        // --- DRAW LEGS (6 Insect Legs) ---
        ctx.strokeStyle = "#1a2b0a"; // Dark Green/Black
        ctx.lineWidth = 2;
        ctx.lineCap = "round";
        
        for(let i = 0; i < 3; i++) { 
            let sideOffset = (i * 6) - 6; 
            let legLength = 18;
            
            // Animation: Tripod Gait
            let legSwing = Math.sin(this.walkCycle + (i%2 * Math.PI)) * 5;
            
            // Top Legs
            ctx.beginPath();
            ctx.moveTo(sideOffset, -5);
            ctx.lineTo(sideOffset - legSwing, -legLength); // Swing is inverted to match direction
            ctx.stroke();

            // Bottom Legs
            ctx.beginPath();
            ctx.moveTo(sideOffset, 5);
            ctx.lineTo(sideOffset - legSwing, legLength);
            ctx.stroke();
        }

        // --- DRAW BODY PARTS (Facing RIGHT) ---

        // 1. ABDOMEN (The Egg Sack) - REAR (Negative X)
        let spawnPressure = (this.spawnTimer / 180);
        let pulse = spawnPressure > 0.8 ? Math.sin(this.spawnTimer * 0.5) * 2 : 0;
        
        let sackR = 50 + (150 * spawnPressure);
        let sackG = 100 + (50 * spawnPressure);
        
        ctx.fillStyle = `rgb(${sackR}, ${sackG}, 20)`;
        ctx.beginPath();
        // MOVED TO NEGATIVE X (-10)
        ctx.ellipse(-10, 0, 14 + pulse, 10 + pulse, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#1a2b0a";
        ctx.lineWidth = 1;
        ctx.stroke();

        // Abdomen Details
        ctx.fillStyle = "rgba(0,0,0,0.2)";
        ctx.beginPath();
        ctx.arc(-8, -4, 2, 0, Math.PI*2);
        ctx.arc(-12, 3, 3, 0, Math.PI*2);
        ctx.arc(-6, 2, 2, 0, Math.PI*2);
        ctx.fill();

        // 2. THORAX (Armor) - CENTER
        let darkGreen = `rgb(${20 + 40*pct}, ${40 + 60*pct}, 20)`;
        ctx.fillStyle = darkGreen;
        ctx.beginPath();
        ctx.ellipse(4, 0, 8, 6, 0, 0, Math.PI * 2); // MOVED TO POSITIVE X
        ctx.fill();
        ctx.stroke();

        // 3. HEAD (Mandibles) - FRONT (Positive X)
        ctx.fillStyle = darkGreen;
        ctx.beginPath();
        ctx.arc(12, 0, 5, 0, Math.PI * 2); // MOVED TO POSITIVE X
        ctx.fill();
        ctx.stroke();

        // Mandibles (Pincers) - Pointing Right
        ctx.strokeStyle = "#8b0000"; 
        ctx.beginPath();
        ctx.moveTo(14, -2); ctx.lineTo(20, -4); // Point Right
        ctx.moveTo(14, 2);  ctx.lineTo(20, 4);  // Point Right
        ctx.stroke();

        // Glowing Eyes
        ctx.fillStyle = "#f00"; 
        ctx.beginPath();
        ctx.arc(14, -2, 1.5, 0, Math.PI*2);
        ctx.arc(14, 2, 1.5, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class LarvaEnemy {
    constructor(x, y) {
        this.x = x; 
        this.y = y;
        
        // Very weak, very fast
        this.radius = 5; 
        this.hp = 10; 
        this.maxHp = 10;
        this.bounty = 1; 
        
        this.speed = 1.5; 
        this.vx = (Math.random() - 0.5) * 5; 
        this.vy = (Math.random() - 0.5) * 5;
        
        this.wallDamageCooldown = 0;
        
        // Animation randomizer
        this.wiggleOffset = Math.random() * 100;
        this.wiggleTimer = 0;
    }

    update() {
        this.wiggleTimer += 0.5;

        // 1. Movement
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);

        let isBlocked = sharedMovement(this, col, row);
        if (isBlocked) sharedDestroyWalls(this, col, row, 0.2, 5);

        this.x += this.vx;
        this.y += this.vy;

        // 2. Physics
        separate(this, enemies, 0.8); 
        separate(this, allies, 0.5);
        resolveWallCollision(this);

        // 3. Attack (Suicide)
        let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dx, dy) < 20) { 
            takeDamage(1); 
            this.hp = 0; 
            createParticles(this.x, this.y, "#adff2f", 5);
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Rotate to face movement
        let angle = Math.atan2(this.vy, this.vx);
        ctx.rotate(angle);

        let wiggle = Math.sin(this.wiggleTimer + this.wiggleOffset) * 2;

        // Colors
        let pct = this.hp / this.maxHp;
        let r = 100 + (100 * pct);
        let g = 200 + (55 * pct);
        
        // Draw Maggot Body (3 overlapping circles decreasing in size)
        
        // 1. Tail (Wiggles the most)
        ctx.fillStyle = `rgb(${r-40}, ${g-40}, 0)`;
        ctx.beginPath();
        ctx.arc(-8, wiggle, 3, 0, Math.PI*2);
        ctx.fill();

        // 2. Mid-Body (Wiggles a little)
        ctx.fillStyle = `rgb(${r-20}, ${g-20}, 0)`;
        ctx.beginPath();
        ctx.arc(-4, wiggle * 0.5, 4, 0, Math.PI*2);
        ctx.fill();

        // 3. Head (Steady)
        ctx.fillStyle = `rgb(${r}, ${g}, 0)`; // Brightest
        ctx.strokeStyle = "#1a2b0a";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.ellipse(2, 0, 5, 4, 0, 0, Math.PI*2); // Oval head
        ctx.fill();
        ctx.stroke();

        // Tiny Pincers/Mouth
        ctx.strokeStyle = "black";
        ctx.beginPath();
        ctx.moveTo(6, -2); ctx.lineTo(8, 0); ctx.lineTo(6, 2);
        ctx.stroke();

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class LeaperEnemy {
    constructor() {
        // --- SPAWN LOGIC ---
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- STATS ---
        this.radius = 12;
        this.speed = 0.8; // Slow walk
        this.hp = 25 + (wave * 5); 
        this.maxHp = this.hp;
        this.bounty = 5;
        
        this.vx = -1;
        this.vy = 0;
        
        // --- JUMP MECHANICS ---
        this.state = 'RUN';
        this.jumpTimer = 0;
        this.jumpDuration = 45; 
        this.jumpCooldown = 0;  
        this.jumpHeight = 0;    
        
        // --- VISUALS ---
        this.angle = Math.PI;
        this.animTimer = Math.random() * 100;
        this.wingOpenAmount = 0; 
    }

    update(dt) {
        this.animTimer += 0.1*dt;
        if (this.jumpCooldown > 0) this.jumpCooldown--;

        let dx = (playerBase.x * CELL_SIZE + CELL_SIZE/2) - this.x;
        let dy = (playerBase.y * CELL_SIZE + CELL_SIZE/2) - this.y;
        let distToBase = Math.hypot(dx, dy);

        // --- STATE MACHINE ---
        if (this.state === 'RUN') {
            let col = Math.floor(this.x / CELL_SIZE);
            let row = Math.floor(this.y / CELL_SIZE);
            
            // 1. STANDARD MOVEMENT
            // We call sharedMovement to handle walking/pathfinding. 
            // We store 'isStuck' to know if the base is totally sealed off.
            let isStuck = sharedMovement(this, col, row);

            // 2. ROTATION (Face movement)
            if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
                let targetAngle = Math.atan2(this.vy, this.vx);
                let diff = targetAngle - this.angle;
                while (diff < -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;
                this.angle += diff * 0.05; 
            }
            if (this.wingOpenAmount > 0) this.wingOpenAmount -= 0.05;

            // --- 3. PROACTIVE JUMP CHECK ---
            // We check for a wall directly towards the base, even if 'isStuck' is false.
            if (this.jumpCooldown <= 0 && distToBase > 60) {
                
                // Look ahead 40px (approx 1 cell) towards the base
                let lookDist = 40;
                let lookX = this.x + (Math.cos(this.angle) * lookDist);
                let lookY = this.y + (Math.sin(this.angle) * lookDist);
                
                let wallCol = Math.floor(lookX / CELL_SIZE);
                let wallRow = Math.floor(lookY / CELL_SIZE);

                // Is there a wall right in front of us?
                if (wallCol >= 0 && wallCol < COLS && wallRow >= 0 && wallRow < ROWS) {
                    if (grid[wallCol][wallRow].wall) {
                        
                        // WALL FOUND! Now check the landing spot (Jump over 1 wall = ~2 cells away)
                        let landDist = 90; // 40 (wall) + 50 (landing)
                        let landX = this.x + (Math.cos(this.angle) * landDist);
                        let landY = this.y + (Math.sin(this.angle) * landDist);
                        
                        let landCol = Math.floor(landX / CELL_SIZE);
                        let landRow = Math.floor(landY / CELL_SIZE);
                        
                        let canLand = true;

                        // Check if landing spot is valid
                        if (landCol >= 0 && landCol < COLS && landRow >= 0 && landRow < ROWS) {
                            // CANNOT jump if the landing spot is ALSO a wall (Double Wall)
                            if (grid[landCol][landRow].wall) {
                                canLand = false;
                            }
                        } else {
                            canLand = false; // Don't jump off map
                        }

                        // DECISION:
                        if (canLand) {
                            // A single wall detected + clear landing -> JUMP!
                            this.vx = 0; 
                            this.vy = 0;
                            this.state = 'CHARGE';
                            this.jumpTimer = 100; // 1.6s wait
                        } 
                    }
                }
            }

            // --- 4. STUCK LOGIC ---
            // If we are stuck (base sealed) AND we didn't start a jump above, break the wall.
            if (isStuck && this.state !== 'CHARGE') {
                sharedDestroyWalls(this, col, row, 1, 5);
            }

            this.jumpHeight = 0;
        } 
        else if (this.state === 'CHARGE') {
            this.angle += (Math.random() - 0.5) * 0.1; // Shaking effect
            this.jumpTimer--;
            
            if (this.wingOpenAmount < 0.5) this.wingOpenAmount += 0.005;

            if (this.jumpTimer <= 0) {
                this.state = 'AIR';
                this.jumpTimer = this.jumpDuration;
                
                // Launch towards base
                let angleToBase = Math.atan2(dy, dx);
                let jumpDist = CELL_SIZE * 2.5; 
                let requiredSpeed = jumpDist / this.jumpDuration;

                this.vx = Math.cos(angleToBase) * requiredSpeed;
                this.vy = Math.sin(angleToBase) * requiredSpeed;
                this.angle = angleToBase;
            }
        }
        else if (this.state === 'AIR') {
            this.jumpTimer--;
            if (this.wingOpenAmount < 1) this.wingOpenAmount += 0.1;

            // Parabolic Arc
            let t = 1 - (this.jumpTimer / this.jumpDuration); 
            this.jumpHeight = Math.sin(t * Math.PI) * 60; 

            if (this.jumpTimer <= 0) {
                // Land
                this.state = 'RUN';
                this.jumpCooldown = 120; 
                this.vx = 0; 
                this.vy = 0;
                createParticles(this.x, this.y, "#00ffcc", 8); 
            }
        }

        // Apply Velocity
        this.x += this.vx;
        this.y += this.vy;

        if (distToBase < 30) { takeDamage(10); this.hp = 0; }

        // Physics (Do not collide with walls while in AIR)
        if (this.state !== 'AIR') {
            separate(this, enemies, 0.5);
            resolveWallCollision(this);
        }
    }

    draw() {
        ctx.save();
        
        let shadowSize = 8 - (this.jumpHeight / 10);
        if (shadowSize < 0) shadowSize = 0;
        ctx.fillStyle = "rgba(0,0,0,0.4)";
        ctx.beginPath();
        ctx.ellipse(this.x, this.y + 5, shadowSize, shadowSize * 0.5, 0, 0, Math.PI*2);
        ctx.fill();

        ctx.translate(this.x, this.y - this.jumpHeight);
        ctx.rotate(this.angle);

        if (this.state === 'CHARGE') {
            let scaleMod = 1.0 - (Math.sin(Date.now() / 20) * 0.05);
            ctx.scale(scaleMod, 1/scaleMod); 
        }

        const cNeon = "#00d2ff";
        const cDark = "#005566";
        const cBlack = "#002233";

        // Legs
        ctx.strokeStyle = cNeon;
        ctx.lineWidth = 3;
        ctx.lineJoin = "round";
        const drawHindLeg = (side) => {
            let legOffset = (this.state === 'RUN') ? Math.sin(this.animTimer * 2 + side) * 5 : -10;
            if (this.state === 'AIR') legOffset = 15; 
            ctx.beginPath();
            ctx.moveTo(-5, side * 5); 
            ctx.lineTo(-15 + legOffset, side * 12); 
            ctx.lineTo(-5 + legOffset, side * 15); 
            ctx.stroke();
            ctx.fillStyle = cDark;
            ctx.beginPath();
            ctx.ellipse(-10 + (legOffset/2), side * 8, 4, 2, 0.5 * side, 0, Math.PI*2);
            ctx.fill();
        };
        drawHindLeg(1);
        drawHindLeg(-1);

        // Wings
        if (this.wingOpenAmount > 0.01) {
            ctx.save();
            ctx.fillStyle = "rgba(0, 210, 255, 0.4)";
            ctx.globalCompositeOperation = "lighter";
            ctx.beginPath();
            ctx.rotate(-0.2 * this.wingOpenAmount);
            ctx.moveTo(-5, -5); ctx.quadraticCurveTo(-20, -20, -25, -5); ctx.lineTo(-5, -2); ctx.fill();
            ctx.rotate(0.4 * this.wingOpenAmount); 
            ctx.beginPath();
            ctx.moveTo(-5, 5); ctx.quadraticCurveTo(-20, 20, -25, 5); ctx.lineTo(-5, 2); ctx.fill();
            ctx.restore();
        }

        // Body
        ctx.fillStyle = cBlack;
        ctx.beginPath(); ctx.ellipse(-8, 0, 10, 5, 0, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = cNeon; ctx.lineWidth = 1;
        for(let i=0; i<3; i++) { ctx.beginPath(); ctx.arc(-6 - (i*4), 0, 4 - i, -Math.PI/2, Math.PI/2); ctx.stroke(); }
        ctx.fillStyle = cDark;
        ctx.beginPath(); ctx.ellipse(2, 0, 6, 5, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "rgba(255,255,255,0.2)";
        ctx.beginPath(); ctx.ellipse(2, -2, 4, 2, 0, 0, Math.PI*2); ctx.fill();

        // Head
        ctx.fillStyle = cBlack;
        ctx.beginPath(); ctx.moveTo(6, -3); ctx.lineTo(14, 0); ctx.lineTo(6, 3); ctx.fill();
        ctx.fillStyle = (this.state === 'CHARGE') ? "#fff" : "#ff0044"; 
        ctx.beginPath(); ctx.arc(8, -2, 1.5, 0, Math.PI*2); ctx.arc(8, 2, 1.5, 0, Math.PI*2); ctx.fill();

        let twitch = Math.sin(Date.now() / 50) * 2;
        ctx.strokeStyle = cDark; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(14, -1); ctx.lineTo(16 + (twitch/4), -3);
        ctx.moveTo(14, 1);  ctx.lineTo(16 + (twitch/4), 3); ctx.stroke();

        // Front Legs
        ctx.strokeStyle = cNeon; ctx.lineWidth = 1.5;
        const drawFrontLeg = (side, offset) => {
            let legMove = (this.state === 'RUN') ? Math.sin(this.animTimer * 3 + offset) * 3 : 0;
            if (this.state === 'AIR') legMove = -5;
            ctx.beginPath(); ctx.moveTo(4, side * 3); ctx.lineTo(8 + legMove, side * 8); ctx.lineTo(12 + legMove, side * 10); ctx.stroke();
        };
        drawFrontLeg(1, 0); drawFrontLeg(-1, Math.PI);

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class ReviverEnemy {
    constructor() {
        // Spawn Logic
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        this.type = "REVIVER_XENOID";
        
        // STATS
        this.radius = 16; 
        this.speed = 0.55; 
        this.hp = 300 + (wave * 40); 
        this.maxHp = this.hp;
        this.bounty = 70; 
        
        this.vx = 0; 
        this.vy = 0;
        this.angle = 0; 
        
        // LOGIC
        this.reviveRadius = 180; 
        this.reviveSpeed = 1.3;  
        
        // ANIMATION STATE
        this.walkCycle = 0; 
        this.mandibleTwitch = 0;
        this.abdomenPulse = 0;
        this.isSinging = false;
        
        // VISUALS
        this.strideLength = 40; // Wider steps
    }

    update(dt) {
        // --- ANIMATION SYNC ---
        let moveSpeed = Math.hypot(this.vx, this.vy);
        
        // Much slower animation increment for a "Heavy" feel
        if (moveSpeed > 0.01) {
            this.walkCycle += 0.015; // Was 0.04
        } else {
            this.walkCycle += 0.005; // Idle breathing
        }

        this.mandibleTwitch += 0.1;
        this.abdomenPulse += 0.05;

        // --- 1. MOVEMENT ---
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);
        
        let isBlocked = sharedMovement(this, col, row);
        if (isBlocked) sharedDestroyWalls(this, col, row, 2, 12);

        this.x += this.vx;
        this.y += this.vy;
        
        // Smooth Rotation
        if (Math.abs(this.vx) > 0.01 || Math.abs(this.vy) > 0.01) {
            let targetAngle = Math.atan2(this.vy, this.vx);
            let diff = targetAngle - this.angle;
            while (diff < -Math.PI) diff += Math.PI * 2;
            while (diff > Math.PI) diff -= Math.PI * 2;
            this.angle += diff * 0.08; 
        }
        
        separate(this, enemies, 1.2); 

        // --- 2. HIVE MIND REVIVAL ---
        this.isSinging = false;
        for (let i = corpses.length - 1; i >= 0; i--) {
            let c = corpses[i];
            if (!c.active) continue;

            if (Math.hypot(c.x - this.x, c.y - this.y) < this.reviveRadius) {
                this.isSinging = true;
                if (typeof c.reviveProgress === 'undefined') c.reviveProgress = 0;
                c.reviveProgress += this.reviveSpeed;

                if (Math.random() > 0.85) createParticles(c.x, c.y, "#7c43bd", 1); 

                if (c.reviveProgress >= 100) {
                    enemies.push(new SkeletonEnemy(c.x, c.y));
                    createParticles(c.x, c.y, "#d500f9", 25); 
                    c.active = false; 
                }
            }
        }
        
        // Base Damage
        let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dx, dy) < 30) {
             takeDamage(20);
             this.hp = 0;
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle); 
        
        let s = 0.5; 
        ctx.scale(s, s);

        let pulse = Math.sin(this.abdomenPulse) * 2;

        // --- 1. WIDE SPIDER LEGS ---
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        const drawLeg = (side, row) => {
            let isFront = row < 2;
            
            // INCREASED LENGTH (Was 26/20)
            let legLen = isFront ? 36 : 28; 
            
            // --- GAIT TIMING ---
            const gaitOffset = [0, 0.5, 0.25, 0.75, 0.1][row];
            let t = (this.walkCycle + gaitOffset + (side === -1 ? 0.5 : 0)) % 1.0;
            
            // --- STANCE VS SWING ---
            let cycleX = 0; 
            let cycleLift = 0; 
            
            let swingDuration = 0.3; // 30% of time spent moving forward

            if (t < swingDuration) {
                // == SWING (AIR) ==
                let p = t / swingDuration; 
                // Move from Back (-1) to Front (+1)
                cycleX = -1 + (p * 2); 
                // Higher lift for longer legs
                cycleLift = Math.sin(p * Math.PI) * 12;
            } else {
                // == STANCE (GROUND) ==
                let p = (t - swingDuration) / (1.0 - swingDuration); 
                // Move from Front (+1) to Back (-1)
                cycleX = 1 - (p * 2); 
                cycleLift = 0; 
            }

            // --- CALCULATE POSITIONS ---
            
            // 1. Mount Point
            let mountX, mountY;
            if (isFront) {
                mountX = 9 - (row * 7); 
                mountY = side * 6;
            } else {
                let backIndex = row - 2;
                mountX = -14 - (backIndex * 8); 
                mountY = side * 8; 
            }

            // 2. Neutral Angle
            // Slight adjustment to fan them out more given the length
            let baseAngle = isFront ? (0.4 - row * 0.35) : (2.7 + (row-2) * 0.35);
            
            // 3. Apply Stride
            let strideOffset = cycleX * (this.strideLength / 2);
            
            let neutralReach = legLen;
            let nx = mountX + (Math.cos(baseAngle) * neutralReach);
            let ny = mountY + (Math.sin(baseAngle) * neutralReach * side);
            
            let footX = nx + strideOffset;
            let footY = ny; 

            // 4. IK for the Knee
            let midX = (mountX + footX) / 2;
            let midY = (mountY + footY) / 2;
            let dx = footX - mountX;
            let dy = footY - mountY;
            let dist = Math.hypot(dx, dy);
            
            // KNEE OUT: Increased to handle longer legs (Was 14)
            let kneeOut = 20 + (cycleLift * 0.8); 
            
            let perpX = -dy / dist;
            let perpY = dx / dist;
            if (perpY * side < 0) { perpX = -perpX; perpY = -perpY; }

            let kneeX = midX + (perpX * kneeOut);
            let kneeY = midY + (perpY * kneeOut);

            // --- DRAW ---
            
            // Shadow
            if (cycleLift > 1) {
                ctx.fillStyle = "rgba(0,0,0,0.3)";
                ctx.beginPath();
                // Shadow location slightly under the lifted foot
                ctx.arc(footX - (cycleX * 4), footY, 3, 0, Math.PI*2); 
                ctx.fill();
            }

            // Femur
            ctx.strokeStyle = "#1a237e"; 
            ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(mountX, mountY); ctx.lineTo(kneeX, kneeY); ctx.stroke();
            
            // Tibia
            let lightness = 57 + (cycleLift * 4); 
            ctx.strokeStyle = `hsl(231, 48%, ${lightness}%)`;
            ctx.lineWidth = 2.5;
            ctx.beginPath(); ctx.moveTo(kneeX, kneeY); ctx.lineTo(footX, footY); ctx.stroke();

            // Joints
            ctx.fillStyle = "#000"; ctx.beginPath(); ctx.arc(mountX, mountY, 3, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "#4a148c"; ctx.beginPath(); ctx.arc(kneeX, kneeY, 3.5, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "#d500f9"; ctx.beginPath(); ctx.arc(footX, footY, 2, 0, Math.PI*2); ctx.fill();
        };

        // Render Legs (Back to Front)
        for(let i=4; i>=2; i--) { drawLeg(1, i); drawLeg(-1, i); }
        
        // --- BODY ---
        ctx.strokeStyle = "#212121"; ctx.lineWidth = 10;
        ctx.beginPath(); ctx.moveTo(4, 0); ctx.lineTo(-12, 0); ctx.stroke();

        ctx.save();
        ctx.translate(-22, 0); 
        ctx.fillStyle = "#0d1b2a"; 
        ctx.beginPath(); ctx.ellipse(0, 0, 15, 11 + (pulse*0.3), 0, 0, Math.PI*2); ctx.fill();
        
        let buttGrad = ctx.createLinearGradient(0, -10, 0, 10);
        buttGrad.addColorStop(0, "#1a237e"); buttGrad.addColorStop(0.5, "#000"); buttGrad.addColorStop(1, "#1a237e");
        ctx.fillStyle = buttGrad;
        ctx.beginPath(); ctx.ellipse(3, 0, 11, 7, 0, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = this.isSinging ? "#d500f9" : "#4a148c";
        ctx.shadowBlur = 15; ctx.shadowColor = ctx.fillStyle;
        ctx.beginPath(); ctx.arc(-9, 0, 5, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
        ctx.restore();

        // Front Legs
        drawLeg(1, 1); drawLeg(-1, 1);
        drawLeg(1, 0); drawLeg(-1, 0);

        // Thorax
        ctx.fillStyle = "#1a237e";
        ctx.beginPath();
        ctx.moveTo(12, 0); ctx.lineTo(6, 8); ctx.lineTo(-4, 7); ctx.lineTo(-8, 0); ctx.lineTo(-4, -7); ctx.lineTo(6, -8);
        ctx.fill();
        ctx.fillStyle = "#304ffe";
        ctx.beginPath(); ctx.moveTo(9, 0); ctx.lineTo(0, 2); ctx.lineTo(-6, 0); ctx.lineTo(0, -2); ctx.fill();

        // Head
        ctx.save();
        ctx.translate(12, 0);
        let twitch = Math.sin(this.mandibleTwitch) * 0.2;
        ctx.fillStyle = "#283593"; ctx.strokeStyle = "#5c6bc0"; ctx.lineWidth = 1;
        
        ctx.save(); ctx.rotate(-0.4 + twitch);
        ctx.beginPath(); ctx.moveTo(0, -3); ctx.lineTo(13, -6); ctx.lineTo(10, -1); ctx.lineTo(0, 0);
        ctx.fill(); ctx.stroke(); ctx.restore();
        
        ctx.save(); ctx.rotate(0.4 - twitch);
        ctx.beginPath(); ctx.moveTo(0, 3); ctx.lineTo(13, 6); ctx.lineTo(10, 1); ctx.lineTo(0, 0);
        ctx.fill(); ctx.stroke(); ctx.restore();

        ctx.fillStyle = "#000"; ctx.beginPath(); ctx.arc(0, 0, 5.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#00e5ff"; ctx.shadowBlur = 5; ctx.shadowColor = "#00e5ff";
        ctx.beginPath(); ctx.arc(3, -2, 1.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(4, -1, 1, 0, Math.PI*2); ctx.fill(); 
        ctx.beginPath(); ctx.arc(3, 2, 1.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(4, 1, 1, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
        
        ctx.strokeStyle = "#d500f9"; ctx.lineWidth = 0.5;
        ctx.beginPath(); ctx.moveTo(5, -1); ctx.lineTo(18, -6 + Math.sin(Date.now()/60)*2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(5, 1); ctx.lineTo(18, 6 - Math.sin(Date.now()/60)*2); ctx.stroke();
        ctx.restore();

        // Singing
        if (this.isSinging) {
            let wavePhase = (Date.now() / 150) % 10;
            ctx.lineWidth = 1.5;
            for(let w=0; w<3; w++) { 
                let r = (wavePhase + (w*4)) * 6;
                let alpha = 1 - (r/45);
                if (alpha > 0) {
                    ctx.strokeStyle = `rgba(0, 229, 255, ${alpha})`; 
                    ctx.beginPath(); ctx.arc(15, 0, r, -0.8, 0.8); ctx.stroke();
                }
            }
        }

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class SkeletonEnemy {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.type = "SKELETON_UNIT";
        
        // Stats
        this.hp = 30 + (wave * 5);
        this.maxHp = this.hp;
        this.speed = 1.6;
        this.vx = 0; 
        this.vy = 0;
        this.radius = 12;
        this.bounty = 1;
        
        this.angle = 0;
        this.walkCycle = 0;
        this.twitch = 0; // Replaced "flicker" with a muscular spasm
    }

    update(dt) {
        this.walkCycle += 0.15; // Slower, more deliberate stride
        this.twitch = Math.random() > 0.98 ? Math.random() * 2 : 0; 
        
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);
        
        let isBlocked = sharedMovement(this, col, row);
        if (isBlocked) sharedDestroyWalls(this, col, row, 5, 5);

        this.x += this.vx;
        this.y += this.vy;
        
        if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
            this.angle = Math.atan2(this.vy, this.vx);
        }
        
        separate(this, enemies, 0.5);
    }

    draw() {
        ctx.save();
        ctx.translate(this.x + this.twitch, this.y + this.twitch); // Spasmodic movement
        ctx.rotate(this.angle);

        // Biological animation variables
        let breathe = Math.sin(this.walkCycle) * 1.5;
        let limbSwing = Math.sin(this.walkCycle);
        
        // --- 1. THE SPINE (Calcified Bone) ---
        ctx.strokeStyle = "#e0e0ce"; // Aged bone color
        ctx.lineWidth = 3;
        ctx.lineCap = "round";

        // Segmented vertebrae
        for(let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.fillStyle = i % 2 === 0 ? "#f5f5dc" : "#d2b48c";
            ctx.arc(-8 + (i * 4), 0, 2.5, 0, Math.PI * 2);
            ctx.fill();
        }

        // --- 2. ROTTING RIBCAGE ---
        ctx.strokeStyle = "#f5f5dc";
        ctx.lineWidth = 2;
        
        // Curved ribs instead of straight lines
        [1, -1].forEach(side => {
            ctx.beginPath();
            ctx.moveTo(2, side * 2);
            // Ribs expand and contract (breathing)
            ctx.quadraticCurveTo(-2, side * (8 + breathe), 4, side * (6 + breathe));
            ctx.stroke();
        });

        // --- 3. THE SKULL ---
        // Main cranium
        ctx.fillStyle = "#f5f5dc"; 
        ctx.beginPath();
        ctx.arc(6, 0, 5, 0, Math.PI * 2);
        ctx.fill();
        
        // Sunken Jaw
        ctx.beginPath();
        ctx.ellipse(8, 2, 3, 4, Math.PI/4, 0, Math.PI * 2);
        ctx.fill();

        // --- 4. THE EYE (Malevolent Glow) ---
        ctx.shadowBlur = 10;
        ctx.shadowColor = "#ff0000";
        ctx.fillStyle = "#4a0404"; // Dark socket
        ctx.beginPath();
        ctx.arc(7, -2, 2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = "#ff4444"; // Pinprick pupil
        ctx.beginPath();
        ctx.arc(7.5, -2, 0.8, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // --- 5. LASHING LIMBS (Exposed Tendons) ---
        ctx.strokeStyle = "#8b0000"; // Deep blood red
        ctx.lineWidth = 2;

        // Right Arm - Swinging erratically
        ctx.beginPath();
        ctx.moveTo(2, -4); 
        let rArmX = 10 + (limbSwing * 4);
        ctx.bezierCurveTo(rArmX, -10, rArmX + 2, -5, rArmX + 4, -8); 
        ctx.stroke();

        // Left Arm
        ctx.beginPath();
        ctx.moveTo(2, 4);
        let lArmX = 10 - (limbSwing * 4);
        ctx.bezierCurveTo(lArmX, 10, lArmX + 2, 5, lArmX + 4, 8);
        ctx.stroke();

        // --- 6. MIASMA / BLOOD DRIP (Rear) ---
        ctx.fillStyle = "#660000";
        ctx.globalAlpha = 0.3 + (Math.random() * 0.2);
        ctx.beginPath();
        ctx.arc(-12, breathe, 3, 0, Math.PI * 2);
        ctx.arc(-15, -breathe, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class FlyingEnemy {
    constructor() {
        // Spawn off-screen
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- STATS ---
        this.radius = 9;       
        this.speed = 0.6;      
        this.hp = 150 + (wave * 20)* difficultyMultiplier; 
        this.maxHp = this.hp;
        this.bounty = 3;

        this.vx = 0;
        this.vy = 0;
        
        this.animOffset = Math.random() * 1000;
    }

    update(dt) {
        // 1. MOVEMENT (Straight Line)
        let baseX = (playerBase.x * CELL_SIZE) + CELL_SIZE;
        let baseY = (playerBase.y * CELL_SIZE) + CELL_SIZE;
        
        let dx = baseX - this.x;
        let dy = baseY - this.y;
        let dist = Math.hypot(dx, dy);

        if (dist > 0) {
            this.vx = (dx / dist) * this.speed;
            this.vy = (dy / dist) * this.speed;
        }

        // REMOVED: The "wobble" code was here. 
        // Now it just tracks directly towards the base.

        this.x += this.vx *dt;
        this.y += this.vy *dt;

        // 2. PHYSICS
        separate(this, enemies, 0.5);

        // 3. ATTACK
        if (dist < 30) {
            takeDamage(5); 
            this.hp = 0;   
            createParticles(this.x, this.y, "#ff3300", 10); 
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        // --- SCALING ---
        ctx.scale(0.7, 0.9); 

        // 1. ORIENTATION (Face Forward)
        let angle = Math.atan2(this.vy, this.vx);
        ctx.rotate(angle + Math.PI / 2); 

        // Animation Variables
        let time = Date.now();
        let flutterFront = Math.sin((time / 60) + this.animOffset); 
        let flutterBack = Math.cos((time / 60) + this.animOffset);

        // --- 2. WINGS ---
        ctx.save();
        ctx.fillStyle = "rgba(200, 255, 255, 0.15)";
        ctx.strokeStyle = "rgba(0, 255, 255, 0.4)";
        ctx.lineWidth = 1;

        const drawWing = (xOffset, yOffset, length, width, rot) => {
            ctx.save();
            ctx.translate(xOffset, yOffset);
            ctx.rotate(rot); 
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(width, -length * 0.2); 
            ctx.lineTo(0, -length); 
            ctx.lineTo(-width, -length * 0.2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Inner Vein
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, -length * 0.8); ctx.stroke();
            ctx.restore();
        };

        // Front Wings
        drawWing(4, -5, 22, 4, 1.0 + (flutterFront * 0.3)); 
        drawWing(-4, -5, 22, 4, -1.0 - (flutterFront * 0.3));

        // Back Wings
        drawWing(3, 0, 16, 3, 2.2 + (flutterBack * 0.4));   
        drawWing(-3, 0, 16, 3, -2.2 - (flutterBack * 0.4));  
        ctx.restore();

        // --- 3. BODY & TAIL ---
        // Tail
        ctx.fillStyle = "#1a1a1a"; 
        ctx.strokeStyle = "#cc3300"; 
        ctx.lineWidth = 1;

        for(let i = 0; i < 4; i++) {
            let tailSize = 6 - i; 
            let tailY = 10 + (i * 4);
            let wiggle = Math.sin(time / 400 + (i * 0.5)) * 1; 

            ctx.beginPath();
            ctx.moveTo(wiggle, tailY);
            ctx.lineTo(wiggle + tailSize, tailY + tailSize);
            ctx.lineTo(wiggle, tailY + (tailSize * 2));
            ctx.lineTo(wiggle - tailSize, tailY + tailSize);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            if (i === 3) { 
                ctx.fillStyle = "#ff0000";
                ctx.beginPath(); ctx.arc(wiggle, tailY + 4, 2, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = "#1a1a1a";
            }
        }

        // Thorax
        ctx.fillStyle = "#222"; 
        ctx.beginPath();
        ctx.moveTo(0, -8); ctx.lineTo(6, -2); ctx.lineTo(4, 8); ctx.lineTo(-4, 8); ctx.lineTo(-6, -2);
        ctx.closePath(); ctx.fill(); ctx.stroke();

        // Head
        ctx.beginPath();
        ctx.moveTo(0, -8); ctx.lineTo(5, -14); ctx.lineTo(0, -18); ctx.lineTo(-5, -14);
        ctx.closePath(); ctx.fillStyle = "#000"; ctx.fill();

        // --- 4. FACE ---
        ctx.fillStyle = "#ff3300"; 
        ctx.shadowColor = "#ff0000"; ctx.shadowBlur = 8;
        ctx.beginPath(); ctx.ellipse(-3, -12, 2, 4, -0.3, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(3, -12, 2, 4, 0.3, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0; 

        // Mandibles
        ctx.strokeStyle = "#999"; ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(-2, -18); ctx.quadraticCurveTo(-6, -22, -1, -24);
        ctx.moveTo(2, -18); ctx.quadraticCurveTo(6, -22, 1, -24);
        ctx.stroke();

        ctx.restore();

        if (this.hp < this.maxHp) {
            const barW = 24;
            const barH = 4;
            const yOffset = 28;

            const barX = this.x - (barW / 2);
            const barY = this.y - yOffset;

            const pct = Math.max(0, Math.min(1, this.hp / this.maxHp));
            const hue = (pct * pct) * 120;

            ctx.fillStyle = "#333333";
            ctx.fillRect(barX, barY, barW, barH);

            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
            ctx.fillRect(barX, barY, barW * pct, barH);

            ctx.strokeStyle = "#000000";
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barW, barH);
        }
    }
}

class MagnetEnemy {
    constructor() {
        // --- SPAWN SETUP ---
        this.x = (typeof VIRTUAL_WIDTH !== 'undefined') ? VIRTUAL_WIDTH + 60 : 1000;
        let playableHeight = (typeof VIRTUAL_HEIGHT !== 'undefined') ? VIRTUAL_HEIGHT : 600;
        this.y = CELL_SIZE + Math.random() * (playableHeight - (CELL_SIZE * 2));

        // --- STATS ---
        this.radius = 22;          
        this.hp = 3500 + (wave * 550); 
        this.maxHp = this.hp;
        this.speed = 0.50;         
        this.bounty = 280;       
        
        // --- PHYSICS ---
        this.vx = 0;
        this.vy = 0;
        this.friction = 0.92;
        this.angle = Math.PI;      

        // --- ABILITY ---
        this.magnetRange = 340;    
        this.magnetForce = 1.6;   

        // --- VISUALS ---
        this.animTimer = 0;
        this.pulsePhase = 0;
        this.legCycle = 0;
        this.scale = 0.55; 
    }

    update(dt) {
        if (!dt) dt = 1;
        this.animTimer += dt * 0.05;
        this.pulsePhase += dt * 0.12;

        // --- MOVEMENT ---
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);
        
        let isBlocked = false;
        if (typeof sharedMovement === 'function') {
            isBlocked = sharedMovement(this, col, row);
        }

        if (isBlocked && typeof sharedDestroyWalls === 'function') {
            sharedDestroyWalls(this, col, row, 6, 30);
        }

        // Apply Velocity
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= this.friction;
        this.vy *= this.friction;

        // Calculate speed
        let speed = Math.hypot(this.vx, this.vy);
        
        // Face movement direction
        if (speed > 0.05) {
            let targetAngle = Math.atan2(this.vy, this.vx);
            let diff = targetAngle - this.angle;
            while (diff < -Math.PI) diff += Math.PI * 2;
            while (diff > Math.PI) diff -= Math.PI * 2;
            this.angle += diff * 0.08;
            
            // Leg animation
            this.legCycle += speed * 0.35; 
        }

        // --- MAGNET LOGIC (Fixed: Single Owner) ---
        if (typeof projectiles !== 'undefined') {
            for (let p of projectiles) {
                if (!p.active) continue;

                let dx = this.x - p.x;
                let dy = this.y - p.y;
                let distSq = dx*dx + dy*dy;
                let rangeSq = this.magnetRange * this.magnetRange;

                // 1. Release Lock if Out of Range
                // If I own this bullet but it's now too far away, let it go.
                if (distSq >= rangeSq) {
                    if (p.magnetOwner === this) {
                        p.magnetOwner = null;
                    }
                    continue; // Skip attraction
                }

                // 2. Check Ownership
                // If it is owned by someone else, AND that owner is still alive:
                if (p.magnetOwner && p.magnetOwner !== this) {
                    if (p.magnetOwner.hp > 0) {
                        continue; // Don't touch it
                    } else {
                        // Previous owner is dead, I can steal it
                        p.magnetOwner = null; 
                    }
                }

                // 3. Apply Attraction
                // Claim ownership
                p.magnetOwner = this;
                
                // Hijack Homing Target (if applicable)
                if (p.target && p.target !== this) p.target = this;

                let dist = Math.sqrt(distSq);

                // Stronger pull closer to center
                let strength = 1 + (1 - dist/this.magnetRange); 
                let force = this.magnetForce * strength;

                p.vx += (dx / dist) * force;
                p.vy += (dy / dist) * force;

                if (typeof p.angle !== 'undefined') {
                    let tA = Math.atan2(dy, dx);
                    let aD = tA - p.angle;
                    while (aD < -Math.PI) aD += Math.PI * 2;
                    while (aD > Math.PI) aD -= Math.PI * 2;
                    p.angle += aD * 0.2;
                }
            }
        }
        
        if (typeof separate === 'function') separate(this, enemies, 0.45);
        if (typeof resolveWallCollision === 'function') resolveWallCollision(this);
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        // --- 1. FIELD AURA ---
        let pulse = Math.sin(this.pulsePhase);
        let fieldR = this.magnetRange * (0.9 + pulse * 0.03);
        
        ctx.beginPath();
        ctx.arc(0, 0, fieldR, 0, Math.PI*2);
        let grad = ctx.createRadialGradient(0, 0, 10, 0, 0, fieldR);
        grad.addColorStop(0, "rgba(0,0,0,0)");
        grad.addColorStop(0.9, `rgba(100, 40, 160, ${0.05 + pulse * 0.02})`);
        grad.addColorStop(1, `rgba(100, 40, 160, 0)`);
        ctx.fillStyle = grad;
        ctx.fill();

        // ROTATE & SCALE
        ctx.rotate(this.angle);
        ctx.scale(this.scale, this.scale); 

        // --- 2. MULTI-JOINTED LEGS (SHORTER VERSION) ---
        const legConfig = [
            { side: 1,  yBase: -12, angle: -0.6, len: 28 },
            { side: -1, yBase: -12, angle: -0.6, len: 28 },
            { side: 1,  yBase: 0,   angle: 0,    len: 32 },
            { side: -1, yBase: 0,   angle: 0,    len: 32 },
            { side: 1,  yBase: 14,  angle: 0.8,  len: 30 },
            { side: -1, yBase: 14,  angle: 0.8,  len: 30 }
        ];

        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        legConfig.forEach((leg, index) => {
            ctx.save();
            let isGroupA = (index === 0 || index === 3 || index === 4);
            let legPhase = this.legCycle + (isGroupA ? 0 : Math.PI);
            
            let stride = Math.sin(legPhase) * 10; 
            let lift = Math.cos(legPhase) * 5;
            
            let startX = 5;
            let startY = leg.yBase;
            let baseAngle = (leg.side === 1 ? Math.PI/2 : -Math.PI/2) + (leg.angle * leg.side);
            
            let footDist = 20 + leg.len + lift;
            let footX = startX + Math.cos(baseAngle) * footDist + (stride * 0.5);
            let footY = startY + Math.sin(baseAngle) * footDist + stride;

            let coxaLen = 10;
            let coxaX = startX + Math.cos(baseAngle) * coxaLen;
            let coxaY = startY + Math.sin(baseAngle) * coxaLen;

            let dx = footX - coxaX;
            let dy = footY - coxaY;
            let dist = Math.hypot(dx, dy);
            let midX = coxaX + dx * 0.5;
            let midY = coxaY + dy * 0.5;
            
            let kneePush = 16;
            let perpX = -dy / dist;
            let perpY = dx / dist;
            if (leg.side === -1) { perpX = -perpX; perpY = -perpY; }
            
            let kneeX = midX + perpX * kneePush;
            let kneeY = midY + perpY * kneePush;

            // Draw Segments
            ctx.strokeStyle = "#150a1a";
            ctx.lineWidth = 7;
            ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(kneeX, kneeY); ctx.stroke();

            ctx.strokeStyle = "#25152e";
            ctx.lineWidth = 5;
            ctx.beginPath(); ctx.moveTo(kneeX, kneeY); ctx.lineTo(footX, footY); ctx.stroke();

            // Sharp tips
            ctx.strokeStyle = "#4a2d54";
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(footX, footY); ctx.lineTo(footX + (footX-kneeX)*0.4, footY + (footY-kneeY)*0.4); ctx.stroke();

            ctx.fillStyle = "#3d2a45";
            ctx.beginPath(); ctx.arc(kneeX, kneeY, 4, 0, Math.PI*2); ctx.fill();

            ctx.restore();
        });

        // --- 3. BODY STRUCTURE ---

        // Abdomen
        ctx.fillStyle = "#0d0612";
        ctx.strokeStyle = "#2a1a35";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-10, -15);
        ctx.lineTo(-30, -10);
        ctx.lineTo(-40, 0);   
        ctx.lineTo(-30, 10);
        ctx.lineTo(-10, 15);
        ctx.fill();
        ctx.stroke();

        // Thorax
        ctx.fillStyle = "#1a0e21";
        ctx.beginPath();
        ctx.moveTo(0, -18);
        ctx.lineTo(15, -12);
        ctx.lineTo(20, 0);
        ctx.lineTo(15, 12);
        ctx.lineTo(0, 18);
        ctx.lineTo(-10, 10);
        ctx.lineTo(-10, -10);
        ctx.closePath();
        ctx.fill();
        
        ctx.strokeStyle = "#3c2547";
        ctx.beginPath();
        ctx.moveTo(-5, -15); ctx.lineTo(10, -10);
        ctx.moveTo(-5, 15);  ctx.lineTo(10, 10);
        ctx.stroke();

        // Head
        ctx.fillStyle = "#25142e";
        ctx.beginPath();
        ctx.moveTo(20, -8);
        ctx.lineTo(28, -10);
        ctx.lineTo(32, -4);
        ctx.lineTo(32, 4);
        ctx.lineTo(28, 10);
        ctx.lineTo(20, 8);
        ctx.fill();

        // --- 4. STATIC SHARP MANDIBLES ---
        ctx.fillStyle = "#1a1a1a"; 
        ctx.strokeStyle = "#604070"; 
        ctx.lineWidth = 1;

        // TOP MANDIBLE (Left)
        ctx.beginPath();
        ctx.moveTo(32, -5);         
        ctx.lineTo(38, -10); 
        ctx.lineTo(36, -12); 
        ctx.lineTo(55, -18); // Sharp tip
        ctx.lineTo(50, -8);  
        ctx.lineTo(32, -2);          
        ctx.fill();
        ctx.stroke();

        // BOTTOM MANDIBLE (Right)
        ctx.beginPath();
        ctx.moveTo(32, 5);
        ctx.lineTo(38, 10);
        ctx.lineTo(36, 12);
        ctx.lineTo(55, 18); // Sharp tip
        ctx.lineTo(50, 8);
        ctx.lineTo(32, 2);
        ctx.fill();
        ctx.stroke();

        // Eyes
        ctx.fillStyle = "#ff0044";
        ctx.shadowBlur = 8; 
        ctx.shadowColor = "#ff0044";
        ctx.beginPath(); ctx.arc(26, -7, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(26, 7, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;

        // --- 5. GLOWING VENTS ---
        let ventGlow = 0.5 + Math.sin(this.pulsePhase * 3) * 0.5;

        ctx.save();
        ctx.translate(-20, -6);
        ctx.rotate(-0.2);
        ctx.shadowColor = `rgba(255, 50, 80, ${ventGlow})`;
        ctx.shadowBlur = 15;
        ctx.fillStyle = `rgba(255, 50, 80, ${0.5 + ventGlow * 0.5})`;
        ctx.beginPath();
        ctx.moveTo(0, 0); ctx.lineTo(10, -2); ctx.lineTo(0, -4); ctx.fill(); 
        ctx.restore();

        ctx.save();
        ctx.translate(-20, 6);
        ctx.rotate(0.2);
        ctx.shadowColor = `rgba(50, 180, 255, ${ventGlow})`;
        ctx.shadowBlur = 15;
        ctx.fillStyle = `rgba(50, 180, 255, ${0.5 + ventGlow * 0.5})`;
        ctx.beginPath();
        ctx.moveTo(0, 0); ctx.lineTo(10, 2); ctx.lineTo(0, 4); ctx.fill(); 
        ctx.restore();

        // Final Gloss
        ctx.fillStyle = "rgba(255,255,255,0.08)";
        ctx.beginPath();
        ctx.moveTo(5, -5); ctx.lineTo(15, -8); ctx.lineTo(10, 0); ctx.fill();

        ctx.restore(); 

        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class BossEnemy {
    constructor() {
        // --- SPAWN LOGIC ---
        this.col = COLS - 1; 
        this.row = Math.floor(ROWS / 2);
        this.x = this.col * CELL_SIZE + CELL_SIZE / 2;
        this.y = this.row * CELL_SIZE + CELL_SIZE / 2;

        // --- BOSS STATS ---
        this.radius = 45; // Huge hitbox
        this.speed = 0.4; // Slow, heavy, unstoppable
        this.maxHp = 1000 * difficultyMultiplier * (wave * 0.3);
        this.hp = this.maxHp;
        this.damage = 9999; // Instakill structures
        this.bounty = 500;
        this.active = true;

        // --- PHYSICS (Unstoppable) ---
        this.vx = 0; this.vy = 0;
        this.angle = Math.PI; // Facing left
        this.animTimer = 0;

        // --- VISUALS (Evolved Spider Theme) ---
        this.colors = {
            armor: "#5c5443",      // Darker, dirtier bone color
            highlight: "#8c8260",  // Aged Chitin
            joints: "#1a0b0b",     // Dark organic joints
            core: "#ff4400",       // Burning orange/red core
            eyes: "#ccff00",       // The signature Acid Green eyes
            blood: "#5e0e0e"       // Dried blood tips
        };
    }

    update(dt) {
        // 1. UNSTOPPABLE MOVEMENT (Ignores Knockback)
        // We move the coordinates directly towards the base
        let targetX = (playerBase.x * CELL_SIZE) + CELL_SIZE; 
        let targetY = (playerBase.y * CELL_SIZE) + CELL_SIZE;
        let dx = targetX - this.x;
        let dy = targetY - this.y;
        let dist = Math.hypot(dx, dy);

        if (dist > 1) {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
            
            // Heavy Rotation
            let desiredAngle = Math.atan2(dy, dx);
            let diff = desiredAngle - this.angle;
            while (diff < -Math.PI) diff += Math.PI * 2;
            while (diff > Math.PI) diff -= Math.PI * 2;
            this.angle += diff * 0.04;
        }

        // 2. WALL CRUSHER (Boss Logic)
        // Destroys everything in a wide radius
        let gridRadius = Math.ceil(this.radius / CELL_SIZE);
        let cx = Math.floor(this.x / CELL_SIZE);
        let cy = Math.floor(this.y / CELL_SIZE);

        for (let i = -gridRadius; i <= gridRadius; i++) {
            for (let j = -gridRadius; j <= gridRadius; j++) {
                let c = cx + i;
                let r = cy + j;
                if (c >= 0 && c < COLS && r >= 0 && r < ROWS) {
                    let cell = grid[c][r];
                    if (cell.wall) {
                        let cellX = c * CELL_SIZE + CELL_SIZE/2;
                        let cellY = r * CELL_SIZE + CELL_SIZE/2;
                        
                        // Circle collision check
                        if (Math.hypot(this.x - cellX, this.y - cellY) < this.radius + 15) {
                            cell.wall = false;
                            cell.occupied = false;
                            
                            // Spawn Debris (Matching armor color)
                            for(let k=0; k<6; k++) {
                                particles.push({
                                    x: cellX, y: cellY,
                                    vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
                                    life: 60, color: this.colors.armor, size: Math.random()*4
                                });
                            }
                        }
                    }
                }
            }
        }

        // 3. BASE DESTRUCTION
        if (dist < this.radius + 30) {
            this.hp = 0;
            takeDamage(this.damage);
        }

        this.animTimer += 0.08; // Slower animation than small enemies
    }

    draw() {
        // --- 1. DRAW BOSS (Rotated) ---
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        const s = 2.8; // Scale
        
        // --- PALETTE ---
        const c = {
            chitinDark:  "#120b05",
            chitinMid:   "#3d3215",
            chitinLight: "#6e5d38",
            bone:        "#8c8260", 
            joint:       "#0f0505", 
            acid:        "#ccff00", 
            
            // Abdomen Palette
            sacInner:    "#ff5500", 
            sacOuter:    "#3b2010", 
            ventGlow:    "rgba(255, 100, 0, 0.8)"
        };

        const breathe = Math.sin(this.animTimer * 0.8);
        const walkCycle = this.animTimer;

        // --- HELPER: LEG ---
        const drawLeg = (ox, oy, restX, restY, phase, side) => {
            const cycle = walkCycle + phase;
            const lift = Math.max(0, Math.sin(cycle));
            const stride = Math.cos(cycle);

            let sx = ox * s; 
            let sy = oy * s;
            let fx = sx + (restX * s) + (stride * 5 * s);
            let fy = sy + (restY * s) + (lift * -4 * side * s);
            let midX = (sx + fx) / 2;
            let midY = (sy + fy) / 2;
            let kx = midX - (2 * s); 
            let ky = midY + (side * 6 * s); 

            // Femur
            ctx.lineCap = "round";
            ctx.strokeStyle = c.chitinMid;
            ctx.lineWidth = 3.5 * s;
            ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(kx, ky); ctx.stroke();
            
            ctx.strokeStyle = c.joint; 
            ctx.lineWidth = 1.5 * s;
            ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(kx, ky); ctx.stroke();

            // Tibia
            ctx.strokeStyle = c.bone;
            ctx.lineWidth = 2 * s;
            ctx.beginPath(); ctx.moveTo(kx, ky); ctx.lineTo(fx, fy); ctx.stroke();

            // Joint
            ctx.fillStyle = c.joint;
            ctx.beginPath(); ctx.arc(kx, ky, 2.2 * s, 0, Math.PI*2); ctx.fill();
            
            // Spike
            ctx.fillStyle = c.bone;
            ctx.beginPath();
            ctx.moveTo(kx, ky);
            ctx.lineTo(kx - (1*s), ky - (side * 4 * s)); 
            ctx.lineTo(kx + (1*s), ky);
            ctx.fill();

            // Foot
            ctx.fillStyle = "#5e0e0e";
            ctx.beginPath(); ctx.arc(fx, fy, 0.8 * s, 0, Math.PI*2); ctx.fill();
        };

        // --- LAYER: REAR LEGS ---
        ctx.filter = "brightness(0.6)"; 
        drawLeg(-6, -3, -8, -8, 0, -1);
        drawLeg(-6, 3, -8, 8, Math.PI, 1);
        ctx.filter = "none";

        // --- LAYER: ABDOMEN (Corrected) ---
        const sacPulse = 1 + (breathe * 0.05);
        
        // 1. Define Shape Path
        ctx.beginPath();
        ctx.moveTo(-4*s, -5*s); 
        ctx.bezierCurveTo(-15*s, -12*s*sacPulse, -32*s, -9*s, -38*s, 0); 
        ctx.bezierCurveTo(-32*s, 9*s, -15*s, 12*s*sacPulse, -4*s, 5*s);  
        ctx.lineTo(-4*s, -5*s); 
        
        ctx.save(); 
        ctx.clip(); 

        // 2. Translucent Gradient (Extended Radius to cover tip)
        // Increased radius from 18*s to 22*s to prevent fade-out at the tip
        const sacGrad = ctx.createRadialGradient(-20*s, 0, 2*s, -20*s, 0, 22*s);
        sacGrad.addColorStop(0, c.sacInner); 
        sacGrad.addColorStop(0.6, c.sacOuter); 
        sacGrad.addColorStop(1, "#1a0f05"); 
        ctx.fillStyle = sacGrad;
        ctx.fill();

        // 3. Ribbed Segmentation (Dark Lines)
        ctx.strokeStyle = "rgba(0,0,0,0.5)";
        ctx.lineWidth = 2 * s;
        for(let i=1; i<=4; i++) {
            let rx = -8*s - (i * 6 * s);
            ctx.beginPath();
            ctx.moveTo(rx, -10*s);
            ctx.quadraticCurveTo(rx - (4*s), 0, rx, 10*s);
            ctx.stroke();
        }

        ctx.restore(); // Remove Clip
        
        // 4. (Removed the Rim Light Stroke here to fix white stripe)

        // 5. Spinal Armor Plates
        ctx.fillStyle = c.chitinDark;
        for(let i=0; i<6; i++) {
            let spX = -8*s - (i * 5 * s);
            let h = 4 * s * (1 - (i/7)); 
            ctx.beginPath();
            ctx.moveTo(spX + 3*s, 0);
            ctx.lineTo(spX, -h); 
            ctx.lineTo(spX - 3*s, 0);
            ctx.lineTo(spX, h);  
            ctx.fill();
            
            // Highlight (Darkened slightly)
            ctx.strokeStyle = "rgba(110, 93, 56, 0.5)";
            ctx.lineWidth = 0.5;
            ctx.beginPath(); ctx.moveTo(spX, -h); ctx.lineTo(spX - 2*s, 0); ctx.stroke();
        }

        // --- LAYER: LEGS ---
        drawLeg(-2, -4, -4, -11, Math.PI*0.5, -1); 
        drawLeg(-2, 4, -4, 11, Math.PI*1.5, 1);
        drawLeg(4, -4, 4, -10, 0, -1); 
        drawLeg(4, 4, 4, 10, Math.PI, 1);
        drawLeg(8, -3, 10, -5, Math.PI, -1); 
        drawLeg(8, 3, 10, 5, 0, 1);

        // --- LAYER: THORAX ---
        const thoraxGrad = ctx.createRadialGradient(0, 0, 1*s, 0, 0, 14*s);
        thoraxGrad.addColorStop(0, c.chitinMid);
        thoraxGrad.addColorStop(1, c.chitinDark);
        
        ctx.fillStyle = thoraxGrad;
        ctx.beginPath();
        ctx.moveTo(10*s, -5*s); 
        ctx.lineTo(14*s, -2*s); 
        ctx.lineTo(14*s, 2*s);
        ctx.lineTo(10*s, 5*s);
        ctx.lineTo(-4*s, 7*s);  
        ctx.lineTo(-8*s, 0);    
        ctx.lineTo(-4*s, -7*s); 
        ctx.fill();

        // Central Shield
        ctx.fillStyle = c.chitinDark;
        ctx.strokeStyle = c.chitinLight; 
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(8*s, 0);
        ctx.lineTo(2*s, -3.5*s);
        ctx.lineTo(-6*s, 0);
        ctx.lineTo(2*s, 3.5*s);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Vents
        ctx.fillStyle = c.ventGlow;
        ctx.shadowColor = "orange";
        ctx.shadowBlur = 8 * (0.5 + breathe * 0.5); 
        
        for(let i=0; i<3; i++) {
            ctx.beginPath();
            ctx.ellipse(0 + (i*2.5*s), -5.5*s, 0.6*s, 1.5*s, 0.4, 0, Math.PI*2);
            ctx.fill();
            ctx.beginPath();
            ctx.ellipse(0 + (i*2.5*s), 5.5*s, 0.6*s, 1.5*s, -0.4, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.shadowBlur = 0;

        // --- LAYER: HEAD (NIGHTMARE VARIANT) ---
ctx.save();
ctx.translate(13 * s, 0); // Head locked to body

// --- 0. PALETTE ---
const c_bone     = "#1a1616"; // Dark Chitin
const c_blood    = "#4a0a0a"; // Dried blood
const c_tip      = "#000000"; // Sharp tip
const c_highlight= "rgba(255, 255, 255, 0.1)";

// --- 1. THE MAW (Inner Mouth) ---
ctx.fillStyle = "#000000";
ctx.beginPath();
ctx.arc(0, 0, 4.5 * s, 0, Math.PI * 2);
ctx.fill();

// --- 2. INNER GRASPERS (Secondary Mandibles) ---
// These are small, fast-moving claws inside the mouth that "fiddle"
const innerTwitch = Math.sin(this.animTimer * 8) * 0.3;
ctx.fillStyle = "#2e1a1a";
for(let dir = -1; dir <= 1; dir+=2) {
    ctx.save();
    ctx.translate(2.5 * s, dir * 1.0 * s); // Positioned inside
    ctx.scale(1, dir); // Flip for bottom/top
    ctx.rotate(innerTwitch);
    
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.quadraticCurveTo(2*s, -0.5*s, 3*s, 0.5*s); // Hook
    ctx.lineTo(2.5*s, 0.8*s); // Thickness
    ctx.lineTo(0, 0.5*s);
    ctx.fill();
    // Add a glowing tip to the inner claws
    ctx.fillStyle = "#ff0000";
    ctx.beginPath(); ctx.arc(3*s, 0.5*s, 0.2*s, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = "#2e1a1a"; // Reset
    ctx.restore();
}

// --- 3. MAIN MANDIBLES (Serrated Crushers) ---
// Heavy, breathing motion
const biteOpen = 0.2 + (Math.sin(this.animTimer * 1.5) * 0.15); 

const drawNightmareMandible = (scaleY) => {
    ctx.save();
    ctx.scale(1, scaleY); 
    ctx.rotate(-biteOpen); 
    
    // 1. COMPLEX GRADIENT (Chitin -> Bone -> Blood)
    const mGrad = ctx.createLinearGradient(0, 0, 14*s, 0);
    mGrad.addColorStop(0,   c_bone);
    mGrad.addColorStop(0.4, "#2d2424"); // Grayish armor
    mGrad.addColorStop(0.7, c_blood);   // Reddening
    mGrad.addColorStop(1,   c_tip);     // Black tip
    
    ctx.fillStyle = mGrad;
    ctx.strokeStyle = "#0d0505";
    ctx.lineWidth = 0.3 * s;

    ctx.beginPath();
    ctx.moveTo(0, -2*s); // Wide, muscular attachment base
    
    // --- OUTER ARMOR PLATING ---
    // Instead of one curve, we break it into two "plates"
    ctx.bezierCurveTo(3*s, -3.5*s, 5*s, -3.5*s, 7*s, -2*s); // Plate 1
    ctx.lineTo(7.2*s, -2.2*s); // Jagged transition
    ctx.bezierCurveTo(9*s, -3*s, 12*s, -1.5*s, 14*s, 0.5*s); // The Main Hook Tip

    // --- INNER SERRATED EDGE ---
    // We draw the return path manually to add TEETH
    ctx.lineTo(13*s, 0.8*s); // Thickness of tip
    
    // Tooth 1 (The Ripper)
    ctx.lineTo(11*s, 0); 
    ctx.lineTo(10.5*s, 0.8*s); 
    
    // Tooth 2 (The Crusher)
    ctx.lineTo(9*s, 0.2*s);
    ctx.lineTo(8*s, 1.2*s);
    
    // Tooth 3 (The Grinder - closer to mouth)
    ctx.lineTo(6*s, 0.5*s);
    ctx.lineTo(5*s, 1.5*s);

    ctx.lineTo(0, 1.5*s); // Back to base
    ctx.closePath();
    ctx.fill();
    ctx.stroke();
    
    // --- TEXTURE DETAILS ---
    
    // A. The "Ridge" (3D volume line)
    ctx.strokeStyle = "rgba(0,0,0,0.5)";
    ctx.beginPath();
    ctx.moveTo(2*s, -1*s);
    ctx.quadraticCurveTo(7*s, -1.5*s, 12*s, 0.2*s);
    ctx.stroke();

    // B. Sensory Spikes (Hairs/Setae on the chin)
    ctx.strokeStyle = "#5c4040";
    ctx.lineWidth = 0.15 * s;
    ctx.beginPath();
    // Draw 3 little hairs sticking out of the bottom jaw
    ctx.moveTo(4*s, 1.2*s); ctx.lineTo(4.2*s, 2.0*s);
    ctx.moveTo(5.5*s, 1.0*s); ctx.lineTo(5.8*s, 1.8*s);
    ctx.moveTo(7*s, 0.5*s); ctx.lineTo(7.3*s, 1.2*s);
    ctx.stroke();

    // C. Specular Highlight (Slimy look)
    ctx.strokeStyle = c_highlight;
    ctx.lineWidth = 0.4 * s;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(3*s, -2.5*s);
    ctx.quadraticCurveTo(6*s, -2.8*s, 9*s, -1.5*s);
    ctx.stroke();

    ctx.restore();
};

// Draw Left and Right
ctx.save();
ctx.translate(3*s, -1.5*s);
drawNightmareMandible(1); 
ctx.restore();

ctx.save();
ctx.translate(3*s, 1.5*s);
drawNightmareMandible(-1); 
ctx.restore();

// --- 4. HEAD CARAPACE ---
// Reusing the beetle shape but darkening it to match the new jaw
const skullGrad = ctx.createRadialGradient(2*s, 0, 1*s, 4*s, 0, 8*s);
skullGrad.addColorStop(0, "#2a2222");
skullGrad.addColorStop(1, "#0a0a0a");

ctx.fillStyle = skullGrad;
ctx.beginPath();
ctx.moveTo(-2*s, -4*s); 
ctx.bezierCurveTo(3*s, -4.5*s, 6*s, -3*s, 8*s, 0); 
ctx.bezierCurveTo(6*s, 3*s, 3*s, 4.5*s, -2*s, 4*s);
ctx.lineTo(-2.5*s, 0);
ctx.fill();

// --- 5. EYES ---
// Standard predatory setup
const acid = "#aaff00";
const drawEye = (x, y, r) => {
    ctx.save();
    ctx.translate(x*s, y*s);
    ctx.shadowColor = acid; ctx.shadowBlur = 10;
    ctx.fillStyle = "#000"; ctx.beginPath(); ctx.arc(0,0,r*s,0,Math.PI*2); ctx.fill();
    ctx.shadowBlur = 0;
    ctx.fillStyle = acid; ctx.beginPath(); ctx.arc(0,0,r*0.6*s,0,Math.PI*2); ctx.fill();
    ctx.restore();
}
drawEye(4, -2, 1); drawEye(4, 2, 1);
drawEye(2.5, -3.5, 0.6); drawEye(2.5, 3.5, 0.6);

ctx.restore(); 
ctx.restore();

        // --- 2. FLOATING HEALTH BAR ---
        ctx.save();
        ctx.translate(this.x, this.y); 
        
        const barY = -(20 * s); 
        const barW = 100;
        const hpPct = this.hp / this.maxHp;
        
        ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
        ctx.beginPath();
        ctx.roundRect(-barW/2, barY, barW, 8, 3);
        ctx.fill();
        
        const barGrad = ctx.createLinearGradient(-barW/2, 0, barW/2, 0);
        barGrad.addColorStop(0, "#ff3300"); 
        barGrad.addColorStop(1, "#ccff00"); 
        
        ctx.fillStyle = barGrad;
        ctx.beginPath();
        ctx.roundRect(-barW/2 + 1, barY + 1, Math.max(0, (barW-2) * hpPct), 6, 2);
        ctx.fill();

        ctx.fillStyle = "#fff";
        ctx.font = "bold 12px Arial";
        ctx.textAlign = "center";
        ctx.fillText("HIVE QUEEN", 0, barY - 5);

        ctx.restore();
    }
}

function spawnBoss() {
    let boss = new BossEnemy();
    enemies.push(boss);
    
    // Optional: Announcement text
    currentAnnouncement = {
        text: "WARNING: BOSS DETECTED",
        life: 180,
        color: "#ff0000",
        update: function(dt) { this.life--; if(this.life<=0) this.active=false; },
        draw: function() {
            if(this.life > 0) {
                ctx.fillStyle = this.color;
                ctx.font = "bold 40px Segoe UI";
                ctx.textAlign = "center";
                ctx.fillText(this.text, canvas.width/2, 100);
            }
        },
        active: true
    };
}

class ShielderEnemy {
    constructor() {
        // --- SPAWN POSITION ---
        let boundW = (typeof VIRTUAL_WIDTH !== 'undefined') ? VIRTUAL_WIDTH : canvas.width;
        let boundH = (typeof VIRTUAL_HEIGHT !== 'undefined') ? VIRTUAL_HEIGHT : canvas.height;

        this.x = boundW + 20; 
        let playableHeight = boundH - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- STATS (Maintained Shielder Stats) ---
        this.radius = 16;            
        this.speed = 0.5;            
        this.hp = 400 + (wave * 25); 
        this.maxHp = this.hp;
        this.bounty = 40;
        
        // Initial Velocity
        this.vx = -0.5; 
        this.vy = 0;

        // --- COOLDOWNS ---
        this.attackCooldown = 0; 
        this.wallDamageCooldown = 0;

        // --- SHIELD ABILITY ---
        this.shieldRadius = 140;
        this.isShieldActive = true;
        
        // Timer (Frames)
        this.frameTimer = 0;
        this.onDuration = 300; 
        this.offDuration = 180;
        this.totalCycle = this.onDuration + this.offDuration;

        // --- VISUALS (Stag Beetle) ---
        this.angle = Math.PI; 
        this.animTimer = Math.random() * 10; 
        
        this.colors = {
            shell: "#1a1a2e", highlight: "#303045", core: "#00d2ff", legs: "#111"
        };
    }

    update(dt) {
        // --- 1. SHIELD TIMER LOGIC ---
        this.frameTimer+=dt;
        if (this.frameTimer >= this.totalCycle) this.frameTimer = 0;
        this.isShieldActive = (this.frameTimer < this.onDuration);

        // --- 2. MOVEMENT & WALL LOGIC (Updated to match your snippet) ---
        
        // Animation speed
        this.animTimer += 0.3 * dt; 

        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);

        let isBlocked = sharedMovement(this, col, row);
        
        // Wall Destruction Logic (Matches provided snippet)
        if (isBlocked) {
            sharedDestroyWalls(this, col, row, 2, 10);
        }

        if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
            this.angle = Math.atan2(this.vy, this.vx);
        }

        this.x += this.vx;
        this.y += this.vy;

        // Separation & Collision
        if (typeof enemies !== 'undefined') separate(this, enemies, 0.5); 
        if (typeof allies !== 'undefined') separate(this, allies, 0.8);
        
        // This ensures they don't walk through walls
        resolveWallCollision(this);

        // Base Damage Logic
        if (this.attackCooldown > 0) this.attackCooldown -= dt;
        
        if (typeof playerBase !== 'undefined') {
            let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
            let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
            if (Math.hypot(dx, dy) < 30) { 
                takeDamage(5); // Damage the player
                this.hp = 0;   // Suicide attack
            }
        }

        // --- 3. SHIELD EFFECT ---
        if (this.isShieldActive && typeof enemies !== 'undefined') {
            for (let e of enemies) {
                if (e === this) continue; 
                if (Math.hypot(e.x - this.x, e.y - this.y) < this.shieldRadius) {
                    e.isInvincible = true;
                    // Visual link
                    if (Math.random() < 0.05) {
                         particles.push({
                            x: e.x, y: e.y, 
                            vx: (this.x - e.x)*0.02, vy: (this.y - e.y)*0.02,
                            life: 15, color: this.colors.core, size: 1
                        });
                    }
                }
            }
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // --- DRAW SHIELD ---
        if (this.isShieldActive) {
            ctx.beginPath();
            ctx.arc(0, 0, this.shieldRadius, 0, Math.PI*2);
            ctx.strokeStyle = "rgba(0, 210, 255, 0.5)";
            ctx.lineWidth = 2;
            ctx.setLineDash([20, 15]);
            ctx.stroke();
            ctx.setLineDash([]); 
            ctx.fillStyle = "rgba(0, 210, 255, 0.05)";
            ctx.fill();
        } else {
            let pct = (this.frameTimer - this.onDuration) / this.offDuration; 
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI * 2 * (1-pct));
            ctx.strokeStyle = "#ff4444";
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // --- DRAW BODY (Maintained Stag Beetle Visuals) ---
        ctx.rotate(this.angle);

        // 1. LEGS
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        const drawLeg = (ox, oy, restX, restY, phase, side) => {
            let cycle = this.animTimer + phase;
            let footX = ox + restX + (Math.cos(cycle) * 3);
            let footY = oy + restY + (Math.abs(Math.sin(cycle)) * -2.0 * side);
            let kneeX = (ox + footX) / 2 - 2;
            let kneeY = (oy + footY) / 2 + (side * 6); 

            ctx.strokeStyle = "#000"; ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(kneeX, kneeY); ctx.lineTo(footX, footY); ctx.stroke();
            ctx.strokeStyle = "#333"; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(kneeX, kneeY); ctx.lineTo(footX, footY); ctx.stroke();
            ctx.fillStyle = this.colors.core; ctx.beginPath(); ctx.arc(kneeX, kneeY, 1.5, 0, Math.PI*2); ctx.fill();
        };

        drawLeg(4, -5,  4, -10, 0, -1);
        drawLeg(4,  5,  4,  10, Math.PI, 1);
        drawLeg(-2, -6, -2, -12, Math.PI, -1);
        drawLeg(-2,  6, -2,  12, 0, 1);
        drawLeg(-8, -5, -6, -10, 0, -1);
        drawLeg(-8,  5, -6,  10, Math.PI, 1);

        // 2. SEGMENTED BODY
        ctx.fillStyle = this.colors.shell;
        ctx.strokeStyle = this.colors.highlight;
        ctx.lineWidth = 2;

        // Rear
        ctx.beginPath(); ctx.moveTo(-6, -5); ctx.lineTo(-14, -3); ctx.lineTo(-18, 0); ctx.lineTo(-14, 3); ctx.lineTo(-6, 5); ctx.fill(); ctx.stroke();
        // Mid
        ctx.beginPath(); ctx.moveTo(2, -8); ctx.lineTo(-8, -7); ctx.lineTo(-10, 0); ctx.lineTo(-8, 7); ctx.lineTo(2, 8); ctx.fill(); ctx.stroke();
        // Vents
        ctx.fillStyle = "#111"; ctx.beginPath(); ctx.moveTo(-4, -4); ctx.lineTo(-2, -4); ctx.lineTo(-2, 4); ctx.lineTo(-4, 4); ctx.fill(); ctx.fillStyle = this.colors.shell; 
        // Front
        ctx.beginPath(); ctx.moveTo(10, -5); ctx.lineTo(8, -11); ctx.lineTo(0, -9); ctx.lineTo(-2, -6); ctx.lineTo(-2, 6); ctx.lineTo(0, 9); ctx.lineTo(8, 11); ctx.lineTo(10, 5); ctx.fill(); ctx.stroke();

        // 3. CORE
        let coreColor = this.isShieldActive ? this.colors.core : "#444";
        ctx.shadowBlur = this.isShieldActive ? 15 : 0;
        ctx.shadowColor = coreColor;
        ctx.fillStyle = coreColor;
        ctx.beginPath(); ctx.moveTo(2, -4); ctx.lineTo(7, 0); ctx.lineTo(2, 4); ctx.lineTo(-3, 0); ctx.fill();
        ctx.shadowBlur = 0; 

        // 4. HEAD
        ctx.fillStyle = "#0a0a10"; 
        ctx.beginPath();
        ctx.moveTo(8, -4); ctx.quadraticCurveTo(16, -8, 22, -3); ctx.lineTo(18, -1); ctx.quadraticCurveTo(14, -4, 8, -2);
        ctx.moveTo(8, 4); ctx.quadraticCurveTo(16, 8, 22, 3); ctx.lineTo(18, 1); ctx.quadraticCurveTo(14, 4, 8, 2); 
        ctx.fill();

        ctx.fillStyle = this.colors.shell;
        ctx.strokeStyle = this.colors.highlight;
        ctx.beginPath();
        ctx.moveTo(6, -6); ctx.lineTo(14, -3); ctx.lineTo(14, 3); ctx.lineTo(6, 6);
        ctx.fill(); ctx.stroke();

        ctx.fillStyle = "#ff0044"; 
        ctx.shadowBlur = 5; ctx.shadowColor = "#ff0044";
        ctx.beginPath(); ctx.moveTo(10, -5); ctx.lineTo(12, -4); ctx.lineTo(12, -2); ctx.lineTo(10, -3); ctx.fill();
        ctx.beginPath(); ctx.moveTo(10, 5); ctx.lineTo(12, 4); ctx.lineTo(12, 2); ctx.lineTo(10, 3); ctx.fill();
        ctx.shadowBlur = 0;

        ctx.restore();

        // --- HEALTH BAR ---
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class SwordTroop {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.radius = 11; 
        this.type = "SWORD_ALLY";
        
        // STATS
        this.hp = 250; this.maxHp = 250; 
        this.range = 45; 
        this.damage = 50; 
        this.lifeTimer = 1800; // 30s

        // MOVEMENT
        this.speed = 2.2; 
        this.vx = 0; this.vy = 0;
        this.friction = 0.12;
        this.angle = 0; 

        // ANIMATION STATE
        this.cooldown = 0;
        this.maxCooldown = 50; 
        this.swingState = "IDLE"; 
        this.swingProgress = 0;
        
        // Animation Variables
        this.swordAngle = 0.5; 
        this.bodyLean = 0; 
        this.impactAlpha = 0;

        // AI VARS
        this.pathTimer = Math.random() * 30;
        this.pathRefreshRate = 20; 
        this.currentPath = [];
        this.nodeReachThreshold = 15;
        this.target = null;
        this.walkCycle = 0;
    }

    update(dt) {
        this.lifeTimer--;
        if (this.lifeTimer <= 0) this.hp = 0;

        // --- TARGETING ---
        if (!this.target || this.target.hp <= 0 || Math.random() < 0.05) {
            let nearest = null;
            let minDist = Infinity;
            for (let e of enemies) {
                let d = (e.x - this.x)**2 + (e.y - this.y)**2;
                if (d < minDist) { minDist = d; nearest = e; }
            }
            this.target = nearest;
        }

        let moving = false;

        if (this.target) {
            let dx = this.target.x - this.x;
            let dy = this.target.y - this.y;
            let distToTarget = Math.hypot(dx, dy);

            // COMBAT
            if (distToTarget < this.range) {
                this.vx *= 0.5; this.vy *= 0.5;
                this.angle = Math.atan2(dy, dx);

                if (this.cooldown <= 0 && this.swingState === "IDLE") {
                    this.swingState = "LIFT";
                    this.swingProgress = 0;
                    this.cooldown = this.maxCooldown;
                }
            }
            // MOVEMENT
            else {
                let moveX = this.target.x;
                let moveY = this.target.y;
                let usingPath = false;
                let canSee = typeof hasLineOfSight === 'function' ? hasLineOfSight(this.x, this.y, this.target.x, this.target.y) : true;

                if (!canSee && typeof findPath === 'function') {
                    this.pathTimer--;
                    if (this.pathTimer <= 0) {
                        this.currentPath = findPath(this, this.target);
                        this.pathTimer = this.pathRefreshRate;
                    }
                    if (this.currentPath && this.currentPath.length > 0) {
                        let nextNode = this.currentPath[0];
                        moveX = nextNode.x;
                        moveY = nextNode.y;
                        usingPath = true;
                        if (Math.hypot(nextNode.x - this.x, nextNode.y - this.y) < this.nodeReachThreshold) this.currentPath.shift();
                    }
                }
                if (!usingPath && canSee) this.currentPath = [];

                let mdx = moveX - this.x;
                let mdy = moveY - this.y;
                let mDist = Math.hypot(mdx, mdy);

                if (mDist > 1) {
                    let dirX = mdx / mDist;
                    let dirY = mdy / mDist;
                    this.vx += (dirX * this.speed - this.vx) * this.friction;
                    this.vy += (dirY * this.speed - this.vy) * this.friction;
                    moving = true;
                    if (Math.hypot(this.vx, this.vy) > 0.5) this.angle = Math.atan2(this.vy, this.vx);
                }
            }
        }

        if (!moving) { this.vx *= 0.8; this.vy *= 0.8; }
        if (this.cooldown > 0) this.cooldown--;
        if (this.impactAlpha > 0) this.impactAlpha -= 0.15; 

        if (moving) this.walkCycle += 0.35; else this.walkCycle = 0;

        this.updateNewAnimation();

        this.x += this.vx * dt;
        this.y += this.vy * dt;

        if(typeof separate === 'function') { separate(this, allies, 0.6); separate(this, enemies, 0.4); }
        if(typeof resolveWallCollision === 'function') resolveWallCollision(this);
    }

    updateNewAnimation() {
        let baseAngle = 0.4; 

        if (this.swingState !== "IDLE") {
            this.swingProgress++;

            // --- PHASE 1: LIFT (Two-handed wind up) ---
            if (this.swingState === "LIFT") {
                let duration = 12;
                let t = this.swingProgress / duration;
                let ease = t * t; 
                
                this.swordAngle = baseAngle - (ease * 2.6); 
                this.bodyLean = -3 * ease;

                if (this.swingProgress >= duration) {
                    this.swingState = "CHOP";
                    this.swingProgress = 0;
                }
            }
            // --- PHASE 2: CHOP ---
            else if (this.swingState === "CHOP") {
                let duration = 6;
                let t = this.swingProgress / duration;
                
                this.swordAngle = -2.2 + (t * 4.2); 
                this.bodyLean = -3 + (t * 8);

                if (this.swingProgress === 3) {
                     this.impactAlpha = 1.0;
                     if (this.target) {
                        let d = Math.hypot(this.target.x - this.x, this.target.y - this.y);
                        if (d < this.range + 15) {
                            this.target.hp -= this.damage;
                            if(typeof createParticles === 'function') {
                                createParticles(this.target.x, this.target.y, "#ffffff", 8);
                                createParticles(this.target.x, this.target.y, "#aa00ff", 6);
                            }
                            this.target.vx += Math.cos(this.angle) * 5;
                            this.target.vy += Math.sin(this.angle) * 5;
                        }
                    }
                }

                if (this.swingProgress >= duration) {
                    this.swingState = "RECOVER";
                    this.swingProgress = 0;
                }
            }
            // --- PHASE 3: RECOVER ---
            else if (this.swingState === "RECOVER") {
                let duration = 15;
                let t = this.swingProgress / duration;
                let ease = 1 - Math.pow(1 - t, 3);
                
                this.swordAngle = 2.0 - (ease * 1.6); 
                this.bodyLean = 5 * (1 - ease);

                if (this.swingProgress >= duration) {
                    this.swingState = "IDLE";
                    this.swordAngle = baseAngle;
                    this.bodyLean = 0;
                }
            }
        } else {
            this.bodyLean = 0;
            this.swordAngle = baseAngle + Math.sin(Date.now() / 250) * 0.05;
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // --- SHADOW ---
        ctx.fillStyle = "rgba(0,0,0,0.8)";
        ctx.beginPath();
        ctx.ellipse(-2 + (this.bodyLean * 0.5), 2, 11, 8, 0, 0, Math.PI*2);
        ctx.fill();

        // --- LEGS ---
        let leftLeg = Math.sin(this.walkCycle) * 5;
        let rightLeg = Math.sin(this.walkCycle + Math.PI) * 5;
        
        ctx.fillStyle = "#2a2a2a"; 
        ctx.beginPath(); ctx.arc(-4 + leftLeg + (this.bodyLean * 0.3), -5, 4, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(-4 + rightLeg + (this.bodyLean * 0.3), 5, 4, 0, Math.PI*2); ctx.fill();
        
        ctx.fillStyle = "#4a4a55"; 
        ctx.fillRect(-6 + leftLeg + (this.bodyLean * 0.3), -7, 6, 4);
        ctx.fillRect(-6 + rightLeg + (this.bodyLean * 0.3), 3, 6, 4);
        ctx.strokeStyle = "#888"; ctx.lineWidth = 0.5;
        ctx.strokeRect(-6 + leftLeg + (this.bodyLean * 0.3), -7, 6, 4);
        ctx.strokeRect(-6 + rightLeg + (this.bodyLean * 0.3), 3, 6, 4);

        // --- BODY ---
        ctx.save();
        ctx.translate(this.bodyLean, 0); 

        // Chest
        let chestGrad = ctx.createLinearGradient(-5, -5, 10, 5);
        chestGrad.addColorStop(0.0, "#666"); 
        chestGrad.addColorStop(0.4, "#222"); 
        chestGrad.addColorStop(1.0, "#444"); 
        
        ctx.fillStyle = chestGrad;
        ctx.beginPath();
        ctx.moveTo(-6, -7); ctx.lineTo(6, -7);
        ctx.lineTo(8, 0); ctx.lineTo(6, 7);
        ctx.lineTo(-6, 7);
        ctx.fill();
        ctx.strokeStyle = "#a0a0b0"; ctx.lineWidth = 1; ctx.stroke();

        // Shoulders
        let shoulderGrad = ctx.createRadialGradient(-2, -9, 0, 0, -7, 6);
        shoulderGrad.addColorStop(0, "#fff"); shoulderGrad.addColorStop(1, "#111");
        ctx.fillStyle = shoulderGrad;
        ctx.beginPath(); ctx.arc(0, -7, 5, 0, Math.PI*2); ctx.fill(); 
        ctx.beginPath(); ctx.arc(0, 7, 5, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#8899aa"; ctx.stroke(); ctx.beginPath(); ctx.arc(0, 7, 5, 0, Math.PI*2); ctx.stroke(); 

        // Head
        ctx.save();
        ctx.translate(2, 0); 
        ctx.fillStyle = "#222"; ctx.beginPath(); ctx.arc(0, 0, 5.5, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#aaa"; ctx.lineWidth = 1; ctx.stroke();
        ctx.fillStyle = "rgba(255,255,255,0.4)"; ctx.beginPath(); ctx.ellipse(-2, -2, 2, 1, Math.PI/-4, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#fff"; ctx.shadowColor = "#aa00ff"; ctx.shadowBlur = 10;
        ctx.beginPath(); ctx.fillRect(2, -3, 3, 6); ctx.shadowBlur = 0;
        ctx.restore();

        // --- TWO-HANDED SWORD GRIP ---
        ctx.save();
        ctx.translate(0, 0); // Rotate from center of body/shoulders
        ctx.rotate(this.swordAngle); 

        // 1. LEFT ARM (The supporting arm, underneath)
        // Reaches slightly shorter than the right arm
        ctx.fillStyle = "#222"; 
        ctx.fillRect(0, 4, 8, 4); // Arm segment
        ctx.strokeRect(0, 4, 8, 4);

        // 2. RIGHT ARM (The main arm, on top)
        // Reaches further out
        ctx.fillStyle = "#333"; 
        ctx.fillRect(0, -4, 11, 4); // Arm segment
        ctx.strokeRect(0, -4, 11, 4);

        // 3. HANDS (Gauntlets)
        // Left Hand (Closer to body)
        ctx.fillStyle = "#111"; 
        ctx.translate(8, 6); // Move to Left Hand pos
        ctx.beginPath(); ctx.arc(0, 0, 3.5, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = "#888"; ctx.stroke();
        
        // Right Hand (Further out)
        ctx.translate(4, -8); // Move relative to Left Hand to get to Right Hand pos
        ctx.fillStyle = "#111";
        ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = "#aaa"; ctx.stroke();

        // 4. THE SWORD (Held by both hands)
        // We are now at the Right Hand position.
        // Rotate 90 degrees so sword points out
        ctx.rotate(Math.PI / 2); 

        // Hilt (Extended for two hands)
        // Goes "down" (backwards) to reach the Left hand
        ctx.fillStyle = "#444";
        ctx.fillRect(-2, -4, 4, 16); // Longer handle
        ctx.fillStyle = "#888"; 
        ctx.fillRect(-4, 10, 8, 2); // Pommel (at the bottom/back)

        // --- SWOOSH TRAIL ---
        if (this.swingState === "CHOP") {
            ctx.save();
            ctx.beginPath();
            ctx.arc(-8, -6, 40, Math.PI, 0, false); 
            ctx.strokeStyle = "rgba(200, 150, 255, 0.5)";
            ctx.lineWidth = 12;
            ctx.lineCap = "round";
            ctx.shadowColor = "#d000ff";
            ctx.shadowBlur = 15;
            ctx.stroke();
            ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
            ctx.lineWidth = 4;
            ctx.stroke();
            ctx.restore();
        }

        // Blade
        ctx.shadowColor = "#d000ff"; ctx.shadowBlur = 15;
        let bladeGrad = ctx.createLinearGradient(0, -6, 0, -45);
        bladeGrad.addColorStop(0, "#ffffff"); bladeGrad.addColorStop(0.3, "#e0c0ff"); bladeGrad.addColorStop(1, "#8800ff");
        ctx.fillStyle = bladeGrad;
        ctx.beginPath();
        ctx.moveTo(-2, -6); ctx.lineTo(-2, -42); ctx.lineTo(0, -46); ctx.lineTo(2, -42); ctx.lineTo(2, -6);
        ctx.fill();
        ctx.shadowBlur = 0; 

        ctx.restore(); // End Arm/Sword Group
        ctx.restore(); // End Body
        
        // --- GROUND IMPACT FLASH ---
        if (this.impactAlpha > 0.01) {
            ctx.globalAlpha = this.impactAlpha;
            ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
            ctx.translate(30, 0); 
            ctx.beginPath();
            for(let i=0; i<8; i++) {
                let ang = (i/8)*Math.PI*2;
                let r = (i%2==0) ? 25 : 10;
                ctx.lineTo(Math.cos(ang)*r, Math.sin(ang)*r);
            }
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }

        ctx.restore(); // End Global

        // HP BAR
        if (this.hp < this.maxHp) {
            const barW = 24; const barH = 4;
            const barX = this.x - (barW / 2); const barY = this.y - 28;
            const pct = Math.max(0, this.hp / this.maxHp);
            const hue = (pct * pct) * 120; 
            ctx.fillStyle = "#000"; ctx.fillRect(barX, barY, barW, barH);
            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`; ctx.fillRect(barX, barY, barW * pct, barH);
            ctx.strokeStyle = "#fff"; ctx.lineWidth = 1; ctx.strokeRect(barX, barY, barW, barH);
        }
    }
}

class ShieldSoldier {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.radius = 15; 
        this.type = "SHIELD_ALLY";
        
        // --- STATS ---
        this.hp = 600;      
        this.maxHp = 600;
        this.range = 45;     
        this.damage = 15;   
        this.lifeTimer = 1800; 

        // --- MOVEMENT ---
        this.speed = 1.6;    
        this.vx = 0; this.vy = 0;
        this.friction = 0.12;
        this.angle = 0;

        // --- COMBAT / ANIMATION ---
        this.cooldown = 0;
        this.maxCooldown = 50; 
        this.pushState = "IDLE"; 
        this.pushProgress = 0;
        this.shieldOffset = 18; 

        // --- AI VARS ---
        this.pathTimer = Math.random() * 30; 
        this.pathRefreshRate = 30; 
        this.currentPath = [];
        this.nodeReachThreshold = 15; 
        
        // --- VISUAL PALETTE ---
        this.walkCycle = 0;
        this.colors = {
            armorDark:  "#1c2630", 
            armorLight: "#2e3d4d", 
            vest:       "#111820", 
            skin:       "#eebb99",
            energyCore: "rgba(0, 220, 255, 0.4)",
            energyEdge: "#00ffff",
            emitter:    "#111"
        };
    }

    update(dt) {
        this.lifeTimer--;
        if (this.lifeTimer <= 0) this.hp = 0;

        // --- TARGETING ---
        let nearest = null;
        let minDist = Infinity;
        if (typeof enemies !== 'undefined') {
            for (let e of enemies) {
                let d = (e.x - this.x)**2 + (e.y - this.y)**2;
                if (d < minDist) { minDist = d; nearest = e; }
            }
        }
        
        let moving = false;

        if (nearest) {
            let distToEnemy = Math.sqrt(minDist);
            let canSeeEnemy = typeof hasLineOfSight === 'function' ? hasLineOfSight(this.x, this.y, nearest.x, nearest.y) : true;

            // 1. COMBAT: Stop and Bash if closest enemy is in range
            if (distToEnemy < this.range && canSeeEnemy) {
                this.vx *= 0.5; this.vy *= 0.5;
                this.angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);

                if (this.cooldown <= 0 && this.pushState === "IDLE") {
                    this.pushState = "WINDUP";
                    this.pushProgress = 0;
                    this.cooldown = this.maxCooldown;
                }
            } 
            // 2. MOVEMENT (Pathfinding)
            else {
                let targetX = nearest.x;
                let targetY = nearest.y;
                let usingPath = false;

                if (!canSeeEnemy && typeof findPath === 'function') {
                    this.pathTimer--;
                    if (this.pathTimer <= 0) {
                        this.currentPath = findPath(this, nearest);
                        this.pathTimer = this.pathRefreshRate;
                    }
                    if (this.currentPath && this.currentPath.length > 0) {
                        let nextNode = this.currentPath[0];
                        targetX = nextNode.x;
                        targetY = nextNode.y;
                        usingPath = true;
                        if (Math.hypot(nextNode.x - this.x, nextNode.y - this.y) < this.nodeReachThreshold) {
                            this.currentPath.shift(); 
                        }
                    }
                }
                
                if (!usingPath && canSeeEnemy) this.currentPath = []; 

                let dx = targetX - this.x;
                let dy = targetY - this.y;
                let dist = Math.hypot(dx, dy);

                if (dist > 5) {
                    let dirX = dx / dist;
                    let dirY = dy / dist;
                    this.vx += (dirX * this.speed - this.vx) * this.friction;
                    this.vy += (dirY * this.speed - this.vy) * this.friction;
                    moving = true;
                    if (Math.hypot(this.vx, this.vy) > 0.1) this.angle = Math.atan2(this.vy, this.vx);
                }
            }
        } else {
            this.vx *= 0.8; this.vy *= 0.8;
        }

        if (this.cooldown > 0) this.cooldown--;
        if (moving) this.walkCycle += 0.3; else this.walkCycle = 0;
        
        this.updateAnimation(); 
        
        this.x += this.vx;
        this.y += this.vy;
        
        if(typeof separate === 'function') { separate(this, allies || [], 0.6); separate(this, enemies || [], 0.4); }
        if(typeof resolveWallCollision === 'function') resolveWallCollision(this);
    }

    updateAnimation() {
        if (this.pushState !== "IDLE") {
            this.pushProgress++;
            
            // --- WINDUP ---
            if (this.pushState === "WINDUP") {
                this.shieldOffset = 18 - (this.pushProgress / 10) * 10; 
                if (this.pushProgress >= 10) { this.pushState = "SLAM"; this.pushProgress = 0; }
            } 
            // --- SLAM (DAMAGE FRAME) ---
            else if (this.pushState === "SLAM") {
                this.shieldOffset = 8 + (this.pushProgress / 5) * 22; 
                
                // ** AOE DAMAGE LOGIC **
                if (this.pushProgress === 2) {
                    if (typeof enemies !== 'undefined') {
                        for (let e of enemies) {
                            // 1. Distance Check
                            let dx = e.x - this.x;
                            let dy = e.y - this.y;
                            let dist = Math.hypot(dx, dy);
                            
                            // Hit everything slightly further than normal range (Reach bonus)
                            if (dist < this.range + 35) {
                                
                                // 2. Angle Check (Are they in front?)
                                let angleToEnemy = Math.atan2(dy, dx);
                                let angleDiff = angleToEnemy - this.angle;
                                
                                // Normalize angle to -PI to PI to prevent wrapping errors
                                while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2;
                                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;

                                // If within ~60 degrees left/right (1.0 radians), HIT
                                if (Math.abs(angleDiff) < 1.0) {
                                    e.hp -= this.damage;
                                    // Knockback is applied based on Shield Facing, not relative angle
                                    // This pushes everyone uniformly away
                                    e.vx += Math.cos(this.angle) * 15;
                                    e.vy += Math.sin(this.angle) * 15;
                                }
                            }
                        }
                    }
                }
                
                if (this.pushProgress >= 8) { this.pushState = "RECOVER"; this.pushProgress = 0; }
            } 
            // --- RECOVER ---
            else if (this.pushState === "RECOVER") {
                this.shieldOffset = 30 - (this.pushProgress / 15) * 12;
                if (this.pushProgress >= 15) { this.pushState = "IDLE"; this.shieldOffset = 18; }
            }
        } else {
            this.shieldOffset = 18 + Math.sin(Date.now() / 300) * 0.5; 
        }
    }


    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // Legs
        let legL = Math.sin(this.walkCycle) * 5;
        let legR = Math.sin(this.walkCycle + Math.PI) * 5;
        ctx.fillStyle = "#111"; 
        ctx.beginPath(); ctx.roundRect(-6 + legL, -9, 6, 4, 2); ctx.fill();
        ctx.beginPath(); ctx.roundRect(-6 + legR, 5, 6, 4, 2); ctx.fill();
        ctx.fillStyle = this.colors.armorLight;
        ctx.beginPath(); ctx.arc(-4 + legL, -7, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(-4 + legR, 7, 2.5, 0, Math.PI*2); ctx.fill();

        // Body
        ctx.fillStyle = this.colors.armorDark;
        ctx.beginPath(); ctx.roundRect(-9, -11, 16, 22, 5); ctx.fill();
        ctx.fillStyle = this.colors.vest;
        ctx.fillRect(-5, -8, 9, 16);
        ctx.strokeStyle = "#333"; ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-4, -4); ctx.lineTo(3, -4);
        ctx.moveTo(-4, 0); ctx.lineTo(3, 0);
        ctx.moveTo(-4, 4); ctx.lineTo(3, 4);
        ctx.stroke();

        // Helmet
        ctx.fillStyle = this.colors.skin;
        ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI*2); ctx.fill();
        let helmGrad = ctx.createRadialGradient(-2, -2, 1, 0, 0, 8);
        helmGrad.addColorStop(0, this.colors.armorLight);
        helmGrad.addColorStop(1, this.colors.armorDark);
        ctx.fillStyle = helmGrad;
        ctx.beginPath(); ctx.arc(0, 0, 7.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#222"; 
        ctx.fillRect(-2, -8.5, 5, 2); ctx.fillRect(-2, 6.5, 5, 2);  
        ctx.fillStyle = "#111"; 
        ctx.beginPath(); ctx.roundRect(3, -5, 3, 10, 2); ctx.fill();
        ctx.fillStyle = "#0ff"; 
        ctx.globalAlpha = 0.6; ctx.fillRect(4, -3, 1, 3); ctx.globalAlpha = 1.0;

        // --- ARMS (Always Centered) ---
        let handleX = this.shieldOffset - 3;
        let handleY = 0; 

        // Right Arm
        ctx.save();
        ctx.translate(3, 10); 
        let rAngle = Math.atan2(handleY - 10, handleX - 3);
        let rDist = Math.hypot(handleX - 3, handleY - 10);
        ctx.rotate(rAngle);
        ctx.fillStyle = this.colors.vest;
        ctx.beginPath(); ctx.roundRect(0, -2, rDist/2, 4, 2); ctx.fill();
        ctx.fillStyle = this.colors.armorLight;
        ctx.beginPath(); ctx.roundRect(rDist/2, -2.5, rDist/2, 5, 2); ctx.fill();
        ctx.fillStyle = "#111";
        ctx.beginPath(); ctx.arc(rDist, 0, 3, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = this.colors.armorDark;
        ctx.beginPath(); ctx.arc(0, 0, 5.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = this.colors.armorLight;
        ctx.beginPath(); ctx.arc(0, 0, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.restore();

        // Left Arm
        ctx.save();
        ctx.translate(3, -10); 
        let lAngle = Math.atan2(handleY - (-10), handleX - 3);
        let lDist = Math.hypot(handleX - 3, handleY - (-10));
        ctx.rotate(lAngle);
        ctx.fillStyle = this.colors.vest;
        ctx.beginPath(); ctx.roundRect(0, -2, lDist/2, 4, 2); ctx.fill();
        ctx.fillStyle = this.colors.armorLight;
        ctx.beginPath(); ctx.roundRect(lDist/2, -2.5, lDist/2, 5, 2); ctx.fill();
        ctx.fillStyle = "#111";
        ctx.beginPath(); ctx.arc(lDist, 0, 3.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = this.colors.armorDark;
        ctx.beginPath(); ctx.arc(0, 0, 5.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = this.colors.armorLight;
        ctx.beginPath(); ctx.arc(0, 0, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.restore();

        // --- SHIELD ---
        ctx.save();
        ctx.translate(this.shieldOffset, 0);
        ctx.fillStyle = this.colors.emitter;
        ctx.fillRect(0, -22, 4, 44); 
        ctx.fillStyle = this.colors.energyEdge;
        ctx.fillRect(1, -21, 2, 2); 
        ctx.fillRect(1, 19, 2, 2); 
        ctx.fillStyle = "#222";
        ctx.fillRect(-4, -6, 4, 12); 

        let glowIntensity = (this.pushState === "SLAM") ? 20 : 8;
        let energyAlpha = (this.pushState === "SLAM") ? 0.7 : 0.35;

        ctx.shadowColor = this.colors.energyEdge;
        ctx.shadowBlur = glowIntensity;
        let eGrad = ctx.createLinearGradient(0, -25, 0, 25);
        eGrad.addColorStop(0, `rgba(0, 200, 255, ${energyAlpha/2})`);
        eGrad.addColorStop(0.5, `rgba(200, 255, 255, ${energyAlpha})`); 
        eGrad.addColorStop(1, `rgba(0, 200, 255, ${energyAlpha/2})`);
        ctx.fillStyle = eGrad;
        ctx.strokeStyle = this.colors.energyEdge;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(4, -22);
        ctx.quadraticCurveTo(8, 0, 4, 22); 
        ctx.lineTo(2, 22);
        ctx.quadraticCurveTo(6, 0, 2, -22); 
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.shadowBlur = 0; 
        ctx.strokeStyle = "rgba(100, 255, 255, 0.3)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i = -16; i < 16; i+=8) {
             ctx.moveTo(3, i); ctx.lineTo(7, i+4);
             ctx.moveTo(3, i); ctx.lineTo(7, i-4);
        }
        ctx.stroke();
        ctx.restore(); 

        ctx.restore(); 

        if (typeof drawHealth === 'function') drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class BardTroop {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 12;
        this.color = "#d633ff"; 
        this.hp = 100;
        this.maxHp = 100;

        // --- STATS ---
        this.lifeTimer = 600; 
        this.tauntRange = 160; 
        this.fleeThreshold = 120; 

        // --- PATHFINDING & PHYSICS ---
        this.speed = 1;         
        this.vx = 0; 
        this.vy = 0;
        this.friction = 0.12;  
        
        this.pathTimer = Math.random() * 30; 
        this.pathRefreshRate = 30; 
        this.currentPath = [];
        this.nodeReachThreshold = 15;

        // --- ANIMATION ---
        this.angle = 0;      
        this.walkCycle = 0;  
        this.targetAngle = 0;
    }

    update(dt) {
        if (typeof dt === 'undefined') dt = 1;

        this.lifeTimer--;
        if (this.lifeTimer <= 0) this.hp = 0;

        // 1. SCAN ENVIRONMENT
        let nearest = null;
        let minDist = Infinity;
        let fleeCount = 0;

        for (let e of enemies) {
            let d = (e.x - this.x)**2 + (e.y - this.y)**2;
            let dist = Math.sqrt(d);

            // A. SEEKING: Track nearest enemy (even through walls)
            if (d < minDist) { minDist = d; nearest = e; }

            // B. INTERACTION: Check Line of Sight for Taunt/Flee
            let canSee = true;
            if (typeof hasLineOfSight === 'function') {
                canSee = hasLineOfSight(this.x, this.y, e.x, e.y);
            }

            if (canSee) {
                if (dist < this.tauntRange) e.tauntTarget = this;
                if (dist < this.fleeThreshold) fleeCount++;
            }
        }

        // 2. DETERMINE TARGET DESTINATION
        let targetX = this.x;
        let targetY = this.y;
        let moving = false;
        let mode = 'IDLE';

        if (fleeCount > 0) {
            // --- MODE: FLEE (RUN TO RIGHT SIDE) ---
            mode = 'FLEE';
            
            // Target the far right edge of the map
            // We assume COLS global exists, otherwise fallback to a large number
            const rightEdge = (typeof COLS !== 'undefined') ? (COLS * CELL_SIZE) - 25 : 2000;
            
            targetX = rightEdge;
            targetY = this.y; // Maintain current height, run straight right
            
        } else if (nearest) {
            // --- MODE: SEEK ---
            mode = 'SEEK';
            targetX = nearest.x;
            targetY = nearest.y;
        }

        // 3. APPLY PATHFINDING
        if (mode !== 'IDLE') {
            let usingPath = false;
            
            // Check Line of Sight to TARGET DESTINATION
            let canSeeTarget = true;
            if (typeof hasLineOfSight === 'function') {
                 canSeeTarget = hasLineOfSight(this.x, this.y, targetX, targetY);
            }

            // If target blocked (by wall), use Pathfinding
            if (!canSeeTarget && typeof findPath === 'function') {
                this.pathTimer--;

                if (this.pathTimer <= 0) {
                    this.currentPath = findPath(this, {x: targetX, y: targetY});
                    this.pathTimer = this.pathRefreshRate;
                }

                if (this.currentPath && this.currentPath.length > 0) {
                    let nextNode = this.currentPath[0];
                    targetX = nextNode.x;
                    targetY = nextNode.y;
                    usingPath = true;

                    let dNode = Math.hypot(nextNode.x - this.x, nextNode.y - this.y);
                    if (dNode < this.nodeReachThreshold) {
                        this.currentPath.shift();
                    }
                }
            }

            if (!usingPath && canSeeTarget) {
                this.currentPath = [];
            }

            // 4. PHYSICS MOVEMENT
            let dx = targetX - this.x;
            let dy = targetY - this.y;
            let dist = Math.hypot(dx, dy);

            if (dist > 5) {
                let dirX = dx / dist;
                let dirY = dy / dist;
                
                // Flee slightly faster
                let currentSpeed = (mode === 'FLEE') ? this.speed * 1.2 : this.speed;

                this.vx += (dirX * currentSpeed - this.vx) * this.friction;
                this.vy += (dirY * currentSpeed - this.vy) * this.friction;
                moving = true;

                if (Math.hypot(this.vx, this.vy) > 0.1) {
                    let desiredAngle = Math.atan2(this.vy, this.vx);
                    let diff = desiredAngle - this.angle;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    this.angle += diff * 0.15;
                }
            }
        }

        if (!moving) {
            this.vx *= 0.8;
            this.vy *= 0.8;
        }

        if (moving) this.walkCycle += 0.25;
        else this.walkCycle = 0;

        this.x += this.vx * dt;
        this.y += this.vy * dt;

        if(typeof separate === 'function') { separate(this, allies, 0.5); } 
        if(typeof resolveWallCollision === 'function') resolveWallCollision(this);
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // Animation Variables
        const bounce = Math.abs(Math.sin(this.walkCycle)) * 2;
        const sway = Math.sin(this.walkCycle) * 0.15; 
        const featherLag = Math.sin(this.walkCycle - 1.5) * 0.4; 

        // --- 1. SOFT SHADOW ---
        let shadowGrad = ctx.createRadialGradient(0, 4, 2, 0, 4, 10);
        shadowGrad.addColorStop(0, "rgba(0,0,0,0.5)");
        shadowGrad.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = shadowGrad;
        ctx.beginPath();
        ctx.scale(1, 0.6);
        ctx.arc(0, 7, 10 - (bounce * 0.5), 0, Math.PI*2);
        ctx.fill();
        ctx.scale(1, 1 / 0.6); 

        // --- 2. LEGS & BOOTS ---
        let lPhase = Math.sin(this.walkCycle);
        let rPhase = Math.sin(this.walkCycle + Math.PI);
        
        ctx.fillStyle = "#2d1b0e"; 
        
        const drawBoot = (x, y, phase) => {
            ctx.save();
            ctx.translate(x, y + (phase * 3)); 
            ctx.rotate(phase * 0.2); 
            ctx.beginPath();
            ctx.ellipse(0, 0, 3.5, 2.5, 0, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = "#4e342e";
            ctx.beginPath();
            ctx.ellipse(1, -1, 1.5, 1, 0, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        };

        drawBoot(-4, 0, lPhase);
        drawBoot(4, 0, rPhase);

        // --- APPLY BODY BOUNCE & SWAY ---
        ctx.translate(0, -bounce);
        ctx.rotate(sway);

        // --- 3. BODY ---
        let bodyGrad = ctx.createLinearGradient(-6, -6, 6, 6);
        bodyGrad.addColorStop(0, "#e056fd"); 
        bodyGrad.addColorStop(1, "#8e24aa"); 
        
        ctx.fillStyle = bodyGrad;
        ctx.beginPath();
        ctx.roundRect(-6, -6, 12, 12, 4);
        ctx.fill();
        
        ctx.strokeStyle = "#FFD700";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-6, 6); ctx.lineTo(6, 6); 
        ctx.stroke();

        ctx.fillStyle = "#3e2723";
        ctx.fillRect(-6.5, 0, 13, 2.5);
        ctx.fillStyle = "#ffb300";
        ctx.fillRect(-2, -0.5, 4, 3.5);
        ctx.fillStyle = "#000"; 
        ctx.fillRect(-1, 0.5, 2, 1.5);

        // --- 4. THE LUTE ---
        ctx.save();
        ctx.translate(5, 2); 
        ctx.rotate(0.3); 

        let luteGrad = ctx.createRadialGradient(-2, -2, 1, 0, 0, 8);
        luteGrad.addColorStop(0, "#D2691E"); 
        luteGrad.addColorStop(1, "#5D4037"); 
        ctx.fillStyle = luteGrad;
        
        ctx.beginPath();
        ctx.ellipse(0, 0, 7.5, 6, 0, 0, Math.PI*2); 
        ctx.fill();

        ctx.fillStyle = "#DEB887";
        ctx.beginPath(); ctx.ellipse(0, -0.5, 6.5, 5, 0, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = "#3e2723";
        ctx.beginPath(); ctx.arc(0, -1, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#8d6e63"; ctx.lineWidth = 0.5;
        ctx.beginPath(); ctx.moveTo(-2.5, -1); ctx.lineTo(2.5, -1); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, -3.5); ctx.lineTo(0, 1.5); ctx.stroke();

        ctx.fillStyle = "#3e2723";
        ctx.fillRect(-3, 3, 6, 1.5);

        ctx.save();
        ctx.rotate(-0.1); 
        
        ctx.fillStyle = "#1a1a1a"; 
        ctx.fillRect(-16, -2, 12, 3.5);
        
        ctx.strokeStyle = "#888";
        ctx.lineWidth = 0.5;
        for(let i=0; i<4; i++) {
            let fx = -6 - (i*2.5);
            ctx.beginPath(); ctx.moveTo(fx, -2); ctx.lineTo(fx, 1.5); ctx.stroke();
        }

        ctx.translate(-16, -0.5); 
        ctx.rotate(-1.2); 
        ctx.fillStyle = "#5D4037";
        ctx.fillRect(0, -2, 6, 4); 
        
        ctx.fillStyle = "#fff";
        ctx.beginPath(); ctx.arc(2, -2, 1, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(4, -2, 1, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(2, 2, 1, 0, Math.PI*2); ctx.fill();
        ctx.restore(); 

        ctx.strokeStyle = "rgba(255,255,255,0.7)";
        ctx.lineWidth = 0.4;
        ctx.beginPath();
        ctx.moveTo(-16, -1); ctx.lineTo(0, -1);
        ctx.moveTo(-16, 0); ctx.lineTo(0, 0);
        ctx.moveTo(-16, 1); ctx.lineTo(0, 1);
        ctx.stroke();

        // --- RIGHT HAND ---
        let strumSpeed = Math.sin(Date.now() / 60) * 2; 
        
        ctx.save();
        ctx.translate(1, 1); 
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(-2, -2, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.rotate(0.5 + (strumSpeed * 0.2)); 
        ctx.fillStyle = "#ffcc80"; 
        ctx.beginPath();
        ctx.ellipse(0, 0, 2.5, 2, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = "#e6b975"; 
        ctx.beginPath();
        ctx.ellipse(1, -1, 1.5, 0.8, 0.5, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.moveTo(1, 0); ctx.lineTo(4, 1); ctx.lineTo(2, 2); ctx.fill();
        ctx.restore(); 

        // --- LEFT HAND ---
        ctx.save();
        ctx.translate(-10, -1); 
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(2, 4, 3, 0, Math.PI*2); ctx.fill(); 
        ctx.fillStyle = "#dcbfa6"; 
        ctx.beginPath(); ctx.arc(0, 0, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#ffcc80"; 
        ctx.beginPath(); ctx.roundRect(-1, -2.5, 1.5, 3, 1); ctx.fill();
        ctx.beginPath(); ctx.roundRect(0.5, -2.2, 1.5, 3, 1); ctx.fill();
        ctx.beginPath(); ctx.roundRect(2, -1.8, 1.5, 2.5, 1); ctx.fill();
        ctx.restore(); 
        ctx.restore(); 


        // --- 5. HEAD & HAT ---
        ctx.save();
        ctx.translate(0, -5); 
        ctx.rotate(sway * 0.5); 
        
        let faceGrad = ctx.createRadialGradient(-1, -2, 1, 0, 0, 6);
        faceGrad.addColorStop(0, "#ffcc80"); 
        faceGrad.addColorStop(1, "#e6b975"); 
        ctx.fillStyle = faceGrad;
        ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI*2); ctx.fill();
        
        ctx.fillStyle = "#3e2723";
        ctx.beginPath(); ctx.arc(-1.5, 1, 5.5, 0, Math.PI*2); ctx.fill();
        
        ctx.fillStyle = "#2e7d32";
        ctx.beginPath();
        ctx.moveTo(-6, -2); ctx.quadraticCurveTo(0, -7, 6, -2); ctx.lineTo(7, 0); ctx.quadraticCurveTo(0, -2, -7, 0); ctx.fill();
        
        ctx.save();
        ctx.translate(-3, -3); 
        ctx.rotate(featherLag); 
        ctx.fillStyle = "#d32f2f"; 
        ctx.beginPath();
        ctx.moveTo(0, 0); ctx.quadraticCurveTo(-4, -6, -8, -2); ctx.quadraticCurveTo(-4, -2, 0, 0); ctx.fill();
        ctx.strokeStyle = "#b71c1c";
        ctx.lineWidth = 0.5;
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-6, -3); ctx.stroke();
        ctx.restore();
        ctx.restore(); 

        ctx.restore(); 

        // --- 6. HP BAR ---
        if (typeof drawHealth === 'function') {
            drawHealth(this.x, this.y, this.hp, this.maxHp);
        }
    }
}

class Soldier {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.radius = 9; 
        this.range = 250;
        this.damage = 15;

        // MOVEMENT
        this.speed = 1.8;
        this.vx = 0; this.vy = 0;
        this.friction = 0.12;
        this.angle = 0; 
        
        // ATTACK
        this.cooldown = 0;
        this.maxCooldown = 90;
        this.hp = 50; this.maxHp = 50;
        this.lifeTimer = 1200;

        // --- IMPROVED AI VARS ---
        this.pathTimer = Math.random() * 30; // Randomize start to spread CPU load
        this.pathRefreshRate = 30; // Re-calculate path every 30 frames (0.5s)
        this.currentPath = [];
        this.nodeReachThreshold = 15; // How close to a node before moving to the next
        
        // VISUALS
        this.walkCycle = 0; 
        this.hairColor = Math.random() > 0.5 ? "#4a3b2a" : (Math.random() > 0.5 ? "#2a2a2a" : "#e6bc2d");
        this.skinColor = "#ffdbac"; 
    }

    update(dt) {
        this.lifeTimer--;

        // --- TARGETING ---
        let nearest = null;
        let minDist = Infinity;
        for (let e of enemies) {
            let d = (e.x - this.x)**2 + (e.y - this.y)**2;
            if (d < minDist) { minDist = d; nearest = e; }
        }

        let moving = false;

        if (nearest) {
            let distToEnemy = Math.sqrt(minDist);
            // Check Line of Sight (LOS)
            let canSeeEnemy = typeof hasLineOfSight === 'function' ? hasLineOfSight(this.x, this.y, nearest.x, nearest.y) : true;

            // 1. COMBAT STATE: If inside range and we can see them, stop and shoot.
            if (distToEnemy < this.range && canSeeEnemy) {
                // Slow down quickly when shooting
                this.vx *= 0.5; this.vy *= 0.5;
                this.angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);

                if (this.cooldown <= 0) {
                    let gunOffsetX = Math.cos(this.angle) * 20 - Math.sin(this.angle) * 6;
                    let gunOffsetY = Math.sin(this.angle) * 20 + Math.cos(this.angle) * 6;
                    
                    if(typeof Bullet !== 'undefined') {
                        projectiles.push(new Bullet(this.x + gunOffsetX, this.y + gunOffsetY, nearest, this.damage));
                    }
                    this.cooldown = this.maxCooldown;
                }
            }
            
            // 2. MOVEMENT STATE
            else {
                let targetX = nearest.x;
                let targetY = nearest.y;
                let usingPath = false;

                // If blocked, use Pathfinding
                if (!canSeeEnemy && typeof findPath === 'function') {
                    this.pathTimer--;

                    // A. Calculate Path (Periodically)
                    if (this.pathTimer <= 0) {
                        // Assuming findPath returns array of objects {x, y} in WORLD coordinates
                        this.currentPath = findPath(this, nearest);
                        this.pathTimer = this.pathRefreshRate;
                    }

                    // B. Follow Path (Waypoint Consumption)
                    if (this.currentPath && this.currentPath.length > 0) {
                        let nextNode = this.currentPath[0];
                        targetX = nextNode.x;
                        targetY = nextNode.y;
                        usingPath = true;

                        // Check distance to the current waypoint
                        let dNode = Math.hypot(nextNode.x - this.x, nextNode.y - this.y);
                        
                        // If we are close enough to the node, remove it and target the next one immediately
                        if (dNode < this.nodeReachThreshold) {
                            this.currentPath.shift(); // Remove first element
                        }
                    }
                }
                
                // If we see the enemy, or pathfinding failed, or path is empty, we go Direct
                if (!usingPath && canSeeEnemy) {
                    this.currentPath = []; // Clear path if we can see target directly
                }

                // C. Apply Physics
                let dx = targetX - this.x;
                let dy = targetY - this.y;
                let dist = Math.hypot(dx, dy);

                if (dist > 5) {
                    let dirX = dx / dist;
                    let dirY = dy / dist;
                    this.vx += (dirX * this.speed - this.vx) * this.friction;
                    this.vy += (dirY * this.speed - this.vy) * this.friction;
                    moving = true;
                    
                    // Only rotate if moving significantly
                    if (Math.hypot(this.vx, this.vy) > 0.1) {
                         this.angle = Math.atan2(this.vy, this.vx);
                    }
                }
            }
        }

        if (!moving) { this.vx *= 0.8; this.vy *= 0.8; }
        if (this.cooldown > 0) this.cooldown--;
        
        // Animate Legs
        if (moving) this.walkCycle += 0.25;
        else this.walkCycle = 0;

        this.x += this.vx *dt;
        this.y += this.vy *dt;

        // Collision
        if(typeof separate === 'function') { separate(this, allies, 0.5); separate(this, enemies, 0.5); }
        if(typeof resolveWallCollision === 'function') resolveWallCollision(this);
    }

    // ... DRAW METHOD REMAINS EXACTLY THE SAME AS YOUR INPUT ...
    draw() {
        // (Paste your existing draw code here)
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // --- 0. RECOIL PHYSICS MATH (Kept your logic) ---
        let timeSinceFire = this.maxCooldown - this.cooldown;
        let kick = 0; 
        let lift = 0; 

        // Frame 0-3: SNAP BACK
        if (timeSinceFire >= 0 && timeSinceFire < 4) {
            kick = 8;       
            lift = -0.25;   
        } 
        // Frame 4-8: RECOVERY
        else if (timeSinceFire >= 4 && timeSinceFire < 10) {
            kick = 4;       
            lift = -0.1;    
        }

        // --- 1. SHADOW (Slightly more dynamic) ---
        ctx.fillStyle = "rgba(0,0,0,0.4)";
        ctx.beginPath();
        // Shadow moves slightly opposite to lift to ground the unit
        ctx.ellipse(0 - kick/2, 2, 9, 7, 0, 0, Math.PI*2);
        ctx.fill();

        // --- 2. LEGS (Standardized colors) ---
        let leftLeg = Math.sin(this.walkCycle) * 4;
        let rightLeg = Math.sin(this.walkCycle + Math.PI) * 4;
        
        // Pants
        ctx.fillStyle = "#2e3b2a"; 
        ctx.beginPath(); ctx.arc(-4 + leftLeg, -5, 4, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(-4 + rightLeg, 5, 4, 0, Math.PI*2); ctx.fill();
        // Boots with treads
        ctx.fillStyle = "#0a0a0a";
        ctx.beginPath(); ctx.arc(-3 + leftLeg, -5, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(-3 + rightLeg, 5, 2.5, 0, Math.PI*2); ctx.fill();

        // --- 3. ARMS (Adjusted for new Gun Bulk) ---
        // Create a slight gradient for skin to look rounder
        let skinGrad = ctx.createRadialGradient(0,0,0, 0,0, 4);
        skinGrad.addColorStop(0, this.skinColor);
        skinGrad.addColorStop(1, "#dcb"); // Highlight

        ctx.fillStyle = this.skinColor;
        
        // Left Arm (Support Hand - holding the handguard)
        ctx.save();
        ctx.translate(5 - kick, -4); // Moved forward to grab the new handguard
        ctx.rotate(0.4 + lift); 
        ctx.fillRect(0, -2.5, 14, 5); 
        ctx.beginPath(); ctx.arc(14, 0, 3.5, 0, Math.PI*2); ctx.fill(); // Hand
        ctx.restore();

        // Right Arm (Trigger Hand)
        ctx.save();
        ctx.translate(-2 - kick, 6); 
        ctx.rotate(-0.3 + lift); 
        ctx.fillRect(0, -2.5, 10, 5); 
        ctx.beginPath(); ctx.arc(10, 0, 3.5, 0, Math.PI*2); ctx.fill(); // Hand
        ctx.restore();

        // --- 4. THE HIGH-DETAIL RIFLE ---
        ctx.save();
        ctx.translate(6 - kick, 4); 
        ctx.rotate(lift); 
        
        // -- A. DEFINE GRADIENTS --
        // Gun Metal (Dark Grey to Light Grey to Dark)
        let metalGrad = ctx.createLinearGradient(0, -5, 0, 5);
        metalGrad.addColorStop(0, "#1a1a1a");
        metalGrad.addColorStop(0.4, "#555"); // Highlight on top ridge
        metalGrad.addColorStop(1, "#111");

        // Polymer/Plastic (Matte Black)
        let polyGrad = ctx.createLinearGradient(0, -5, 0, 5);
        polyGrad.addColorStop(0, "#222");
        polyGrad.addColorStop(1, "#000");

        // -- B. STOCK (Tactical Skeletal Stock) --
        ctx.fillStyle = polyGrad;
        ctx.beginPath();
        ctx.moveTo(-10, -3);
        ctx.lineTo(-4, -3); // Connect to body
        ctx.lineTo(-4, 3);
        ctx.lineTo(-10, 5); // Angled bottom
        ctx.lineTo(-12, 4); // Buttpad bottom
        ctx.lineTo(-12, -2); // Buttpad top
        ctx.fill();
        // Stock Cheek Rest
        ctx.fillStyle = "#333";
        ctx.fillRect(-11, -3, 6, 2);

        // -- C. MAGAZINE (Curved Banana Clip) --
        ctx.save();
        ctx.translate(2, 2);
        ctx.rotate(0.3); // Angle the mag forward
        ctx.fillStyle = "#151515";
        // Draw Curved Mag shape
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(5,0);
        ctx.lineTo(4, 8); // Taper in
        ctx.quadraticCurveTo(2.5, 9, 1, 8); // Curved bottom
        ctx.lineTo(0,0);
        ctx.fill();
        // Mag Ribs (Texture)
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(1, 2); ctx.lineTo(4, 2);
        ctx.moveTo(1.5, 4); ctx.lineTo(3.5, 4);
        ctx.moveTo(2, 6); ctx.lineTo(3, 6);
        ctx.stroke();
        ctx.restore();

        // -- D. MAIN BODY (Receiver) --
        ctx.fillStyle = metalGrad;
        ctx.beginPath();
        // Receiver shape with mag well dip
        ctx.moveTo(-4, -4);
        ctx.lineTo(8, -4);
        ctx.lineTo(8, 2); // Mag well front
        ctx.lineTo(2, 2); // Mag well back
        ctx.lineTo(-2, 4); // Grip area
        ctx.lineTo(-4, 4);
        ctx.fill();

        // Ejection Port (Grey detail on side)
        ctx.fillStyle = "#444";
        ctx.fillRect(0, -2, 4, 2);
        ctx.fillStyle = "#000"; // Bolt line
        ctx.fillRect(1, -1.5, 2, 1);

        // -- E. HANDGUARD & BARREL --
        // Handguard (Rails)
        ctx.fillStyle = "#2a2a2a";
        ctx.fillRect(8, -3, 10, 5);
        
        // Cooling Vents (Holes in handguard)
        ctx.fillStyle = "#000";
        for(let i=0; i<3; i++) {
            ctx.beginPath();
            ctx.arc(10 + (i*3), -0.5, 1, 0, Math.PI*2);
            ctx.fill();
        }

        // Exposed Barrel
        ctx.fillStyle = "#111";
        ctx.fillRect(18, -1.5, 4, 2);

        // Muzzle Brake (The tip)
        ctx.fillStyle = "#333";
        ctx.fillRect(22, -2, 3, 3); // Thicker tip

        // -- F. ATTACHMENTS --
        
        // Laser Sight Module (Side)
        ctx.fillStyle = "#111";
        ctx.fillRect(14, 2, 4, 2);
        // Laser Beam (Faint red line)
        ctx.strokeStyle = "rgba(255, 0, 0, 0.4)";
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(18, 3);
        ctx.lineTo(100, 3); // Shoots far out
        ctx.stroke();

        // Holographic Sight (Top)
        ctx.fillStyle = "#222";
        ctx.fillRect(0, -6, 6, 2); // Mount
        ctx.fillStyle = "#000";
        ctx.fillRect(0, -9, 1, 3); // Rear post
        ctx.fillRect(5, -9, 1, 3); // Front post
        ctx.fillStyle = "rgba(0, 255, 255, 0.3)"; // Blue Glass
        ctx.fillRect(1, -8, 4, 2);
        // Red Dot inside glass
        ctx.fillStyle = "red";
        ctx.beginPath(); ctx.arc(3, -7, 0.8, 0, Math.PI*2); ctx.fill();


        // -- G. MUZZLE FLASH (Enhanced) --
        if (timeSinceFire < 3) {
            // Inner Core (White)
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.moveTo(25, -0.5);
            ctx.lineTo(50, -3); 
            ctx.lineTo(50, 2);
            ctx.fill();

            // Star Burst (Orange)
            ctx.fillStyle = "rgba(255, 200, 50, 0.7)";
            ctx.beginPath();
            const flashX = 25;
            const flashY = -0.5;
            // Draw a spiky shape
            for (let i = 0; i < 8; i++) {
                let angle = (i / 8) * Math.PI * 2;
                let r = (i % 2 === 0) ? 15 : 8; // Spike length varies
                ctx.lineTo(flashX + Math.cos(angle) * r, flashY + Math.sin(angle) * r);
            }
            ctx.fill();
            
            // Smoke puff (Grey)
            ctx.fillStyle = "rgba(100, 100, 100, 0.3)";
            ctx.beginPath();
            ctx.arc(35, -5, 6, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.restore(); // End Rifle transform

        // --- 5. SHOULDERS & VEST (Tactical Armor) ---
        ctx.fillStyle = "#2f3a25"; // Vest Color
        ctx.beginPath(); ctx.ellipse(-2, -6, 5, 4, 0, 0, Math.PI*2); ctx.fill(); // L Shoulder
        ctx.beginPath(); ctx.ellipse(-2, 6, 5, 4, 0, 0, Math.PI*2); ctx.fill(); // R Shoulder
        
        // Vest Body
        ctx.fillRect(-6, -5, 10, 10);
        // Vest Plate Detail
        ctx.fillStyle = "#1e2b1a";
        ctx.fillRect(-4, -3, 6, 6);

        // --- 6. HEAD (With Helmet option or Hair) ---
        let headShake = (kick > 0) ? (Math.random() * 2 - 1) : 0;

        // Skin (Neck)
        ctx.fillStyle = this.skinColor;
        ctx.beginPath(); ctx.arc(-2 + headShake, 0, 3.5, 0, Math.PI*2); ctx.fill();

        // Helmet / Hair
        ctx.fillStyle = this.hairColor; // Or make this a helmet color like #222
        ctx.beginPath();
        ctx.arc(-1 + headShake, 0, 5.5, 0, Math.PI*2); 
        ctx.fill();
        
        // If NOT wearing a helmet, draw skin face area
        ctx.fillStyle = this.skinColor; 
        ctx.beginPath();
        // Slightly offset ellipse for top-down face look
        ctx.ellipse(2 + headShake, 0, 3, 4, 0, 0, Math.PI*2); 
        ctx.fill();

        ctx.restore(); // End Player transform

        // --- HP BAR (Cleaned up) ---
        if (this.hp < this.maxHp) {
            const barW = 24;
            const barH = 4;
            const yOffset = 28;

            const barX = this.x - (barW / 2);
            const barY = this.y - yOffset;

            const pct = Math.max(0, Math.min(1, this.hp / this.maxHp));
            const hue = (pct * pct) * 120;

            ctx.fillStyle = "#333333";
            ctx.fillRect(barX, barY, barW, barH);

            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
            ctx.fillRect(barX, barY, barW * pct, barH);

            ctx.strokeStyle = "#000000";
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barW, barH);
        }
    }
}

    // -- BUILDINGS --

    class Barracks {
    constructor(col, row) {
        this.col = col;
        this.row = row;
        this.timer = 0;
        this.spawnRate = 600; // Keeps 600 (approx 10 sec at 60fps baseline)
        
        // Animation Variables
        this.angleOuter = 0;
        this.angleInner = 0;
        this.pistonOffset = 0;
    }

    update(dt) {
        // 1. INCREMENT TIMER BY DT
        // Since dt is roughly 1.0, this counts up exactly like before,
        // but compensates for lag.
        this.timer += dt; 
        
        let progress = this.timer / this.spawnRate;

        // 2. DYNAMIC ROTATION
        // Multiply "speed" by dt so rotation is smooth regardless of framerate
        let speed = 0.02 + (progress * 0.15); 
        this.angleOuter += speed * dt;
        this.angleInner -= (speed * 1.5) * dt; 

        // 3. PISTON ANIMATION
        // We don't multiply by dt inside Math.sin because 'this.timer' 
        // has already been adjusted by dt above.
        this.pistonOffset = Math.sin(this.timer * 0.1) * 3;

        // 4. SPAWN LOGIC
        if (this.timer >= this.spawnRate) {
            this.timer = 0;
            
            let sx = this.col * CELL_SIZE + CELL_SIZE/2;
            let sy = this.row * CELL_SIZE + CELL_SIZE/2;
            
            // Check if allies array exists before pushing
            if (typeof allies !== 'undefined') {
                allies.push(new Soldier(sx, sy));
            }
            
            // SPAWN EFFECTS
            if (typeof createParticles !== 'undefined') {
                createParticles(sx, sy, "#00ffff", 12); 
                createParticles(sx, sy, "#ffffff", 6);
            }
        }
    }

    draw() {
        let x = this.col * CELL_SIZE;
        let y = this.row * CELL_SIZE;
        let cx = x + CELL_SIZE / 2;
        let cy = y + CELL_SIZE / 2;
        let size = CELL_SIZE - 4;

        ctx.save();
        ctx.translate(cx, cy);

        // --- TECH BASE ---
        ctx.fillStyle = "#1a1a2e"; 
        this.drawOctagon(ctx, 0, 0, size/2 + 2);
        
        ctx.strokeStyle = "#16213e";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-size/2, -size/2); ctx.lineTo(size/2, size/2);
        ctx.moveTo(size/2, -size/2); ctx.lineTo(-size/2, size/2);
        ctx.stroke();

        // --- PISTONS ---
        ctx.fillStyle = "#444";
        for (let i = 0; i < 4; i++) {
            ctx.save();
            ctx.rotate((Math.PI / 2) * i); 
            
            ctx.fillRect(-6, -size/2, 12, 10);
            
            let py = -size/2 + 8 + this.pistonOffset;
            ctx.fillStyle = "#888"; 
            ctx.fillRect(-3, py, 6, 8);
            
            ctx.strokeStyle = "#222";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, -size/2 + 5);
            ctx.lineTo(0, py);
            ctx.stroke();
            
            ctx.restore();
        }

        // --- REACTOR CORE ---
        let pct = Math.min(this.timer / this.spawnRate, 1);
        let glowSize = 5 + (pct * 10); 
        
        ctx.shadowBlur = 15 + (pct * 20); 
        ctx.shadowColor = "#00d2ff";
        ctx.fillStyle = `rgba(0, 210, 255, ${0.2 + pct * 0.8})`;
        
        ctx.beginPath();
        ctx.arc(0, 0, glowSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0; 

        // --- PLASMA RINGS ---
        // Outer
        ctx.save();
        ctx.rotate(this.angleOuter);
        ctx.strokeStyle = "#00d2ff"; 
        ctx.lineWidth = 2;
        ctx.setLineDash([10, 8]); 
        ctx.beginPath();
        ctx.arc(0, 0, size/2 - 6, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();

        // Inner
        ctx.save();
        ctx.rotate(this.angleInner);
        ctx.strokeStyle = "#ff00ff"; 
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]); 
        ctx.beginPath();
        ctx.arc(0, 0, size/2 - 12, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
        
        // --- HOLOGRAPHIC PROJECTION ---
        if (pct > 0.5) {
            ctx.save();
            if (Math.random() > 0.1) {
                ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
                ctx.fillRect(-2, -2, 4, 4);
                
                // Hologram Scan Line
                // Use timer directly (it's now a float, but modulo works on floats in JS)
                let scanY = -10 + (20 * ((this.timer % 40)/40));
                
                ctx.strokeStyle = "rgba(0, 255, 0, 0.8)";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(-8, scanY);
                ctx.lineTo(8, scanY);
                ctx.stroke();
            }
            ctx.restore();
        }

        ctx.restore();
    }

    drawOctagon(ctx, x, y, radius) {
        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            let angle = (Math.PI / 4) * i;
            ctx.lineTo(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius);
        }
        ctx.closePath();
        ctx.fill();
    }
}

   class Mortar {
    constructor(col, row) {
        this.col = col;
        this.row = row;

        // --- Stats ---
        this.timer = 0;
        this.cooldown = 200;
        this.range = 550;
        this.shellSpeed = 3.5;

        // --- Visual State ---
        this.recoil = 0;
        this.smoke = [];

        // --- Palette: Industrial Grays ---
        this.cMatteDark = "#2b2b2b";
        this.cMatteMid  = "#4a4a4a";
        this.cChrome    = "#a0a0a0";
        this.cCarbon    = "#1a1a1a";
        this.cAccent    = "#ffffff";
    }

    update(dt) {
        if (this.timer > 0) this.timer--;
        
        // Mechanical Recoil Recovery
        this.recoil = Math.max(0, this.recoil * 0.9);

        // Update Smoke
        for (let i = this.smoke.length - 1; i >= 0; i--) {
            let p = this.smoke[i];
            p.x += p.vx; p.y += p.vy;
            p.size += 0.3; p.life -= 0.02;
            if (p.life <= 0) this.smoke.splice(i, 1);
        }

        // Firing Logic
        if (this.timer <= 0) {
            let target = this.findTarget();
            if (target) {
                const cx = this.col * CELL_SIZE + CELL_SIZE / 2;
                const cy = this.row * CELL_SIZE + CELL_SIZE / 2;

                // --- TUNED PREDICTION ALGORITHM ---
                
                // 1. Get Enemy Velocity
                let tvx = target.vx || 0;
                let tvy = target.vy || 0;

                // 2. Calculate "Perfect" Time to Impact
                // We use the iterative method to find the exact flight time
                let t = 0;
                let predX = target.x;
                let predY = target.y;
                
                // Iteration 1: Simple distance check
                let dist = Math.hypot(target.x - cx, target.y - cy);
                t = dist / this.shellSpeed;

                // Iteration 2: Refine based on movement
                let futureX = target.x + tvx * t;
                let futureY = target.y + tvy * t;
                dist = Math.hypot(futureX - cx, futureY - cy);
                t = dist / this.shellSpeed;

                // 3. APPLY DAMPENING (The Fix)
                // Instead of shooting EXACTLY where they will be in 't' frames,
                // we only lead them by a percentage. This prevents overshooting 
                // when enemies turn corners.
                const PREDICTION_FACTOR = 0.6; // 0.0 = At enemy, 1.0 = Full Lead, 0.6 = Balanced
                
                let finalX = target.x + (tvx * t * PREDICTION_FACTOR);
                let finalY = target.y + (tvy * t * PREDICTION_FACTOR);

                projectiles.push(new MortarShell(cx, cy, finalX, finalY));

                this.timer = this.cooldown;
                this.recoil = 30; 

                // Smoke Logic
                const tipY = cy - (CELL_SIZE * 0.8) + this.recoil; 
                for (let i = 0; i < 12; i++) {
                    let angle = (Math.random() - 0.5) * 1.5;
                    let speed = 2 + Math.random() * 4;
                    this.smoke.push({
                        x: cx,
                        y: tipY,
                        vx: Math.sin(angle) * speed,
                        vy: -Math.cos(angle) * speed,
                        size: 4 + Math.random() * 6,
                        life: 1.0,
                        color: Math.random() > 0.5 ? 'rgba(200,200,200,' : 'rgba(80,80,80,'
                    });
                }
            }
        }
    }

    findTarget() {
        const cx = this.col * CELL_SIZE + CELL_SIZE / 2;
        const cy = this.row * CELL_SIZE + CELL_SIZE / 2;
        let closest = null;
        let recordDist = Infinity;
        for (let e of enemies) {
            let d = Math.hypot(e.x - cx, e.y - cy);
            if (d < this.range && d < recordDist) {
                recordDist = d; closest = e;
            }
        }
        return closest;
    }

    draw() {
        const cx = this.col * CELL_SIZE + CELL_SIZE / 2;
        const cy = this.row * CELL_SIZE + CELL_SIZE / 2;
        const size = CELL_SIZE;

        ctx.save();
        ctx.translate(cx, cy);

        // --- LAYER 1: Industrial Base ---
        ctx.fillStyle = this.cMatteDark;
        ctx.beginPath();
        for(let i=0; i<8; i++){
            let ang = i * Math.PI / 4;
            ctx.lineTo(size*0.45 * Math.cos(ang), size*0.45 * Math.sin(ang));
        }
        ctx.fill();
        
        ctx.strokeStyle = this.cMatteMid;
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(0,0, size*0.35, 0, Math.PI*2); ctx.stroke();
        
        ctx.fillStyle = "#111";
        [0, 2, 4, 6].forEach(i => {
            let a = i * Math.PI / 4;
            ctx.beginPath(); 
            ctx.rect(size*0.38*Math.cos(a)-2, size*0.38*Math.sin(a)-2, 4, 4); 
            ctx.fill();
        });

        // --- LAYER 2: THE BARREL (Sandwiched) ---
        ctx.save();
        ctx.translate(0, size * 0.1); 

        const totalLen = size * 0.9;
        
        // 2a. Breech Block
        const breechW = size * 0.42;
        const breechH = size * 0.25;
        this.drawMachinedBlock(0, 0, breechW, breechH, this.cMatteDark);
        
        // 2b. Segment 1: Outer Shielding
        const seg1W = size * 0.34;
        const seg1H = totalLen * 0.3;
        this.drawCylinder(0, -breechH, seg1W, seg1H, this.cMatteMid, this.cCarbon);

        // 2c. Segment 2: Polished Hydraulic Piston
        const seg2W = size * 0.26;
        const seg2H = totalLen * 0.3;
        const r2 = this.recoil * 0.5;
        this.drawCylinder(0, -breechH - seg1H + r2, seg2W, seg2H, "#ffffff", "#888888"); 

        // 2d. Segment 3: Magnetic Rail / Tip
        const seg3W = size * 0.18;
        const seg3H = totalLen * 0.4;
        const r3 = this.recoil;
        const tipY = -breechH - seg1H - seg2H + r3;
        
        this.drawCylinder(0, tipY, seg3W, seg3H, this.cMatteMid, "#000");
        
        // Muzzle Flash
        if (this.recoil > 15) {
            ctx.globalCompositeOperation = 'lighter';
            ctx.shadowBlur = 30;
            ctx.shadowColor = "#ff3300"; 
            ctx.fillStyle = "rgba(255, 60, 30, 0.6)";
            ctx.beginPath();
            ctx.ellipse(0, tipY - seg3H - 15, size/2.5, size/2, 0, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.globalCompositeOperation = 'source-over';
        }
        ctx.restore();

        // --- LAYER 3: HEAVY SIDE PLATING ---
        const mountW = size * 0.14;
        const mountH = size * 0.5;
        const spread = size * 0.24;
        
        this.drawHeavyMount(-spread, 0, mountW, mountH, size);
        this.drawHeavyMount(spread, 0, mountW, mountH, size);

        // --- LAYER 4: The Axle ---
        ctx.fillStyle = "#111";
        ctx.fillRect(-spread, -4, spread*2, 8);
        this.drawHex( -spread - 2, 0, 5, "#333");
        this.drawHex( spread + 2, 0, 5, "#333");

        ctx.restore();

        // --- LAYER 5: Smoke ---
        for (let p of this.smoke) {
            ctx.fillStyle = `${p.color} ${p.life * 0.5})`; 
            ctx.beginPath();
            ctx.arc(p.x - cx, p.y - cy, p.size, 0, Math.PI*2);
            ctx.fill();
        }
    }

    drawMachinedBlock(x,y,w,h, color) {
        ctx.save();
        ctx.translate(x,y);
        ctx.fillStyle = color;
        ctx.fillRect(-w/2, -h, w, h);
        ctx.fillStyle = "rgba(255,255,255,0.1)";
        ctx.fillRect(-w/2, -h, 2, h); 
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.fillRect(w/2 - 2, -h, 2, h); 
        ctx.fillStyle = "#111";
        ctx.fillRect(-w/4, -h/2, w/2, 2);
        ctx.fillRect(-w/4, -h/2 + 4, w/2, 2);
        ctx.restore();
    }

    drawCylinder(x, y, w, h, cLight, cDark) {
        ctx.save();
        ctx.translate(x, y);
        let grad = ctx.createLinearGradient(-w/2, 0, w/2, 0);
        grad.addColorStop(0, cDark);
        grad.addColorStop(0.2, cDark);
        grad.addColorStop(0.4, cLight); 
        grad.addColorStop(0.5, cLight);
        grad.addColorStop(0.8, cDark);
        grad.addColorStop(1.0, "#000");
        ctx.fillStyle = grad;
        ctx.fillRect(-w/2, -h, w, h);
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(-w/2, -h, w, 1);
        ctx.restore();
    }
    
    drawHeavyMount(x, y, w, h, size) {
        ctx.save();
        ctx.translate(x, y);
        ctx.fillStyle = this.cMatteMid;
        ctx.strokeStyle = "#111";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-w/2, size/4); 
        ctx.lineTo(-w/2, -h/4);   
        ctx.lineTo(0, -h/2);      
        ctx.lineTo(w/2, -h/4);    
        ctx.lineTo(w/2, size/4);  
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = this.cMatteDark;
        ctx.beginPath();
        ctx.arc(0, size/5, 3, 0, Math.PI*2); 
        ctx.fill();
        ctx.fillStyle = this.cAccent; 
        ctx.fillRect(-2, -h/3, 4, 4);
        ctx.restore();
    }
    
    drawHex(x, y, r, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        for(let i=0; i<6; i++) {
            ctx.lineTo(x + r*Math.cos(i*Math.PI/3), y + r*Math.sin(i*Math.PI/3));
        }
        ctx.fill();
    }
}

    // -- PROJECTILES --

    class HealingVomit {
    constructor(startX, startY, target, healAmount) {
        this.x = startX;
        this.y = startY;
        this.target = target;
        this.healAmount = healAmount;
        this.speed = 8; // Faster projectile to catch running targets
        this.active = true;
        this.radius = 4;
        this.trail = [];
    }

    update(dt) {
        if (!this.target || this.target.hp <= 0) {
            this.active = false;
            return;
        }

        let dx = this.target.x - this.x;
        let dy = this.target.y - this.y;
        let dist = Math.hypot(dx, dy);

        // SAFETY FIX: If target has no radius, assume 15
        let hitDist = (this.target.radius || 15) + 10; 

        if (dist < hitDist) {
            this.target.hp = Math.min(this.target.maxHp, this.target.hp + this.healAmount);
            if(typeof createParticles === 'function') createParticles(this.target.x, this.target.y, "#00ffcc", 5);
            this.active = false;
        } else {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
            this.trail.push({x: this.x, y: this.y, r: Math.random() * 3 + 1});
            if(this.trail.length > 5) this.trail.shift();
        }
    }

    draw() {
        ctx.save();
        ctx.fillStyle = "#00ffcc";
        for(let t of this.trail) {
            ctx.globalAlpha = 0.5;
            ctx.beginPath(); ctx.arc(t.x, t.y, t.r, 0, Math.PI*2); ctx.fill();
        }
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 6; ctx.shadowColor = "#00ffcc";
        ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0; ctx.restore();
    }
}

class MinigunBullet {
    constructor(x, y, angle, damage, speed) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.damage = damage;
        this.speed = speed;
        this.active = true;
        this.life = 140; 
        
        // VISUALS: Size 0.7 as requested
        this.size = 0.7; 
    }

    update(dt) {
        // Move in straight line
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        
        this.life -= dt;
        if (this.life <= 0) this.active = false;

        // --- CUSTOM COLLISION LOGIC ---
        for (let e of enemies) {
            let dist = Math.hypot(e.x - this.x, e.y - this.y);
            
            // Hitbox check
            if (dist < e.radius + 10) {
                // --- NEW SHIELD LOGIC ---
                if (e.isInvincible) {
                    // BLOCKED! Blue particles indicate shield hit
                    if (typeof createParticles === 'function') {
                        createParticles(this.x, this.y, "#00d2ff", 4); 
                    }
                } else {
                    // NORMAL HIT: Apply damage
                    e.hp -= this.damage;
                    
                    // Visual Hit Effect (Orange/Gold)
                    if (typeof createParticles === 'function') {
                        createParticles(this.x, this.y, "#ffaa00", 3);
                    }
                }

                this.active = false; // Bullet is destroyed either way
                break; // Hit one enemy per bullet
            }
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // Glowing Tracer Round
        ctx.shadowBlur = 8;
        ctx.shadowColor = "#ffaa00";
        ctx.fillStyle = "#ffffaa";

        ctx.fillRect(-5, -1, 10, 2); 

        ctx.restore();
    }
}


    class Bullet {
    constructor(x, y, target, damage, size = 1) {
        this.x = x; this.y = y;
        this.target = target;
        this.damage = damage;
        this.size = size; 
        
        this.speed = 12;
        this.active = true;
        this.type = 'bullet';
        
        this.angle = 0;
    }

    update(dt) {
        if (!this.target || this.target.hp <= 0) {
            this.active = false;
            return;
        }

        let dx = this.target.x - this.x;
        let dy = this.target.y - this.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        
        // Update angle to face the target
        this.angle = Math.atan2(dy, dx);

        // HIT CHECK:
        if (dist < this.speed + (this.size * 4)) {
            
            // --- NEW SHIELD LOGIC ---
            if (this.target.isInvincible) {
                // BLOCKED! Blue particles
                if (typeof createParticles === 'function') {
                    createParticles(this.target.x, this.target.y, "#00d2ff", 6 * this.size);
                }
            } else {
                // NORMAL HIT
                this.target.hp -= this.damage;
                
                // Death check
                if(this.target.hp <= 0 && this.target.hp > -100) {
                    createParticles(this.target.x, this.target.y, "#ffaa00", 6 * this.size);
                    this.target.hp = -999; 
                }
            }
            
            this.active = false; // Bullet destroyed
        } else {
            this.x += (dx/dist) * this.speed;
            this.y += (dy/dist) * this.speed;
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        ctx.scale(this.size, this.size);
        ctx.globalCompositeOperation = "lighter";

        // Trail
        let grad = ctx.createLinearGradient(0, 0, -25, 0);
        grad.addColorStop(0, "rgba(255, 200, 50, 0.8)"); 
        grad.addColorStop(1, "rgba(255, 50, 0, 0)");     
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.moveTo(2, 0);    
        ctx.lineTo(-4, 2);    
        ctx.lineTo(-25, 0);   
        ctx.lineTo(-4, -2);   
        ctx.fill();

        // Core
        ctx.shadowColor = "#ffaa00";
        ctx.shadowBlur = 10; 
        ctx.fillStyle = "#ffffff";
        
        ctx.beginPath();
        ctx.ellipse(0, 0, 6, 1.5, 0, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
    }
}
    
    class MortarShell {
    constructor(x, y, tx, ty) {
        this.x = x; 
        this.y = y;
        this.tx = tx; 
        this.ty = ty;
        
        // 1. Calculate Geometry
        this.startDist = Math.hypot(tx - x, ty - y);
        // Yaw is the angle across the ground (2D plane)
        this.yaw = Math.atan2(ty - y, tx - x); 
        
        // 2. Flight Logic
        const flightTime = 60; // Frames to reach target
        this.speed = this.startDist / flightTime;
        // Enforce minimum speed to prevent floating shells
        if (this.speed < 2) this.speed = 2; 

        this.active = true;
        
        // 3. Stats (Passed to explosion)
        this.damage = 50;
        this.blastRadius = 100;

        // 4. Visuals
        this.z = 0; // Height off ground
        this.trail = []; 
    }

    update(dt) {
        if (!dt) dt = 1;

        let dx = this.tx - this.x;
        let dy = this.ty - this.y;
        let dist = Math.sqrt(dx*dx + dy*dy);

        // --- Trail Logic ---
        // Only spawn trail particles while moving
        if (dist > this.speed) {
             this.trail.push({x: this.x, y: this.y - this.z, alpha: 1.0});
             if(this.trail.length > 25) this.trail.shift(); 
        }
        // Fade out existing trail segments
        for(let p of this.trail) p.alpha -= 0.04;

        // --- Target Reached Logic ---
        if (dist <= this.speed) {
            this.active = false;
            
            // DAMAGE TRIGGER:
            // We pass this shell's specific damage and radius to the global function
            if (typeof createExplosion === 'function') {
                createExplosion(this.tx, this.ty, this.damage, this.blastRadius);
            }
        } else {
            // Move towards target
            this.x += (dx/dist) * this.speed * dt;
            this.y += (dy/dist) * this.speed * dt;
        }
    }

    // Helper: Calculates how high the shell is based on distance traveled
    getArcHeight(distTraveled) {
        let progress = distTraveled / this.startDist;
        // Clamp progress between 0 and 1
        progress = Math.max(0, Math.min(1, progress));
        
        // Parabola height logic
        let maxArcHeight = 50 + (this.startDist * 0.15); 
        return Math.sin(progress * Math.PI) * maxArcHeight;
    }

    draw() {
        // --- 1. Calculate Physics State ---
        let distRemaining = Math.hypot(this.tx - this.x, this.ty - this.y);
        let distTraveled = this.startDist - distRemaining;
        this.z = this.getArcHeight(distTraveled);

        // --- 2. Calculate Visual Rotation ---
        // Predict where the shell will be in the next frame to point it correctly
        let lookAhead = this.speed; 
        let nextDistTraveled = distTraveled + lookAhead;
        
        // Future ground position
        let nextX = this.x + Math.cos(this.yaw) * lookAhead;
        let nextY = this.y + Math.sin(this.yaw) * lookAhead;
        
        // Future screen position (Y - Z)
        let nextZ = this.getArcHeight(nextDistTraveled);
        
        // Angle between current screen pos and next screen pos
        let currentScreenY = this.y - this.z;
        let nextScreenY = nextY - nextZ;
        
        let visualRotation = Math.atan2(nextScreenY - currentScreenY, nextX - this.x);

        // --- 3. Draw Shadow (Ground Level) ---
        let scale = 1.0 + (this.z / 300); // Slight size increase with height
        let shadowSize = 6 * (1 - (this.z / 200)); 
        let shadowAlpha = 0.4 * (1 - (this.z / 150));
        
        if (shadowSize > 0) {
            ctx.save();
            ctx.fillStyle = `rgba(0,0,0,${Math.max(0, shadowAlpha)})`;
            ctx.beginPath();
            // Shadow stays on the ground, rotated by Yaw
            ctx.ellipse(this.x, this.y, shadowSize * 1.5, shadowSize * 0.8, this.yaw, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        }

        // --- 4. Draw Trail ---
        ctx.lineWidth = 3 * scale;
        ctx.lineCap = "round";
        // Draw segments connecting trail points
        for (let i = 0; i < this.trail.length - 1; i++) {
            let p1 = this.trail[i];
            let p2 = this.trail[i+1];
            if(p1.alpha <= 0) continue;
            
            ctx.strokeStyle = `rgba(200, 200, 200, ${p1.alpha * 0.5})`;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        // --- 5. Draw Shell Sprite ---
        ctx.save();
        
        // Translate to actual visual position (Ground Y - Height Z)
        ctx.translate(this.x, this.y - this.z);
        ctx.rotate(visualRotation);
        ctx.scale(scale, scale); 

        // Shell Body Shape
        ctx.fillStyle = "#333";
        ctx.beginPath();
        ctx.moveTo(14, 0);   // Nose
        ctx.lineTo(-8, 4.5);  // Back Bottom
        ctx.lineTo(-8, -4.5); // Back Top
        ctx.fill();

        // Driving Band (Copper ring detail)
        ctx.fillStyle = "#b87333"; 
        ctx.fillRect(-5, -4.5, 4, 9);

        // Metallic Highlight
        ctx.fillStyle = "rgba(255,255,255,0.4)";
        ctx.fillRect(-7, -1.5, 18, 3);

        // Engine/Thruster Glow
        ctx.shadowBlur = 8;
        ctx.shadowColor = "#ff5500";
        ctx.fillStyle = "#ff5500";
        ctx.beginPath(); 
        ctx.arc(-8, 0, 3, 0, Math.PI*2); 
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.restore();
    }
}

function drawBlueprint() {
    let col = Math.floor(mouseX / CELL_SIZE);
    let row = Math.floor(mouseY / CELL_SIZE);

    if (currentTool === 'wall') {
        // ... (Existing Wall Logic) ...
        // 1. Grid Snap Calculations
        let col = Math.floor(mouseX / CELL_SIZE);
        let row = Math.floor(mouseY / CELL_SIZE);

        // Ensure we are inside the grid
        if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {

            // 2. Setup Colors (Simulate 100% Health)
            let hpPct = 1.0; 
            let gray = Math.floor(60 + (60 * hpPct)); // 120
            let colMain = `rgb(${gray}, ${gray}, ${gray})`;
            let colLight = `rgb(${gray + 40}, ${gray + 40}, ${gray + 40})`;
            let colDark = `rgb(${gray - 40}, ${gray - 40}, ${gray - 40})`;
            let colDetail = `rgb(${gray - 20}, ${gray - 20}, ${gray - 20})`;

            // 3. Check Neighbors (To draw connections)
            let nUp = (row > 0 && grid[col][row - 1].wall);
            let nDown = (row < ROWS - 1 && grid[col][row + 1].wall);
            let nLeft = (col > 0 && grid[col - 1][row].wall);
            let nRight = (col < COLS - 1 && grid[col + 1][row].wall);

            // 4. Geometry Calculations
            let drawX = col * CELL_SIZE;
            let drawY = row * CELL_SIZE;
            let coreSize = CELL_SIZE * 0.85; 
            let offset = (CELL_SIZE - coreSize) / 2;
            
            let cX = drawX + offset;
            let cY = drawY + offset;
            let cW = coreSize;
            let cH = coreSize;

            // --- DRAWING ---

            // A. Base Layer (Main Block + Arms)
            ctx.fillStyle = colMain;
            ctx.fillRect(cX, cY, cW, cH); // Center
            
            if (nUp) ctx.fillRect(cX, drawY, cW, offset);
            if (nDown) ctx.fillRect(cX, cY + cH, cW, offset);
            if (nLeft) ctx.fillRect(drawX, cY, offset, cH);
            if (nRight) ctx.fillRect(cX + cW, cY, offset, cH);

            // B. Grip Lines (Texture on the arms only)
            ctx.fillStyle = colDark;
            let lineSpace = 4;
            if (nUp) for(let i = drawY + 2; i < cY; i+=lineSpace) ctx.fillRect(cX + 2, i, cW - 4, 1);
            if (nDown) for(let i = cY + cH + 2; i < drawY + CELL_SIZE; i+=lineSpace) ctx.fillRect(cX + 2, i, cW - 4, 1);
            if (nLeft) for(let i = drawX + 2; i < cX; i+=lineSpace) ctx.fillRect(i, cY + 2, 1, cH - 4);
            if (nRight) for(let i = cX + cW + 2; i < drawX + CELL_SIZE; i+=lineSpace) ctx.fillRect(i, cY + 2, 1, cH - 4);

            // C. 3D Bevels (Outer Edges)
            let drawLine = (x1, y1, x2, y2, color) => {
                ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = 2;
                ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
            };
            
            drawLine(cX, cY, cX + cW, cY, colLight);       // Top Highlight
            drawLine(cX, cY, cX, cY + cH, colLight);       // Left Highlight
            drawLine(cX + cW, cY, cX + cW, cY + cH, colDark); // Right Shadow
            drawLine(cX, cY + cH, cX + cW, cY + cH, colDark); // Bottom Shadow

            // D. Inner Reinforced Plate (Clean Square)
            let pad = 6;
            ctx.fillStyle = colDetail;
            ctx.fillRect(cX + pad, cY + pad, cW - pad*2, cH - pad*2);
            
            // Inner Shadow (Inset look)
            ctx.strokeStyle = colDark;
            ctx.lineWidth = 1;
            ctx.strokeRect(cX + pad, cY + pad, cW - pad*2, cH - pad*2);
        }
    }
    else if (currentTool === 'barracks') {
        if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
            const x = col * CELL_SIZE + CELL_SIZE / 2;
            const y = row * CELL_SIZE + CELL_SIZE / 2;
            const size = CELL_SIZE - 4;
            
            const isOccupied = grid[col][row].occupied || grid[col][row].wall;
            const canAfford = money >= 200; // Adjust to match your UI cost

            ctx.save();
            ctx.translate(x, y);
            ctx.globalAlpha = 0.5; // Transparent "Ghost" mode

            // --- 1. TECH BASE ---
            // Draw Octagon inline to avoid dependency issues
            ctx.fillStyle = "#1a1a2e"; 
            ctx.beginPath();
            for (let i = 0; i < 8; i++) {
                let angle = (Math.PI / 4) * i;
                let rad = size/2 + 2;
                ctx.lineTo(Math.cos(angle) * rad, Math.sin(angle) * rad);
            }
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = "#16213e";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-size/2, -size/2); ctx.lineTo(size/2, size/2);
            ctx.moveTo(size/2, -size/2); ctx.lineTo(-size/2, size/2);
            ctx.stroke();

            // --- 2. PISTONS (Static) ---
            ctx.fillStyle = "#444";
            for (let i = 0; i < 4; i++) {
                ctx.save();
                ctx.rotate((Math.PI / 2) * i); 
                
                // Base
                ctx.fillRect(-6, -size/2, 12, 10);
                
                // Rod (Static position)
                let py = -size/2 + 8;
                ctx.fillStyle = "#888"; 
                ctx.fillRect(-3, py, 6, 8);
                
                // Wire
                ctx.strokeStyle = "#222";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, -size/2 + 5);
                ctx.lineTo(0, py);
                ctx.stroke();
                
                ctx.restore();
            }

            // --- 3. REACTOR CORE ---
            // Static moderate glow
            ctx.shadowBlur = 15; 
            ctx.shadowColor = "#00d2ff";
            ctx.fillStyle = `rgba(0, 210, 255, 0.6)`;
            
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0; 

            // --- 4. PLASMA RINGS ---
            // Outer Ring
            ctx.strokeStyle = "#00d2ff"; 
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 8]); 
            ctx.beginPath();
            ctx.arc(0, 0, size/2 - 6, 0, Math.PI * 2);
            ctx.stroke();

            // Inner Ring
            ctx.strokeStyle = "#ff00ff"; 
            ctx.setLineDash([5, 5]); 
            ctx.beginPath();
            ctx.arc(0, 0, size/2 - 12, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]); // Reset dash

            ctx.restore();
        }
    }
    else if (currentTool === 'wall_turret') {
        // ... (Existing Turret Logic) ...
        // --- 1. CALCULATE GRID SNAP ---
        let col = Math.floor(mouseX / CELL_SIZE);
        let row = Math.floor(mouseY / CELL_SIZE);
        
        // Center the blueprint on the grid cell
        let snapX = col * CELL_SIZE + CELL_SIZE / 2;
        let snapY = row * CELL_SIZE + CELL_SIZE / 2;

        // --- 2. DRAW RANGE CONE (Centered on Snap) ---
        ctx.save();
        ctx.translate(snapX, snapY); 
        
        ctx.beginPath();
        ctx.fillStyle = "rgba(0, 255, 0, 0.1)";
        ctx.strokeStyle = "rgba(0, 255, 0, 0.5)";
        ctx.moveTo(0, 0);
        // Note: Adjusted radius to 210 to match the new turret range
        ctx.arc(0, 0, 210, buildRotation - Math.PI / 3, buildRotation + Math.PI / 3);
        ctx.lineTo(0, 0);
        ctx.fill();
        ctx.stroke();
        ctx.restore();

        // --- 3. DRAW TURRET VISUALS (Updated to Match New Class) ---
        ctx.save();
        ctx.translate(snapX, snapY); 
        ctx.rotate(buildRotation);

        // A. Industrial Hex Base
        ctx.fillStyle = "#263238"; 
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            ctx.lineTo(15 * Math.cos(i * Math.PI / 3), 15 * Math.sin(i * Math.PI / 3));
        }
        ctx.fill();
        ctx.strokeStyle = "#37474f"; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI*2); ctx.stroke();

        // B. The Heavy Cannon
        // Breech
        ctx.fillStyle = "#1c1c1c"; ctx.fillRect(0, -7, 12, 14);
        // Barrel
        ctx.fillStyle = "#455a64"; ctx.fillRect(10, -5, 30, 10);
        // Thermal Sleeve
        ctx.fillStyle = "#37474f"; ctx.fillRect(22, -6, 10, 12); 
        ctx.fillStyle = "#546e7a"; ctx.fillRect(26, -6, 2, 12);
        // Muzzle Brake
        ctx.fillStyle = "#212121";
        ctx.beginPath();
        ctx.moveTo(38, -8); ctx.lineTo(46, -8); 
        ctx.lineTo(48, -6); ctx.lineTo(48, 6);
        ctx.lineTo(46, 8);  ctx.lineTo(38, 8);
        ctx.closePath(); ctx.fill();
        // White Hot Tip
        ctx.fillStyle = "#ffffff"; 
        ctx.fillRect(47, -5, 2, 10);

        // C. Complex Triangular Housing
        // Lower Armor Plate (Darker)
        ctx.fillStyle = "#37474f"; 
        ctx.beginPath();
        ctx.moveTo(16, 0);       // Nose
        ctx.lineTo(0, -10);      // Shoulder
        ctx.lineTo(-10, -18);    // Wing Tip
        ctx.lineTo(-14, -12);    // Cut
        ctx.lineTo(-18, 0);      // Rear
        ctx.lineTo(-14, 12);     // Cut
        ctx.lineTo(-10, 18);     // Wing Tip
        ctx.lineTo(0, 10);       // Shoulder
        ctx.closePath();
        ctx.fill();

        // Upper Armor Plate (Lighter)
        ctx.fillStyle = "#546e7a"; 
        ctx.beginPath();
        ctx.moveTo(14, 0);       
        ctx.lineTo(-12, -8);     
        ctx.lineTo(-16, 0);      
        ctx.lineTo(-12, 8);      
        ctx.closePath();
        ctx.fill();

        // Spine Detail
        ctx.strokeStyle = "rgba(0,0,0,0.2)";
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(-16, 0); ctx.lineTo(14, 0); ctx.stroke();

        // Optics / Status Light
        ctx.fillStyle = "#00e676"; 
        ctx.fillRect(-10, -3, 4, 6);

        ctx.restore();
    }
    else if (currentTool === 'mortar') {
        // ... (Existing Mortar Logic) ...
        // 1. Grid Snap Calculations
        let col = Math.floor(mouseX / CELL_SIZE);
        let row = Math.floor(mouseY / CELL_SIZE);
        
        let x = col * CELL_SIZE; 
        let y = row * CELL_SIZE;
        let centerX = x + CELL_SIZE / 2;
        let centerY = y + CELL_SIZE / 2;
        let size = CELL_SIZE;

        // 2. Range Circle (Kept Green as requested)
        ctx.beginPath();
        ctx.fillStyle = "rgba(0, 255, 0, 0.1)";
        ctx.strokeStyle = "rgba(0, 255, 0, 0.5)";
        ctx.arc(centerX, centerY, 550, 0, Math.PI * 2); // Match stats range (550)
        ctx.fill();
        ctx.stroke();

        // 3. Mortar Visuals (Ported from Class)
        ctx.save();
        ctx.translate(centerX, centerY);

        // --- Palette ---
        const cMatteDark = "#2b2b2b";
        const cMatteMid  = "#4a4a4a";
        const cCarbon    = "#1a1a1a";
        const cAccent    = "#ffffff";

        // --- LAYER 1: Industrial Base ---
        ctx.fillStyle = cMatteDark;
        ctx.beginPath();
        for(let i=0; i<8; i++){
            let ang = i * Math.PI / 4;
            ctx.lineTo(size*0.45 * Math.cos(ang), size*0.45 * Math.sin(ang));
        }
        ctx.fill();
        
        ctx.strokeStyle = cMatteMid;
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(0,0, size*0.35, 0, Math.PI*2); ctx.stroke();
        
        // Bolts
        ctx.fillStyle = "#111";
        [0, 2, 4, 6].forEach(i => {
            let a = i * Math.PI / 4;
            ctx.beginPath(); 
            ctx.rect(size*0.38*Math.cos(a)-2, size*0.38*Math.sin(a)-2, 4, 4); 
            ctx.fill();
        });

        // --- LAYER 2: THE BARREL ---
        // We simulate the helper functions here locally
        ctx.save();
        ctx.translate(0, size * 0.1); // Pivot offset

        const totalLen = size * 0.9;
        const breechW = size * 0.42;
        const breechH = size * 0.25;

        // 2a. Breech Block
        ctx.fillStyle = cMatteDark;
        ctx.fillRect(-breechW/2, -breechH, breechW, breechH);
        
        // 2b. Barrel Segments (Helper logic inlined for gradients)
        const drawGradCyl = (gx, gy, w, h, c1, c2) => {
            let grad = ctx.createLinearGradient(gx-w/2, 0, gx+w/2, 0);
            grad.addColorStop(0, c2); grad.addColorStop(0.4, c1); 
            grad.addColorStop(0.5, c1); grad.addColorStop(1.0, "#000");
            ctx.fillStyle = grad;
            ctx.fillRect(gx-w/2, gy-h, w, h);
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.fillRect(gx-w/2, gy-h, w, 1); // Segment line
        };

        const seg1W = size * 0.34; const seg1H = totalLen * 0.3;
        const seg2W = size * 0.26; const seg2H = totalLen * 0.3;
        const seg3W = size * 0.18; const seg3H = totalLen * 0.4;

        // Draw segments (No recoil in preview)
        drawGradCyl(0, -breechH, seg1W, seg1H, cMatteMid, cCarbon);
        drawGradCyl(0, -breechH - seg1H, seg2W, seg2H, "#ffffff", "#888888");
        const tipY = -breechH - seg1H - seg2H;
        drawGradCyl(0, tipY, seg3W, seg3H, cMatteMid, "#000");

        // Muzzle Device
        ctx.fillStyle = cCarbon;
        ctx.fillRect(-seg3W/2 - 2, tipY - seg3H, seg3W + 4, 10);
        ctx.fillStyle = cAccent;
        ctx.fillRect(-2, tipY - seg3H + 4, 4, 2); 

        ctx.restore(); // End Barrel

        // --- LAYER 3: HEAVY SIDE PLATING ---
        const mountW = size * 0.14;
        const mountH = size * 0.5;
        const spread = size * 0.24;

        const drawMount = (mx) => {
            ctx.save();
            ctx.translate(mx, 0);
            ctx.fillStyle = cMatteMid;
            ctx.strokeStyle = "#111";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-mountW/2, size/4); 
            ctx.lineTo(-mountW/2, -mountH/4);   
            ctx.lineTo(0, -mountH/2);       
            ctx.lineTo(mountW/2, -mountH/4);    
            ctx.lineTo(mountW/2, size/4);   
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Bolt
            ctx.fillStyle = cMatteDark;
            ctx.beginPath(); ctx.arc(0, size/5, 3, 0, Math.PI*2); ctx.fill();
            // Light
            ctx.fillStyle = cAccent; ctx.fillRect(-2, -mountH/3, 4, 4);
            ctx.restore();
        };

        drawMount(-spread);
        drawMount(spread);

        // --- LAYER 4: The Axle ---
        ctx.fillStyle = "#111";
        ctx.fillRect(-spread, -4, spread*2, 8);

        ctx.restore(); // End Translation
    }
    else if (currentTool === 'trap') {
        // ... (Existing Trap Logic) ...
        // 1. Grid Snap Calculations
        let col = Math.floor(mouseX / CELL_SIZE);
        let row = Math.floor(mouseY / CELL_SIZE);
        let snapX = col * CELL_SIZE + CELL_SIZE / 2;
        let snapY = row * CELL_SIZE + CELL_SIZE / 2;

        ctx.save();
        ctx.translate(snapX, snapY);

        // 2. Trigger Radius (Visual Aid)
        ctx.beginPath();
        ctx.fillStyle = "rgba(255, 50, 50, 0.2)";
        ctx.strokeStyle = "rgba(255, 50, 50, 0.6)";
        ctx.arc(0, 0, 22, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // 3. Trap Visuals (Ready State - Retracted)
        const size = CELL_SIZE - 4;
        const half = size / 2;

        // --- A. Base Plate ---
        ctx.beginPath();
        ctx.moveTo(-half + 6, -half);
        ctx.lineTo(half - 6, -half);
        ctx.lineTo(half, -half + 6);
        ctx.lineTo(half, half - 6);
        ctx.lineTo(half - 6, half);
        ctx.lineTo(-half + 6, half);
        ctx.lineTo(-half, half - 6);
        ctx.lineTo(-half, -half + 6);
        ctx.closePath();

        // Gradient: Titanium/Slate
        let baseGrad = ctx.createLinearGradient(-half, -half, half, half);
        baseGrad.addColorStop(0, "#6a6a70"); 
        baseGrad.addColorStop(1, "#3a3a40"); 
        ctx.fillStyle = baseGrad;
        ctx.fill();
        
        ctx.strokeStyle = "#889"; 
        ctx.lineWidth = 1;
        ctx.stroke();

        // Inner Panel
        ctx.fillStyle = "#222"; 
        ctx.fillRect(-half + 5, -half + 5, size - 10, size - 10);
        ctx.strokeStyle = "#111";
        ctx.strokeRect(-half + 5, -half + 5, size - 10, size - 10);

        // --- B. Spike Housings (Empty/Retracted) ---
        const spikeOffset = 9;
        const spikePositions = [
            {x: -spikeOffset, y: -spikeOffset}, 
            {x: spikeOffset, y: -spikeOffset},  
            {x: -spikeOffset, y: spikeOffset},  
            {x: spikeOffset, y: spikeOffset}    
        ];

        for(let pos of spikePositions) {
            let isBack = pos.y < 0;
            // Draw the empty hole
            ctx.fillStyle = "#111"; 
            ctx.beginPath(); ctx.arc(pos.x, pos.y, 4.5, 0, Math.PI*2); ctx.fill();
            // Draw the rim
            ctx.strokeStyle = isBack ? "#555" : "#777";
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // --- C. Center Light (Green for Ready) ---
        ctx.fillStyle = "#111";
        ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = "#00ff00"; 
        ctx.beginPath(); ctx.arc(0, 0, 1.5, 0, Math.PI*2); ctx.fill();
        ctx.shadowColor = "#0f0";
        ctx.shadowBlur = 8;
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.restore();
    }
    else if (currentTool === 'minigun') {
        if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
            const x = col * CELL_SIZE + CELL_SIZE / 2;
            const y = row * CELL_SIZE + CELL_SIZE / 2;
            const isOccupied = grid[col][row].occupied || grid[col][row].wall;
            const canAfford = money >= 400; // Cost matches UI

            ctx.save();
            ctx.translate(x, y);
            ctx.globalAlpha = 0.65; // Ghost transparency

            // --- 1. INDUSTRIAL BASE ---
            // Drop shadow
            ctx.fillStyle = "rgba(0,0,0,0.3)";
            ctx.beginPath(); ctx.arc(2, 2, 22, 0, Math.PI * 2); ctx.fill();

            // Main X-Stand
            ctx.fillStyle = "#1a1a1a";
            
            for(let i=0; i<4; i++) {
                ctx.save(); 
                ctx.rotate((Math.PI/4) + (i * Math.PI/2));
                
                // Leg Strut
                ctx.fillRect(-6, -6, 12, 24); 
                
                // Foot Pad
                ctx.fillStyle ="#333";
                ctx.beginPath();
                ctx.moveTo(-8, 18); ctx.lineTo(8, 18);
                ctx.lineTo(10, 24); ctx.lineTo(-10, 24);
                ctx.fill();
                
                // Bolt
                ctx.fillStyle = "#555";
                ctx.beginPath(); ctx.arc(0, 12, 2, 0, Math.PI*2); ctx.fill();
                
                ctx.restore();
            }

            // Central Bearing Ring
            ctx.fillStyle = "#222";
            ctx.beginPath(); ctx.arc(0,0, 16, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = "#444"; ctx.lineWidth = 2; ctx.stroke();
            
            // Rivets
            ctx.fillStyle = "#666";
            for(let i=0; i<8; i++){
                let ra = i * (Math.PI*2)/8;
                ctx.beginPath(); ctx.arc(Math.cos(ra)*12, Math.sin(ra)*12, 1.5, 0, Math.PI*2); ctx.fill();
            }

            // --- 2. AMMO SYSTEM ---
            const ammoX = -28;
            const ammoY = 18;
            const angle = 0; // Static angle for blueprint
            
            let feedPortX = Math.cos(angle - 0.5) * 8; 
            let feedPortY = Math.sin(angle - 0.5) * 8;

            // Belt Curve
            ctx.beginPath();
            ctx.moveTo(ammoX, ammoY);
            ctx.quadraticCurveTo(ammoX, ammoY - 25, feedPortX, feedPortY);
            
            ctx.lineWidth = 7; ctx.strokeStyle = "#111"; ctx.stroke(); 
            ctx.lineWidth = 4; ctx.strokeStyle = "#d4af37"; ctx.setLineDash([2, 3]); ctx.stroke(); 
            ctx.setLineDash([]);

            // Ammo Box
            ctx.fillStyle = "#2f3f2f";
            ctx.fillRect(ammoX - 10, ammoY - 10, 24, 20);
            ctx.fillStyle = "#4a5b4a"; 
            ctx.fillRect(ammoX - 8, ammoY - 12, 20, 4);

            // --- 3. TURRET HEAD (Static) ---
            ctx.rotate(angle);

            // Rear Motor Housing
            ctx.fillStyle = "#222";
            ctx.beginPath();
            ctx.arc(-12, 0, 11, Math.PI/2, -Math.PI/2); 
            ctx.fill();
            ctx.fillRect(-12, -11, 10, 22);

            // Main Receiver Body
            ctx.fillStyle = "#3a3a3a"; 
            ctx.beginPath();
            ctx.moveTo(-5, -10);
            ctx.lineTo(15, -10);
            ctx.lineTo(15, 10);
            ctx.lineTo(-5, 10);
            ctx.fill();
            
            ctx.fillStyle = "#1a1a1a";
            ctx.fillRect(-2, -11, 6, 22);

            // Barrel Bundle
            const bW = 46; const bH = 14; const bX = 15; const bY = -bH/2;
            ctx.fillStyle = "#050505";
            ctx.fillRect(bX, bY, bW, bH);

            // Static Barrels (No heat color)
            ctx.fillStyle = "#444"; 
            const spacing = 5;
            for(let i = -spacing; i < bH + spacing; i += spacing) {
                let yPos = bY + i;
                if(yPos < bY + bH && yPos > bY) {
                     ctx.fillRect(bX, yPos, bW, 2);
                }
            }

            // Barrel Details
            ctx.fillStyle = "#222";
            ctx.fillRect(bX + 20, bY - 1, 4, bH + 2); // Clamp
            ctx.fillStyle = "#111";
            ctx.fillRect(bX + bW - 2, bY - 1, 3, bH + 2); // Muzzle

            ctx.restore();

            // --- 4. RANGE INDICATOR ---
            ctx.beginPath();
            ctx.arc(x, y, 280, 0, Math.PI * 2); // Range matches class stats (280)
            ctx.strokeStyle ="rgba(255, 255, 255, 0.5)";
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }
    else if (currentTool === 'money_farm') {
        // ... (Existing Money Farm Logic) ...
        if (col >= 0 && col < COLS - 1 && row >= 0 && row < ROWS - 1) {
            // Calculate center coordinates based on the grid column/row
            let x = col * CELL_SIZE;
            let y = row * CELL_SIZE;
            let cx = x + CELL_SIZE;
            let cy = y + CELL_SIZE;
            let radius = CELL_SIZE - 5;

            ctx.save(); // Save context to handle transparency safely
            ctx.globalAlpha = 0.7; // Make the whole preview slightly transparent

            // --- 1. BASE PAD (Static) ---
            ctx.fillStyle = "#1a1a22";
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fill();

            // --- 2. TECH PATTERNS (Static) ---
            ctx.strokeStyle = "#330066";
            ctx.lineWidth = 2;
            ctx.beginPath();
            // Inner rings
            ctx.arc(cx, cy, radius * 0.8, 0, Math.PI * 2);
            ctx.arc(cx, cy, radius * 0.5, 0, Math.PI * 2);
            // Spokes
            for (let i = 0; i < 8; i++) {
                let angle = (Math.PI / 4) * i;
                ctx.moveTo(cx + Math.cos(angle) * (radius * 0.5), cy + Math.sin(angle) * (radius * 0.5));
                ctx.lineTo(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius);
            }
            ctx.stroke();

            // --- 3. GAUGE TRACK (Empty/Static) ---
            // Just drawing the background track, no progress fill
            let gaugeRadius = radius * 0.75;
            ctx.strokeStyle = "rgba(100, 0, 200, 0.4)";
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.arc(cx, cy, gaugeRadius, 0, Math.PI * 2);
            ctx.stroke();

            // --- 4. THE PLANT (Static/No Rotation) ---
            let plantSize = radius * 0.4;
            
            // Outer Petals
            ctx.fillStyle = "#7700aa"; // Static dark crystal color
            ctx.beginPath();
            for (let i = 0; i < 8; i += 2) {
                let angle = (Math.PI * 2 / 8) * i; // Fixed angle (no rotation)
                ctx.moveTo(cx, cy);
                ctx.lineTo(cx + Math.cos(angle - 0.3) * plantSize, cy + Math.sin(angle - 0.3) * plantSize);
                ctx.lineTo(cx + Math.cos(angle) * plantSize * 1.2, cy + Math.sin(angle) * plantSize * 1.2);
                ctx.lineTo(cx + Math.cos(angle + 0.3) * plantSize, cy + Math.sin(angle + 0.3) * plantSize);
            }
            ctx.fill();

            // Inner Core (Static size, no pulse)
            ctx.fillStyle = "#ff00aa"; // Static magenta
            ctx.beginPath();
            let coreSize = plantSize * 0.5;
            for (let i = 0; i < 6; i++) {
                let angle = (Math.PI * 2 / 6) * i;
                let px = cx + Math.cos(angle) * coreSize;
                let py = cy + Math.sin(angle) * coreSize;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.fill();

            // --- 5. SELECTION BORDER ---
            // Keeps the user aware of the 2x2 footprint
            ctx.strokeStyle = "rgba(0, 255, 255, 0.5)";
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, CELL_SIZE * 2, CELL_SIZE * 2);

            ctx.restore(); // Restore context to remove transparency
        }
    }
    else if (currentTool === 'cryo_tower') {
        if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
            const x = col * CELL_SIZE + CELL_SIZE / 2;
            const y = row * CELL_SIZE + CELL_SIZE / 2;
            const isOccupied = grid[col][row].occupied || grid[col][row].wall;
            const canAfford = money >= 150; // Adjust cost to match your UI

            ctx.save();
            ctx.translate(x, y);
            ctx.globalAlpha = 0.5; // Transparent "Ghost" mode

            // Note: We do NOT tint it red for invalid placement, 
            // keeping natural colors as requested.

            // --- 1. FROST AURA FLOOR ---
            const r = 160; // Range
            let grad = ctx.createRadialGradient(0, 0, 10, 0, 0, r * 0.7);
            grad.addColorStop(0, "rgba(200, 240, 255, 0.1)");
            grad.addColorStop(1, "rgba(0, 0, 0, 0)");
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();

            // --- 2. STATIC BASE ---
            // Tech Rune Ring
            ctx.strokeStyle = "rgba(0, 225, 255, 0.3)";
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]); 
            ctx.beginPath(); ctx.arc(0, 0, 25, 0, Math.PI*2); ctx.stroke();
            ctx.setLineDash([]); 

            // Ice Floor Cracks
            ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
            for(let i=0; i<8; i++) {
                ctx.save();
                ctx.rotate((i / 8) * Math.PI * 2);
                ctx.beginPath();
                ctx.moveTo(6, 0); 
                ctx.lineTo(18, 0); 
                ctx.stroke();
                ctx.restore();
            }

            // Mechanical Base Legs
            ctx.fillStyle = "#546e7a"; 
            for (let i = 0; i < 3; i++) {
                ctx.save();
                ctx.rotate((i * Math.PI * 2) / 3);
                ctx.beginPath();
                ctx.moveTo(-3, 5); ctx.lineTo(3, 5);
                ctx.lineTo(5, 14); ctx.lineTo(-5, 14);
                ctx.fill();
                ctx.fillStyle = "#00e5ff";
                ctx.fillRect(-1.5, 10, 3, 2); 
                ctx.fillStyle = "#546e7a";
                ctx.restore();
            }

            // --- 3. THE CRYSTAL (Floating) ---
            ctx.translate(0, -12); // Static hover height

            // Glow (Simple radial, no heavy shadowBlur)
            let glow = ctx.createRadialGradient(0, 0, 0, 0, 0, 20);
            glow.addColorStop(0, `rgba(0, 255, 255, 0.3)`);
            glow.addColorStop(1, "rgba(0, 255, 255, 0)");
            ctx.fillStyle = glow;
            ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI*2); ctx.fill();

            // Crystal Shape
            // Re-create gradient locally for the blueprint
            let crystalGrad = ctx.createLinearGradient(-6, -12, 6, 12);
            crystalGrad.addColorStop(0, "#e0f7fa");
            crystalGrad.addColorStop(0.5, "#00bcd4"); 
            crystalGrad.addColorStop(1, "#006064");
            ctx.fillStyle = crystalGrad;

            ctx.beginPath();
            ctx.moveTo(0, -14); ctx.lineTo(7, 0); ctx.lineTo(0, 14); ctx.lineTo(-7, 0);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = "rgba(255,255,255,0.9)";
            ctx.lineWidth = 1;
            ctx.stroke();

            // Inner Core
            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            ctx.rect(-3.5, -3.5, 7, 7); 
            ctx.fill();

            // Orbit Ring
            ctx.save();
            ctx.scale(1, 0.35); 
            ctx.strokeStyle = `rgba(0, 229, 255, 0.6)`;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI*2); 
            ctx.stroke();
            ctx.restore();

            ctx.restore(); // Restore main context

            // --- 4. RANGE INDICATOR ---
            // Only the range line indicates validity (Red/White)
            ctx.beginPath();
            ctx.arc(x, y, 160, 0, Math.PI * 2);
            ctx.strokeStyle ="rgba(255, 255, 255, 0.5)";
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }
}

function createExplosion(x, y, damage = 50, blastRadius = 60) {
    // 1. VISUALS
    // Add a simple particle burst if you have a particle system, otherwise just the circle
    if (typeof particles !== 'undefined') {
        // Example: Orange sparks
        for(let i=0; i<8; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
                life: 20, color: "orange"
            });
        }
    }
    
    // Draw the blast circle (flash)
    ctx.fillStyle = "rgba(255, 100, 0, 0.5)";
    ctx.beginPath();
    ctx.arc(x, y, blastRadius, 0, Math.PI * 2); 
    ctx.fill();

    // 2. DAMAGE LOGIC
    if (typeof enemies === 'undefined') return;

    for (let enemy of enemies) {
        // Safety Check
        if (!enemy || enemy.hp <= 0) continue;

        let dist = Math.hypot(enemy.x - x, enemy.y - y);

        // Check if inside explosion range
        if (dist < blastRadius) {
            if (enemy.isInvincible) {
                // BLOCKED!
                if (typeof createParticles === 'function') {
                    createParticles(enemy.x, enemy.y, "#00d2ff", 5); 
                }
            } else {
                // FIXED: Use the argument 'damage', not 'this.damage'
                enemy.hp -= damage;
            }
        }
    }
}

class Trap {
    constructor(x, y) {
        this.col = Math.floor(x / CELL_SIZE);
        this.row = Math.floor(y / CELL_SIZE);
        this.x = this.col * CELL_SIZE + CELL_SIZE / 2;
        this.y = this.row * CELL_SIZE + CELL_SIZE / 2;

        this.type = "TRAP";
        this.hp = 150;
        this.damage = 80;
        this.radius = 22;
        
        this.state = "READY";
        this.cooldown = 0;
        this.maxCooldown = 160;
    }

    update(dt) {
        if (this.state === "COOLDOWN") {
            this.cooldown--;
            if (this.cooldown <= 0) {
                this.state = "READY";
            }
        } 
        else if (this.state === "READY") {
            for (let e of enemies) {
                let d = Math.hypot(e.x - this.x, e.y - this.y);
                if (d < this.radius) {
                    this.trigger();
                    break; 
                }
            }
        }
    }

    trigger() {
        this.state = "COOLDOWN";
        this.cooldown = this.maxCooldown;

        if(typeof createParticles === 'function') {
            createParticles(this.x, this.y, "#ffffff", 8);
            createParticles(this.x, this.y, "#888888", 6);
        }

        for (let e of enemies) {
            let d = Math.hypot(e.x - this.x, e.y - this.y);
            if (d < this.radius + 8) { 
                e.hp -= this.damage;
                e.vx += (Math.random() - 0.5) * 10; 
                e.vy += (Math.random() - 0.5) * 10;
            }
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        // --- 1. TITANIUM BASE (Lighter for visibility) ---
        const size = CELL_SIZE - 4;
        const half = size / 2;

        // Base Plate Shape
        ctx.beginPath();
        ctx.moveTo(-half + 6, -half);
        ctx.lineTo(half - 6, -half);
        ctx.lineTo(half, -half + 6);
        ctx.lineTo(half, half - 6);
        ctx.lineTo(half - 6, half);
        ctx.lineTo(-half + 6, half);
        ctx.lineTo(-half, half - 6);
        ctx.lineTo(-half, -half + 6);
        ctx.closePath();

        // Gradient: Mid-Grey to Slate (Contrast against black BG)
        let baseGrad = ctx.createLinearGradient(-half, -half, half, half);
        baseGrad.addColorStop(0, "#6a6a70"); // Lighter top-left
        baseGrad.addColorStop(1, "#3a3a40"); // Darker bottom-right
        ctx.fillStyle = baseGrad;
        ctx.fill();

        // Bright Edge Highlight
        ctx.strokeStyle = "#889"; 
        ctx.lineWidth = 1;
        ctx.stroke();

        // Inner Panel (Darker but not black)
        ctx.fillStyle = "#222"; 
        ctx.fillRect(-half + 5, -half + 5, size - 10, size - 10);
        ctx.strokeStyle = "#111";
        ctx.strokeRect(-half + 5, -half + 5, size - 10, size - 10);

        // --- 2. SPIKE HOUSINGS ---
        const spikeOffset = 9;
        const spikePositions = [
            {x: -spikeOffset, y: -spikeOffset}, 
            {x: spikeOffset, y: -spikeOffset},  
            {x: -spikeOffset, y: spikeOffset},  
            {x: spikeOffset, y: spikeOffset}    
        ];

        for(let pos of spikePositions) {
            let isBack = pos.y < 0;

            // Housing Hole
            ctx.fillStyle = "#111"; // Not pure black
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 4.5, 0, Math.PI*2);
            ctx.fill();
            
            // Bright Rim (So holes are visible on the dark panel)
            ctx.strokeStyle = isBack ? "#555" : "#777";
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // --- 3. ANIMATION LOGIC ---
        let extension = 0;
        if (this.state === "COOLDOWN") {
            let pct = this.cooldown / this.maxCooldown;
            if (pct > 0.85) extension = (1 - pct) / 0.15; 
            else if (pct > 0.3) extension = 1.0;          
            else extension = pct / 0.3;                   
        }

        // --- 4. HIGH-CONTRAST SPIKES ---
        if (extension > 0.01) {
            const h = 24 * extension; 
            const w = 3;              

            for(let pos of spikePositions) {
                let sx = pos.x;
                let sy = pos.y;
                let tipY = sy - h;
                let isBack = sy < 0;

                // Shadow
                ctx.fillStyle = "rgba(0,0,0,0.6)";
                ctx.beginPath();
                ctx.ellipse(sx, sy + 3, w+1, w/1.5, 0, 0, Math.PI*2);
                ctx.fill();

                // Spike Gradient (Much brighter now)
                let steelGrad = ctx.createLinearGradient(sx - w, sy, sx + w, sy);
                
                if (isBack) {
                    // Back Row: Medium Steel
                    steelGrad.addColorStop(0.0, "#222");
                    steelGrad.addColorStop(0.2, "#444");
                    steelGrad.addColorStop(0.4, "#aaa"); // Highlight
                    steelGrad.addColorStop(0.7, "#666");
                    steelGrad.addColorStop(1.0, "#222");
                } else {
                    // Front Row: Bright Chrome
                    steelGrad.addColorStop(0.0, "#333");
                    steelGrad.addColorStop(0.2, "#666");
                    steelGrad.addColorStop(0.4, "#fff"); // Pure white shine
                    steelGrad.addColorStop(0.7, "#999");
                    steelGrad.addColorStop(1.0, "#333");
                }

                ctx.fillStyle = steelGrad;
                ctx.beginPath();
                ctx.moveTo(sx - w, sy);
                ctx.lineTo(sx + w, sy);
                ctx.lineTo(sx + w, tipY + 5); 
                ctx.lineTo(sx, tipY);       
                ctx.lineTo(sx - w, tipY + 5); 
                ctx.fill();
            }
        }

        // --- 5. CENTER INDICATOR (Bright LED) ---
        ctx.fillStyle = "#111";
        ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI*2); ctx.fill();

        // Neon Green or Bright Red
        let lightColor = (this.state === "READY") ? "#00ff00" : "#ff3333"; 
        ctx.fillStyle = lightColor;
        ctx.beginPath(); ctx.arc(0, 0, 1.5, 0, Math.PI*2); ctx.fill();
        
        if (this.state === "READY") {
            ctx.shadowColor = "#0f0";
            ctx.shadowBlur = 8; // Stronger glow
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        ctx.restore();
    }
}

class CryoTower {
    constructor(col, row) {
        this.col = col;
        this.row = row;
        this.x = col * CELL_SIZE + CELL_SIZE / 2;
        this.y = row * CELL_SIZE + CELL_SIZE / 2;
        this.type = "CRYO";
        this.range = 160;
        this.slowFactor = 0.5;

        // Animation State
        this.hoverY = 0;
        this.hoverTime = Math.random() * 100;
        this.spin = 0;
        this.pulse = 0;
        this.isFiring = false; 

        // --- OPTIMIZATION 1: RENDER STATIC BASE ONCE (Per instance) ---
        this.cacheCanvas = document.createElement('canvas');
        this.cacheCanvas.width = this.range * 2;
        this.cacheCanvas.height = this.range * 2;
        this.cacheCtx = this.cacheCanvas.getContext('2d');
        this.renderStaticBase(); 

        // --- OPTIMIZATION 2: INIT SHARED ASSETS (Run once for the whole class) ---
        // We create the heavy "Frost Field" and "Crystal Gradient" only once.
        // All CryoTowers will share these images instead of recalculating them.
        if (!CryoTower.cachedField) {
            CryoTower.createSharedAssets(this.range);
        }
    }

    // This creates the heavy graphics once and stores them in static properties
    static createSharedAssets(range) {
        // A. Cache the Frost Field (The big blue circle)
        const size = range * 2;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        const cx = range; 
        const cy = range;

        // 1. The Outer Ring
        ctx.beginPath();
        ctx.arc(cx, cy, range - 2, 0, Math.PI * 2); // -2 to keep inside canvas
        ctx.strokeStyle = "rgb(100, 240, 255)"; // Base color, opacity handled in draw
        ctx.lineWidth = 2;
        ctx.stroke();

        // 2. The Inner Gradient
        let grad = ctx.createRadialGradient(cx, cy, 10, cx, cy, range);
        grad.addColorStop(0, "rgba(255, 255, 255, 0)"); 
        grad.addColorStop(0.6, "rgba(0, 200, 255, 0.1)");
        grad.addColorStop(1, "rgba(200, 240, 255, 0.25)");
        ctx.fillStyle = grad;
        ctx.fill();

        CryoTower.cachedField = canvas;

        // B. Cache the Crystal Gradient (The teal look)
        // We create a tiny canvas just to generate the gradient object or store the data
        // Actually, we can just store the gradient function logic or create it on a temp canvas
        const gCanvas = document.createElement('canvas');
        const gCtx = gCanvas.getContext('2d');
        let crystalGrad = gCtx.createLinearGradient(-6, -12, 6, 12);
        crystalGrad.addColorStop(0, "#e0f7fa");
        crystalGrad.addColorStop(0.5, "#00bcd4"); 
        crystalGrad.addColorStop(1, "#006064");
        CryoTower.cachedCrystalGrad = crystalGrad;
    }

    renderStaticBase() {
        const c = this.cacheCtx;
        const r = this.range;
        const cx = r; 
        const cy = r; 

        // 1. Frost Aura Floor
        let grad = c.createRadialGradient(cx, cy, 10, cx, cy, r * 0.7);
        grad.addColorStop(0, "rgba(200, 240, 255, 0.1)");
        grad.addColorStop(1, "rgba(0, 0, 0, 0)");
        c.fillStyle = grad;
        c.beginPath(); c.arc(cx, cy, r, 0, Math.PI*2); c.fill();

        // 2. Tech Rune Ring
        c.save();
        c.translate(cx, cy);
        c.strokeStyle = "rgba(0, 225, 255, 0.15)";
        c.lineWidth = 1;
        c.setLineDash([4, 4]); 
        c.beginPath(); c.arc(0, 0, 25, 0, Math.PI*2); c.stroke();
        c.setLineDash([]); 
        c.restore();

        // 3. Ice Floor Cracks
        c.strokeStyle = "rgba(255, 255, 255, 0.4)";
        c.lineWidth = 1; 
        for(let i=0; i<8; i++) {
            c.save();
            c.translate(cx, cy);
            c.rotate((i / 8) * Math.PI * 2);
            c.beginPath();
            c.moveTo(6, 0); 
            c.lineTo(18 + Math.random() * 5, (Math.random()-0.5) * 4); 
            c.stroke();
            c.restore();
        }

        // 4. Mechanical Base Legs
        c.translate(cx, cy);
        c.fillStyle = "#546e7a"; 
        for (let i = 0; i < 3; i++) {
            c.save();
            c.rotate((i * Math.PI * 2) / 3);
            c.beginPath();
            c.moveTo(-3, 5); c.lineTo(3, 5);
            c.lineTo(5, 14); c.lineTo(-5, 14);
            c.fill();
            c.fillStyle = "#00e5ff";
            c.fillRect(-1.5, 10, 3, 2); 
            c.fillStyle = "#546e7a";
            c.restore();
        }
    }

    update(dt) {
        if (this.hp <= 0) this.active = false;
        // Assuming 'grid' and 'enemies' are global variables
        if (!grid[this.col][this.row].occupied) this.active = false;
        this.hoverTime += 0.05 *dt;
        this.hoverY = Math.sin(this.hoverTime) * 3;
        
        let spinSpeed = this.isFiring ? 0.10 : 0.02;
        this.spin += spinSpeed;
        this.pulse = (Math.sin(this.hoverTime * 3) + 1) / 2; 

        this.isFiring = false; 

        // Optimization: Simple distance check
        for (let e of enemies) {
            // Pre-check rect collision (faster than hypot) to skip far enemies
            if (Math.abs(e.x - this.x) > this.range || Math.abs(e.y - this.y) > this.range) continue;

            let dist = Math.hypot(e.x - this.x, e.y - this.y);
            if (dist < this.range) {
                e.isSlowed = true;
                this.isFiring = true; 
                
                if (Math.random() < 0.05 && typeof createParticles === 'function') {
                    createParticles(e.x, e.y, "#caf0f8", 1); 
                }
            }
        }
    }

    drawFrostField() {
        if (!this.isFiring) return;

        // Optimization: Draw the Pre-rendered image instead of calculating gradient
        ctx.globalAlpha = 0.3 + (this.pulse * 0.2); // Pulse opacity
        ctx.drawImage(CryoTower.cachedField, this.x - this.range, this.y - this.range);
        ctx.globalAlpha = 1.0; // Reset
    }

    draw() {
        // 1. Static Base (Cached instance)
        ctx.drawImage(this.cacheCanvas, this.x - this.range, this.y - this.range);

        // 2. Frost Field (Cached shared)
        this.drawFrostField();

        // 3. The Crystal
        ctx.save();
        ctx.translate(this.x, this.y + this.hoverY - 12); 

        // OPTIMIZATION: "Fake" Glow using Radial Gradient instead of shadowBlur
        // shadowBlur is very laggy. This looks 95% the same but is instant.
        const glowSize = this.isFiring ? 30 : 20;
        const glowOpacity = this.isFiring ? 0.6 : 0.3;
        
        // Draw the glow *behind* the crystal
        let glow = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
        glow.addColorStop(0, `rgba(0, 255, 255, ${glowOpacity})`);
        glow.addColorStop(1, "rgba(0, 255, 255, 0)");
        ctx.fillStyle = glow;
        ctx.beginPath(); 
        ctx.arc(0, 0, glowSize, 0, Math.PI*2); 
        ctx.fill();

        ctx.globalCompositeOperation = "lighter"; 
        
        // Rotating Shell
        ctx.save();
        ctx.rotate(this.spin);
        
        // Use the SHARED Cached Gradient
        ctx.fillStyle = CryoTower.cachedCrystalGrad;
        
        ctx.beginPath();
        ctx.moveTo(0, -14); ctx.lineTo(7, 0); ctx.lineTo(0, 14); ctx.lineTo(-7, 0);
        ctx.closePath();
        ctx.fill();
        
        ctx.strokeStyle = "rgba(255,255,255,0.9)";
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();

        // Inner Core
        ctx.save();
        ctx.rotate(-this.spin * 1.5); 
        ctx.fillStyle = "#ffffff";
        ctx.globalAlpha = 0.8 + (this.pulse * 0.2); 
        ctx.beginPath();
        ctx.rect(-3.5, -3.5, 7, 7); 
        ctx.fill();
        ctx.restore();

        // Rings
        ctx.globalCompositeOperation = "source-over"; 
        // Removed shadowBlur here too
        
        ctx.save();
        ctx.scale(1, 0.35); 
        ctx.strokeStyle = `rgba(0, 229, 255, ${0.4 + this.pulse * 0.4})`;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(0, 0, 20, 0, Math.PI*2); 
        ctx.stroke();
        ctx.restore();

        ctx.restore();
    }
}

class WallTurret {
    constructor(col, row, angle) {
        // Positioning
        this.col = col;
        this.row = row;
        this.x = col * CELL_SIZE + CELL_SIZE / 2;
        this.y = row * CELL_SIZE + CELL_SIZE / 2;

        // Angles
        this.baseAngle = angle;    
        this.headAngle = angle;    
        this.fov = 120 * (Math.PI / 180); 

        // Combat Stats
        this.range = 400; 
        this.damage = 5; 
        this.cooldown = 0;
        this.maxCooldown = 90; 
        this.active = true;

        // Health
        this.hp = 300; 

        // Visual States
        this.recoil = 0;       
        this.flashTimer = 0;   
    }

    update(dt) {
        let cell = grid[this.col][this.row];

        // 1. DEATH CHECK
        if (!cell.wall) {
            this.active = false;
            createParticles(this.x, this.y, "#333", 12); 
            return;
        }

        this.hp = cell.wallHp;

        // 2. TIMERS
        if (this.cooldown > 0) this.cooldown--;
        if (this.recoil > 0) this.recoil -= 0.5; 
        if (this.flashTimer > 0) this.flashTimer--; 

        // 3. TARGETING
        let targetAngle = this.baseAngle; 
        
        for (let e of enemies) {
            let dx = e.x - this.x;
            let dy = e.y - this.y;
            let dist = Math.hypot(dx, dy);

            if (dist < this.range) {
                let angleToEnemy = Math.atan2(dy, dx);
                let diff = angleToEnemy - this.baseAngle;
                while (diff < -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;

                if (Math.abs(diff) < this.fov / 2) {
                    targetAngle = angleToEnemy; 

                    // FIRE LOGIC
                    if (this.cooldown <= 0) {
                        projectiles.push(new Bullet(this.x, this.y, e, this.damage, 1.8));
                        
                        this.cooldown = this.maxCooldown;
                        this.recoil = 14;     
                        this.flashTimer = 6; 
                        
                        // Muzzle debris
                        let tipX = this.x + Math.cos(this.headAngle) * 40;
                        let tipY = this.y + Math.sin(this.headAngle) * 40;
                        createParticles(tipX, tipY, "#ff9800", 6); 
                        createParticles(tipX, tipY, "#777", 4);    
                    }
                    break; 
                }
            }
        }

        // 4. SMOOTH ROTATION
        let rotDiff = targetAngle - this.headAngle;
        while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
        while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
        this.headAngle += rotDiff * 0.15; 
    }

    draw() {
        // --- LAYER 1: HEAVY MOUNT ---
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.baseAngle); 
        
        // Base Shadow
        ctx.fillStyle = "rgba(0,0,0,0.6)"; 
        ctx.beginPath(); ctx.arc(0, 0, 16, 0, Math.PI*2); ctx.fill();

        // Industrial Hex Base
        ctx.fillStyle = "#263238"; 
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            ctx.lineTo(15 * Math.cos(i * Math.PI / 3), 15 * Math.sin(i * Math.PI / 3));
        }
        ctx.fill();
        ctx.strokeStyle = "#37474f"; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI*2); ctx.stroke();
        ctx.restore();


        // --- LAYER 2: THE TRIANGULAR TANK KILLER ---
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.headAngle);

        // A. Laser Rangefinder (CHANGED TO WHITE)
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(this.range, 0);
        ctx.strokeStyle = "rgba(255, 255, 255, 0.3)"; // White beam
        ctx.lineWidth = 1;
        ctx.setLineDash([20, 20]); ctx.stroke(); ctx.setLineDash([]); 

        // B. Shadow 
        ctx.fillStyle = "rgba(0,0,0,0.5)"; 
        ctx.beginPath();
        ctx.moveTo(14, 0); ctx.lineTo(-12, -16); ctx.lineTo(-12, 16);
        ctx.fill();

        // C. RECOIL
        let kick = -this.recoil; 

        // --- D. THE HEAVY CANNON ---
        ctx.fillStyle = "#1c1c1c"; ctx.fillRect(0 + kick, -7, 12, 14); // Breech
        ctx.fillStyle = "#455a64"; ctx.fillRect(10 + kick, -5, 30, 10); // Barrel
        
        // Thermal Sleeve
        ctx.fillStyle = "#37474f"; ctx.fillRect(22 + kick, -6, 10, 12); 
        ctx.fillStyle = "#546e7a"; ctx.fillRect(26 + kick, -6, 2, 12);

        // Muzzle Brake
        ctx.fillStyle = "#212121";
        ctx.beginPath();
        ctx.moveTo(38 + kick, -8); ctx.lineTo(46 + kick, -8); 
        ctx.lineTo(48 + kick, -6); ctx.lineTo(48 + kick, 6);
        ctx.lineTo(46 + kick, 8);  ctx.lineTo(38 + kick, 8);
        ctx.closePath(); ctx.fill();
        
        // Heat Tip (CHANGED TO WHITE)
        ctx.fillStyle = "#ffffff"; // Pure White (White Hot Metal)
        ctx.shadowColor = "white"; 
        ctx.shadowBlur = 5;
        ctx.fillRect(47 + kick, -5, 2, 10);
        ctx.shadowBlur = 0; // Reset shadow

        // --- E. COMPLEX TRIANGULAR HOUSING ---
        
        // 1. Lower Armor Plate (Wide Delta Wing)
        ctx.fillStyle = "#37474f"; 
        ctx.beginPath();
        ctx.moveTo(16 + kick, 0);       
        ctx.lineTo(0 + kick, -10);      
        ctx.lineTo(-10 + kick, -18);    
        ctx.lineTo(-14 + kick, -12);    
        ctx.lineTo(-18 + kick, 0);      
        ctx.lineTo(-14 + kick, 12);     
        ctx.lineTo(-10 + kick, 18);     
        ctx.lineTo(0 + kick, 10);       
        ctx.closePath();
        ctx.fill();

        // 2. Upper Armor Plate (Raised Central Arrow)
        ctx.fillStyle = "#546e7a"; 
        ctx.beginPath();
        ctx.moveTo(14 + kick, 0);       
        ctx.lineTo(-12 + kick, -8);     
        ctx.lineTo(-16 + kick, 0);      
        ctx.lineTo(-12 + kick, 8);      
        ctx.closePath();
        ctx.fill();

        // 3. Central Spine
        ctx.strokeStyle = "rgba(0,0,0,0.2)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-16 + kick, 0); ctx.lineTo(14 + kick, 0);
        ctx.stroke();

        // 4. Side Vents
        ctx.fillStyle = "#263238"; 
        ctx.beginPath(); ctx.moveTo(-8 + kick, -14); ctx.lineTo(-4 + kick, -12); ctx.lineTo(-8 + kick, -10); ctx.fill();
        ctx.beginPath(); ctx.moveTo(-8 + kick, 14); ctx.lineTo(-4 + kick, 12); ctx.lineTo(-8 + kick, 10); ctx.fill();

        // 5. Optics (Status light changed to White for cooldown)
        ctx.fillStyle = this.cooldown > 0 ? "#ff0000" : "#00e676"; 
        ctx.fillRect(-10 + kick, -3, 4, 6);
        

        // F. MUZZLE FLASH
        if (this.flashTimer > 0) {
            ctx.fillStyle = "#fff";
            ctx.beginPath(); ctx.ellipse(50 + kick, 0, 10, 6, 0, 0, Math.PI*2); ctx.fill();
            
            ctx.fillStyle = `rgba(255, 160, 0, ${this.flashTimer / 5})`; 
            let size = 15 + Math.random() * 5;
            ctx.beginPath(); ctx.arc(52 + kick, 0, size, 0, Math.PI*2); ctx.fill();
            
            ctx.strokeStyle = `rgba(255, 200, 50, ${this.flashTimer / 5})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(48+kick, -5); ctx.lineTo(65+kick, -15);
            ctx.moveTo(48+kick, 5); ctx.lineTo(65+kick, 15);
            ctx.stroke();
        }
        ctx.restore();


        // --- LAYER 3: HEALTH BAR ---
        let maxHp = 300; 
        if (this.hp < maxHp && this.hp > 0) {
            let hpPct = Math.max(0, this.hp / maxHp);
            ctx.fillStyle = "#111"; ctx.fillRect(this.x - 16, this.y - 28, 32, 4);
            if (hpPct > 0.6) ctx.fillStyle = "#00e676";      
            else if (hpPct > 0.3) ctx.fillStyle = "#ffea00"; 
            else ctx.fillStyle = "#ff1744";                   
            ctx.fillRect(this.x - 15, this.y - 27, 30 * hpPct, 2);
        }
    }
}

class Minigun {
    constructor(col, row) {
        this.col = col;
        this.row = row;
        this.x = col * CELL_SIZE + CELL_SIZE / 2;
        this.y = row * CELL_SIZE + CELL_SIZE / 2;

        // --- STATS ---
        this.range = 280;
        this.damage = 3;
        this.maxFireRate = 2;
        this.currentFireTimer = 0;
        this.maxHp = 500;
        this.hp = this.maxHp;
        this.active = true;

        // --- VISUALS ---
        this.angle = 0;
        this.spinSpeed = 0;
        this.heat = 0;
        this.recoil = 0;
        this.barrelScroll = 0;
        this.shells = [];
    }

    update(dt) {
        if (this.hp <= 0) this.active = false;
        // Assuming 'grid' and 'enemies' are global variables
        if (!grid[this.col][this.row].occupied) this.active = false;

        // 1. Target Finding
        let target = null;
        let minDist = this.range;
        for (let e of enemies) {
            let d = Math.hypot(e.x - this.x, e.y - this.y);
            if (d < minDist) {
                minDist = d;
                target = e;
            }
        }

        // 2. State Logic
        if (target) {
            let dx = target.x - this.x;
            let dy = target.y - this.y;
            let targetAngle = Math.atan2(dy, dx);

            // Aiming (Smooth)
            let angleDiff = targetAngle - this.angle;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            this.angle += angleDiff * 0.15;

            // Spool Up
            this.spinSpeed = Math.min(this.spinSpeed + 0.05, 1.0);

            // Fire Logic
            if (Math.abs(angleDiff) < 0.6 && this.spinSpeed > 0.8) {
                if (this.currentFireTimer <= 0) {
                    this.currentFireTimer = this.maxFireRate;
                    this.recoil = 4; // Slightly more visual recoil
                    this.heat = Math.min(this.heat + 0.04, 1.0);

                    // Muzzle Position logic
                    const barrelLen = 45 - this.recoil; // Longer visual barrel
                    const mx = this.x + Math.cos(this.angle) * barrelLen;
                    const my = this.y + Math.sin(this.angle) * barrelLen;

                    const spread = (Math.random() - 0.5) * 0.25;
                    const fireAngle = this.angle + spread;

                    // FIRE
                    projectiles.push(new MinigunBullet(mx, my, fireAngle, this.damage, 9));

                    // Flash
                    if (typeof createParticles === 'function') createParticles(mx, my, "#ffcc00", 2);

                    // Eject Shells
                    this.shells.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(this.angle - 1.8) * 3 + (Math.random() - 0.5), // Eject slightly back-right
                        vy: Math.sin(this.angle - 1.8) * 3 + (Math.random() - 0.5),
                        life: 20, angle: Math.random() * 6
                    });
                }
            }
        } else {
            // Spool Down
            this.spinSpeed *= 0.96;
            this.heat *= 0.97;
        }

        if (this.currentFireTimer > 0) this.currentFireTimer--;
        this.recoil *= 0.8;
        this.barrelScroll += this.spinSpeed * 3;

        // Update Shells
        for (let s of this.shells) { s.x += s.vx; s.y += s.vy; s.life--; s.vx *= 0.9; s.vy *= 0.9; }
        this.shells = this.shells.filter(s => s.life > 0);
    }

    draw() {
        // --- 0. SHELL CASINGS (On the floor) ---
        ctx.fillStyle = "#d4af37"; 
        for (let s of this.shells) {
            ctx.save();
            ctx.translate(s.x, s.y);
            ctx.rotate(s.angle);
            ctx.fillRect(-2, -1, 4, 2);
            ctx.restore();
        }

        ctx.save();
        ctx.translate(this.x, this.y);

        // --- 1. INDUSTRIAL BASE (New Shape) ---
        // Drop shadow for the base
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.beginPath(); ctx.arc(2, 2, 22, 0, Math.PI * 2); ctx.fill();

        // Main X-Stand
        ctx.fillStyle = "#1a1a1a"; // Dark Metal
        
        // Draw 4 distinct heavy legs
        for(let i=0; i<4; i++) {
            ctx.save(); 
            ctx.rotate((Math.PI/4) + (i * Math.PI/2)); // Rotate 45 deg for X shape
            
            // Leg Strut
            ctx.fillRect(-6, -6, 12, 24); 
            
            // Foot Pad (Chamfered look)
            ctx.fillStyle = "#333";
            ctx.beginPath();
            ctx.moveTo(-8, 18); ctx.lineTo(8, 18);
            ctx.lineTo(10, 24); ctx.lineTo(-10, 24);
            ctx.fill();
            
            // Bolt detail on leg
            ctx.fillStyle = "#555";
            ctx.beginPath(); ctx.arc(0, 12, 2, 0, Math.PI*2); ctx.fill();
            
            ctx.restore();
        }

        // Central Bearing Ring (The turret sits on this)
        ctx.fillStyle = "#222";
        ctx.beginPath(); ctx.arc(0,0, 16, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#444"; ctx.lineWidth = 2; ctx.stroke();
        
        // Rivets on the ring
        ctx.fillStyle = "#666";
        for(let i=0; i<8; i++){
            let ra = i * (Math.PI*2)/8;
            ctx.beginPath(); ctx.arc(Math.cos(ra)*12, Math.sin(ra)*12, 1.5, 0, Math.PI*2); ctx.fill();
        }

        // --- 2. AMMO SYSTEM (Calculated before rotation) ---
        const ammoX = -28;
        const ammoY = 18;
        
        // Calculate where the belt connects to the gun (The "Feed Port")
        // We project a point relative to the gun's angle
        let feedPortX = Math.cos(this.angle - 0.5) * 8; // Offset to the side of the gun
        let feedPortY = Math.sin(this.angle - 0.5) * 8;

        // Belt Curve
        ctx.beginPath();
        ctx.moveTo(ammoX, ammoY);
        // Control point moves slightly with gun to fake flexibility
        ctx.quadraticCurveTo(ammoX, ammoY - 25, feedPortX, feedPortY);
        
        ctx.lineWidth = 7; ctx.strokeStyle = "#111"; ctx.stroke(); // Belt Backing
        ctx.lineWidth = 4; ctx.strokeStyle = "#d4af37"; ctx.setLineDash([2, 3]); ctx.stroke(); // Bullets
        ctx.setLineDash([]);

        // Ammo Box (Green Metal)
        ctx.fillStyle = "#2f3f2f";
        ctx.fillRect(ammoX - 10, ammoY - 10, 24, 20);
        ctx.fillStyle = "#4a5b4a"; // Lid
        ctx.fillRect(ammoX - 8, ammoY - 12, 20, 4);

        // --- 3. ROTATING TURRET HEAD ---
        ctx.rotate(this.angle);
        const kick = -this.recoil;

        // -- Rear Motor Housing (Rounded back) --
        ctx.fillStyle = "#222";
        ctx.beginPath();
        ctx.arc(-12 + kick, 0, 11, Math.PI/2, -Math.PI/2); // Half circle back
        ctx.fill();
        ctx.fillRect(-12 + kick, -11, 10, 22); // Connect to body

        // -- Main Receiver Body --
        ctx.fillStyle = "#3a3a3a"; // Lighter grey for contrast
        // Top shape
        ctx.beginPath();
        ctx.moveTo(-5 + kick, -10);
        ctx.lineTo(15 + kick, -10);
        ctx.lineTo(15 + kick, 10);
        ctx.lineTo(-5 + kick, 10);
        ctx.fill();
        
        // Side mounting plate visual
        ctx.fillStyle = "#1a1a1a";
        ctx.fillRect(-2 + kick, -11, 6, 22);

        // -- BARREL BUNDLE --
        const bW = 46; // Length
        const bH = 14; // Width
        const bX = 15 + kick;
        const bY = -bH/2;

        ctx.fillStyle = "#050505"; // Very dark barrel base
        ctx.fillRect(bX, bY, bW, bH);

        // Spinning Animation (Clipped)
        ctx.save();
        ctx.beginPath(); ctx.rect(bX, bY, bW, bH); ctx.clip();

        // Heat Gradient
        // Calculate color based on heat: Black -> Red -> Orange -> White/Yellow
        let heatR = 60 + (this.heat * 195);
        let heatG = 60 + (this.heat * 140);
        let heatB = 60;
        ctx.fillStyle = `rgb(${heatR}, ${heatG}, ${heatB})`;

        const spacing = 5;
        const scroll = this.barrelScroll % spacing;
        
        // Draw horizontal lines representing the barrels spinning
        for(let i = -spacing; i < bH + spacing; i += spacing) {
            let yPos = bY + i + scroll;
            // Draw barrel tube
            ctx.fillRect(bX, yPos, bW, 2);
            // Highlight (shine)
            ctx.fillStyle = "rgba(255,255,255,0.3)";
            ctx.fillRect(bX, yPos, bW, 1);
            ctx.fillStyle = `rgb(${heatR}, ${heatG}, ${heatB})`; // Reset color
        }
        ctx.restore();

        // -- Barrel Details --
        // 1. Clamp Ring (Middle of barrel)
        ctx.fillStyle = "#222";
        ctx.fillRect(bX + 20, bY - 1, 4, bH + 2);
        
        // 2. Muzzle Plate (The very front tip)
        ctx.fillStyle = "#111";
        ctx.fillRect(bX + bW - 2, bY - 1, 3, bH + 2);
        // Little dots on muzzle plate to show holes
        ctx.fillStyle = "#000";
        ctx.beginPath(); ctx.arc(bX + bW, -3, 1, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(bX + bW, 3, 1, 0, Math.PI*2); ctx.fill();

        ctx.restore(); // End Rotation

        // --- 4. HEALTH BAR ---
        if(typeof drawHealth === 'function') drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class MoneyFarm {
    constructor(col, row) {
        this.col = col;
        this.row = row;
        this.x = col * CELL_SIZE;
        this.y = row * CELL_SIZE;
        
        // Stats
        this.amount = 50;        // Money per wave
        this.active = true;
        
        // Wave Tracking
        this.lastPaidWave = wave; // Track the last wave we paid out for
        
        // Visual Animation
        this.spin = 0;
        this.visualTimer = 0; // Kept for animation loops
        
        // Popup Text Stats
        this.popupText = "";
        this.popupAlpha = 0;
        this.popupY = 0;
    }

    update(dt) {
        // 1. Check if base is still intact
        let isIntact = true;
        for(let i=0; i<2; i++) {
            for(let j=0; j<2; j++) {
                if (!grid[this.col+i][this.row+j].wall) {
                    isIntact = false;
                }
            }
        }

        if (!isIntact) {
            this.cleanup();
            let idx = structures.indexOf(this);
            if (idx !== -1) structures.splice(idx, 1);
            return;
        }

        // 2. Generate Money (Per Wave)
        if (wave > this.lastPaidWave) {
            // Payout
            money += this.amount;
            this.lastPaidWave = wave;
            
            // Visual Popup Init
            this.popupText = "+$" + this.amount;
            this.popupAlpha = 1.0; // Fully visible
            this.popupY = this.y;  // Start at top of building
            
            // Update UI
            if(document.getElementById('money')) document.getElementById('money').innerText = Math.floor(money);
        }

        // 3. Update Visuals
        this.spin += 0.05;
        this.visualTimer += dt;
        
        // Handle Popup Animation (Float up and Fade out)
        if (this.popupAlpha > 0) {
            this.popupY -= 0.5; // Float up
            this.popupAlpha -= 0.01; // Fade out
            if (this.popupAlpha < 0) this.popupAlpha = 0;
        }
    }

    draw() {
        let cx = this.x + CELL_SIZE;
        let cy = this.y + CELL_SIZE;
        let radius = CELL_SIZE - 5;
       
        // We set pct to roughly 0.95 so it looks "active" and glowing, 
        // but keeps the colors interesting (Magenta -> Cyan).
        let pct = 1; 

        // --- 1. THE BASE PAD (Background) ---
        ctx.fillStyle = "#1a1a22"; 
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI*2);
        ctx.fill();

        ctx.save();
        ctx.strokeStyle = "#330066"; 
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cx, cy, radius * 0.8, 0, Math.PI*2);
        ctx.arc(cx, cy, radius * 0.5, 0, Math.PI*2);
        for(let i=0; i<8; i++) {
            let angle = (Math.PI/4) * i;
            ctx.moveTo(cx + Math.cos(angle)*(radius*0.5), cy + Math.sin(angle)*(radius*0.5));
            ctx.lineTo(cx + Math.cos(angle)*radius, cy + Math.sin(angle)*radius);
        }
        ctx.stroke();
        ctx.restore();


        // --- 2. THE PROGRESS RING (Circular Energy Gauge) ---
        let gaugeRadius = radius * 0.75;
        ctx.save();
        ctx.lineWidth = 8;
        ctx.lineCap = "round"; 

        // 2a. Background track
        ctx.strokeStyle = "rgba(100, 0, 200, 0.2)";
        ctx.beginPath();
        ctx.arc(cx, cy, gaugeRadius, 0, Math.PI*2);
        ctx.stroke();

        // 2b. The filling energy arc
        let startAngle = -Math.PI / 2;
        let endAngle = startAngle + (Math.PI * 2 * pct);
        
        let colorStart = "#aa00ff"; 
        let colorEnd = "#00eeff"; 

        let gaugeGrad = ctx.createLinearGradient(this.x, this.y, this.x + CELL_SIZE*2, this.y + CELL_SIZE*2);
        gaugeGrad.addColorStop(0, colorStart);
        gaugeGrad.addColorStop(1, colorEnd);

        ctx.strokeStyle = gaugeGrad;
        ctx.shadowColor = colorEnd;
        ctx.shadowBlur = 15;
        
        ctx.beginPath();
        ctx.arc(cx, cy, gaugeRadius, startAngle, endAngle, false);
        ctx.stroke();
        ctx.restore();


        // --- 3. THE CENTRAL XENO-CROP (Alien Crystal Plant) ---
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(Date.now() / 3000);
        
        let coreColor = "#ff00aa"; 
        let outerColor = "#7700aa";

        let plantSize = radius * 0.4;
        
        // Outer petals
        ctx.fillStyle = outerColor;
        ctx.beginPath();
        for(let i=0; i<8; i+=2) { 
             let angle = (Math.PI*2/8) * i;
             ctx.moveTo(0,0);
             ctx.lineTo(Math.cos(angle - 0.3) * plantSize, Math.sin(angle - 0.3) * plantSize);
             ctx.lineTo(Math.cos(angle) * plantSize * 1.2, Math.sin(angle) * plantSize * 1.2); 
             ctx.lineTo(Math.cos(angle + 0.3) * plantSize, Math.sin(angle + 0.3) * plantSize);
        }
        ctx.fill();

        // Inner Core 
        let pulse = Math.sin(Date.now() / 400) * 3;
        let coreSize = (plantSize * 0.5) + pulse;

        ctx.fillStyle = coreColor;
        ctx.shadowColor = coreColor;
        ctx.shadowBlur = 25; 
        ctx.beginPath();
        for(let i=0; i<6; i++) {
            let angle = (Math.PI*2/6) * i;
            let px = Math.cos(angle) * coreSize;
            let py = Math.sin(angle) * coreSize;
            if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();


        // --- 4. ORBITING HARVEST DRONES ---
        // I removed the (pct < 1) check so they are ALWAYS visible
        ctx.save();
        ctx.translate(cx, cy);
        let orbitSpeed = Date.now() / 600;
        let numParticles = 3;
        
        ctx.fillStyle = "#00ffff";
        ctx.shadowColor = "#ffffff";
        ctx.shadowBlur = 10;

        for(let i=0; i<numParticles; i++) {
            let angle = orbitSpeed + (Math.PI*2 / numParticles) * i;
            let px = Math.cos(angle) * gaugeRadius;
            let py = Math.sin(angle) * gaugeRadius;
            
            ctx.beginPath();
            ctx.arc(px, py, 3, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.restore();
        
        // --- 5. FLOATING MONEY TEXT ---
        if (this.popupAlpha > 0) {
            ctx.save();
            ctx.globalAlpha = this.popupAlpha;
            ctx.font = "bold 15px 'Segoe UI', sans-serif";
            ctx.fillStyle = "#ffd700"; // Gold color
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.textAlign = "center";
            
            // Draw Outline
            ctx.strokeText(this.popupText, cx, this.popupY);
            // Draw Fill
            ctx.fillText(this.popupText, cx, this.popupY);
            
            ctx.restore();
        }
    }

    cleanup() {
        for(let i=0; i<2; i++) {
            for(let j=0; j<2; j++) {
                if (this.col + i < COLS && this.row + j < ROWS) {
                    let c = grid[this.col+i][this.row+j];
                    c.occupied = false;
                    c.wall = false;
                    c.wallHp = 100;
                }
            }
        }
        updateFlowField(); 
    }
}
// Helper function for rounded rectangles (paste this outside the class or method)
function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

    /** CORE SYSTEMS **/
const VIRTUAL_WIDTH = COLS * CELL_SIZE; 
const VIRTUAL_HEIGHT = ROWS * CELL_SIZE;

let scale = 1;
let offsetX = 0;
let offsetY = 0;

// Calculates how to fit the game into the current window
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // 1. Determine Scale: Fit width OR height, whichever is smaller
    let scaleX = window.innerWidth / VIRTUAL_WIDTH;
    let scaleY = window.innerHeight / VIRTUAL_HEIGHT;
    scale = Math.min(scaleX, scaleY);

    // 2. Determine Centering (Letterboxing)
    // We calculate how much empty space is left and divide by 2 to center it
    offsetX = (window.innerWidth - (VIRTUAL_WIDTH * scale)) / 2;
    offsetY = (window.innerHeight - (VIRTUAL_HEIGHT * scale)) / 2;
}

    function init() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    
    // --- 1. SETUP SCALING ---
    // Apply initial size and event listener for future window resizing
    resize();
    window.addEventListener('resize', resize);

        
        // Init Grid
        for (let x = 0; x < COLS; x++) {
            grid[x] = [];
            for (let y = 0; y < ROWS; y++) {
                grid[x][y] = new Cell(x, y);
                grid[x][y].wallHp = 100;
            }
        }

        // --- BASE OCCUPANCY (2x2) ---
        // Mark the 4 cells covered by the base as occupied so nothing can be built there
        for(let i = 0; i < 2; i++) {
            for(let j = 0; j < 2; j++) {
                let bx = playerBase.x + i;
                let by = playerBase.y + j;
                if (bx >= 0 && bx < COLS && by >= 0 && by < ROWS) {
                    grid[bx][by].occupied = true; 
                }
            }
        }

         // --- 4. BORDERS ---
    // Wall off Top and Bottom
    for (let x = 0; x < COLS; x++) {
        grid[x][0].wall = true;
        grid[x][ROWS - 1].wall = true; 
    }
    // Wall off Left side
    for (let y = 0; y < ROWS; y++) {
        grid[0][y].wall = true;
    }

    // --- 5. INPUT LISTENERS (With Scaling Math) ---
    
    // Helper to calculate Game Coordinates from Screen Coordinates
    function updateMousePos(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        
        // 1. Get position relative to canvas element
        let rawX = clientX - rect.left;
        let rawY = clientY - rect.top;

        // 2. Subtract the black bars (offset) and divide by the zoom level (scale)
        mouseX = (rawX - offsetX) / scale;
        mouseY = (rawY - offsetY) / scale;
    }

        // --- INPUT LISTENERS ---
        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            updateMousePos(e.clientX, e.clientY);
            handleInput(); 
        });

        window.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        // Track mouse position AND handle dragging
        // (This is the correct one using getBoundingClientRect)
        window.addEventListener('mousemove', (e) => {
            updateMousePos(e.clientX, e.clientY);
            
            if (isMouseDown) {
                handleInput();
            }
        });

        window.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();

        // Tools
        if(key === '1') setTool('wall');
        if(key === '2') setTool('troop');
        if(key === '3') setTool('barracks');
        if(key === '4') setTool('mortar');
        if(key === '5') setTool('delete');
        if(key === '6') setTool('trap'); // Added trap back in if you have it
        if(key === '7') setTool('wall_turret');
        if(key === '8') setTool('money_farm');
        if(key === '9') setTool('sword_troop');
        if(key === 's') setTool('shield_troop');
        
        // Rotation
        if (key === 'r') {
            buildRotation = (buildRotation + Math.PI / 2) % (Math.PI * 2);
        }
    });

        // --- GAME START ---
        updateFlowField();
        
        // NEW: Trigger the first wave + Animation immediately
        wave = 0; 
        startNextWave(); 

        requestAnimationFrame(gameLoop);
    }

   function updateFlowField() {
        // 1. Reset grid
        for (let x = 0; x < COLS; x++) {
            for (let y = 0; y < ROWS; y++) {
                grid[x][y].distance = Infinity; 
                grid[x][y].vecX = 0;
                grid[x][y].vecY = 0;
            }
        }

        // 2. BFS Flood Fill starting from Base
        let queue = [];
        // Ensure base is within bounds
        if(playerBase.x >= 0 && playerBase.x < COLS && playerBase.y >= 0 && playerBase.y < ROWS) {
            let baseCell = grid[playerBase.x][playerBase.y];
            baseCell.distance = 0;
            queue.push(baseCell);
        }

        while (queue.length > 0) {
            let current = queue.shift();

            // Neighbors (Up, Down, Left, Right)
            let neighbors = [
                {x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}
            ];

            for (let n of neighbors) {
                let nx = current.x + n.x;
                let ny = current.y + n.y;

                if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
                    let nextCell = grid[nx][ny];
                    
                    // If it's not a wall and we haven't visited it yet
                    if (!nextCell.wall && nextCell.distance === Infinity) {
                        nextCell.distance = current.distance + 1;
                        // Point vector towards current (the way we came from)
                        nextCell.vecX = -n.x;
                        nextCell.vecY = -n.y;
                        queue.push(nextCell);
                    }
                }
            }
        }
    }

    // TOOL SELECTION FUNCTION
    function setTool(toolName) {
        currentTool = toolName;
        
        // Remove 'active' class from all buttons
        const buttons = document.getElementsByClassName('tool-btn');
        for (let i = 0; i < buttons.length; i++) {
            buttons[i].classList.remove('active');
        }

        // Highlight the correct button
        let btnId = '';
        switch(toolName) {
            case 'wall':        btnId = 'btn-wall'; break;
            case 'cryo_tower':  btnId = 'btn-cryo'; break;
            case 'trap':        btnId = 'btn-trap'; break;
            case 'wall_turret': btnId = 'btn-wallturret'; break;
            case 'troop':       btnId = 'btn-troop'; break;
            case 'sword_troop': btnId = 'btn-sword'; break;
            case 'barracks':    btnId = 'btn-barracks'; break;
            case 'mortar':      btnId = 'btn-mortar'; break;
            case 'money_farm':  btnId = 'btn-farm'; break;
            case 'delete':      btnId = 'btn-delete'; break;
            case 'minigun':     btnId = 'btn-minigun'; break; // <--- NEW LINE
        }

        if (btnId) {
            const btn = document.getElementById(btnId);
            if (btn) btn.classList.add('active');
        }
    }

    function handleInput() {
        if (gameOver) return;

        // Calculate Grid Coordinates of the mouse
        let col = Math.floor(mouseX / CELL_SIZE);
        let row = Math.floor(mouseY / CELL_SIZE);

        // Bounds Check
        if (col < 0 || col >= COLS || row < 0 || row >= ROWS) return;

        let cell = grid[col][row];
        let didChange = false; 

        // --- WALL TOOL ---
        if (currentTool === 'wall') {
            if (!cell.wall && !cell.occupied && money >= 10) {
                cell.wall = true;
                cell.wallHp = 100;
                money -= 10;
                didChange = true;
            }
        }
        
        // --- DELETE TOOL (ROBUST FIX) ---
       else if (currentTool === 'delete') {
            let deletedSomething = false;

            // 1. Remove Traps
            for (let i = traps.length - 1; i >= 0; i--) {
                let t = traps[i];
                // Traps store grid coordinates (col, row)
                if (t.col === col && t.row === row) {
                    traps.splice(i, 1);
                    money += 20; // Refund half of $40
                    deletedSomething = true;
                    // Traps usually don't block paths, so didChange might not be needed, 
                    // but we set it just in case logic changes later.
                }
            }

            // 2. Remove Structures (Prioritize over walls to fix Wall Turret issue)
            // 2. Remove Structures (Prioritize over walls)
        for (let i = structures.length - 1; i >= 0; i--) {
            let s = structures[i];
            
            // Calculate center of structure for clicking
            // If it's a MoneyFarm, it's 2x2 (100x100px), else it's 1x1 (50x50px)
            let size = (s instanceof MoneyFarm) ? CELL_SIZE * 2 : CELL_SIZE;
            let sx = s.col * CELL_SIZE;
            let sy = s.row * CELL_SIZE;

            // Simple AABB collision for the mouse click
            if (mouseX >= sx && mouseX < sx + size &&
                mouseY >= sy && mouseY < sy + size) {
                
                // --- FIX STARTS HERE ---
                // 1. Check if the structure has a special cleanup method (like MoneyFarm)
                if (typeof s.cleanup === 'function') {
                    s.cleanup();
                } 
                // 2. Fallback for standard 1x1 structures
                else {
                    let c = grid[s.col][s.row];
                    c.occupied = false;
                    if (c.wall) {
                        c.wall = false;
                        c.wallHp = 100;
                    }
                    updateFlowField();
                }
                // --- FIX ENDS HERE ---

                structures.splice(i, 1); // Remove from array
                money += (s instanceof MoneyFarm) ? 175 : 100; // Refund (Example amounts)
                
                deletedSomething = true;
                didChange = true;
                break; 
            }
        }

            // 3. Remove Generic Walls (Only if no structure was found)
            // This handles standard walls that don't have buildings on them.
            if (!deletedSomething && cell.wall) {
                cell.wall = false;
                cell.wallHp = 100;
                money += 5;
                didChange = true;
            }
        }

        // --- PLACEMENT TOOLS ---
        else if (currentTool === 'bard_troop') {
             if (money >= 100) {
                 allies.push(new BardTroop(mouseX, mouseY));
                 money -= 100;
             }
        }
        else if (currentTool === 'troop') {
             if (money >= 10) {
                 allies.push(new Soldier(mouseX, mouseY));
                 money -= 10;
             }
        }
        else if (currentTool === 'sword_troop') {
            // Cost Check ($50)
            if (money >= 50) {
                // Spawn the ally at mouse position
                allies.push(new SwordTroop(mouseX, mouseY));
                money -= 50;
                
                // Optional: Particle effect on spawn
                createParticles(mouseX, mouseY, "#00ffff", 10);
            }
        }
        // Inside the tool placement logic (handleInput function)
        else if (currentTool === 'shield_troop') {
            if (money >= 75) {
                allies.push(new ShieldSoldier(mouseX, mouseY));
                money -= 75;
                // Optional spawn effect
                if(typeof createParticles === 'function') createParticles(mouseX, mouseY, "#0088aa", 10);
            }
        }
        else if (currentTool === 'barracks') {
            if (!cell.wall && !cell.occupied && money >= 200) {
                structures.push(new Barracks(col, row));
                cell.occupied = true;
                money -= 200;
                didChange = true; 
            }
        }
        else if (currentTool === 'mortar') {
            if (!cell.wall && !cell.occupied && money >= 200) {
                // Pass col/row as expected by your class
                structures.push(new Mortar(col, row));
                cell.occupied = true;
                money -= 200;
                didChange = true;
            }
        }
        else if (currentTool === 'trap') {
            if (!cell.wall && !cell.occupied && money >= 40) {
                traps.push(new Trap(mouseX, mouseY));
                cell.occupied = true; // Prevent building on top of it
                money -= 40;
                didChange = true;
            }
        }
        // Inside handleInput(x, y) ...

        else if (currentTool === 'wall_turret') {
            // Check if valid spot: Not occupied AND NOT a Wall
            if (!cell.occupied && !cell.wall && money >= 150) {
                // 1. Create the Turret (Pass buildRotation so it faces the right way!)
                let angle = (typeof buildRotation !== 'undefined') ? buildRotation : 0;
                structures.push(new WallTurret(col, row, angle));

                // 2. Make it a "Wall" in the grid
                cell.occupied = true;
                cell.wall = true;      // <--- Enemies still see it as a wall
                cell.wallHp = 300;     // <--- Sets HP to full (300/300)

                // 3. Update Enemy Pathfinding
                updateFlowField(); 
                money -= 150;
                didChange = true;
            }
        }
        else if (currentTool === 'minigun') {
            if (!cell.wall && !cell.occupied && money >= 400) {
                structures.push(new Minigun(col, row));
                cell.occupied = true;
                cell.wall = true;      // <--- Enemies still see it as a wall
                cell.wallHp = 300;
                money -= 400;
                didChange = true;
                
                // Spawn Effect
                createParticles(mouseX, mouseY, "#ffff00", 15);
            }
        }
        else if (currentTool === 'cryo_tower') {
            if (!cell.wall && !cell.occupied && money >= 100) {
                structures.push(new CryoTower(col, row));
                cell.occupied = true;
                cell.wall = true;      // <--- Enemies still see it as a wall
                cell.wallHp = 300;
                money -= 100;
                didChange = true;
                
                // Spawn Effect
                createParticles(mouseX, mouseY, "#ffff00", 15);
            }
        }
        else if (currentTool === 'money_farm') {
            let cost = 350;
            
            // Check bounds (needs 2x2 space)
            if (col + 1 >= COLS || row + 1 >= ROWS) return;

            // Check if area is clear (4 cells)
            let isClear = true;
            for(let i=0; i<2; i++) {
                for(let j=0; j<2; j++) {
                    let c = grid[col+i][row+j];
                    if (c.occupied || c.wall) isClear = false;
                }
            }

            if (isClear && money >= cost) {
                money -= cost;
                structures.push(new MoneyFarm(col, row));

                // Mark the 4 cells as "Walls" with LOW HP
                for(let i=0; i<2; i++) {
                    for(let j=0; j<2; j++) {
                        let c = grid[col+i][row+j];
                        c.occupied = true;
                        c.wall = true;
                        c.wallHp = 30; 
                    }
                }
                
                // --- FIX STARTS HERE ---
                // Force the enemies to recalculate their paths immediately
                updateFlowField(); 
                // --- FIX ENDS HERE ---

                didChange = true;
            }
        }
        
        // --- OPTIMIZATION ---
        // Only recalculate paths if the map layout changed (Walls or Buildings)
        if (didChange) {
            updateFlowField();
        }
    }

    function takeDamage(amount) {
        playerBase.hp -= amount;
        if (playerBase.hp <= 0) {
            playerBase.hp = 0;
            gameOver = true;
            document.getElementById('game-over').style.display = 'block';
            document.getElementById('final-wave').innerText = wave;
        }
    }

    function createParticles(x, y, color, count) {
        for(let i=0; i<count; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 6,
                vy: (Math.random() - 0.5) * 6,
                life: 20,
                color: color
            });
        }
    }

    // Physics: Soft Collision / Separation Logic
    function separate(entity, neighbors, pushStrength) {
        // OPTIMIZATION: Only check a random sample of neighbors to save CPU
        // If we check all 500+ enemies against each other, the browser will freeze.
        let checkLimit = 8; 
        let checks = 0;
        let start = Math.floor(Math.random() * neighbors.length); // Random start index

        for (let i = 0; i < neighbors.length; i++) {
            if (checks >= checkLimit) break;
            
            let idx = (start + i) % neighbors.length;
            let other = neighbors[idx];

            if (entity === other) continue; // Don't collide with self

            let dx = entity.x - other.x;
            let dy = entity.y - other.y;
            let distSq = dx*dx + dy*dy;
            
            // If they are touching (radius + radius)
            let combinedRadius = entity.radius + other.radius; 
            // We add a small buffer (* 1.1) so they don't perfectly overlap
            let minDist = combinedRadius * 1.1; 

            if (distSq > 0 && distSq < minDist * minDist) {
                let dist = Math.sqrt(distSq);
                
                // Calculate push vector (normalized)
                let pushX = dx / dist;
                let pushY = dy / dist;

                // Apply Push
                entity.x += pushX * pushStrength;
                entity.y += pushY * pushStrength;
                
                checks++;
            }
        }
    }

    function resolveWallCollision(entity) {
        // 1. Keep in bounds (Canvas edges)
        let mapWidth = COLS * CELL_SIZE;
        let mapHeight = ROWS * CELL_SIZE;

        if (entity.x < entity.radius) { entity.x = entity.radius; entity.vx *= -0.5; }
        if (entity.y < entity.radius) { entity.y = entity.radius; entity.vy *= -0.5; }
        if (entity.x > mapWidth - entity.radius) { entity.x = mapWidth - entity.radius; entity.vx *= -0.5; }
        if (entity.y > mapHeight - entity.radius) { entity.y = mapHeight - entity.radius; entity.vy *= -0.5; }

        // 2. Grid Wall Collision (Check 3x3 cells around the entity)
        let minCol = Math.floor((entity.x - entity.radius) / CELL_SIZE);
        let maxCol = Math.floor((entity.x + entity.radius) / CELL_SIZE);
        let minRow = Math.floor((entity.y - entity.radius) / CELL_SIZE);
        let maxRow = Math.floor((entity.y + entity.radius) / CELL_SIZE);

        for (let c = minCol; c <= maxCol; c++) {
            for (let r = minRow; r <= maxRow; r++) {
                // Ensure we are checking valid grid coordinates
                if (c >= 0 && c < COLS && r >= 0 && r < ROWS) {
                    let cell = grid[c][r];
                    // If it's a wall, resolve collision
                    if (cell.wall) {
                        // Find the closest point on the wall rectangle to the circle center
                        let wallX = c * CELL_SIZE;
                        let wallY = r * CELL_SIZE;
                        
                        let closestX = Math.max(wallX, Math.min(entity.x, wallX + CELL_SIZE));
                        let closestY = Math.max(wallY, Math.min(entity.y, wallY + CELL_SIZE));

                        let distX = entity.x - closestX;
                        let distY = entity.y - closestY;
                        let distSq = (distX * distX) + (distY * distY);

                        // If overlap exists (distance < radius)
                        if (distSq < (entity.radius * entity.radius) && distSq > 0.001) {
                            let dist = Math.sqrt(distSq);
                            let overlap = entity.radius - dist;
                            
                            // Normal vector (direction to push out)
                            let nx = distX / dist;
                            let ny = distY / dist;

                            // Push entity out of wall
                            entity.x += nx * overlap;
                            entity.y += ny * overlap;

                            // Physics Response: Kill velocity moving INTO the wall
                            // Dot product to find velocity along normal
                            let vDot = (entity.vx * nx) + (entity.vy * ny);
                            if (vDot < 0) {
                                // Reflect/Dampen velocity
                                entity.vx -= vDot * nx * 1.2; 
                                entity.vy -= vDot * ny * 1.2;
                            }
                        }
                    }
                }
            }
        }
    }

    function collideWithRect(circle, rx, ry, rw, rh) {
        // Find the closest point on the rectangle to the circle's center
        let testX = circle.x;
        let testY = circle.y;

        if (circle.x < rx) testX = rx;
        else if (circle.x > rx + rw) testX = rx + rw;

        if (circle.y < ry) testY = ry;
        else if (circle.y > ry + rh) testY = ry + rh;

        let distX = circle.x - testX;
        let distY = circle.y - testY;
        let distance = Math.sqrt(distX*distX + distY*distY);

        // If closer than radius, we are inside! Push out.
        if (distance < circle.radius && distance > 0) {
            let overlap = circle.radius - distance;
            let nx = distX / distance;
            let ny = distY / distance;
            
            circle.x += nx * overlap;
            circle.y += ny * overlap;
        }
    }

    function getSmartVector(entity) {
    let col = Math.floor(entity.x / CELL_SIZE);
    let row = Math.floor(entity.y / CELL_SIZE);

    // 1. Check if we are inside the target cell (distance 0)
    // If so, just seek the exact center of this cell to stop jittering
    if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
        if (grid[col][row].distance === 0) {
             let dx = (col * CELL_SIZE + CELL_SIZE / 2) - entity.x;
             let dy = (row * CELL_SIZE + CELL_SIZE / 2) - entity.y;
             // If close enough, stop completely
             if (Math.hypot(dx, dy) < 2) return { x: 0, y: 0 };
        }
    }

    let lowestDist = Infinity;
    let targetX = 0;
    let targetY = 0;
    let count = 0;

    // 2. Check all 8 Neighbors (360 logic)
    // We include {x:0, y:0} (current cell) to ensure we can move WITHIN the current cell
    // if it happens to be the best path (rare, but good for safety).
    let dirs = [
        {x: 0, y: -1}, {x: 0, y: 1}, {x: -1, y: 0}, {x: 1, y: 0}, 
        {x: -1, y: -1}, {x: 1, y: -1}, {x: -1, y: 1}, {x: 1, y: 1},
        {x: 0, y: 0} 
    ];

    for (let d of dirs) {
        let c = col + d.x;
        let r = row + d.y;

        if (c >= 0 && c < COLS && r >= 0 && r < ROWS) {
            let cell = grid[c][r];

            // Ignore walls and unreachable areas
            if (cell.wall || cell.distance === Infinity) continue;

            // Important: We handle corners here.
            // If moving diagonal, check if we are cutting a hard corner.
            if (Math.abs(d.x) === 1 && Math.abs(d.y) === 1) {
                if (grid[col + d.x][row].wall || grid[col][row + d.y].wall) continue;
            }

            // FOUND A BETTER (OR EQUAL) PATH
            // We use "<=" to collect ALL equally good cells. 
            // This averages the direction for smooth angles.
            if (cell.distance < lowestDist) {
                // Found a strictly better path, reset our accumulator
                lowestDist = cell.distance;
                targetX = c * CELL_SIZE + CELL_SIZE / 2;
                targetY = r * CELL_SIZE + CELL_SIZE / 2;
                count = 1;
            } else if (cell.distance === lowestDist) {
                // Found an equally good path, add it to the average
                targetX += c * CELL_SIZE + CELL_SIZE / 2;
                targetY += r * CELL_SIZE + CELL_SIZE / 2;
                count++;
            }
        }
    }

    // 3. Calculate Vector
    if (count > 0) {
        // Average position of all best cells
        targetX /= count;
        targetY /= count;

        let dx = targetX - entity.x;
        let dy = targetY - entity.y;
        let dist = Math.sqrt(dx*dx + dy*dy);

        if (dist > 0.01) {
            return { x: dx / dist, y: dy / dist };
        }
    }

    // Fallback: If no valid neighbors found, just push toward map center
    // (Prevents getting stuck on outer bounds)
    let centerX = (COLS * CELL_SIZE) / 2;
    let centerY = (ROWS * CELL_SIZE) / 2;
    let cx = centerX - entity.x;
    let cy = centerY - entity.y;
    let cLen = Math.hypot(cx, cy);
    return { x: cx / cLen, y: cy / cLen };
}

    // BFS Pathfinding for Soldiers
    function findNextStep(startEntity, targetEntity) {
        let sx = Math.floor(startEntity.x / CELL_SIZE);
        let sy = Math.floor(startEntity.y / CELL_SIZE);
        let tx = Math.floor(targetEntity.x / CELL_SIZE);
        let ty = Math.floor(targetEntity.y / CELL_SIZE);

        // 1. If target is in the same or adjacent tile, move directly
        if (Math.abs(sx - tx) <= 1 && Math.abs(sy - ty) <= 1) {
             if (!grid[tx][ty].wall) return { x: targetEntity.x, y: targetEntity.y };
        }

        // 2. BFS Pathfinding
        let queue = [{ x: sx, y: sy, parent: null }];
        let visited = new Set();
        visited.add(sx + "," + sy);

        let iterations = 0;
        let maxIterations = 200; // Increased search range slightly

        // Track the tile that gets us closest to the enemy (in case we don't finish)
        let closestNode = null;
        let minDistanceToTarget = Infinity;
        
        while (queue.length > 0 && iterations < maxIterations) { 
            let current = queue.shift();
            iterations++;

            // Calculate distance to target from this node
            let dist = Math.abs(current.x - tx) + Math.abs(current.y - ty);
            if (dist < minDistanceToTarget) {
                minDistanceToTarget = dist;
                closestNode = current;
            }

            // If we found the target exactly
            if (current.x === tx && current.y === ty) {
                closestNode = current;
                break; // Stop searching, we found it
            }

            // Check Neighbors
            let neighbors = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}];

            for (let n of neighbors) {
                let nx = current.x + n.x;
                let ny = current.y + n.y;
                let key = nx + "," + ny;

                if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
                    if (!grid[nx][ny].wall && !visited.has(key)) {
                        visited.add(key);
                        queue.push({ x: nx, y: ny, parent: current });
                    }
                }
            }
        }

        // 3. Backtrack from the 'closestNode' found
        // If we found the target, this backtracks from the target.
        // If we ran out of time, this backtracks from the tile that got closest.
        if (closestNode) {
            let step = closestNode;
            // Walk back up the family tree until we find the Immediate Child of start
            while (step.parent && step.parent.parent !== null) {
                step = step.parent;
            }
            
            return { 
                x: step.x * CELL_SIZE + CELL_SIZE/2, 
                y: step.y * CELL_SIZE + CELL_SIZE/2 
            };
        }

        // Fallback (only happens if fully boxed in)
        return { x: startEntity.x, y: startEntity.y };
    }

    function spawnEnemy() {
    let rand = Math.random();
    
    // --- CHANCE CONFIGURATION ---
    
    // 1. Tanks (Big, Slow)
    let tankChance = (wave > 8) ? 0.15 : (wave > 3 ? 0.1 : 0);
    
    // 2. Runners (Fast Swarm)
    let runnerChance = (wave > 2) ? 0.25 : (wave > 1 ? 0.2 : 0);

    // 3. Shielders (Support Unit)
    let shielderChance = (wave > 12) ? 0.10 : 0;

    // 4. Leapers (Wall Jumpers)
    let leaperChance = (wave > 11) ? 0.10 : 0;
    
    // 5. Breachers (Wall Breakers)
    let breacherChance = (wave > 7) ? 0.05 : 0; 
    
    // 6. Dashers (Fast Burst)
    let dasherChance = (wave > 6) ? 0.10 : 0; 
    
    // 7. Snipers (Ranged)
    let sniperChance = (wave > 8) ? 0.05 : 0;

    // 8. Broodmothers (Boss/Summoner)
    let broodChance = (wave > 10) ? 0.05 : 0; 

    // [NEW] 9. Magnet Enemy (Bullet Attractor)
    // Starts Wave 6. Serves as an early-mid game tank.
    let magnetChance = (wave > 18) ? 0.05 : 0;

    let reviverChance = (wave > 15) ? 0.05 : 0;

    let flyingChance = (wave > 9) ? 0.08 : 0;

    // --- SELECTION LOGIC ---
    let currentTotal = 0;
    
    // Check Tank
    currentTotal += tankChance;
    if (rand < currentTotal) { enemies.push(new TankEnemy()); return; }
    
    // Check Runner
    currentTotal += runnerChance;
    if (rand < currentTotal) { enemies.push(new RunnerEnemy()); return; }

    // Check Shielder
    currentTotal += shielderChance;
    if (rand < currentTotal) { enemies.push(new ShielderEnemy()); return; }

    // Check Leaper
    currentTotal += leaperChance;
    if (rand < currentTotal) { enemies.push(new LeaperEnemy()); return; }

    // Check Breacher
    currentTotal += breacherChance;
    if (rand < currentTotal) { enemies.push(new BreacherEnemy()); return; }

    // Check Dasher
    currentTotal += dasherChance;
    if (rand < currentTotal) { enemies.push(new DasherEnemy()); return; }
    
    // Check Sniper
    currentTotal += sniperChance;
    if (rand < currentTotal) { enemies.push(new SniperEnemy()); return; }
    
    // Check Broodmother
    currentTotal += broodChance;
    if (rand < currentTotal) { enemies.push(new BroodmotherEnemy()); return; }

    // [NEW] Check Magnet
    currentTotal += magnetChance;
    if (rand < currentTotal) { enemies.push(new MagnetEnemy()); return; }

    // Check Reviver
    currentTotal += reviverChance;
    if (rand < currentTotal) { enemies.push(new ReviverEnemy()); return; }

    // Check Flying
    currentTotal += flyingChance;
    if (rand < currentTotal) { enemies.push(new FlyingEnemy()); return; }

    // Default: Basic Enemy
    enemies.push(new Enemy());
}

    function startNextWave() {
    wave++;
    waveState = 'spawning';
    enemiesSpawned = 0;

    // 1. Determine if this is a Boss Wave (Every 10th wave)
    const isBossWave = (wave % 10 === 0);

    // 2. Create the Cinematic Announcement
    if (isBossWave) {
        // Red, ominous text for Boss waves
        currentAnnouncement = new WaveAnnouncement(
            `WAVE ${wave}`,       // Title
            " BOSS DETECTED ", // Subtitle
            "#ff0044"             // Color (Red)
        );
    } else {
        // Standard White text for normal waves
        currentAnnouncement = new WaveAnnouncement(
            `WAVE ${wave}`,       // Title
            "INCOMING SWARM",     // Subtitle
            "#ffffff"             // Color (White)
        );
    }

    // 3. Calculate Difficulty (Scaling)
    // Number of enemies grows linearly
    enemiesToSpawn = 5 + wave;
    
    // Spawn rate gets faster (lower number = faster), capped at 20 frames minimum
    spawnRate = Math.max(20, 60 - (wave * 0.5));

    // 4. Spawn the Boss
    if (isBossWave) {
        let boss = new BossEnemy();
        enemies.push(boss); // Add boss immediately to the active field
        
        // Optional: Reduce the number of small enemies slightly during a boss fight 
        // so the player isn't totally overwhelmed.
        enemiesToSpawn = Math.floor(enemiesToSpawn * 0.8); 
    }
}

    // --- HELPER 1: LINE OF SIGHT ---
// --- HELPER: CHECK IF PATH IS CLEAR ---
// --- HELPER: THICK LINE OF SIGHT (Prevents Corner Clipping) ---
// --- 1. RAYCASTING (Vision) ---
function castRay(sx, sy, ex, ey) {
    let dx = ex - sx;
    let dy = ey - sy;
    let dist = Math.hypot(dx, dy);
    let steps = dist / (CELL_SIZE / 2); // Check twice per cell

    for (let i = 0; i <= steps; i++) {
        let t = i / steps;
        let cx = sx + dx * t;
        let cy = sy + dy * t;
        
        let col = Math.floor(cx / CELL_SIZE);
        let row = Math.floor(cy / CELL_SIZE);

        if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
            if (grid[col][row].wall) return false; // Hit a wall
        }
    }
    return true; // Clear path
}

// --- IMPROVED HELPER: Thick Raycast ---
// Checks 3 parallel lines to ensure the enemy's body actually fits
function hasLineOfSight(x0, y0, x1, y1, radius = 0) {
    let dx = x1 - x0;
    let dy = y1 - y0;
    let dist = Math.hypot(dx, dy);
    if (dist === 0) return true;

    // Calculate perpendicular offset vector for width
    let nx = -dy / dist; 
    let ny = dx / dist;
    
    // Check 3 Rays: Center, Left Edge, Right Edge
    // We add a tiny buffer (+2) to radius to prevent grazing
    let r = Math.max(0, radius + 2); 
    let offsets = [
        { x: 0, y: 0 },            // Center
        { x: nx * r, y: ny * r },  // Left side of body
        { x: -nx * r, y: -ny * r } // Right side of body
    ];

    for (let o of offsets) {
        let startX = x0 + o.x;
        let startY = y0 + o.y;
        let endX = x1 + o.x;
        let endY = y1 + o.y;

        // Check points along this specific ray
        let steps = Math.ceil(dist / (CELL_SIZE / 2));
        for (let i = 0; i <= steps; i++) {
            let t = i / steps;
            let cx = startX + (endX - startX) * t;
            let cy = startY + (endY - startY) * t;
            
            let col = Math.floor(cx / CELL_SIZE);
            let row = Math.floor(cy / CELL_SIZE);
            
            if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
                if (grid[col][row].wall) return false; // Blocked
            }
        }
    }
    return true; // Path is wide enough!
}
// --- 2. PATHFINDING (BFS) ---
// --- HELPER: PATHFINDING (BFS) ---
function findPath(unit, target) {
    let startCol = Math.floor(unit.x / CELL_SIZE);
    let startRow = Math.floor(unit.y / CELL_SIZE);
    let endCol = Math.floor(target.x / CELL_SIZE);
    let endRow = Math.floor(target.y / CELL_SIZE);

    if (startCol === endCol && startRow === endRow) return [];

    let queue = [{c: startCol, r: startRow}];
    let visited = new Set();
    let cameFrom = {}; 
    let startKey = `${startCol},${startRow}`;
    
    visited.add(startKey);
    cameFrom[startKey] = null;

    let found = false;
    let finalNode = null;

    while (queue.length > 0) {
        let current = queue.shift();

        if (current.c === endCol && current.r === endRow) {
            found = true;
            finalNode = current;
            break;
        }

        // Define neighbors (Straight & Diagonal)
        let directions = [
            // straight
            {x: 0, y: -1}, {x: 0, y: 1}, {x: -1, y: 0}, {x: 1, y: 0},
            // diagonal
            {x: -1, y: -1}, {x: 1, y: -1}, {x: -1, y: 1}, {x: 1, y: 1}
        ];

        for (let dir of directions) {
            let nc = current.c + dir.x;
            let nr = current.r + dir.y;

            if (nc >= 0 && nc < COLS && nr >= 0 && nr < ROWS) {
                // 1. Basic Wall Check
                if (grid[nc][nr].wall) continue;

                // 2. CORNER CUTTING PREVENTION
                // If moving diagonally (both x and y change), check adjacent straight tiles
                if (dir.x !== 0 && dir.y !== 0) {
                    if (grid[current.c + dir.x][current.r].wall || grid[current.c][current.r + dir.y].wall) {
                        continue; // Block this diagonal move
                    }
                }

                let key = `${nc},${nr}`;
                if (!visited.has(key)) {
                    visited.add(key);
                    cameFrom[key] = current;
                    queue.push({c: nc, r: nr});
                }
            }
        }
    }

    // Reconstruct path
    let path = [];
    if (found) {
        let curr = finalNode;
        while (curr) {
            if (curr.c === startCol && curr.r === startRow) break;
            path.push({
                x: curr.c * CELL_SIZE + CELL_SIZE/2,
                y: curr.r * CELL_SIZE + CELL_SIZE/2
            });
            let key = `${curr.c},${curr.r}`;
            curr = cameFrom[key];
        }
        path.reverse(); // Order: Start -> End
    }
    return path;
}

let lastTime = performance.now();

        function gameLoop(timestamp) {
    if (!timestamp) timestamp = performance.now();
    let deltaTime = timestamp - lastTime;
    lastTime = timestamp;

    if (deltaTime > 100) deltaTime = 100;
    const dt = deltaTime / (1000 / 60);

    if (!gameActive) {
        requestAnimationFrame(gameLoop);
        return;
    }

    if (gameOver) return;

    // --- 1. CLEAR PHYSICAL SCREEN ---
    // Fill the whole window with black to handle the letterboxing (black bars)
    ctx.fillStyle = "#050505";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // --- 2. START SCALING SYSTEM ---
    // We save the context state, translate to the center, and scale everything down
    ctx.save();
    ctx.translate(offsetX, offsetY); 
    ctx.scale(scale, scale);         

    // --- 3. DRAW GAME WORLD (Inside Virtual 64x36 Grid) ---
    // From here on, we use VIRTUAL dimensions (3200x1800), the scale handles the rest.

    // Background
    ctx.fillStyle = "#111";
    ctx.fillRect(0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);

    // Grid Lines
    ctx.strokeStyle = "#222";
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let x = 0; x <= COLS; x++) { ctx.moveTo(x*CELL_SIZE,0); ctx.lineTo(x*CELL_SIZE, VIRTUAL_HEIGHT); }
    for (let y = 0; y <= ROWS; y++) { ctx.moveTo(0,y*CELL_SIZE); ctx.lineTo(VIRTUAL_WIDTH, y*CELL_SIZE); }
    ctx.stroke();

    // Walls Logic
    for (let x = 0; x < COLS; x++) {
        for (let y = 0; y < ROWS; y++) {
            let cell = grid[x][y];
            if (cell.wall && !cell.occupied) {
                // Regeneration
                if (cell.wallHp < 100) cell.wallHp += 0.05 *dt;
                if (cell.wallHp > 100) cell.wallHp = 100;

                // Colors
                let hpPct = cell.wallHp / 100;
                let gray = Math.floor(60 + (60 * hpPct)); 
                let colMain = `rgb(${gray}, ${gray}, ${gray})`;
                let colLight = `rgb(${gray + 40}, ${gray + 40}, ${gray + 40})`;
                let colDark = `rgb(${gray - 40}, ${gray - 40}, ${gray - 40})`;
                let colDetail = `rgb(${gray - 20}, ${gray - 20}, ${gray - 20})`;

                // Neighbors
                let nUp = (y > 0 && grid[x][y - 1].wall);
                let nDown = (y < ROWS - 1 && grid[x][y + 1].wall);
                let nLeft = (x > 0 && grid[x - 1][y].wall);
                let nRight = (x < COLS - 1 && grid[x + 1][y].wall);

                let drawX = x * CELL_SIZE;
                let drawY = y * CELL_SIZE;
                let coreSize = CELL_SIZE * 0.85; 
                let offset = (CELL_SIZE - coreSize) / 2;
                
                let cX = drawX + offset;
                let cY = drawY + offset;
                let cW = coreSize;
                let cH = coreSize;

                // Draw Base Block
                ctx.fillStyle = colMain;
                ctx.fillRect(cX, cY, cW, cH); 
                
                // Draw Connections
                if (nUp) ctx.fillRect(cX, drawY, cW, offset);
                if (nDown) ctx.fillRect(cX, cY + cH, cW, offset);
                if (nLeft) ctx.fillRect(drawX, cY, offset, cH);
                if (nRight) ctx.fillRect(cX + cW, cY, offset, cH);

                // Grip Lines
                ctx.fillStyle = colDark;
                let lineSpace = 4;
                if (nUp) for(let i = drawY + 2; i < cY; i+=lineSpace) ctx.fillRect(cX + 2, i, cW - 4, 1);
                if (nDown) for(let i = cY + cH + 2; i < drawY + CELL_SIZE; i+=lineSpace) ctx.fillRect(cX + 2, i, cW - 4, 1);
                if (nLeft) for(let i = drawX + 2; i < cX; i+=lineSpace) ctx.fillRect(i, cY + 2, 1, cH - 4);
                if (nRight) for(let i = cX + cW + 2; i < drawX + CELL_SIZE; i+=lineSpace) ctx.fillRect(i, cY + 2, 1, cH - 4);

                // 3D Bevels
                ctx.beginPath(); ctx.strokeStyle = colLight; ctx.lineWidth = 2;
                ctx.moveTo(cX, cY); ctx.lineTo(cX + cW, cY); ctx.stroke(); // Top
                ctx.moveTo(cX, cY); ctx.lineTo(cX, cY + cH); ctx.stroke(); // Left
                
                ctx.beginPath(); ctx.strokeStyle = colDark;
                ctx.moveTo(cX + cW, cY); ctx.lineTo(cX + cW, cY + cH); ctx.stroke(); // Right
                ctx.moveTo(cX, cY + cH); ctx.lineTo(cX + cW, cY + cH); ctx.stroke(); // Bottom

                // Inner Plate
                let pad = 6;
                ctx.fillStyle = colDetail;
                ctx.fillRect(cX + pad, cY + pad, cW - pad*2, cH - pad*2);
                ctx.strokeStyle = colDark; ctx.lineWidth = 1;
                ctx.strokeRect(cX + pad, cY + pad, cW - pad*2, cH - pad*2);
            }
        }
    }

    // --- VOID PORTAL (2x2) ---
    ctx.save();
    const bx = playerBase.x * CELL_SIZE;
    const by = playerBase.y * CELL_SIZE;
    const bSize = CELL_SIZE * 2;
    const centerBx = bx + CELL_SIZE;
    const centerBy = by + CELL_SIZE;
    const time = Date.now();
    const isHit = (Date.now() - (playerBase.lastHitTime || 0)) < 150;

    // Foundation
    ctx.fillStyle = "#1a1a1d"; 
    ctx.shadowColor = "#000"; ctx.shadowBlur = 15;
    ctx.beginPath();
    const cut = 15;
    ctx.moveTo(bx + cut, by); ctx.lineTo(bx + bSize - cut, by); ctx.lineTo(bx + bSize, by + cut);
    ctx.lineTo(bx + bSize, by + bSize - cut); ctx.lineTo(bx + bSize - cut, by + bSize);
    ctx.lineTo(bx + cut, by + bSize); ctx.lineTo(bx, by + bSize - cut); ctx.lineTo(bx, by + cut);
    ctx.closePath(); ctx.fill(); ctx.shadowBlur = 0;

    // Runes
    ctx.save();
    ctx.beginPath(); ctx.rect(bx, by, bSize, bSize); ctx.clip();
    ctx.strokeStyle = isHit ? "#ff0000" : "#a020f0"; ctx.lineWidth = 2;
    ctx.setLineDash([10, 25]); ctx.beginPath(); ctx.arc(centerBx, centerBy, CELL_SIZE * 0.8, 0, Math.PI * 2); ctx.stroke();
    ctx.setLineDash([5, 15]); ctx.beginPath(); ctx.arc(centerBx, centerBy, CELL_SIZE * 0.9, 0, Math.PI * 2); ctx.stroke();
    ctx.restore();

    // Portal Swirl
    const portalRadius = CELL_SIZE * 0.65;
    ctx.fillStyle = "#000";
    ctx.beginPath(); ctx.arc(centerBx, centerBy, portalRadius, 0, Math.PI * 2); ctx.fill();

    ctx.save();
    ctx.translate(centerBx, centerBy);
    ctx.globalCompositeOperation = 'lighter';
    ctx.rotate(time * 0.001);
    const grad1 = ctx.createRadialGradient(0, 0, 10, 0, 0, portalRadius);
    grad1.addColorStop(0, "rgba(0, 0, 0, 0)");
    grad1.addColorStop(0.4, isHit ? "rgba(255, 0, 0, 0.4)" : "rgba(75, 0, 130, 0.4)");
    grad1.addColorStop(0.8, isHit ? "rgba(255, 50, 0, 0.6)" : "rgba(138, 43, 226, 0.6)");
    grad1.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = grad1;
    ctx.beginPath();
    for (let i = 0; i < Math.PI * 2; i += 0.1) {
        let r = portalRadius * (0.9 + Math.sin(i * 5 + time * 0.002) * 0.05);
        ctx.lineTo(Math.cos(i) * r, Math.sin(i) * r);
    }
    ctx.fill();

    // Inner Spiral
    ctx.rotate(time * -0.003);
    const grad2 = ctx.createRadialGradient(0, 0, 5, 0, 0, portalRadius * 0.8);
    grad2.addColorStop(0, "#ffffff");
    grad2.addColorStop(0.2, isHit ? "#ff0000" : "#ff00ff");
    grad2.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = grad2;
    for (let i = 0; i < 3; i++) {
        ctx.rotate((Math.PI * 2) / 3);
        ctx.beginPath(); ctx.ellipse(20, 0, portalRadius * 0.6, portalRadius * 0.2, 0.5, 0, Math.PI * 2); ctx.fill();
    }
    ctx.restore();

    // Health Bar
    const hpPct = Math.max(0, playerBase.hp / 100);
    const barW = bSize * 0.6;
    const barX = centerBx - barW / 2;
    const barY = by - 10;
    ctx.fillStyle = "rgba(0,0,0,0.8)"; ctx.fillRect(barX, barY, barW, 4);
    const hpColor = hpPct > 0.5 ? "#b042ff" : (hpPct > 0.2 ? "#ff00ff" : "#ff0000");
    ctx.fillStyle = hpColor; ctx.shadowColor = hpColor; ctx.shadowBlur = 5;
    ctx.fillRect(barX, barY, barW * hpPct, 4); ctx.shadowBlur = 0;
    ctx.restore();

    // Hover Ghost (Calculates using Scaled Mouse Coords)
    let gc = Math.floor(mouseX/CELL_SIZE);
    let gr = Math.floor(mouseY/CELL_SIZE);
    if (gc >= 0 && gc < COLS && gr >= 0 && gr < ROWS) {
        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx.strokeRect(gc*CELL_SIZE, gr*CELL_SIZE, CELL_SIZE, CELL_SIZE);

    }

    // --- GAME LOGIC ---

    if (waveState === 'spawning') {
        spawnTimer+=dt;
        if (spawnTimer > spawnRate) {
            spawnEnemy(); 
            enemiesSpawned++;
            spawnTimer = 0;
            if (enemiesSpawned >= enemiesToSpawn) waveState = 'fighting';
        }
    } else if (waveState === 'fighting') {
        if (enemies.length === 0) {                
            money += 50;
            startNextWave(); 
        }
    }
    
    // Structures - Update & Cleanup
    for (let i = structures.length - 1; i >= 0; i--) {
        let s = structures[i];
        if (s.update) s.update(dt);
        // Note: Draw is removed from here to handle depth sorting below
        if ((s.active === false) || (s.hp !== undefined && s.hp <= 0)) {
            structures.splice(i, 1);
        }
    }

    // Structures - Depth Sort & Draw
    // Sort by row (Y-coordinate) so lower buildings (higher Y) are drawn last (on top)
    structures.sort((a, b) => a.row - b.row);

    for (let s of structures) {
        if (s.draw) s.draw();
    }

    // Traps
    for (let i = traps.length - 1; i >= 0; i--) {
        traps[i].update(dt);
        traps[i].draw();
        if (traps[i].hp <= 0) {
            grid[traps[i].col][traps[i].row].occupied = false;
            traps.splice(i, 1);
        }
    }

    // Spikes
    for (let i = spikes.length - 1; i >= 0; i--) {
        spikes[i].update(dt);
        spikes[i].draw();
        if (!spikes[i].active) spikes.splice(i, 1);
    }

    for (let i = corpses.length - 1; i >= 0; i--) {
        corpses[i].update();
        corpses[i].draw(); // Draw corpses below enemies
        if (!corpses[i].active) {
            corpses.splice(i, 1);
        }
    }

    // Enemies & Portal Damage
    let baseCenterX = (playerBase.x * CELL_SIZE) + CELL_SIZE;
    let baseCenterY = (playerBase.y * CELL_SIZE) + CELL_SIZE;

    enemies.forEach(e => {
    e.isInvincible = false;
    });

    for (let i = enemies.length - 1; i >= 0; i--) {
        let e = enemies[i];
        e.update(dt);      

        let distToPortal = Math.hypot(e.x - baseCenterX, e.y - baseCenterY);
        if (distToPortal < CELL_SIZE * 0.6) {
            takeDamage(5); 
            playerBase.lastHitTime = Date.now();
            if(typeof createParticles === 'function') createParticles(e.x, e.y, "#a020f0", 8);
            enemies.splice(i, 1);
            continue; 
        }
        e.draw();
        
        if (e.hp <= 0) {
            money += e.bounty; 
            if (e.type !== "SKELETON_UNIT") {
            corpses.push(new Corpse(e.x, e.y)); 
            }
            if(typeof createParticles === 'function') createParticles(e.x, e.y, "orange", 6);
            enemies.splice(i, 1);
        }
    }

    // Allies
    for (let i = allies.length - 1; i >= 0; i--) {
        let a = allies[i];
        a.update(dt);
        a.draw();
        if (a.hp <= 0 || a.lifeTimer <= 0) {
            allies.splice(i, 1);
            createParticles(a.x, a.y, "#00d2ff", 5);
        }
    }

    // Projectiles
    for (let i = projectiles.length - 1; i >= 0; i--) {
        projectiles[i].update(dt);
        projectiles[i].draw();
        if (!projectiles[i].active) projectiles.splice(i, 1);
    }

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx * dt; 
        p.y += p.vy * dt; 
        p.life -= dt;
        ctx.fillStyle = p.color; ctx.globalAlpha = p.life/20;
        ctx.fillRect(p.x, p.y, 3, 3);
        ctx.globalAlpha = 1;
        if (p.life <= 0) particles.splice(i, 1);
    }

    // Blueprint
    drawBlueprint();

        // Announcement
    if (currentAnnouncement && currentAnnouncement.active) {
        currentAnnouncement.update(dt);
        currentAnnouncement.draw();
    }

    // --- 4. END SCALING SYSTEM ---
    ctx.restore();

    // --- 5. UI UPDATES (No scaling needed for HTML Overlay) ---
    document.getElementById('hp').innerText = Math.ceil(playerBase.hp);
    document.getElementById('money').innerText = Math.floor(money);
    document.getElementById('wave').innerText = wave;
    let remaining = (enemiesToSpawn - enemiesSpawned) + enemies.length;
    document.getElementById('enemy-count').innerText = remaining > 0 ? remaining : 0;

    requestAnimationFrame(gameLoop);
}

    let currentDifficulty = 'medium'; // Default

    // 1. Hook into startGame to capture the chosen difficulty
    const _originalStartGame = startGame;
    startGame = function(mode) {
        currentDifficulty = mode; // Save difficulty for restart
        _originalStartGame(mode);
    }

    // 2. Patch the Game Loop to handle freezing
    const _originalGameLoop = gameLoop;
    gameLoop = function(timestamp) {
        // If paused, keep the loop alive but skip the update/draw logic
        // This freezes the last frame on the canvas behind the menu
        if (isPaused) {
            requestAnimationFrame(gameLoop);
            return;
        }
        _originalGameLoop(timestamp);
    }

    // 3. Toggle Pause Function
    function togglePause() {
        // Prevent pausing if game hasn't started or is over
        if (!gameActive || gameOver) return;

        isPaused = !isPaused;
        const menu = document.getElementById('pause-menu');
        menu.style.display = isPaused ? 'flex' : 'none';
    }

    // 4. Restart Game (Reloads page and auto-starts with same difficulty)
    function restartGame() {
        sessionStorage.setItem('swarm_restart_diff', currentDifficulty);
        location.reload();
    }

    // 5. Main Menu (Reloads page cleanly)
    function goToMainMenu() {
        sessionStorage.removeItem('swarm_restart_diff');
        location.reload();
    }

    // 6. Input Listener for 'P'
    window.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'p') {
            togglePause();
        }
    });

    // 7. Auto-Start Check (Runs on page load for "Restart" functionality)
    // Checks if we are restarting instantly
    const _restartDiff = sessionStorage.getItem('swarm_restart_diff');
    if (_restartDiff) {
        // FIX: Hide menu immediately to prevent flickering
        const menu = document.getElementById('main-menu');
        if (menu) menu.style.display = 'none';

        sessionStorage.removeItem('swarm_restart_diff');
        
        // Wait briefly for DOM to be ready, then start
        setTimeout(() => startGame(_restartDiff), 100);
    }
    init();

</script>
</body>
</html>
