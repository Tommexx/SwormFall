<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swarm Defense: Heavy Artillery</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { display: block; }
        /* --- UI CONTAINER --- */
#ui {
    position: absolute;
    top: 20px;
    left: 20px;
    width: 340px; /* Fixed width for alignment */
    display: flex;
    flex-direction: column;
    gap: 15px;
    pointer-events: none; /* Allows clicking through gaps */
    font-family: 'Segoe UI', sans-serif;
}

/* --- PANELS --- */
.hud-panel {
    background: rgba(12, 12, 18, 0.95);
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.6);
    border-radius: 12px;
    padding: 15px;
    pointer-events: auto;
    backdrop-filter: blur(10px);
}

/* --- STATS HEADER --- */
.stats-header {
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    margin-bottom: 10px;
    padding-bottom: 5px;
}
.stats-header h1 {
    font-size: 22px;
    color: #00d2ff;
    text-shadow: 0 0 10px rgba(0, 210, 255, 0.4);
    margin: 0;
    text-transform: uppercase;
    letter-spacing: 2px;
}
.stats-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 5px;
    font-size: 14px;
    color: #aab;
}
.stat-val { color: white; font-weight: bold; }

/* --- TABS SYSTEM --- */
.tab-nav {
    display: flex;
    background: rgba(0, 0, 0, 0.4);
    border-radius: 8px;
    padding: 4px;
    gap: 4px;
    margin-bottom: 12px;
}
.tab-btn {
    flex: 1;
    background: transparent;
    border: none;
    color: #667;
    padding: 8px 0;
    font-size: 12px;
    font-weight: 700;
    text-transform: uppercase;
    cursor: pointer;
    border-radius: 6px;
    transition: all 0.2s;
    text-align: center;
}
.tab-btn:hover { background: rgba(255, 255, 255, 0.05); color: #fff; }
.tab-btn.active-tab {
    background: rgba(0, 210, 255, 0.15);
    color: #00d2ff;
    box-shadow: 0 0 10px rgba(0, 210, 255, 0.1);
}

/* --- TOOL BUTTONS --- */
.tab-content { display: none; animation: slideIn 0.2s ease-out; }
.tab-content.active-content { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }

@keyframes slideIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

.tool-btn {
    background: linear-gradient(180deg, #2a2a35 0%, #1a1a20 100%);
    border: 1px solid #3a3a45;
    color: #ccc;
    padding: 10px;
    border-radius: 8px;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    position: relative;
    transition: all 0.2s;
    min-height: 50px;
}
.tool-btn:hover {
    border-color: #00d2ff;
    transform: translateY(-2px);
    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
}
/* Selected State (matches your JS logic) */
.tool-btn.active {
    background: linear-gradient(180deg, #00d2ff 0%, #0088aa 100%);
    border-color: #fff;
    color: #002233;
}
.tool-btn.active span { color: #004455; } /* Cost text on active */

.btn-label { font-size: 13px; font-weight: bold; margin-bottom: 2px; }
.btn-cost { font-size: 11px; color: #00ff88; font-family: monospace; }
.btn-hotkey { position: absolute; top: 6px; right: 8px; font-size: 10px; opacity: 0.4; font-weight: bold; }

/* Special Delete Button Styling */
.btn-delete { border-color: #ff4444; }
.btn-delete:hover { background: rgba(50, 10, 10, 1); border-color: #ff0000; }
.btn-delete .btn-cost { color: #ff8888; }
.tool-btn.active.btn-delete {
    background: linear-gradient(180deg, #ff4444 0%, #aa0000 100%);
    color: white;
}
        
        /* --- FULL SCREEN OVERLAY --- */
#game-over {
    display: none; /* Hidden by default */
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(10, 0, 0, 0.85); /* Dark red-black tint */
    backdrop-filter: blur(8px);       /* Blurs the game behind it */
    z-index: 10000;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    font-family: 'Segoe UI', Tahoma, monospace;
    overflow: hidden;
}

/* --- SCANLINE EFFECT --- */
#game-over::before {
    content: " ";
    display: block;
    position: absolute;
    top: 0; left: 0; bottom: 0; right: 0;
    background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
    z-index: 2;
    background-size: 100% 2px, 3px 100%;
    pointer-events: none;
}

/* --- THE CARD CONTAINER --- */
.game-over-card {
    position: relative;
    z-index: 5;
    background: #0a0a0a;
    border: 1px solid #ff0033;
    box-shadow: 0 0 50px rgba(255, 0, 51, 0.2), inset 0 0 20px rgba(255, 0, 51, 0.1);
    padding: 60px;
    text-align: center;
    max-width: 500px;
    width: 80%;
    /* "Cut corner" tech look */
    clip-path: polygon(
        0 0, 
        100% 0, 
        100% calc(100% - 30px), 
        calc(100% - 30px) 100%, 
        0 100%
    );
}

/* --- TYPOGRAPHY --- */
#game-over h1 {
    margin: 0 0 10px 0;
    font-size: 4rem;
    color: #ff0033;
    text-transform: uppercase;
    font-weight: 900;
    letter-spacing: 5px;
    text-shadow: 4px 4px 0px #330000;
    animation: glitch 2s infinite;
}

.sub-text {
    color: #ff6666;
    font-size: 1.2rem;
    letter-spacing: 2px;
    margin-bottom: 30px;
    text-transform: uppercase;
    border-bottom: 1px solid #330000;
    padding-bottom: 20px;
}

.stat-box {
    background: rgba(255, 255, 255, 0.05);
    padding: 20px;
    margin-bottom: 30px;
    border-left: 4px solid #ff0033;
}

.stat-label {
    display: block;
    color: #aaa;
    font-size: 0.9rem;
    margin-bottom: 5px;
    text-transform: uppercase;
}

#final-wave {
    font-size: 3.5rem;
    color: white;
    font-weight: bold;
    text-shadow: 0 0 10px rgba(255,255,255,0.5);
}

/* --- BUTTON --- */
.retry-btn {
    background: #ff0033;
    color: white;
    border: none;
    padding: 15px 40px;
    font-size: 1.2rem;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 2px;
    cursor: pointer;
    transition: all 0.3s ease;
    width: 100%;
    clip-path: polygon(0 0, 100% 0, 100% 70%, 95% 100%, 0 100%);
}

.retry-btn:hover {
    background: #ff3366;
    box-shadow: 0 0 30px rgba(255, 0, 51, 0.6);
    transform: translateY(-2px);
}

.retry-btn:active {
    transform: translateY(1px);
}

/* --- ANIMATIONS --- */
@keyframes glitch {
    0% { text-shadow: 4px 4px 0px #330000; }
    2% { text-shadow: -4px -4px 0px #330000; transform: translate(-2px, 0); }
    4% { text-shadow: 2px -2px 0px #330000; transform: translate(2px, 0); }
    6% { text-shadow: 4px 4px 0px #330000; transform: translate(0, 0); }
    100% { text-shadow: 4px 4px 0px #330000; }
}

        /* --- MAIN MENU CONTAINER --- */
#main-menu {
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 200;
    font-family: 'Segoe UI', sans-serif;
}

#main-menu h1 {
    font-size: 72px;
    color: #fff;
    text-shadow: 0 0 10px rgba(0, 210, 255, 0.8), 0 0 40px rgba(0, 210, 255, 0.4);
    margin-bottom: 10px;
    letter-spacing: 4px;
    font-weight: 800;
    text-transform: uppercase;
}

#main-menu p {
    color: #889;
    font-size: 18px;
    margin-bottom: 60px;
    letter-spacing: 2px;
    text-transform: uppercase;
}

/* --- CARDS CONTAINER --- */
.difficulty-container {
    display: flex;
    gap: 25px;
    flex-wrap: wrap;
    justify-content: center;
    perspective: 1000px;
}

/* --- BASE CARD STYLE --- */
.diff-card {
    position: relative;
    width: 200px;
    height: 300px;
    background: rgba(255, 255, 255, 0.03);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    overflow: hidden;
    backdrop-filter: blur(10px);
}

/* Hover Effect: Lift and Glow */
.diff-card:hover {
    transform: translateY(-15px) scale(1.02);
    background: rgba(255, 255, 255, 0.08);
}

/* Content Styling */
.diff-card .icon {
    width: 60px;
    height: 60px;
    margin-bottom: 20px;
    transition: 0.4s;
}

.diff-card .title {
    font-size: 24px;
    font-weight: bold;
    text-transform: uppercase;
    margin-bottom: 5px;
    color: #fff;
    z-index: 2;
}

.diff-card .stats {
    font-size: 14px;
    opacity: 0.7;
    z-index: 2;
}

.diff-card .desc {
    font-size: 12px;
    color: #aaa;
    margin-top: 15px;
    text-align: center;
    padding: 0 15px;
    line-height: 1.4;
    z-index: 2;
}

/* --- UNIQUE CARD THEMES --- */

/* 1. EASY (Green/Safety) */
.card-easy { border-bottom: 4px solid #00ff88; }
.card-easy .icon svg { fill: #00ff88; filter: drop-shadow(0 0 5px #00ff88); }
.card-easy:hover { box-shadow: 0 0 30px rgba(0, 255, 136, 0.3); border-color: #00ff88; }
.card-easy .stats { color: #00ff88; }

/* 2. MEDIUM (Yellow/Industrial) */
.card-medium { border-bottom: 4px solid #ffcc00; }
.card-medium .icon svg { fill: #ffcc00; filter: drop-shadow(0 0 5px #ffcc00); }
.card-medium:hover { box-shadow: 0 0 30px rgba(255, 204, 0, 0.3); border-color: #ffcc00; }
.card-medium .stats { color: #ffcc00; }

/* 3. HARD (Orange/Warning) */
.card-hard { border-bottom: 4px solid #ff6600; }
.card-hard .icon svg { fill: #ff6600; filter: drop-shadow(0 0 5px #ff6600); }
.card-hard:hover { box-shadow: 0 0 30px rgba(255, 102, 0, 0.4); border-color: #ff6600; }
.card-hard .stats { color: #ff6600; }

/* 4. EXTREME (Red/Danger) */
.card-extreme { 
    border-bottom: 4px solid #ff0000; 
    box-shadow: inset 0 0 20px rgba(255, 0, 0, 0.1); /* Inner red tint */
}

/* The Skull Icon Style */
.card-extreme .icon svg { 
    fill: #ff0000; 
    /* Double shadow for intense glow */
    filter: drop-shadow(0 0 20px #ff0000) drop-shadow(0 0 20px #ff0000);
}

/* Hover Effects */
.card-extreme:hover { 
    box-shadow: 0 0 50px rgba(255, 0, 0, 0.6), inset 0 0 30px rgba(255, 0, 0, 0.2); 
    border-color: #ff0000; 
    animation: violent-shake 0.4s infinite; /* Aggressive jitter */
}
.card-extreme:hover .icon svg {
    filter: drop-shadow(0 0 15px #ff0000) drop-shadow(0 0 40px #ff0000);
    transform: scale(1.1);
}

.card-extreme .stats { color: #ff0000; font-weight: bold; text-shadow: 0 0 10px #ff0000; }

/* 5. CREATIVE (Cyan/GodMode) */
.card-creative { border-bottom: 4px solid #00d2ff; }
.card-creative .icon svg { fill: #00d2ff; filter: drop-shadow(0 0 10px #00d2ff); }
.card-creative:hover { box-shadow: 0 0 40px rgba(0, 210, 255, 0.5); border-color: #00d2ff; }
.card-creative .stats { color: #00d2ff; }

/* Subtle Grid Background on cards */
.diff-card::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0; bottom: 0;
    background-image: 
        linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
    background-size: 20px 20px;
    opacity: 0.2;
    z-index: 1;
}

@keyframes violent-shake {
    0% { transform: translateY(-15px) rotate(0deg); }
    25% { transform: translateY(-15px) rotate(2deg); }
    50% { transform: translateY(-15px) rotate(-2deg); }
    75% { transform: translateY(-15px) rotate(2deg); }
    100% { transform: translateY(-15px) rotate(0deg); }
}

/* --- PAUSE MENU STYLES --- */
        #pause-menu {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 10, 0.85); /* Dark semi-transparent background */
            backdrop-filter: blur(8px);       /* Blur effect */
            z-index: 300;                     /* Above everything else */
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', sans-serif;
        }

        #pause-menu h1 {
            font-size: 60px;
            color: white;
            margin-bottom: 40px;
            text-transform: uppercase;
            letter-spacing: 10px;
            text-shadow: 0 0 20px #00d2ff;
        }

        .pause-buttons {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .pause-btn {
            background: transparent;
            color: #00d2ff;
            border: 2px solid #00d2ff;
            padding: 15px 60px;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 2px;
            transition: all 0.2s ease;
            text-align: center;
            width: 300px;
        }

        .pause-btn:hover {
            background: #00d2ff;
            color: #050505;
            box-shadow: 0 0 30px rgba(0, 210, 255, 0.6);
            transform: scale(1.05);
        }

        /* --- ENEMY INTRO OVERLAY --- */
#enemy-intro-overlay {
    display: none; /* Hidden by default */
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.85);
    z-index: 9999; /* On top of everything */
    justify-content: center;
    align-items: center;
    backdrop-filter: blur(5px);
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
}

.intro-card {
    background: linear-gradient(135deg, #1a1a24 0%, #0f0f13 100%);
    border: 1px solid #444;
    border-left: 4px solid #ff0044; /* Red Accent */
    width: 650px;
    padding: 30px;
    border-radius: 8px;
    box-shadow: 0 0 50px rgba(0, 0, 0, 0.9);
    color: white;
    position: relative;
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.intro-header {
    border-bottom: 1px solid #333;
    padding-bottom: 10px;
    margin-bottom: 10px;
}

.intro-title {
    font-size: 28px;
    font-weight: 800;
    color: #fff;
    text-transform: uppercase;
    letter-spacing: 2px;
    text-shadow: 0 0 10px rgba(255, 0, 68, 0.5);
}

.intro-sub {
    font-size: 11px;
    color: #888;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.intro-content {
    display: flex;
    gap: 25px;
    align-items: flex-start;
}

/* THE PREVIEW CANVAS */
#enemy-preview-canvas {
    background: radial-gradient(circle at center, #2a2a35 0%, #000 100%);
    border: 1px solid #555;
    border-radius: 4px;
    box-shadow: inset 0 0 20px #000;
}

.intro-details {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

/* STAT BARS (10 Rectangles) */
.stat-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
}

.stat-label {
    font-size: 12px;
    color: #aaa;
    font-weight: bold;
    text-transform: uppercase;
    width: 80px;
}

.stat-bar-container {
    display: flex;
    gap: 4px; /* Space between rectangles */
}

.stat-pip {
    width: 14px;
    height: 10px;
    background: #222; /* Empty color */
    border-radius: 1px;
    transition: background 0.3s;
}

/* Filled Colors */
.stat-pip.filled.durability { background: #ff4444; box-shadow: 0 0 5px #ff4444; }
.stat-pip.filled.speed { background: #ffcc00; box-shadow: 0 0 5px #ffcc00; }
.stat-pip.filled.damage { background: #aa00ff; box-shadow: 0 0 5px #aa00ff; }

.lore-text {
    margin-top: 10px;
    font-size: 14px;
    line-height: 1.6;
    color: #ddd;
    font-style: italic;
    background: rgba(255, 255, 255, 0.05);
    padding: 15px;
    border-radius: 4px;
    border-left: 2px solid #666;
}

.continue-btn {
    width: 100%;
    padding: 15px;
    background: #ff0044;
    color: white;
    border: none;
    font-weight: bold;
    font-size: 16px;
    cursor: pointer;
    text-transform: uppercase;
    letter-spacing: 2px;
    transition: 0.2s;
    margin-top: 10px;
}

.continue-btn:hover {
    background: #ff2266;
    box-shadow: 0 0 20px rgba(255, 0, 68, 0.5);
}

/* --- SKILL TREE MODAL (The Window) --- */
/* =========================================
   FUTURE-TECH SKILL TREE CSS
   ========================================= */

/* --- VARIABLES --- */
:root {
    --neon-blue: #00f3ff;
    --neon-purple: #bc13fe;
    --neon-gold: #ffd700;
    --void-bg: #050505;
    --glass-bg: rgba(10, 15, 30, 0.85);
}

/* --- THE MAIN OVERLAY --- */
#skill-tree-overlay {
    position: fixed;
    top: 0; left: 0;
    width: 100vw; height: 100vh;
    background: transparent;
    z-index: 2000;
    display: none;
    flex-direction: column;
    font-family: 'Courier New', monospace; /* Tech font */
}

/* --- HEADER (HOLO-BAR) --- */
.st-header {
    height: 70px;
    background: var(--glass-bg);
    border-bottom: 2px solid var(--neon-purple);
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0 40px;
    z-index: 10;
    backdrop-filter: blur(10px);
    box-shadow: 0 0 20px rgba(188, 19, 254, 0.3);
}

.st-title { 
    font-size: 28px; 
    color: #fff; 
    font-weight: bold; 
    text-transform: uppercase; 
    letter-spacing: 4px;
    text-shadow: 0 0 10px var(--neon-blue);
}

.st-currency { 
    font-size: 22px; 
    color: var(--neon-gold); 
    font-weight: bold; 
    text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
}

.st-close-btn { 
    background: transparent; 
    color: var(--neon-blue); 
    border: 1px solid var(--neon-blue); 
    padding: 10px 30px; 
    font-weight: bold; 
    cursor: pointer; 
    text-transform: uppercase;
    transition: 0.3s;
    letter-spacing: 2px;
}
.st-close-btn:hover {
    background: var(--neon-blue);
    color: #000;
    box-shadow: 0 0 20px var(--neon-blue);
}

/* --- THE VIEWPORT (CAMERA) --- */
#st-viewport {
    flex: 1;
    overflow: hidden;
    position: relative;
    cursor: grab;
    background: transparent;
}
#st-viewport:active { cursor: grabbing; }

/* --- THE WORLD (GRID SYSTEM) --- */
#st-world {
    width: 3000px;
    height: 3000px;
    position: relative;
    
    /* FUTURISTIC GRID BACKGROUND */
    background-color: transparent;

}

/* Add a Vignette Overlay to focus the center */
#st-world::after {
    content: "";
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    /* Adjusted to be slightly see-through at edges (0.9 instead of solid #000) */
    background: radial-gradient(circle at center, transparent 0%, rgba(0,0,0,0.85) 80%);
    pointer-events: none;
}

/* --- CONNECTION LINES (SVG) --- */
#st-connections {
    position: absolute;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 0;
    pointer-events: none;
}
.connection-line {
    stroke: #333;
    stroke-width: 3;
    transition: stroke 0.5s, stroke-width 0.5s;
    opacity: 0.4;
}

/* --- THE NODES (HEXAGONS) --- */
.skill-node {
    position: absolute;
    transform: translate(-50%, -50%);
    z-index: 2;
    cursor: pointer;
    transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275), 
                box-shadow 0.3s ease, 
                border-color 0.3s ease, 
                background-color 0.3s ease,
                filter 0.3s ease,
                opacity 0.3s ease;
    display: flex;
    justify-content: center;
    align-items: center;
    color: #fff;
    font-size: 24px;
    user-select: none;
}

/* 1. CORE NODE (Circle) */
.node-core {
    width: 90px; height: 90px;
    border-radius: 50%;
    background: radial-gradient(circle, #444, #111);
    border: 2px solid #fff;
    box-shadow: 0 0 30px rgba(255,255,255, 0.2);
}

/* 2. STAT NODE (Circle) */
.node-stat {
    width: 50px; height: 50px;
    border-radius: 50%;
    background: #1a1a1a;
    border: 2px solid #555;
}

/* 3. UNLOCK NODE (Hexagon) */
.node-unlock {
    width: 80px; height: 70px; /* Hexagon aspect ratio */
    background: #222;
    /* CSS MAGIC FOR HEXAGON SHAPE */
    clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
    border: none; /* Borders don't work well with clip-path, we use box-shadow via a trick or background */
}
/* Hexagon Border Trick (Inner Shadow) */
.node-unlock::before {
    content: "";
    position: absolute;
    top: 2px; left: 2px; right: 2px; bottom: 2px;
    background: #111;
    clip-path: polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%);
    z-index: -1;
}

/* --- NODE STATES --- */

/* LOCKED */
.skill-node.locked {
    opacity: 0.6;
    filter: grayscale(100%);
}

/* UNLOCKED (Available to buy) */
.skill-node.unlocked {
    border-color: var(--neon-gold);
    animation: pulseGold 2s infinite;
}


/* PURCHASED */
.skill-node.purchased {
    background: var(--neon-purple);
    box-shadow: 0 0 25px var(--neon-purple);
    border-color: #fff;
    z-index: 5;
}
.node-unlock.purchased {
    background: var(--neon-purple); 
    box-shadow: none; /* Drop shadow doesn't work on clip-path */
    filter: drop-shadow(0 0 10px var(--neon-purple)); /* This works on shapes */
}

/* HOVER EFFECT */
.skill-node:hover {
    transform: translate(-50%, -50%) scale(1.2);
    z-index: 100;
}

/* --- TOOLTIP (DATA CARD) --- */
#st-tooltip {
    position: absolute;
    background: rgba(5, 5, 10, 0.95);
    border: 1px solid var(--neon-blue);
    padding: 0;
    width: 300px;
    pointer-events: none;
    z-index: 3000;
    display: none;
    box-shadow: 0 0 20px rgba(0, 243, 255, 0.2);
    /* Corner cuts */
    clip-path: polygon(
        10px 0, 100% 0, 
        100% calc(100% - 10px), calc(100% - 10px) 100%, 
        0 100%, 0 10px
    );
}

#tt-title { 
    background: rgba(0, 243, 255, 0.1);
    color: var(--neon-blue); 
    margin: 0; padding: 12px;
    font-size: 16px; 
    text-transform: uppercase; 
    border-bottom: 1px solid rgba(0, 243, 255, 0.3);
}

#tt-desc { 
    padding: 12px; 
    color: #ccc; 
    font-size: 13px; 
    line-height: 1.5; 
    margin: 0;
}

#tt-cost {
    padding: 10px 12px;
    text-align: right;
    font-weight: bold;
    font-size: 14px;
    border-top: 1px solid #333;
}

/* --- ANIMATIONS --- */
@keyframes pulseGold {
    0% { box-shadow: 0 0 0 rgba(255, 215, 0, 0); border-color: #887000; }
    50% { box-shadow: 0 0 20px rgba(255, 215, 0, 0.6); border-color: #ffd700; }
    100% { box-shadow: 0 0 0 rgba(255, 215, 0, 0); border-color: #887000; }
}
/* --- TOOLTIP --- */
#st-tooltip {
    position: absolute;
    background: rgba(15, 15, 20, 0.98);
    border: 1px solid #666;
    padding: 15px;
    border-radius: 8px;
    width: 280px;
    pointer-events: none;
    z-index: 3000;
    display: none;
    box-shadow: 0 10px 30px rgba(0,0,0,1);
}
#st-tooltip h3 { margin: 0 0 5px 0; color: #a388ee; border-bottom: 1px solid #444; padding-bottom: 5px; }
#st-tooltip p { font-size: 13px; color: #ccc; line-height: 1.4; margin-bottom: 10px; }
#st-tooltip .cost { font-weight: bold; color: #f1c40f; }

.tool-btn {
    position: relative; /* Needed for the overlay to sit on top */
}

/* The Lock Overlay */
.tool-btn.is-locked::after {
    content: "ðŸ”’"; 
    position: absolute;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.7); /* Darken the button */
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    border-radius: 8px;
    cursor: not-allowed;
    z-index: 10;
}

/* Optional: Dim the icon behind the lock */
.tool-btn.is-locked img, 
.tool-btn.is-locked span {
    opacity: 0.3;
}

/* --- VOID TECH BUTTON STYLE --- */
.skill-btn {
    /* Dark Purple Void Gradient */
    background: linear-gradient(135deg, #1a0b2e 0%, #000000 100%);
    
    /* Neon Purple Border */
    border: 1px solid #9b59b6; 
    
    /* Glowing Text */
    color: #e0d0ff; 
    font-family: 'Segoe UI', sans-serif;
    font-weight: bold;
    text-transform: uppercase;
    letter-spacing: 1px;
    
    /* Spacing & Layout */
    margin-top: 15px; /* Separates it from the "Start Game" buttons */
    padding: 12px 24px;
    cursor: pointer;
    border-radius: 6px;
    
    /* The Void Glow */
    box-shadow: 0 0 10px rgba(155, 89, 182, 0.2);
    transition: all 0.3s ease;
    
    /* Animation */
    animation: voidPulse 3s infinite ease-in-out;
}

/* Hover Effect: Brightens and lifts */
.skill-btn:hover {
    background: linear-gradient(135deg, #381a5c 0%, #0f0f15 100%);
    border-color: #be93d4;
    box-shadow: 0 0 20px rgba(155, 89, 182, 0.6), inset 0 0 10px rgba(155, 89, 182, 0.2);
    transform: translateY(-2px);
    text-shadow: 0 0 8px rgba(224, 208, 255, 0.8);
}

/* Active/Click Effect */
.skill-btn:active {
    transform: translateY(1px);
    box-shadow: 0 0 5px rgba(155, 89, 182, 0.4);
}

/* The Pulse Animation */
@keyframes voidPulse {
    0% { box-shadow: 0 0 8px rgba(155, 89, 182, 0.2); border-color: #7d3c98; }
    50% { box-shadow: 0 0 18px rgba(155, 89, 182, 0.5); border-color: #af7ac5; }
    100% { box-shadow: 0 0 8px rgba(155, 89, 182, 0.2); border-color: #7d3c98; }
}
    </style>
</head>
<body>

    <div id="main-menu">
    <h1>SWARM DEFENSE</h1>
    <p>System Initialized. Select Combat Simulation Level.</p>
    <div class="difficulty-container">
        
        <div class="diff-card card-easy" onclick="startGame('easy')">
            <div class="icon">
                <svg viewBox="0 0 24 24"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm0 10.99h7c-.53 4.12-3.28 7.79-7 8.94V12H5V6.3l7-3.11v8.8z"/></svg>
            </div>
            <div class="title">Recruit</div>
            <div class="stats">Enemy HP x0.5</div>
            <div class="desc">For new commanders. Enemies are weak and fall easily.</div>
        </div>

        <div class="diff-card card-medium" onclick="startGame('medium')">
            <div class="icon">
                <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm-1-13h2v4h-2zm0 6h2v4h-2z"/></svg>
            </div>
            <div class="title">Soldier</div>
            <div class="stats">Enemy HP x1.0</div>
            <div class="desc">The standard experience. Balanced tactical combat.</div>
        </div>

        <div class="diff-card card-hard" onclick="startGame('hard')">
            <div class="icon">
                <svg viewBox="0 0 24 24"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>
            </div>
            <div class="title">Veteran</div>
            <div class="stats">Enemy HP x2.0</div>
            <div class="desc">Enemies are tough. Optimal layouts required to survive.</div>
        </div>

        <div class="diff-card card-extreme" onclick="startGame('extreme')">
            <div class="icon">
                <svg viewBox="0 0 24 24"><path d="M12 2c-4.97 0-9 4.03-9 9 0 4.97 9 13 9 13s9-8.03 9-13c0-4.97-4.03-9-9-9zm0 16c-1.1 0-2-.9-2-2h4c0 1.1-.9 2-2 2zm6-6c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-4 0c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-4 0c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-4 0c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"/></svg>
            </div>
            <div class="title">Nightmare</div>
            <div class="stats">Enemy HP x3.0</div>
            <div class="desc">Massive health pools. One mistake means death.</div>
        </div>

        <div class="diff-card card-creative" onclick="startGame('creative')">
            <div class="icon">
                <svg viewBox="0 0 24 24"><path d="M22.7 19l-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4z"/></svg>
            </div>
            <div class="title">Sandbox</div>
            <div class="stats">Infinite Money</div>
            <div class="desc">Test your defenses with unlimited resources.</div>
        </div>
    </div>
    <button class="menu-btn skill-btn" onclick="openSkillTree()">Void Tech (Skills)</button>
</div>

<div id="ui">
    <div class="hud-panel">
        <div class="stats-header">
            <h1>Swarm Defense V3</h1>
        </div>
        <div class="stats-grid">
            <span>HP: <span id="hp" class="stat-val" style="color:#0f0">100</span></span>
            <span>Wave: <span id="wave" class="stat-val">1</span></span>
            <span>Money: <span id="money" class="stat-val" style="color:gold">400</span></span>
            <span>Enemies: <span id="enemy-count" class="stat-val">0</span></span>
        </div>
    </div>
    
    <div class="hud-panel controls"> <div class="tab-nav">
            <button class="tab-btn active-tab" onclick="openTab(event, 'defense')">Defense</button>
            <button class="tab-btn" onclick="openTab(event, 'attack')">Attack</button>
            <button class="tab-btn" onclick="openTab(event, 'economy')">Economy</button>
        </div>

        <div id="tab-defense" class="tab-content active-content">
            <button id="btn-wall" class="tool-btn active" onclick="setTool('wall')">
                <span class="btn-label">Titan Wall</span>
                <span class="btn-cost">$10</span>
                <span class="btn-hotkey">[1]</span>
            </button>
            <button id="btn-cryo" class="tool-btn" onclick="setTool('cryo_tower')">
                <span class="btn-label">Cryo Tower</span>
                <span class="btn-cost">$100</span>
                <span class="btn-hotkey">[0]</span>
            </button>
            <button id="btn-trap" class="tool-btn" onclick="setTool('trap')">
                <span class="btn-label">Spike Trap</span>
                <span class="btn-cost">$40</span>
                <span class="btn-hotkey">[6]</span>
            </button>
            <button id="btn-bard" class="tool-btn" onclick="setTool('bard_troop')">
                <span class="btn-label">Bard</span>
                <span class="btn-cost">$100</span>
                <span class="btn-hotkey">[B]</span>
            </button>
            <button id="btn-sucker" class="tool-btn" onclick="setTool('sucker')">
                <span class="btn-label">Sucker Tower</span>
                <span class="btn-cost">$150</span>
                <span class="btn-hotkey">[V]</span>
            </button>
        </div>

        <div id="tab-attack" class="tab-content">
            <button id="btn-troop" class="tool-btn" onclick="setTool('troop')">
                <span class="btn-label">Soldier</span>
                <span class="btn-cost">$10</span>
                <span class="btn-hotkey">[2]</span>
            </button>
            <button id="btn-sword" class="tool-btn" onclick="setTool('sword_troop')">
                <span class="btn-label">Sword Soldier</span>
                <span class="btn-cost">$50</span>
                <span class="btn-hotkey">[9]</span>
            </button>
            <button id="btn-shield" class="tool-btn" onclick="setTool('shield_troop')">
                <span class="btn-label">Shield Guard</span>
                <span class="btn-cost">$75</span>
                <span class="btn-hotkey">[S]</span>
            </button>
            <button id="btn-barracks" class="tool-btn" onclick="setTool('barracks')">
                <span class="btn-label">Barracks</span>
                <span class="btn-cost">$200</span>
                <span class="btn-hotkey">[3]</span>
            </button>
            <button id="btn-wallturret" class="tool-btn" onclick="setTool('wall_turret')">
                <span class="btn-label">Wall Turret</span>
                <span class="btn-cost">$150</span>
                <span class="btn-hotkey">[7]</span>
            </button>
            <button id="btn-mortar" class="tool-btn" onclick="setTool('mortar')">
                <span class="btn-label">Mortar</span>
                <span class="btn-cost">$200</span>
                <span class="btn-hotkey">[4]</span>
            </button>
            <button id="btn-minigun" class="tool-btn" onclick="setTool('minigun')">
                <span class="btn-label">Minigun</span>
                <span class="btn-cost">$400</span>
                <span class="btn-hotkey">[M]</span>
            </button>
            <button id="btn-tesla" class="tool-btn" onclick="setTool('tesla')">
                <span class="btn-label">Tesla Coil</span>
                <span class="btn-cost">$250</span>
                <span class="btn-hotkey">[T]</span>
            </button>
            <button id="btn-railgun" class="tool-btn" onclick="setTool('railgun')">
                <span class="btn-label">Titan Railgun</span>
                <span class="btn-cost">$1500</span>
                <span class="btn-hotkey">[A]</span>
            </button>
        </div>

        <div id="tab-economy" class="tab-content">
            <button id="btn-farm" class="tool-btn" onclick="setTool('money_farm')">
                <span class="btn-label">Money Farm</span>
                <span class="btn-cost">$350</span>
                <span class="btn-hotkey">[8]</span>
            </button>
            <button id="btn-bounty" class="tool-btn" onclick="setTool('bounty')">
                <span class="btn-label">Bounty Tower</span>
                <span class="btn-cost">$150</span>
                <span class="btn-hotkey">[Y]</span>
            </button>
            <button id="btn-delete" class="tool-btn btn-delete" onclick="setTool('delete')">
                <span class="btn-label">Salvage</span>
                <span class="btn-cost">+50% Refund</span>
                <span class="btn-hotkey">[5]</span>
            </button>
        </div>

        <div style="font-size: 11px; color: #666; margin-top: 10px; text-align: center;">
            Press <strong>'R'</strong> to Rotate
        </div>
    </div>
</div>


    <div id="game-over">
    <div class="game-over-card">
        <h1>CRITICAL FAILURE</h1>
        <div class="sub-text">Base Integrity: 0%</div>
        
        <div class="stat-box">
            <span class="stat-label">Waves Survived</span>
            <span id="final-wave">0</span>
        </div>

        <button class="retry-btn" onclick="location.reload()">
            Initialize Reboot
        </button>
    </div>
</div>

    <div id="pause-menu" style="display: none;">
        <h1>PAUSED</h1>
        <div class="pause-buttons">
            <button class="pause-btn" onclick="togglePause()">RESUME</button>
            <button class="pause-btn" onclick="restartGame()">RESTART</button>
            <button class="pause-btn" onclick="goToMainMenu()">MAIN MENU</button>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

    <div id="enemy-intro-overlay">
    <div class="intro-card">
        <div class="intro-header">
            <div class="intro-title" id="intro-name">UNKNOWN ENTITY</div>
            <div class="intro-sub">NEW INTEL ACQUIRED</div>
        </div>

        <div class="intro-content">
            <canvas id="enemy-preview-canvas" width="250" height="250"></canvas>

            <div class="intro-details">
                <div id="intro-stats"></div>
            </div>
        </div>

        <div class="lore-text" id="intro-lore">
            Analyzing biological structure...
        </div>

        <button class="continue-btn" onclick="closeEnemyIntro()">RESUME DEFENSE</button>
    </div>
</div>
<div id="skill-tree-overlay">
    
    <div class="st-header">
        <div class="st-title">VOID RESEARCH</div>
        <div class="st-currency">
            <span>ðŸŸ£</span> 
            <span id="st-shard-count">0</span> 
            <span style="font-size: 14px; color: #888; margin-left:5px;">Shards</span>
        </div>
        <button class="st-close-btn" onclick="closeSkillTree()">CLOSE</button>
    </div>

    <div id="st-viewport">
        <div id="st-world">
            
            <svg id="st-connections"></svg>
            
            </div>
    </div>

    <div id="st-tooltip">
        <h3 id="tt-title">Skill Name</h3>
        <p id="tt-desc">Description text...</p>
        <div class="cost" id="tt-cost">Cost: 100</div>
    </div>

</div>
<script>

    /* --- SKILL TREE SYSTEM --- */

    // --- SKILL TREE BACKGROUND ANIMATION ---
// --- SKILL TREE BACKGROUND: NEURAL CONSTELLATION ---
let stCanvas, stCtx;
let stAnimFrame;
let stParticles = [];
const PARTICLE_COUNT = 70;
const CONNECTION_DIST = 150;
const MOUSE_DIST = 200;

// Track mouse relative to canvas
let stMouse = { x: null, y: null };

function initSkillTreeBackground() {
    let container = document.getElementById('skill-tree-overlay');
    
    // 1. Force container transparency so canvas shows
    container.style.background = "transparent"; 

    // 2. Create or Reset Canvas
    if (!document.getElementById('st-bg-canvas')) {
        stCanvas = document.createElement('canvas');
        stCanvas.id = 'st-bg-canvas';
        stCanvas.style.position = 'absolute';
        stCanvas.style.top = '0';
        stCanvas.style.left = '0';
        stCanvas.style.width = '100%';
        stCanvas.style.height = '100%';
        stCanvas.style.zIndex = '-1'; 
        container.insertBefore(stCanvas, container.firstChild);
        
        stCtx = stCanvas.getContext('2d');

        // Mouse Listeners for interactive background
        container.addEventListener('mousemove', function(e) {
            stMouse.x = e.clientX;
            stMouse.y = e.clientY;
        });
        container.addEventListener('mouseleave', function() {
            stMouse.x = null;
            stMouse.y = null;
        });
    }

    // 3. Initialize Particles
    resizeCanvas(); // Set initial size
    stParticles = [];
    for(let i=0; i < PARTICLE_COUNT; i++) {
        stParticles.push(new NetworkParticle());
    }
    
    // 4. Start Loop
    window.addEventListener('resize', resizeCanvas);
    if (stAnimFrame) cancelAnimationFrame(stAnimFrame);
    animateSkillTreeBg();
}

function resizeCanvas() {
    if(!stCanvas) return;
    stCanvas.width = window.innerWidth;
    stCanvas.height = window.innerHeight;
}

class NetworkParticle {
    constructor() {
        this.x = Math.random() * window.innerWidth;
        this.y = Math.random() * window.innerHeight;
        this.vx = (Math.random() - 0.5) * 1.5; // Random velocity X
        this.vy = (Math.random() - 0.5) * 1.5; // Random velocity Y
        this.size = Math.random() * 2 + 1;
        // Randomly assign colors based on your CSS variables
        this.color = Math.random() > 0.5 ? "#00f3ff" : "#bc13fe"; 
    }

    update() {
        this.x += this.vx;
        this.y += this.vy;

        // Bounce off edges
        if (this.x < 0 || this.x > stCanvas.width) this.vx *= -1;
        if (this.y < 0 || this.y > stCanvas.height) this.vy *= -1;

        // Mouse Interaction: Flee from mouse slightly
        if (stMouse.x != null) {
            let dx = stMouse.x - this.x;
            let dy = stMouse.y - this.y;
            let distance = Math.sqrt(dx*dx + dy*dy);
            if (distance < MOUSE_DIST) {
                const forceDirectionX = dx / distance;
                const forceDirectionY = dy / distance;
                const force = (MOUSE_DIST - distance) / MOUSE_DIST;
                this.vx -= forceDirectionX * force * 0.05;
                this.vy -= forceDirectionY * force * 0.05;
            }
        }
    }

    draw() {
        stCtx.beginPath();
        stCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        stCtx.fillStyle = this.color;
        stCtx.fill();
    }
}

function animateSkillTreeBg() {
    if (document.getElementById('skill-tree-overlay').style.display === 'none') return;

    stCtx.clearRect(0, 0, stCanvas.width, stCanvas.height);
    
    // 1. Draw Subtle Background Gradient
    let grad = stCtx.createRadialGradient(stCanvas.width/2, stCanvas.height/2, 0, stCanvas.width/2, stCanvas.height/2, stCanvas.width);
    grad.addColorStop(0, "#0a0f1e"); // Dark Blue Center
    grad.addColorStop(1, "#000000"); // Black Edges
    stCtx.fillStyle = grad;
    stCtx.fillRect(0, 0, stCanvas.width, stCanvas.height);

    // 2. Update and Draw Particles
    stParticles.forEach(p => {
        p.update();
        p.draw();
    });

    // 3. Draw Connections
    connectParticles();

    stAnimFrame = requestAnimationFrame(animateSkillTreeBg);
}

function connectParticles() {
    for (let a = 0; a < stParticles.length; a++) {
        for (let b = a; b < stParticles.length; b++) {
            let dx = stParticles[a].x - stParticles[b].x;
            let dy = stParticles[a].y - stParticles[b].y;
            let distance = Math.sqrt(dx * dx + dy * dy);

            if (distance < CONNECTION_DIST) {
                // Opacity based on distance (closer = brighter)
                let opacity = 1 - (distance / CONNECTION_DIST);
                stCtx.strokeStyle = `rgba(0, 243, 255, ${opacity * 0.2})`; // Neon Blue Lines
                stCtx.lineWidth = 1;
                stCtx.beginPath();
                stCtx.moveTo(stParticles[a].x, stParticles[a].y);
                stCtx.lineTo(stParticles[b].x, stParticles[b].y);
                stCtx.stroke();
            }
        }
        
        // Connect to mouse
        if (stMouse.x != null) {
            let dx = stParticles[a].x - stMouse.x;
            let dy = stParticles[a].y - stMouse.y;
            let distance = Math.sqrt(dx*dx + dy*dy);
            if (distance < MOUSE_DIST) {
                let opacity = 1 - (distance / MOUSE_DIST);
                stCtx.strokeStyle = `rgba(188, 19, 254, ${opacity * 0.4})`; // Neon Purple for Mouse
                stCtx.beginPath();
                stCtx.moveTo(stParticles[a].x, stParticles[a].y);
                stCtx.lineTo(stMouse.x, stMouse.y);
                stCtx.stroke();
            }
        }
    }
}

    const skillData = {
    // =========================================
    // --- CENTER: CORE (Base Upgrades) ---
    // =========================================
    "core_vitality": { 
        name: "Core Vitality", desc: "Base starts with +50 Max HP.", 
        cost: 5, type: "core", x: 0, y: 0, parent: null 
    },
    "core_regen": { 
        name: "Nano-Repair", desc: "Base regenerates 1 HP every 5 seconds.", 
        cost: 100, type: "stat", x: 0, y: 150, parent: "core_vitality" 
    },

    // =========================================
    // --- NORTH: INFANTRY (Sword, Shield, Bard) ---
    // =========================================
    
    // --- Branch 1: Sword ---
    "unlock_sword": {
        name: "UNLOCK: Sword Soldier", desc: "Basic melee unit.",
        cost: 15, type: "unlock", x: 0, y: -150, parent: "core_vitality"
    },
    "sword_dmg": {
        name: "Sharpened Blades", desc: "Sword Soldiers deal +20 Damage.",
        cost: 25, type: "stat", x: -120, y: -160, parent: "unlock_sword"
    },
    "sword_atk_spd": {
        name: "Frenzy Stance", desc: "Sword Soldiers attack 15% faster.",
        cost: 45, type: "stat", x: -140, y: -250, parent: "unlock_sword"
    },
    "sword_move_spd": {
        name: "Lightweight Boots", desc: "Sword Soldiers move 20% faster.",
        cost: 30, type: "stat", x: -80, y: -300, parent: "unlock_sword"
    },

    // --- Branch 2: Shield ---
    "unlock_shield": {
        name: "UNLOCK: Shield Guard", desc: "High HP tank unit.",
        cost: 30, type: "unlock", x: 80, y: -220, parent: "unlock_sword"
    },
    "shield_hp": {
        name: "Titan Armor", desc: "Shield Guards get +200 Max HP.",
        cost: 40, type: "stat", x: 140, y: -280, parent: "unlock_shield"
    },

    // --- Branch 3: Bard ---
    "unlock_bard": {
        name: "UNLOCK: Bard", desc: "Lures enemies away from the base.",
        cost: 50, type: "unlock", x: 0, y: -300, parent: "unlock_sword"
    },
    "bard_range": {
        name: "Louder Music", desc: "Bard lure range increased by 30%.",
        cost: 60, type: "stat", x: -40, y: -380, parent: "unlock_bard"
    },
    "bard_durability": {
        name: "Stage Presence", desc: "Bards have +100 Max HP.",
        cost: 40, type: "stat", x: 40, y: -380, parent: "unlock_bard"
    },

    // =========================================
    // --- WEST: DEFENSE (Turret, Cryo, Spikes) ---
    // =========================================

    // --- Branch 1: Wall Turret ---
    "unlock_wall_turret": {
        name: "UNLOCK: Wall Turret", desc: "Basic defensive tower.",
        cost: 15, type: "unlock", x: -150, y: 0, parent: "core_vitality"
    },
    "turret_fire_rate": {
        name: "Rapid Loader", desc: "Wall Turret fires 20% faster.",
        cost: 30, type: "stat", x: -240, y: -80, parent: "unlock_wall_turret"
    },
    "turret_range": {
        name: "Sniper Lens", desc: "Wall Turret range +40%.",
        cost: 45, type: "stat", x: -150, y: -90, parent: "unlock_wall_turret"
    },
    "turret_dmg": {
        name: "Depleted Uranium", desc: "Wall Turret deals +15 Damage.",
        cost: 50, type: "stat", x: -80, y: -100, parent: "unlock_wall_turret"
    },

    // --- Branch 2: Spikes ---
    "unlock_spikes": {
        name: "UNLOCK: Spike Trap", desc: "Damages enemies walking over it.",
        cost: 25, type: "unlock", x: -240, y: 60, parent: "unlock_wall_turret"
    },
    "spike_dmg": {
        name: "Serrated Tips", desc: "Spikes deal +50% Damage.",
        cost: 40, type: "stat", x: -320, y: 100, parent: "unlock_spikes"
    },

    // --- Branch 3: Cryo Tower ---
    "unlock_cryo": {
        name: "UNLOCK: Cryo Tower", desc: "Slows enemies.",
        cost: 45, type: "unlock", x: -350, y: -20, parent: "unlock_wall_turret"
    },
    "cryo_range": {
        name: "High Pressure", desc: "Cryo Tower range +25%.",
        cost: 60, type: "stat", x: -500, y: -60, parent: "unlock_cryo"
    },
    "cryo_slow": {
        name: "Absolute Zero", desc: "Cryo slows enemies by an extra 15%.",
        cost: 80, type: "stat", x: -470, y: 20, parent: "unlock_cryo"
    },

    // =========================================
    // --- EAST: HEAVY & ECO (Farm, Barracks, Heavy) ---
    // =========================================

    // --- Branch 1: Economy (Farm) ---
    "unlock_farm": {
        name: "UNLOCK: Money Farm", desc: "Generates cash at end of wave.",
        cost: 20, type: "unlock", x: 150, y: 0, parent: "core_vitality"
    },
    "farm_val": {
        name: "Market Stocks", desc: "Farms give +$25 extra per wave.",
        cost: 35, type: "stat", x: 150, y: -110, parent: "unlock_farm"
    },
    "farm_cap": {
        name: "Offshore Accounts", desc: "Farms give another +$25 extra per wave.",
        cost: 70, type: "stat", x: 250, y: -110, parent: "unlock_farm"
    },

    // --- Branch 2: Barracks ---
    "unlock_barracks": {
        name: "UNLOCK: Barracks", desc: "Auto-spawns soldiers.",
        cost: 40, type: "unlock", x: 150, y: 100, parent: "unlock_farm"
    },
    "barracks_speed": {
        name: "Drill Sergeant", desc: "Barracks spawn units 20% faster.",
        cost: 60, type: "stat", x: 100, y: 200, parent: "unlock_barracks"
    },

    // --- Branch 3: Minigun ---
    "unlock_minigun": {
        name: "UNLOCK: Minigun", desc: "Fast fire rate, small damage.",
        cost: 60, type: "unlock", x: 400, y: -40, parent: "unlock_farm"
    },
    "minigun_dmg": {
        name: "Lubricated Barrels", desc: "Minigun does +2 Damage per shot.",
        cost: 70, type: "stat", x: 450, y: -140, parent: "unlock_minigun"
    },
    "minigun_speed": {
        name: "Motor Overdrive", desc: "Minigun attack speed is 15% faster.",
        cost: 80, type: "stat", x: 350, y: -170, parent: "unlock_minigun"
    },

    // --- Branch 4: Mortar ---
    "unlock_mortar": {
        name: "UNLOCK: Mortar", desc: "Long range AoE damage.",
        cost: 70, type: "unlock", x: 300, y: 70, parent: "unlock_farm"
    },
    "mortar_dmg": {
        name: "High Explosive", desc: "Mortar deals +30 Damage.",
        cost: 80, type: "stat", x: 370, y: 140, parent: "unlock_mortar"
    },
    "mortar_area": {
        name: "Napalm Shells", desc: "Mortar explosion radius +25%.",
        cost: 100, type: "stat", x: 300, y: 200, parent: "unlock_mortar"
    },

    // --- Branch 5: Sucker ---
    "unlock_sucker": {
        name: "UNLOCK: Sucker", desc: "Medium range support tower.",
        cost: 60, type: "unlock", x: -350, y: -150, parent: "unlock_cryo"
    },
    "sucker_area": {
        name: "Bigger ventilator", desc: "Sucker gains 15% range",
        cost: 40, type: "stat", x: -450, y: -200, parent: "unlock_sucker"
    },
    "sucker_strenght": {
        name: "Stronger engine", desc: "Sucker sucks 10% more",
        cost: 50, type: "stat", x: -250, y: -200, parent: "unlock_sucker"
    },

    // --- Branch 6: Tesla ---
    "unlock_tesla": {
        name: "UNLOCK: Tesla", desc: "Medium range chain tower.",
        cost: 100, type: "unlock", x: -150, y: 150, parent: "unlock_wall_turret"
    },
    "tesla_chain": {
        name: "Better power suply", desc: "Tesla gains 2 more chains",
        cost: 80, type: "stat", x: -230, y: 200, parent: "unlock_tesla"
    },
    "tesla_range": {
        name: "Improved materials", desc: "Tesla gains 20% more range",
        cost: 70, type: "stat", x: -70, y: 200, parent: "unlock_tesla"
    },

    // --- Branch 6: Railgun ---
    "unlock_railgun": {
        name: "UNLOCK: Railgun", desc: "Endgame devastating ray of death",
        cost: 1000, type: "unlock", x: 600, y: -40, parent: "unlock_minigun"
    },
    "railgun_width": {
        name: "Better barrel mobility", desc: "Beam is 20% wider",
        cost: 300, type: "stat", x: 700, y: -90, parent: "unlock_railgun"
    },
    "railgun_damage": {
        name: "Railgun overdrive", desc: "Railgun does 50% more damage",
        cost: 700, type: "stat", x: 700, y: 10, parent: "unlock_railgun"
    }
//negr
};

// --- CUSTOM SKILL ICON RENDERER ---
function drawSkillIcon(canvas, skillIdentifier) {
    const ctx = canvas.getContext('2d');
    const w = canvas.width;
    const h = canvas.height;
    const cx = w / 2;
    const cy = h / 2;
    // Scale factor: allows the icon to resize if you change canvas size
    const s = w / 50; 

    // Clear and Setup
    ctx.clearRect(0, 0, w, h);
    ctx.save();
    ctx.translate(cx, cy);
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.lineWidth = 3 * s;

    const id = (skillIdentifier || "").toLowerCase();

    // Helper to start a path
    const start = () => ctx.beginPath();
    // Helper to stroke/fill
    const finish = (strokeColor, fillColor = null) => {
        if (fillColor) {
            ctx.fillStyle = fillColor;
            ctx.fill();
        }
        ctx.strokeStyle = strokeColor;
        ctx.stroke();
    };

    // --- 1. CORE / VITALITY (Heart) ---
    if (id.includes("core") || id.includes("vitality") || id.includes("hp")) {
        start();
        // Draw Heart shape
        ctx.moveTo(0, 5 * s);
        ctx.bezierCurveTo(0, -5 * s, -15 * s, -15 * s, -15 * s, 0);
        ctx.bezierCurveTo(-15 * s, 15 * s, 0, 18 * s, 0, 22 * s);
        ctx.bezierCurveTo(0, 18 * s, 15 * s, 15 * s, 15 * s, 0);
        ctx.bezierCurveTo(15 * s, -15 * s, 0, -5 * s, 0, 5 * s);
        finish("#ff4d4d", "#ff000033"); // Red outline, faint red fill
    }

    // --- 2. SWORD (Infantry) ---
    else if (id.includes("sword") || id.includes("blade")) {
        ctx.rotate(Math.PI / 4); // Tilt 45 degrees
        start();
        // Blade
        ctx.moveTo(0, -15 * s);
        ctx.lineTo(0, 10 * s);
        // Hilt/Crossguard
        ctx.moveTo(-5 * s, 10 * s);
        ctx.lineTo(5 * s, 10 * s);
        // Handle
        ctx.moveTo(0, 10 * s);
        ctx.lineTo(0, 16 * s);
        // Pommel
        ctx.moveTo(0, 17 * s);
        ctx.arc(0, 17 * s, 1.5 * s, 0, Math.PI*2);
        finish("#d1d5db"); // Silver
    }

    // --- 3. SHIELD (Guard) ---
    else if (id.includes("shield") || id.includes("armor")) {
        start();
        // Shield shape
        ctx.moveTo(-10 * s, -10 * s);
        ctx.lineTo(10 * s, -10 * s);
        ctx.lineTo(10 * s, 2 * s);
        ctx.quadraticCurveTo(0, 18 * s, -10 * s, 2 * s);
        ctx.closePath();
        finish("#3b82f6", "#1e3a8a33"); // Blue
        
        // Inner cross
        ctx.beginPath();
        ctx.lineWidth = 2 * s;
        ctx.moveTo(0, -6 * s); ctx.lineTo(0, 6 * s);
        ctx.moveTo(-5 * s, 0); ctx.lineTo(5 * s, 0);
        ctx.strokeStyle = "rgba(255,255,255,0.5)";
        ctx.stroke();
    }

    // --- 4. BARD (Music Note) ---
    else if (id.includes("bard") || id.includes("music")) {
        start();
        // Note head
        ctx.ellipse(-5 * s, 10 * s, 4 * s, 3 * s, -0.2, 0, Math.PI * 2);
        // Stem
        ctx.moveTo(-2 * s, 10 * s);
        ctx.lineTo(-2 * s, -10 * s);
        // Flag
        ctx.bezierCurveTo(-2 * s, -6 * s, 6 * s, -6 * s, 6 * s, 0);
        finish("#d946ef"); // Magenta
    }

    // --- 5. TURRET (Basic Defense) ---
    else if (id.includes("turret")) {
        start();
        // Base
        ctx.rect(-8 * s, 8 * s, 16 * s, 6 * s);
        // Turret Head
        ctx.arc(0, 8 * s, 8 * s, Math.PI, 0);
        // Barrel
        ctx.moveTo(0, 0);
        ctx.lineTo(0, -12 * s);
        finish("#10b981"); // Emerald Green
    }

    // --- 6. SPIKES (Trap) ---
    else if (id.includes("spike")) {
        start();
        // Three triangles
        const drawSpike = (ox, oy) => {
            ctx.moveTo(ox - 5 * s, oy + 5 * s);
            ctx.lineTo(ox, oy - 10 * s);
            ctx.lineTo(ox + 5 * s, oy + 5 * s);
            ctx.closePath();
        };
        drawSpike(-8 * s, 5 * s);
        drawSpike(8 * s, 5 * s);
        drawSpike(0, 8 * s); // Center lower
        finish("#9ca3af"); // Grey
    }

    // --- 7. CRYO (Ice/Snowflake) ---
    else if (id.includes("cryo") || id.includes("cold")) {
        ctx.strokeStyle = "#06b6d4"; // Cyan
        ctx.lineWidth = 2 * s;
        for (let i = 0; i < 6; i++) {
            start();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, -12 * s);
            // Little prongs
            ctx.moveTo(0, -8 * s);
            ctx.lineTo(-3 * s, -10 * s);
            ctx.moveTo(0, -8 * s);
            ctx.lineTo(3 * s, -10 * s);
            ctx.stroke();
            ctx.rotate(Math.PI / 3); // Rotate 60 degrees
        }
    }

    // --- 8. FARM / MONEY (Coin) ---
    else if (id.includes("farm") || id.includes("val") || id.includes("stocks")) {
        start();
        ctx.arc(0, 0, 12 * s, 0, Math.PI * 2);
        finish("#eab308", "#facc1533"); // Gold

        // Dollar Symbol
        ctx.beginPath();
        ctx.lineWidth = 2 * s;
        ctx.moveTo(0, -8 * s); ctx.lineTo(0, 8 * s); // Vertical line
        // S curve
        ctx.moveTo(4 * s, -5 * s);
        ctx.bezierCurveTo(-4 * s, -5 * s, -4 * s, 0, 0, 0);
        ctx.bezierCurveTo(4 * s, 0, 4 * s, 5 * s, -4 * s, 5 * s);
        ctx.stroke();
    }

    // --- 9. BARRACKS (Tent/House) ---
    else if (id.includes("barracks")) {
        start();
        // Roof
        ctx.moveTo(-12 * s, 0);
        ctx.lineTo(0, -12 * s);
        ctx.lineTo(12 * s, 0);
        // Walls
        ctx.lineTo(10 * s, 10 * s);
        ctx.lineTo(-10 * s, 10 * s);
        ctx.lineTo(-12 * s, 0);
        finish("#f97316"); // Orange/Brown
        
        // Door
        ctx.beginPath();
        ctx.rect(-3*s, 4*s, 6*s, 6*s);
        ctx.fillStyle = "#fff";
        ctx.fill();
    }

    // --- 10. MINIGUN (Gatling) ---
    else if (id.includes("minigun")) {
        start();
        // Barrel Ring
        ctx.arc(0, 0, 8 * s, 0, Math.PI * 2);
        finish("#475569"); // Slate
        
        // Small holes
        ctx.fillStyle = "#fff";
        const holes = [[0,-5], [4.5,-2.5], [4.5,2.5], [0,5], [-4.5,2.5], [-4.5,-2.5]];
        holes.forEach(pos => {
            ctx.beginPath();
            ctx.arc(pos[0]*s, pos[1]*s, 1.5*s, 0, Math.PI*2);
            ctx.fill();
        });
    }

    // --- 11. MORTAR (Bomb) ---
    else if (id.includes("mortar")) {
        start();
        // Bomb circle
        ctx.arc(0, 4 * s, 9 * s, 0, Math.PI * 2);
        ctx.fill(); // Filled black/dark
        finish("#1f2937"); 
        
        // Fuse
        ctx.beginPath();
        ctx.lineWidth = 2 * s;
        ctx.moveTo(2 * s, -4 * s);
        ctx.quadraticCurveTo(5 * s, -10 * s, 10 * s, -8 * s);
        ctx.strokeStyle = "#fbbf24";
        ctx.stroke();
        
        // Spark
        ctx.beginPath();
        ctx.fillStyle = "#ef4444";
        ctx.arc(10*s, -8*s, 2*s, 0, Math.PI*2);
        ctx.fill();
    }
    
    // Fallback
    else {
        start();
        ctx.rect(-6*s, -6*s, 12*s, 12*s);
        finish("#666");
    }

    ctx.restore();
}

// --- SKILL TREE SYSTEM ---

// 1. STATE MANAGEMENT
let playerProgress = JSON.parse(localStorage.getItem('swarm_save_v2')) || {
    shards: 0,
    unlocked: [] // Array of IDs
};

function saveProgress() {
    localStorage.setItem('swarm_save_v2', JSON.stringify(playerProgress));
    updateSkillVisuals();
}

// 2. RENDERING THE TREE
function initSkillTree() {
    const world = document.getElementById('st-world');
    const svg = document.getElementById('st-connections');
    
    // Clear previous
    world.innerHTML = '<svg id="st-connections"></svg>'; 
    
    // Center the map (1500, 1500 is center of 3000x3000)
    const centerX = 1500;
    const centerY = 1500;

    // Draw Nodes
    for (let id in skillData) {
        const skill = skillData[id];
        
        // Create Node DOM
        const node = document.createElement('div');
        node.className = `skill-node node-${skill.type}`;
        node.setAttribute('data-id', id);
        
        // Position relative to center
        node.style.left = (centerX + skill.x) + 'px';
        node.style.top = (centerY + skill.y) + 'px';
        
        // --- CUSTOM ICON INTEGRATION ---
        const iconCanvas = document.createElement('canvas');
        
        // Size: Adjust these numbers to fit inside your skill node circles/squares
        // 44px is usually a good balance for visibility
        iconCanvas.width = 44; 
        iconCanvas.height = 44;
        
        // Call the function we created to draw the specific icon
        // We pass 'id' so it can match keywords like "sword", "shield", "farm"
        drawSkillIcon(iconCanvas, id);
        
        // Append the canvas to the node
        node.appendChild(iconCanvas);
        // -------------------------------

        // Events
        node.onmouseover = () => showTooltip(node, skill);
        node.onmouseout = () => hideTooltip();
        node.onclick = () => attemptPurchase(id);

        world.appendChild(node);

        // Draw Line to Parent
        if (skill.parent) {
            const parentSkill = skillData[skill.parent];
            drawLine(
                centerX + parentSkill.x, 
                centerY + parentSkill.y, 
                centerX + skill.x, 
                centerY + skill.y,
                id // ID for coloring later
            );
        }
    }
    
    updateSkillVisuals();
}

function hasSkill(id) {
    return playerProgress && playerProgress.unlocked.includes(id);
}

function drawLine(x1, y1, x2, y2, id) {
    const svg = document.getElementById('st-connections');
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    
    line.setAttribute('x1', x1);
    line.setAttribute('y1', y1);
    line.setAttribute('x2', x2);
    line.setAttribute('y2', y2);
    line.setAttribute('class', 'connection-line');
    line.setAttribute('id', 'line-' + id);
    
    svg.appendChild(line);
}

// 3. UPDATING VISUALS (Locked/Unlocked)
function updateSkillVisuals() {
    document.getElementById('st-shard-count').innerText = playerProgress.shards;

    for (let id in skillData) {
        const node = document.querySelector(`.skill-node[data-id="${id}"]`);
        if (!node) continue;

        const skill = skillData[id];
        const isBought = playerProgress.unlocked.includes(id);
        const parentBought = !skill.parent || playerProgress.unlocked.includes(skill.parent);

        // Reset classes
        node.className = `skill-node node-${skill.type}`;
        
        if (isBought) {
    node.classList.add('purchased');
    const line = document.getElementById('line-' + id);
    if(line) {
        // CHANGE THIS LINE:
        line.style.stroke = "#bc13fe"; // Neon Purple
        line.style.strokeWidth = "6"; // Thicker
        line.style.opacity = "1";
        // Add a glow filter if you want (requires defining filter in HTML), 
        // but just making it bright purple works great against the dark grid.
    }
}
    }
}

// 4. INTERACTION (Buying)
function attemptPurchase(id) {
    const skill = skillData[id];
    
    // Checks
    if (playerProgress.unlocked.includes(id)) return; // Already have it
    
    // Check Parent
    if (skill.parent && !playerProgress.unlocked.includes(skill.parent)) {
        alert("You must unlock the previous node first!");
        return;
    }

    // Check Cost
    if (playerProgress.shards >= skill.cost) {
        if(confirm(`Unlock ${skill.name} for ${skill.cost} Shards?`)) {
            playerProgress.shards -= skill.cost;
            playerProgress.unlocked.push(id);
            saveProgress();
        }
    } else {
        alert(`Not enough Shards! Need ${skill.cost}.`);
    }
}

// 5. TOOLTIP LOGIC
function showTooltip(element, skill) {
    const tt = document.getElementById('st-tooltip');
    document.getElementById('tt-title').innerText = skill.name;
    document.getElementById('tt-desc').innerText = skill.desc;
    
    const isOwned = playerProgress.unlocked.includes(element.getAttribute('data-id'));
    const costDiv = document.getElementById('tt-cost');
    costDiv.innerText = isOwned ? "OWNED" : `COST: ${skill.cost}`;
    costDiv.style.color = isOwned ? "#00ff00" : "#f1c40f";

    // Position near mouse (handled by simple CSS for now, or use event)
    const rect = element.getBoundingClientRect();
    tt.style.left = (rect.right + 20) + 'px';
    tt.style.top = rect.top + 'px';
    tt.style.display = 'block';
}
function hideTooltip() { document.getElementById('st-tooltip').style.display = 'none'; }

// 6. PANNING LOGIC (Drag the world)
let isDragging = false;
let startX, startY, scrollLeft, scrollTop;
const viewport = document.getElementById('st-viewport');

viewport.addEventListener('mousedown', (e) => {
    isDragging = true;
    startX = e.pageX - viewport.offsetLeft;
    startY = e.pageY - viewport.offsetTop;
    scrollLeft = viewport.scrollLeft;
    scrollTop = viewport.scrollTop;
});

viewport.addEventListener('mouseleave', () => { isDragging = false; });
viewport.addEventListener('mouseup', () => { isDragging = false; });

viewport.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    e.preventDefault();
    const x = e.pageX - viewport.offsetLeft;
    const y = e.pageY - viewport.offsetTop;
    const walkX = (x - startX) * 1; // Scroll speed
    const walkY = (y - startY) * 1;
    viewport.scrollLeft = scrollLeft - walkX;
    viewport.scrollTop = scrollTop - walkY;
});

// 7. OPEN/CLOSE
function openSkillTree() {
    const overlay = document.getElementById('skill-tree-overlay');
    const viewport = document.getElementById('st-viewport');

    if (overlay && viewport) {
        // 1. Show the menu
        overlay.style.display = 'flex';
        
        // 2. Initialize the tree
        initSkillTree(); 
        initSkillTreeBackground();

        // 3. FORCE CENTER (The Brute Force Math)
        // We wrap this in a double requestAnimationFrame to ensure the 
        // browser has finished "opening" the window before we scroll.
        requestAnimationFrame(() => {
            requestAnimationFrame(() => {
                const worldSize = 3000; // This matches your CSS width/height
                
                // Formula: (WorldSize - YourWindowSize) / 2
                // This gives us the top-left coordinate needed to put 1500,1500 in the center
                const centerX = (worldSize - viewport.clientWidth) / 2;
                const centerY = (worldSize - viewport.clientHeight) / 2;

                // Apply the scroll
                viewport.scrollLeft = centerX;
                viewport.scrollTop = centerY;
            });
        });
    }
}

function closeSkillTree() {
    document.getElementById('skill-tree-overlay').style.display = 'none';
    updateLockedButtons();
}

    // Track seen enemies
const seenEnemies = new Set();

// Database of Enemy Info (Keys must match Class Names exactly)
const ENEMY_INTEL = {
    'Enemy': {
        name: "Chitin Scuttler",
        stats: { durability: 2, speed: 5, threat: 2 },
        lore: "The infantry of the void swarm. While individually weak, their strength lies in overwhelming numbers."
    },
    'RunnerEnemy': {
        name: "Scythe Runner",
        stats: { durability: 1, speed: 9, threat: 4 },
        lore: "Evolved for pure velocity. These agile predators swarm in packs to overwhelm point-defense systems."
    },
    'TankEnemy': {
        name: "Void Behemoth",
        stats: { durability: 9, speed: 2, threat: 5 },
        lore: "A slow-moving fortress of chitin. Heavy weaponry is required to penetrate its thick shell."
    },
    'MagnetEnemy': {
        name: "Void Lodestone",
        stats: { durability: 10, speed: 1, threat: 8 },
        lore: "Generates a powerful magnetic field that forcibly redirects projectiles away from high-value targets."
    },
    'BreacherEnemy': {
        name: "Razor Mantis",
        stats: { durability: 4, speed: 8, threat: 6 },
        lore: "A siege unit equipped with hyper-dense scythes. Uses a frenzied dash to shred through fortifications."
    },
    'DasherEnemy': {
        name: "Phase Dasher",
        stats: { durability: 3, speed: 10, threat: 5 },
        lore: "Capable of short-range hyperspace jumps. It flickers in and out of reality to dodge heavy ordinance."
    },
    'SniperEnemy': {
        name: "Spine Launcher",
        stats: { durability: 2, speed: 3, threat: 8 },
        lore: "A stationary organism that fires biological spikes from extreme range. Targets turrets directly."
    },
    'LeaperEnemy': {
        name: "Wall Jumper",
        stats: { durability: 3, speed: 7, threat: 6 },
        lore: "Possesses powerful hydraulic-like legs capable of vaulting over standard walls."
    },
    'ShielderEnemy': {
        name: "Aegis Drone",
        stats: { durability: 5, speed: 4, threat: 7 },
        lore: "Projects an energy barrier that protects nearby units. Neutralize immediately."
    },
    'ReviverEnemy': {
        name: "Necro-Weaver",
        stats: { durability: 4, speed: 4, threat: 10 },
        lore: "Emits a regenerative pheromone that can reanimate fallen biomass."
    },
    'FlyingEnemy': {
        name: "Void Ray",
        stats: { durability: 3, speed: 6, threat: 5 },
        lore: "An airborne unit that floats above the battlefield, bypassing all ground-based obstacles."
    },
    'BroodmotherEnemy': {
        name: "Void Broodmother",
        stats: { durability: 8, speed: 2, threat: 9 },
        lore: "A massive reproductive host. It carries a gestating sack of larvae that it expels onto the battlefield."
    },
    'LarvaEnemy': {
        name: "Parasitic Larva",
        stats: { durability: 1, speed: 9, threat: 3 },
        lore: "Newly hatched spawn. Fragile but moves with erratic speed to harass defenders."
    },
    'SkeletonEnemy': {
        name: "Calcified Thrall",
        stats: { durability: 6, speed: 3, threat: 4 },
        lore: "Reanimated skeletal structure fused with void energy. Continues to advance even after critical damage."
    }
};

// 1. The Trigger
function checkForNewEnemy(enemy) {
    if (!enemy) return;
    const type = enemy.constructor.name;

    // Check if new and if data exists
    if (!seenEnemies.has(type) && ENEMY_INTEL[type]) {
        seenEnemies.add(type);
        
        // PAUSE GAME
        if (typeof isPaused !== 'undefined') isPaused = true;
        
        // OPEN UI
        openEnemyIntro(enemy, ENEMY_INTEL[type]);
    }
}

// 2. The UI Populator
function openEnemyIntro(enemyInstance, data) {
    const overlay = document.getElementById('enemy-intro-overlay');
    const nameEl = document.getElementById('intro-name');
    const loreEl = document.getElementById('intro-lore');
    const statsEl = document.getElementById('intro-stats');

    if (!overlay) return; // Safety check

    nameEl.textContent = data.name;
    loreEl.textContent = data.lore;

    // Clear and build stats
    statsEl.innerHTML = '';
    createStatRow(statsEl, 'DURABILITY', data.stats.durability, 'durability');
    createStatRow(statsEl, 'VELOCITY', data.stats.speed, 'speed');
    createStatRow(statsEl, 'THREAT', data.stats.threat, 'damage');

    // Render Visuals
    renderEnemyPreview(enemyInstance);

    // Show
    overlay.style.display = 'flex';
}

function createStatRow(container, label, value, colorClass) {
    const row = document.createElement('div');
    row.className = 'stat-row';

    const text = document.createElement('div');
    text.className = 'stat-label';
    text.innerText = label;

    const bars = document.createElement('div');
    bars.className = 'stat-bar-container';

    for (let i = 0; i < 10; i++) {
        const pip = document.createElement('div');
        pip.className = `stat-pip ${i < value ? 'filled ' + colorClass : ''}`;
        bars.appendChild(pip);
    }

    row.appendChild(text);
    row.appendChild(bars);
    container.appendChild(row);
}

// 3. The Close Function
function closeEnemyIntro() {
    const overlay = document.getElementById('enemy-intro-overlay');
    if (overlay) overlay.style.display = 'none';
    
    // UNPAUSE GAME
    if (typeof isPaused !== 'undefined') isPaused = false;
}

// 4. The Renderer (Big, Upwards, Centered)
function renderEnemyPreview(enemy) {
    const pCanvas = document.getElementById('enemy-preview-canvas');
    if (!pCanvas) return;
    
    const pCtx = pCanvas.getContext('2d');
    const w = pCanvas.width;
    const h = pCanvas.height;

    // Clear
    pCtx.clearRect(0, 0, w, h);
    
    // Background
    const grad = pCtx.createRadialGradient(w/2, h/2, 20, w/2, h/2, w/2);
    grad.addColorStop(0, "#2a2a35");
    grad.addColorStop(1, "#15151a");
    pCtx.fillStyle = grad;
    pCtx.fillRect(0, 0, w, h);

    // --- MAGIC SWAP ---
    // We must swap the global context variable so the enemy draws here
    const originalCtx = window.ctx; 
    window.ctx = pCtx;

    pCtx.save();
    
    // 1. Center
    pCtx.translate(w / 2, h / 2);

    // 2. Zoom (Big!)
    const name = enemy.constructor.name;
    let scale = 3.5; // Default Big Zoom
    
    if (name.includes("Brood")) scale = 1.3;      
    else if (name.includes("Tank")) scale = 2.0;  
    else if (name.includes("Magnet")) scale = 2.0;
    else if (name.includes("Breacher")) scale = 2.5;

    pCtx.scale(scale, scale);

    // 3. Mock Position
    const realX = enemy.x;
    const realY = enemy.y;
    const realAngle = enemy.angle;

    enemy.x = 0; 
    enemy.y = 0;
    // 4. Force Upwards
    enemy.angle = -Math.PI / 2; 

    // 5. Draw
    try {
        if (enemy.draw) {
            pCtx.shadowBlur = 20;
            pCtx.shadowColor = "rgba(0,0,0,0.5)";
            enemy.draw();
            pCtx.shadowBlur = 0;
        }
    } catch(e) { console.log(e); }

    // Restore
    enemy.x = realX;
    enemy.y = realY;
    if (realAngle !== undefined) enemy.angle = realAngle;

    pCtx.restore();
    
    // --- RESTORE MAGIC SWAP ---
    window.ctx = originalCtx;
}

    // Function to switch tabs
    function openTab(evt, tabName) {
        // 1. Hide all tab contents
        const contents = document.getElementsByClassName("tab-content");
        for (let i = 0; i < contents.length; i++) {
            contents[i].classList.remove("active-content");
        }

        // 2. Deactivate all tab buttons
        const tabs = document.getElementsByClassName("tab-btn");
        for (let i = 0; i < tabs.length; i++) {
            tabs[i].classList.remove("active-tab");
        }

        // 3. Show current tab and activate button
        document.getElementById('tab-' + tabName).classList.add("active-content");
        evt.currentTarget.classList.add("active-tab");
    }
    /** CONFIGURATION **/
    const CELL_SIZE = 50; 
    
    // Snap width/height to be multiples of CELL_SIZE (50)
    // This ensures the bottom and right walls are fully visible and not cut off
    const COLS = 41;
    const ROWS = 21;

    var canvas, ctx;
    let grid = [];
    let currentAnnouncement = null;
    let isPathBlocked = false;
    let difficultyMultiplier = 1.0; 
    let gameActive = false;
    let isPaused = false;
    this.lastTimer = 0;
    
    // Lists
    let enemies = [];
    let corpses = [];
    let allies = [];      
    let structures = []; 
    let projectiles = []; 
    let particles = [];
    let traps = [];
    let spikes = [];
    this.floaters = []; // Stores the floating money text particles
    
    // Place base in middle of rows
    playerBase = { 
    x: 2, 
    y: Math.floor(ROWS / 2), 
    // Apply Core Vitality
    hp: 100 + (hasSkill('core_vitality') ? 50 : 0), 
    maxHp: 100 + (hasSkill('core_vitality') ? 50 : 0) 
    };
    let money = 200;
    let wave = 1;
    let waveState = 'spawning'; // Options: 'spawning', 'fighting', 'cooldown'
    
    let enemiesToSpawn = 10;    // Total enemies for this wave
    let enemiesSpawned = 0;     // How many have appeared so far
    
    let spawnRate = 60;         // Frames between spawns
    let spawnTimer = 0;
    
    let waveCooldown = 180;     // 3 Seconds rest between waves
    let cooldownTimer = 0;
    let gameOver = false;
    
    let currentTool = 'wall'; 
    let mouseX = 0;
    let mouseY = 0;
    let isMouseDown = false;
    let buildRotation = 0;

    function startGame(mode) {
        // 1. Set Multiplier based on mode
        switch(mode) {
            case 'easy':     difficultyMultiplier = 0.5; break;
            case 'medium':   difficultyMultiplier = 1.0; break;
            case 'hard':     difficultyMultiplier = 2.0; break;
            case 'extreme':  difficultyMultiplier = 3.0; break;
            case 'creative': 
                difficultyMultiplier = 1.0; 
                money = 99999999999; // Infinite money
                break;
        }
        updateFlowField();

        // 2. Update HUD immediately
        document.getElementById('money').innerText = Math.floor(money);

        // 3. Hide Menu
        document.getElementById('main-menu').style.display = 'none';

        // 4. Start the Game Logic
        gameActive = true;
        wave = 0; 
        startNextWave(); 
    }

    function drawHealth(x, y, hp, maxHp) {
    // Only draw if damaged
    if (hp < maxHp) {
        const barW = 24;
        const barH = 4;
        const yOffset = 28;

        const barX = x - (barW / 2);
        const barY = y - yOffset;

        const pct = Math.max(0, Math.min(1, hp / maxHp));
        // Curve the hue so it stays green longer, then quickly turns red
        const hue = (pct * pct) * 120;

        // Background
        ctx.fillStyle = "#333333";
        ctx.fillRect(barX, barY, barW, barH);

        // Health
        ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
        ctx.fillRect(barX, barY, barW * pct, barH);

        // Border
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barW, barH);
    }
}

    /** CLASSES **/

class Corpse {
    constructor(x, y, bounty) { // Added 'bounty' parameter
        this.x = x;
        this.y = y; // This is the "Ground" Y position
        this.bounty = bounty; // Store the enemy's worth
        this.isTargeted = false; // Tells the tower if it's already being grabbed
        
        this.life = 600; 
        this.maxLife = 600;
        this.active = true;
        
        // --- FALLING PHYSICS ---
        this.dropY = -60; // Spawns 60 pixels in the air
        this.velocity = 0;
        this.gravity = 0.8; // How fast it accelerates down
        this.landed = false;

        this.sizeMod = 0.8 + Math.random() * 0.4;
    }

    update() {
        // --- BOUNTY TOWER OVERRIDE ---
        // If an arm grabs this corpse, freeze its physics and life timer
        if (this.isTargeted) return; 

        // 1. FALLING LOGIC
        if (!this.landed) {
            this.velocity += this.gravity;
            this.dropY += this.velocity;

            if (this.fallingIntoHole) {
                // Falls straight into the hole â€” shrink and fade, then vanish
                if (this.dropY > 30) this.active = false;
            } else {
                // Normal ground bounce
                if (this.dropY >= 0) {
                    this.dropY = 0;
                    if (Math.abs(this.velocity) > 2) {
                        this.velocity = -this.velocity * 0.3; 
                    } else {
                        this.landed = true; 
                    }
                }
            }
        }

        // 2. LIFE LOGIC
        if (!this.fallingIntoHole) {
            this.life--;
            if (this.life <= 0) this.active = false;
        }
    }

    draw() {
        ctx.save();
        
        // Sinking logic (End of life) - Don't sink if it's being carried
        let sink = 0;
        if (!this.isTargeted && this.life < 120) sink = (1 - (this.life / 120)) * 10;

        // Combine Falling (dropY) + Sinking (sink)
        ctx.translate(this.x, this.y + this.dropY + sink);

        // Shrink into the hole when falling in
        let holeShrink = 1;
        if (this.fallingIntoHole && this.dropY > 0) {
            holeShrink = Math.max(0, 1 - (this.dropY / 30));
        }
        ctx.scale(this.sizeMod * holeShrink, this.sizeMod * holeShrink);
        
        // Fade out
        ctx.globalAlpha = Math.min(1.0, (this.life / this.maxLife) * 3);

        // --- DRAWING THE CROSS ---
        
        // 1. SHADOW (Only visible when close to ground)
        if (this.dropY > -20) {
            let shadowAlpha = 1 - (Math.abs(this.dropY) / 20);
            ctx.fillStyle = `rgba(0, 0, 0, ${0.4 * shadowAlpha})`;
            ctx.beginPath();
            let sScale = 1 - (Math.abs(this.dropY) / 40); 
            ctx.ellipse(0, 4, 10 * sScale, 5 * sScale, 0, 0, Math.PI * 2);
            ctx.fill();
        }

        // 2. THE CROSS (Stone Gray)
        const stoneDark = "#37474f";
        const stoneLight = "#546e7a";
        const stoneOutline = "#263238";

        ctx.strokeStyle = stoneOutline;
        ctx.lineWidth = 1.5;

        // Vertical Beam
        ctx.fillStyle = stoneDark;
        ctx.fillRect(-2.5, -16, 5, 20);
        ctx.strokeRect(-2.5, -16, 5, 20);

        // Horizontal Beam
        ctx.fillStyle = stoneLight;
        ctx.fillRect(-7, -11, 14, 4);
        ctx.strokeRect(-7, -11, 14, 4);

        // 3. CRACK DETAIL
        ctx.strokeStyle = "rgba(0, 0, 0, 0.4)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-1, -16); 
        ctx.lineTo(0, -13); 
        ctx.lineTo(-1, -11);
        ctx.stroke();

        ctx.restore();
    }
}

   class WaveAnnouncement {
    // Now accepts a title, a subtitle, and a color
    constructor(title, subTitle = "", color = "#ffffff") {
        this.text = title;
        this.subText = subTitle;
        this.baseColor = color;
        
        // Positioning
        this.x = VIRTUAL_WIDTH / 2;
        this.y = VIRTUAL_HEIGHT / 2;

        // Animation State
        this.life = 0;           // Frame counter
        this.maxLife = 180;      // Total duration (e.g., 3 seconds at 60fps)
        this.scale = 0;          // Starts invisible
        this.alpha = 0;
        this.active = true;
    }

    update(dt) {
        this.life++;

        // 1. Entrance (Frames 0-30): Fast Pop-in with overshoot
        if (this.life < 30) {
            this.alpha = Math.min(1, this.alpha + 0.1);
            // Elastic ease-out effect
            let t = this.life / 30; 
            this.scale = 1 + Math.sin(t * Math.PI) * 0.2; // Goes to 1.2 then back to 1
        } 
        // 2. Stay Phase (Frames 30-130): Slow drift
        else if (this.life < 130) {
            this.scale = 1.0;
            this.alpha = 1.0;
        } 
        // 3. Exit (Frames 130+): Fade out and scale up slightly
        else {
            this.alpha -= 0.02;
            this.scale += 0.005; // Gentle expansion while fading
        }

        if (this.life >= this.maxLife || this.alpha <= 0) {
            this.active = false;
        }
    }

    draw() {
        if (!this.active) return;

        ctx.save();
        
        // Center alignment
        ctx.translate(this.x, this.y);
        ctx.scale(this.scale, this.scale);
        ctx.globalAlpha = Math.max(0, this.alpha);

        // --- CINEMATIC BACKGROUND STRIP ---
        // Draws a black bar behind text to ensure legibility over chaotic game play
        ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
        // Draw rectangle centered on 0,0
        ctx.fillRect(-VIRTUAL_WIDTH / 2, -60, VIRTUAL_WIDTH, 120);
        
        // --- BORDERS ON STRIP ---
        ctx.beginPath();
        ctx.moveTo(-VIRTUAL_WIDTH / 2, -60);
        ctx.lineTo(VIRTUAL_WIDTH / 2, -60);
        ctx.moveTo(-VIRTUAL_WIDTH / 2, 60);
        ctx.lineTo(VIRTUAL_WIDTH / 2, 60);
        ctx.strokeStyle = this.baseColor;
        ctx.lineWidth = 2;
        ctx.stroke();

        // --- MAIN TEXT ---
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        
        // Glow Effect
        ctx.shadowColor = this.baseColor;
        ctx.shadowBlur = 20;
        
        // Text Style
        ctx.font = "900 80px 'Segoe UI', Verdana, sans-serif"; 
        ctx.fillStyle = this.baseColor;
        ctx.fillText(this.text, 0, -10); // Slightly up to make room for subtext

        // --- SUB TEXT (If provided) ---
        if (this.subText) {
            ctx.shadowBlur = 10; // Less glow for subtext
            ctx.font = "700 30px 'Segoe UI', Verdana, sans-serif";
            ctx.fillStyle = "#ffffff";
            ctx.letterSpacing = "4px"; // Spaced out looks cooler
            ctx.fillText(this.subText.toUpperCase(), 0, 40);
        }
        
        ctx.restore();
    }
}

    class Cell {
        constructor(x, y) {
            this.x = x; this.y = y;
            this.wall = false;
            this.occupied = false; // Cannot build on top of other buildings
            this.distance = 9999; 
            this.vecX = 0; this.vecY = 0;
        }
    }

    function sharedDestroyWalls(enemy, col, row, damage, tickRate) {
    if (enemy.wallDamageCooldown > 0) {
        enemy.wallDamageCooldown--;
        return;
    }

    let damageDealt = false;
    for (let i = -1; i <= 1; i++) {
        for (let j = -1; j <= 1; j++) {
            let c = col + i;
            let r = row + j;
            if (c >= 0 && c < COLS && r >= 0 && r < ROWS) {
                let targetCell = grid[c][r];
                if (targetCell.wall) {
                    let wx = c * CELL_SIZE + CELL_SIZE/2;
                    let wy = r * CELL_SIZE + CELL_SIZE/2;
                    let dist = Math.hypot(enemy.x - wx, enemy.y - wy);

                    if (dist < enemy.radius + CELL_SIZE/1.5) {
                        targetCell.wallHp -= damage; 
                        createParticles(wx, wy, "#555", 1);
                        damageDealt = true;

                        if (targetCell.wallHp <= 0) {
                            targetCell.wall = false;
                            targetCell.wallHp = 100;
                            updateFlowField(); 
                        }
                    }
                }
            }
        }
    }
    if (damageDealt) enemy.wallDamageCooldown = tickRate;
}

// --- NEW HELPER: Raycast to check for clear path ---
    function hasLineOfSight(x0, y0, x1, y1) {
        let dx = x1 - x0;
        let dy = y1 - y0;
        let distance = Math.hypot(dx, dy);
        
        // Check points along the line every 25 pixels (half a cell)
        let steps = Math.ceil(distance / (CELL_SIZE / 2));
        
        for (let i = 0; i <= steps; i++) {
            let t = i / steps;
            let checkX = x0 + dx * t;
            let checkY = y0 + dy * t;
            
            let col = Math.floor(checkX / CELL_SIZE);
            let row = Math.floor(checkY / CELL_SIZE);
            
            // If we hit a wall, line of sight is blocked
            if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
                if (grid[col][row].wall) return false;
            }
        }
        return true; // No walls found
    }

function sharedMovement(enemy, col, row) {
    // --- 1. CALCULATE SPEED (Your Slow Logic) ---
    let speedMod = enemy.isSlowed ? 0.5 : 1.0; 
    let currentSpeed = enemy.speed * speedMod;
    enemy.isSlowed = false; // Reset flag

    // --- 2. TAUNT CHECK (New Logic) ---
    // If enemy is taunted by a living Bard, chase the Bard instead of the base
    if (enemy.tauntTarget) {
        if (enemy.tauntTarget.hp <= 0) {
            enemy.tauntTarget = null; // Bard is dead, stop chasing
        } else {
            // Move directly towards Bard
            let dx = enemy.tauntTarget.x - enemy.x;
            let dy = enemy.tauntTarget.y - enemy.y;
            let dist = Math.hypot(dx, dy);
            
            if (dist > 0) {
                // Steer towards bard
                enemy.vx += ((dx/dist) * currentSpeed - enemy.vx) * 0.1;
                enemy.vy += ((dy/dist) * currentSpeed - enemy.vy) * 0.1;
            }
            return false; // Skip normal pathfinding
        }
    }

    // --- 3. STANDARD BASE TARGETING ---
    let baseX = (playerBase.x * CELL_SIZE) + CELL_SIZE;
    let baseY = (playerBase.y * CELL_SIZE) + CELL_SIZE;
    
    // Check Line of Sight
    if (hasLineOfSight(enemy.x, enemy.y, baseX, baseY, enemy.radius)) {
        let dx = baseX - enemy.x;
        let dy = baseY - enemy.y;
        let dist = Math.hypot(dx, dy);
        
        if (dist > 0) {
            enemy.vx += ((dx/dist) * currentSpeed - enemy.vx) * 0.1;
            enemy.vy += ((dy/dist) * currentSpeed - enemy.vy) * 0.1;
        }
        return false; 
    }

    // Fallback to Grid Pathfinding
    let onGrid = (col >= 0 && col < COLS && row >= 0 && row < ROWS);
    let cell = onGrid ? grid[col][row] : null;

    if (onGrid && cell.distance !== Infinity) {
        let moveDir = getSmartVector(enemy);
        enemy.vx += (moveDir.x * currentSpeed - enemy.vx) * 0.1;
        enemy.vy += (moveDir.y * currentSpeed - enemy.vy) * 0.1;
        return false; 
    } else {
        // Blocked / Last Resort
        let dx = baseX - enemy.x;
        let dy = baseY - enemy.y;
        let dist = Math.hypot(dx, dy);
        
        if (dist > 0) {
            enemy.vx += ((dx/dist) * currentSpeed - enemy.vx) * 0.1;
            enemy.vy += ((dy/dist) * currentSpeed - enemy.vy) * 0.1;
        }
        return true;
    }
}

   class Enemy {
    constructor() {
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- STATS ---
        this.radius = 8; 
        this.speed = 0.8 + (Math.random() * 0.4);
        this.hp = 20 + (wave * 7);
        this.vx = -1; 
        this.vy = 0;
        this.maxHp = this.hp;
        
        // --- VISUALS ---
        this.angle = 0; 
        this.animTimer = Math.random() * 10; 
        
        this.attackCooldown = 0; 
        this.wallDamageCooldown = 0;
        this.bounty = 2;
    }

    update(dt) {
        // Animation speed
        this.animTimer += 0.3 * dt; 

        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);

        let isBlocked = sharedMovement(this, col, row);
        if (isBlocked) sharedDestroyWalls(this, col, row, 2, 10);

        if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
            this.angle = Math.atan2(this.vy, this.vx);
        }

        this.x += this.vx;
        this.y += this.vy;

        separate(this, enemies, 0.5); 
        separate(this, allies, 0.8);
        resolveWallCollision(this);

        if (this.attackCooldown > 0) this.attackcooldown-=dt;
        
        let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dx, dy) < 30) { takeDamage(5); this.hp = 0; }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        let pct = this.hp / this.maxHp;
        
        // --- PALETTE ---
        let armorColor = "#d8d0a0"; 
        let jointColor = "#4b5320"; 
        let coreColor = `rgba(255, ${Math.floor(50 * pct)}, 0, 1)`; 

        // --- 1. DRAW LEGS ---
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // Updated for Spider Walking Logic
        const drawLeg = (ox, oy, restX, restY, phase, side, widthMod, bendMod) => {
            let cycle = this.animTimer + phase;
            
            // WALKING LOGIC:
            // 1. Move parallel to body (X-axis) for the step.
            //    Math.cos(cycle) creates the Forward/Back stride.
            // 2. Slight In/Out motion (Y-axis) to simulate the arc of lifting the leg.
            //    -Math.sin(cycle) pulls leg in during the 'lift'.
            
            let strideRange = 2.5; // How far the foot steps forward/back
            
            // Calculate dynamic foot position based on resting position
            let footX = ox + restX + (Math.cos(cycle) * strideRange); 
            let footY = oy + restY + (Math.abs(Math.sin(cycle)) * -1.5 * side); // "Lift" effect

            let midX = (ox + footX) / 2;
            let midY = (oy + footY) / 2;
            
            // Knee projection
            let kneeX = midX - 1.5; 
            let kneeY = midY + (side * bendMod); 

            // Thin Outline
            ctx.strokeStyle = "#0f1405"; 
            ctx.lineWidth = 1.5 + widthMod;
            ctx.beginPath();
            ctx.moveTo(ox, oy);
            ctx.lineTo(kneeX, kneeY);
            ctx.lineTo(footX, footY);
            ctx.stroke();

            // Bone Armor
            ctx.strokeStyle = armorColor;
            ctx.lineWidth = 0.8 + widthMod;
            ctx.beginPath();
            ctx.moveTo(ox, oy);       
            ctx.lineTo(kneeX, kneeY); 
            ctx.lineTo(footX, footY); 
            ctx.stroke();

            // Joints
            ctx.fillStyle = jointColor;
            ctx.beginPath();
            ctx.arc(kneeX, kneeY, 1 + widthMod, 0, Math.PI*2);
            ctx.fill();
            
            // Tip
            ctx.fillStyle = "#8b0000"; 
            ctx.beginPath();
            ctx.arc(footX, footY, 0.8, 0, Math.PI*2);
            ctx.fill();
        };

        // --- LEG CONFIGURATION (Spider Gait) ---
        // Using alternating phases (0 vs PI) for adjacent legs creates the "Tripod" run.
        // Also adjusted 'restX' so front legs point forward and back legs point backward.

        // 1. BACK PAIR (Points Backward)
        // ox: -5, restX: -4 (Reaches behind)
        drawLeg(-5, -1.5, -4, -6, 0, -1, 0.5, 3);
        drawLeg(-5, 1.5, -4, 6, Math.PI, 1, 0.5, 3);
        
        // 2. MID-BACK PAIR (Points Slightly Back/Out)
        // ox: -2, restX: -2
        drawLeg(-2, -1.8, -2, -8, Math.PI, -1, 0.2, 5);
        drawLeg(-2, 1.8, -2, 8, 0, 1, 0.2, 5);
        
        // 3. MID-FRONT PAIR (Points Slightly Forward/Out)
        // ox: 1, restX: 2
        drawLeg(1, -1.8, 2, -7, 0, -1, 0.2, 4);
        drawLeg(1, 1.8, 2, 7, Math.PI, 1, 0.2, 4);
        
        // 4. FRONT PAIR (Points Forward)
        // ox: 4, restX: 4 (Reaches ahead)
        drawLeg(4, -1.2, 4, -4, Math.PI, -1, 0.5, 2);
        drawLeg(4, 1.2, 4, 4, 0, 1, 0.5, 2);


        // --- 2. ABDOMEN ---
        let pulse = 0.5 + Math.sin(this.animTimer * 0.5) * 0.1;
        
        ctx.fillStyle = "#2a2205"; 
        ctx.beginPath();
        ctx.ellipse(-4, 0, 9, 3.5, 0, 0, Math.PI * 2);
        ctx.fill();

        // Glowing Vents
        ctx.fillStyle = coreColor;
        ctx.shadowBlur = 6 * pulse;
        ctx.shadowColor = "red";
        for(let i = 0; i < 4; i++) { 
            let xOff = -2 - (i * 2.5);
            ctx.beginPath();
            ctx.ellipse(xOff, 0, 0.8, 2.5 - (i*0.4), 0, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.shadowBlur = 0;

        // --- 3. HEAD ---
        ctx.fillStyle = armorColor;
        ctx.beginPath();
        ctx.moveTo(1, -2.5);
        ctx.lineTo(5, -2);
        ctx.lineTo(9, 0); 
        ctx.lineTo(5, 2);
        ctx.lineTo(1, 2.5);
        ctx.fill();
        
        ctx.strokeStyle = jointColor;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(3, -1.5); ctx.lineTo(3, 1.5);
        ctx.stroke();

        // --- 4. EYES ---
        ctx.fillStyle = '#ccff00';
        ctx.shadowColor = '#ccff00';
        ctx.shadowBlur = 4;
        
        ctx.beginPath(); ctx.arc(7, -1, 1, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(7, 1, 1, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(6, -2, 0.8, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(6, 2, 0.8, 0, Math.PI*2); ctx.fill();
        
        ctx.shadowBlur = 0;

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class TankEnemy {
    constructor() {
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- TANK STATS ---
        this.radius = 22; // Increased size (was 16)
        this.baseSpeed = 0.3 + (Math.random() * 0.2);
        this.speed = this.baseSpeed;
        
        this.hp = 150 + (wave * 50); 
        this.maxHp = this.hp;
        this.bounty = 5;

        this.vx = -1; 
        this.vy = 0;
        this.angle = 0;
        
        this.attackCooldown = 0; 
        this.wallDamageCooldown = 0;
        
        this.animOffset = Math.random() * 10000;
        
        // Jagged Obsidian Body Shape
        this.bodyPoints = [];
        let segments = 7; 
        for (let i = 0; i < segments; i++) {
            this.bodyPoints.push(0.9 + Math.random() * 0.3); 
        }
    }

    update(dt) {
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);

        let isBlocked = sharedMovement(this, col, row);
        
        if (isBlocked) sharedDestroyWalls(this, col, row, 5, 15);

        if (Math.abs(this.vx) > 0.01 || Math.abs(this.vy) > 0.01) {
            this.angle = Math.atan2(this.vy, this.vx);
        }

        this.x += this.vx;
        this.y += this.vy;

        separate(this, enemies, 0.4); 
        separate(this, allies, 0.2);
        resolveWallCollision(this);

        if (this.attackCooldown > 0) this.attackcooldown-=dt;
        
        let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dx, dy) < 30 + this.radius) { takeDamage(20); this.hp = 0; }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        let time = Date.now() + this.animOffset;
        let breath = Math.sin(time * 0.005) * 1.5; // Deeper breath for bigger body

        // --- COLORS ---
        let hpPct = this.hp / this.maxHp;
        let colorBody   = '#151515'; 
        let colorArmor  = '#2a2a2a'; 
        let colorSpike  = '#404040';
        let colorGlow =  '#ff4500'; 

        // --- 1. REAR LEGS (Vestigial) ---
        // Pushed wider to match new body width
        ctx.fillStyle = colorBody;
        const drawLeg = (yOffset, phase) => {
            let kick = Math.sin(time * 0.005 + phase) * 3;
            ctx.beginPath();
            ctx.moveTo(-10, yOffset); // Shifted back
            ctx.lineTo(-16 + kick, yOffset + 4);
            ctx.lineTo(-16 + kick, yOffset - 4);
            ctx.fill();
        };
        drawLeg(-9, 0);       // Wider spacing
        drawLeg(9, Math.PI);

        // --- 2. MAIN BODY ---
        ctx.fillStyle = colorBody;
        ctx.beginPath();
        let segments = this.bodyPoints.length;
        for (let i = 0; i < segments; i++) {
            let theta = (i / segments) * Math.PI * 2;
            // Radius scales automatically here
            let r = (this.radius * 0.85 * this.bodyPoints[i]) + breath;
            let px = Math.cos(theta) * r;
            let py = Math.sin(theta) * r;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();

        // Glowing Cracks (Scaled up)
        ctx.strokeStyle = colorGlow;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(-6, 0); ctx.lineTo(6, -3); ctx.lineTo(0, 6);
        ctx.stroke();

        // --- 3. ARMOR PLATES (Scaled positions) ---
        ctx.fillStyle = colorArmor;
        const drawSpikedPlate = (yDir) => {
            ctx.beginPath();
            // Pushed out yDir * 3 to fit bigger body
            ctx.translate(0, yDir * 3); 
            ctx.moveTo(-2, 2 * yDir);
            ctx.lineTo(8, 4 * yDir);
            ctx.lineTo(10, 10 * yDir);
            ctx.lineTo(-6, 12 * yDir);
            ctx.lineTo(-10, 6 * yDir);
            ctx.fill();

            // Spike
            ctx.fillStyle = colorSpike;
            ctx.beginPath();
            ctx.moveTo(0, 7 * yDir);
            ctx.lineTo(14, 14 * yDir); 
            ctx.lineTo(5, 5 * yDir);
            ctx.fill();
            
            // Reset translate
            ctx.translate(0, -yDir * 3);
            ctx.fillStyle = colorArmor;
        };
        drawSpikedPlate(-1);
        drawSpikedPlate(1);

        // --- 4. HEAD / VISOR (Moved forward) ---
        // Moved x from 8 to 12
        ctx.fillStyle = '#000';
        ctx.beginPath();
        ctx.ellipse(12, 0, 5, 7, 0, 0, Math.PI*2);
        ctx.fill();
        
        ctx.shadowColor = colorGlow;
        ctx.shadowBlur = 10;
        ctx.fillStyle = colorGlow;
        ctx.beginPath();
        ctx.moveTo(12, -5); 
        ctx.lineTo(16, 0); 
        ctx.lineTo(12, 5);
        ctx.lineTo(11, 0); 
        ctx.fill();
        ctx.shadowBlur = 0;

        // --- 5. ARMS (Adjusted for Size) ---
        const drawArm = (side) => {
            let swingPhase = time * 0.003 + (side === 1 ? 0 : Math.PI); 
            let extension = Math.sin(swingPhase) * 5; 
            let rotation = Math.cos(swingPhase) * 0.3;

            ctx.save();
            // Shoulders moved: x (6->10), y (7->12) to clear the fat body
            ctx.translate(10, side * 12); 
            ctx.rotate(rotation);

            // ARM SHAPE: Thick and Short
            ctx.fillStyle = colorArmor;
            ctx.beginPath();
            ctx.moveTo(0, 0);
            // Wrist
            ctx.lineTo(8 + extension, -side * 6); 
            ctx.lineTo(6 + extension, side * 10);
            // Armpit
            ctx.lineTo(-6, side * 7);
            ctx.fill();

            // FIST
            ctx.translate(8 + extension, 0); 
            ctx.rotate(side * 0.5); 
            
            ctx.fillStyle = colorBody;
            ctx.beginPath();
            ctx.moveTo(0, -7); 
            ctx.lineTo(9, -6); 
            ctx.lineTo(14, 0); // Knuckles
            ctx.lineTo(9, 6);
            ctx.lineTo(0, 7);
            ctx.fill();

            // Magma Spike
            ctx.fillStyle = colorGlow;
            ctx.beginPath();
            ctx.moveTo(9, -4); ctx.lineTo(16, 0); ctx.lineTo(9, 4);
            ctx.fill();

            ctx.restore();
        };

        drawArm(-1); 
        drawArm(1);  

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}
    
class RunnerEnemy {
    constructor() {
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- RUNNER STATS ---
        this.radius = 7; // Slightly larger visual presence, same collision feel
        this.baseSpeed = 2.2 + (Math.random() * 0.6); 
        this.speed = this.baseSpeed;
        
        this.hp = 10 + (wave * 3); 
        this.maxHp = this.hp;
        this.bounty = 2;

        this.vx = -1; 
        this.vy = 0;
        this.attackCooldown = 0; 
        
        // --- VISUALS ---
        this.wallDamageCooldown = 0;
        this.animTimer = Math.random() * 10; 
        this.angle = Math.PI; 
    }

    update(dt) {
        this.animTimer += 0.5*dt; // Rapid, jittery movement

        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);

        let isBlocked = sharedMovement(this, col, row);
        
        // Rotate to face velocity
        if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
            this.angle = Math.atan2(this.vy, this.vx);
        }

        if (isBlocked) sharedDestroyWalls(this, col, row, 0.5, 5);

        this.x += this.vx;
        this.y += this.vy;

        separate(this, enemies, 0.5); 
        separate(this, allies, 0.8);
        resolveWallCollision(this);

        if (this.attackCooldown > 0) this.attackcooldown-=dt;
        
        let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dx, dy) < 30) { takeDamage(2); this.hp = 0; }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle); 
        
        // Scale down slightly to fit the tile, but keep details chunky
        // No flip needed, this creature is radially symmetrical-ish
        
        let pct = this.hp / this.maxHp;
        
        // --- PALETTE: High Contrast for Small Scale ---
        // Dark Obsidian Armor
        let armorColor = "#0a0a12"; 
        // Hostile Neon Red/Magenta (Shifts to dull purple when dying)
        let energyColor = `rgb(255, ${50 * pct}, ${100 * pct})`; 
        // Bright core for visibility
        let coreColor = "#ffffff";

        // --- 1. THE LEGS (Scythe Blades) ---
        // Instead of thin lines, we use filled triangles/curves (Scythes).
        // These read much better at small sizes.
        
        ctx.fillStyle = energyColor;
        
        // Helper to draw a scythe leg
        // yOffset: Position on body
        // size: length of blade
        // phase: animation timing
        const drawScythe = (yOffset, size, phase, isRight) => {
            let cycle = Math.sin(this.animTimer + phase);
            let reach = cycle * 4; // How far forward/back it strikes
            let lift = Math.abs(Math.cos(this.animTimer + phase)) * 3; // Up/Down
            
            ctx.save();
            ctx.scale(1, isRight ? 1 : -1); // Mirror for other side
            
            ctx.beginPath();
            // Leg pivot point
            ctx.translate(0, yOffset);
            
            // Movement logic
            let rotation = (reach * 0.1); 
            ctx.rotate(rotation);

            // Draw Scythe Shape (Thick at base, sharp at tip)
            ctx.beginPath();
            ctx.moveTo(0, 0); 
            ctx.lineTo(size, -lift - 4); // The "Elbow"
            ctx.lineTo(size + 2, -lift + 4); // The Tip (stabbing ground)
            ctx.lineTo(2, 2); // Return to body
            ctx.fill();
            
            // Highlight on blade tip
            ctx.fillStyle = coreColor;
            ctx.beginPath();
            ctx.arc(size + 2, -lift + 4, 1, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = energyColor; // Reset

            ctx.restore();
        };

        // Draw 4 Scythe Legs (2 pairs)
        // Back Pair (Larger, bounding)
        drawScythe(2, 8, 0, true);
        drawScythe(2, 8, 0, false);
        
        // Front Pair (Smaller, stabbing)
        drawScythe(-2, 6, Math.PI, true);
        drawScythe(-2, 6, Math.PI, false);

        // --- 2. THE BODY (Exotic Carapace) ---
        // A sharp, diamond/arrowhead shape
        ctx.fillStyle = armorColor;
        ctx.strokeStyle = energyColor;
        ctx.lineWidth = 1.5;

        ctx.beginPath();
        ctx.moveTo(8, 0);   // Head tip (Sharp)
        ctx.lineTo(2, -4);  // Shoulder
        ctx.lineTo(-6, -2); // Rear
        ctx.lineTo(-8, 0);  // Tail tip
        ctx.lineTo(-6, 2);  // Rear
        ctx.lineTo(2, 4);   // Shoulder
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // --- 3. THE CORE (Visibility Anchor) ---
        // A glowing stripe down the back so you can see it in the dark
        ctx.shadowBlur = 6;
        ctx.shadowColor = energyColor;
        ctx.fillStyle = energyColor;
        
        ctx.beginPath();
        ctx.moveTo(4, 0);
        ctx.lineTo(-4, 0);
        ctx.lineWidth = 2;
        ctx.strokeStyle = energyColor;
        ctx.stroke();
        
        // Center "Eye" or "Reactor"
        ctx.fillStyle = coreColor;
        ctx.beginPath();
        ctx.arc(2, 0, 1.5, 0, Math.PI*2);
        ctx.fill();
        
        ctx.shadowBlur = 0; // Reset

        // --- 4. MANDIBLES (Hostility) ---
        // Tiny pincers at the front
        ctx.fillStyle = armorColor;
        ctx.beginPath();
        
        // Left Mandible
        ctx.moveTo(7, -1);
        ctx.lineTo(10, -2);
        ctx.lineTo(9, -0.5);
        
        // Right Mandible
        ctx.moveTo(7, 1);
        ctx.lineTo(10, 2);
        ctx.lineTo(9, 0.5);
        ctx.fill();

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}
class BreacherEnemy {
    constructor() {
        // --- SPAWN ---
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- STATS ---
        this.radius = 14; 
        this.speed = 0.8;       
        this.hp = 40 + (wave * 8); 
        this.maxHp = this.hp;
        this.bounty = 7;

        this.vx = -1; 
        this.vy = 0;
        
        // --- EXPLOSION LOGIC ---
        this.triggered = false;
        this.explodeTimer = 35; 
        this.explodeRadius = 70; 

        // --- VISUALS ---
        this.walkCycle = Math.random() * 10;
        this.antennaTimer = 0;
    }

    update(dt) {
        this.antennaTimer += 0.2*dt;

        // --- 1. ANIMATION SPEED ---
        if (!this.triggered) {
            this.walkCycle += 0.3; 
        } else {
            this.walkCycle += 0.8; 
        }

        // --- 2. TRIGGER LOGIC (COUNTDOWN) ---
        if (this.triggered) {
            this.explodeTimer--;
            this.vx *= 0.85; 
            this.vy *= 0.85;
            
            if (Math.random() < 0.2) createParticles(this.x, this.y, "#ff4500", 1);
            if (this.explodeTimer <= 0) this.detonate();
            return; 
        }

        // --- 3. MOVEMENT & TARGETING ---
        let moveDir = {x:0, y:0};
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);
        
        // Check grid boundaries
        let onGrid = (col >= 0 && col < COLS && row >= 0 && row < ROWS);
        let cell = onGrid ? grid[col][row] : null;
        let hasPath = (onGrid && cell.distance !== Infinity);

        if (hasPath) {
            moveDir = getSmartVector(this);
        } else {
            // Fallback: Move straight to base if no path found
            let dx = (playerBase.x * CELL_SIZE + CELL_SIZE/2) - this.x;
            let dy = (playerBase.y * CELL_SIZE + CELL_SIZE/2) - this.y;
            let dist = Math.hypot(dx, dy);
            if (dist > 0) moveDir = {x: dx/dist, y: dy/dist};
        }

        this.vx += (moveDir.x * this.speed - this.vx) * 0.15;
        this.vy += (moveDir.y * this.speed - this.vy) * 0.15;

        this.x += this.vx;
        this.y += this.vy;

        separate(this, enemies, 0.4); 
        resolveWallCollision(this);

        // --- 4. IMPROVED WALL DETECTION ---
        
        // A. Check Current Cell (Did user place a wall ON me?)
        if (onGrid && grid[col][row].wall) {
            this.triggered = true;
        }

        // B. Check Forward Collision (Am I walking INTO a wall?)
        // We look slightly ahead in the direction of movement + radius
        let lookAheadDist = this.radius + 4;
        let checkX = this.x + (moveDir.x * lookAheadDist);
        let checkY = this.y + (moveDir.y * lookAheadDist);
        let checkCol = Math.floor(checkX / CELL_SIZE);
        let checkRow = Math.floor(checkY / CELL_SIZE);

        if (checkCol >= 0 && checkCol < COLS && checkRow >= 0 && checkRow < ROWS) {
            if (grid[checkCol][checkRow].wall) {
                this.triggered = true;
            }
        }

        // C. Check Base Collision
        let dxBase = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dyBase = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dxBase, dyBase) < 30) this.triggered = true;
        
        // D. Check Ally Collision
        for (let ally of allies) {
            if (Math.hypot(this.x - ally.x, this.y - ally.y) < this.radius + ally.radius + 4) {
                this.triggered = true;
                break;
            }
        }
    }

    detonate() {
        // Visuals
        for(let i=0; i<25; i++) {
            createParticles(this.x, this.y, (Math.random()>0.5 ? "#ff4500" : "#ffff00"), 4);
        }

        // Damage Allies
        for (let i = allies.length - 1; i >= 0; i--) {
            let ally = allies[i];
            if (Math.hypot(this.x - ally.x, this.y - ally.y) < this.explodeRadius) {
                ally.hp -= 80; 
                createParticles(ally.x, ally.y, "red", 3);
            }
        }

        // Damage Walls
        let range = Math.ceil(this.explodeRadius / CELL_SIZE);
        let centerCol = Math.floor(this.x / CELL_SIZE);
        let centerRow = Math.floor(this.y / CELL_SIZE);

        for (let i = -range; i <= range; i++) {
            for (let j = -range; j <= range; j++) {
                let c = centerCol + i;
                let r = centerRow + j;
                if (c >= 0 && c < COLS && r >= 0 && r < ROWS) {
                    let cell = grid[c][r];
                    if (cell.wall) {
                        let wx = c * CELL_SIZE + CELL_SIZE/2;
                        let wy = r * CELL_SIZE + CELL_SIZE/2;
                        // Calculate distance to wall center
                        if (Math.hypot(this.x - wx, this.y - wy) < this.explodeRadius) {
                            cell.wallHp -= 150; 
                            if(cell.wallHp <= 0) {
                                cell.wall = false; 
                                createParticles(wx, wy, "#666", 4);
                            }
                            // Important: Recalculate paths if a wall breaks
                            updateFlowField();
                        }
                    }
                }
            }
        }

        // Damage Base
        let baseDist = Math.hypot(this.x - (playerBase.x * CELL_SIZE), this.y - (playerBase.y * CELL_SIZE));
        if (baseDist < this.explodeRadius + 20) takeDamage(40);

        this.hp = 0; // Enemy dies
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        let angle = Math.atan2(this.vy, this.vx);
        if (Math.abs(this.vx) + Math.abs(this.vy) < 0.1) angle = Math.PI;
        ctx.rotate(angle);

        // --- PALETTE ---
        let legColor = "#dddddd"; 
        let jointColor = "#ffffff"; 
        let bodyColor = "#8b0000"; 
        let headColor = "#a52a2a"; 
        
        // Trigger Effects
        let swell = 0;
        let buttColor = "#ff4500"; 
        if (this.triggered) {
            swell = Math.sin(Date.now() / 30) * 2; 
            buttColor = (Math.floor(Date.now() / 40) % 2 === 0) ? "#ffffff" : "#ff4500";
        } else {
            swell = Math.sin(Date.now() / 200) * 0.5;
        }

        // --- 1. ABDOMEN ---
        ctx.fillStyle = buttColor;
        ctx.beginPath();
        ctx.arc(-11, 0, 10 + swell, 0, Math.PI*2);
        ctx.fill();
        
        ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        ctx.beginPath();
        ctx.arc(-11, 0, 7 + swell, 0, Math.PI*2);
        ctx.fill();

        // --- 2. LEGS ---
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        const drawLeg = (ox, oy, restX, restY, phase, side, widthMod, bendMod) => {
            let cycle = this.walkCycle + phase;
            let strideRange = 3.5;
            
            let footX = ox + restX + (Math.cos(cycle) * strideRange); 
            let footY = oy + restY + (Math.abs(Math.sin(cycle)) * -2.0 * side); 

            let midX = (ox + footX) / 2;
            let midY = (oy + footY) / 2;
            
            let kneeX = midX - 1.5; 
            let kneeY = midY + (side * bendMod); 

            ctx.strokeStyle = "#111"; 
            ctx.lineWidth = 1.5 + widthMod;
            ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(kneeX, kneeY); ctx.lineTo(footX, footY); ctx.stroke();

            ctx.strokeStyle = legColor;
            ctx.lineWidth = 0.8 + widthMod;
            ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(kneeX, kneeY); ctx.lineTo(footX, footY); ctx.stroke();

            ctx.fillStyle = jointColor;
            ctx.beginPath(); ctx.arc(kneeX, kneeY, 1 + widthMod, 0, Math.PI*2); ctx.fill();
            
            ctx.fillStyle = "#ff0000"; 
            ctx.beginPath(); ctx.arc(footX, footY, 0.8, 0, Math.PI*2); ctx.fill();
        };

        // --- LEG CONFIGURATION ---
        drawLeg(-2, -4, -2, -8, Math.PI, -1, 0.2, 5);
        drawLeg(-2, 4, -2, 8, 0, 1, 0.2, 5);
        drawLeg(3, -4, 2, -7, 0, -1, 0.2, 4);
        drawLeg(3, 4, 2, 7, Math.PI, 1, 0.2, 4);
        drawLeg(7, -3, 4, -4, Math.PI, -1, 0.5, 2);
        drawLeg(7, 3, 4, 4, 0, 1, 0.5, 2);


        // --- 3. THORAX ---
        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.ellipse(0, 0, 8, 4.5, 0, 0, Math.PI*2);
        ctx.fill();

        // Thorax Armor Plate
        ctx.fillStyle = "rgba(255,255,255,0.1)";
        ctx.beginPath();
        ctx.ellipse(0, -1, 5, 2, 0, 0, Math.PI*2);
        ctx.fill();

        // --- 4. HEAD ---
        ctx.fillStyle = headColor;
        ctx.beginPath();
        ctx.arc(10, 0, 4.5, 0, Math.PI*2);
        ctx.fill();

        // Mandibles
        ctx.fillStyle = "#eee";
        ctx.beginPath();
        ctx.moveTo(13, -2); ctx.lineTo(17, -3); ctx.lineTo(14, -1);
        ctx.moveTo(13, 2); ctx.lineTo(17, 3); ctx.lineTo(14, 1);
        ctx.fill();

        // Eyes
        ctx.fillStyle = this.triggered ? "#fff" : "#ffff00";
        ctx.beginPath(); ctx.arc(11, -2, 1.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(11, 2, 1.5, 0, Math.PI*2); ctx.fill();

        // Antennae
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 1;
        let twitch = Math.sin(this.antennaTimer) * 1;
        ctx.beginPath(); ctx.moveTo(12, -2); ctx.lineTo(19, -8 + twitch); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(12, 2); ctx.lineTo(19, 8 - twitch); ctx.stroke();

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

    class DasherEnemy {
    constructor() {
        // --- STANDARD SPAWN LOGIC ---
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- DASHER STATS ---
        this.radius = 8; // Much smaller hitbox (was 12)
        this.hp = 25 + (wave * 5); // Slightly less HP due to size
        this.maxHp = this.hp;
        this.bounty = 4;
        
        // Speed Setup
        this.baseSpeed = 0.7; // Slightly faster base speed because small = fast
        this.dashSpeed = 6.0; 
        this.speed = this.baseSpeed;
        
        this.vx = -1; 
        this.vy = 0;
        this.attackCooldown = 0; 
        this.wallDamageCooldown = 0;

        // --- DASH SPECIFIC LOGIC ---
        this.dashTimer = 0;
        this.dashThreshold = 120; // Frames until dash
        this.isDashing = false;

        // --- VISUAL VARS ---
        this.wobbleOffset = Math.random() * 1000;
        this.glowColorHex = "#ff4500"; 
    }

    update(dt) {
        // --- 1. DASH MECHANIC ---
        this.dashTimer++;

        // State A: NOT Dashing (Normal Behavior)
        if (!this.isDashing) {
            // Trigger Dash
            if (this.dashTimer > this.dashThreshold) { 
                this.isDashing = true;
                this.dashTimer = 0;
                
                let currentSpeed = Math.hypot(this.vx, this.vy);
                
                // Calculate dash vector
                if (currentSpeed > 0.01) {
                    this.vx = (this.vx / currentSpeed) * 8; 
                    this.vy = (this.vy / currentSpeed) * 8;
                } else {
                    let dx = (playerBase.x * CELL_SIZE + CELL_SIZE/2) - this.x;
                    let dy = (playerBase.y * CELL_SIZE + CELL_SIZE/2) - this.y;
                    let dist = Math.hypot(dx, dy);
                    this.vx = (dx / dist) * 8;
                    this.vy = (dy / dist) * 8;
                }
                
                // Big burst of particles on the "Flap"
                createParticles(this.x, this.y, this.glowColorHex, 8);
            }
        } 
        // State B: CURRENTLY DASHING
        else {
            if (this.dashTimer > 20) {
                this.isDashing = false;
                this.dashTimer = 0;
                this.vx *= 0.2; // Brake
                this.vy *= 0.2;
            }
        }

        // --- 2. MOVEMENT & WALLS ---
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);

        if (!this.isDashing) {
            let isBlocked = sharedMovement(this, col, row);
            if (isBlocked) sharedDestroyWalls(this, col, row, 1, 8);
        } else {
            let onGrid = (col >= 0 && col < COLS && row >= 0 && row < ROWS);
            let cell = onGrid ? grid[col][row] : null;
            let pathExists = (onGrid && cell.distance !== Infinity);

            if (!pathExists) {
                sharedDestroyWalls(this, col, row, 8, 2);
            }
        }

        // --- 3. PHYSICS ---
        this.x += this.vx;
        this.y += this.vy;

        separate(this, enemies, 0.4); 
        separate(this, allies, 0.6);
        resolveWallCollision(this);

        // --- 4. ATTACK ALLIES ---
        if (this.attackCooldown > 0) this.attackcooldown-=dt;

        for (let ally of allies) {
            let dist = Math.hypot(ally.x - this.x, ally.y - this.y);
            if (dist < this.radius + ally.radius + 5) {
                if (this.attackCooldown <= 0) {
                    ally.hp -= (this.damage || 4); 
                    this.attackCooldown = 60; 
                    createParticles(ally.x, ally.y, "red", 3);
                }
                if (!this.isDashing) {
                    this.vx *= 0.5;
                    this.vy *= 0.5;
                }
            }
        }
        
        // --- 5. ATTACK BASE ---
        let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dx, dy) < 20) { 
            takeDamage(5); 
            this.hp = 0;    
            createParticles(this.x, this.y, this.glowColorHex, 10);
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        // Rotate towards movement
        let angle = Math.atan2(this.vy, this.vx);
        if (Math.abs(this.vx) + Math.abs(this.vy) < 0.1) angle = Math.PI;
        ctx.rotate(angle);

        let time = Date.now() / 100 + this.wobbleOffset;

        // --- PALETTE ---
        const chitinDark = "#1a0505";   
        const chitinMid = "#5c0a0a";    
        const wingColor = "#a31414";  
        const glowColor = this.glowColorHex; 

        // --- WING ANIMATION LOGIC ---
        let wingAngle = 0.5; // Default angle (radians)

        if (this.isDashing) {
            // DASHING: Wings snapped back tight (aerodynamic)
            // They stay back for the duration of the dash
            wingAngle = 2.8; 
        } 
        else {
            // NOT DASHING
            let timeUntilDash = this.dashThreshold - this.dashTimer;
            
            if (timeUntilDash < 30) {
                // WIND-UP PHASE (Last 0.5s before dash):
                // Wings spread WIDE open to prepare for the stroke
                // Lerp from normal flutter to wide open (approx PI/2)
                let percent = 1 - (timeUntilDash / 30);
                wingAngle = 0.5 + (percent * 1.5); // Opens up to ~2.0 rads
                
                // Add a violent shake just before launch
                wingAngle += Math.sin(time * 50) * 0.1; 
            } else {
                // IDLE: Gentle flutter
                wingAngle = 0.4 + Math.sin(time * 0.8) * 0.2;
            }
        }

        // --- DRAW WINGS (Under Body) ---
        // Top Wing
        ctx.save();
        ctx.fillStyle = wingColor;
        ctx.rotate(-wingAngle);
        ctx.beginPath();
        // Sharp, aggressive insect wing shape
        ctx.moveTo(0, 0); 
        ctx.lineTo(8, -8); // Wing tip (scaled down)
        ctx.lineTo(12, -2); 
        ctx.lineTo(2, 2); 
        ctx.fill();
        ctx.restore();

        // Bottom Wing (Mirrored)
        ctx.save();
        ctx.fillStyle = wingColor;
        ctx.rotate(wingAngle);
        ctx.beginPath();
        ctx.moveTo(0, 0); 
        ctx.lineTo(8, 8); 
        ctx.lineTo(12, 2); 
        ctx.lineTo(2, -2); 
        ctx.fill();
        ctx.restore();


        // --- DRAW BODY (Scaled Down) ---
        // Tail (Engine)
        ctx.save();
        ctx.translate(-6, 0); 
        ctx.fillStyle = chitinDark;
        ctx.beginPath();
        ctx.moveTo(0, -3); ctx.lineTo(-6, 0); ctx.lineTo(0, 3);
        ctx.fill();
        // Engine Glow
        if(this.isDashing || this.dashTimer > 100) {
            ctx.fillStyle = glowColor;
            ctx.globalAlpha = (this.isDashing) ? 1 : 0.5;
            ctx.beginPath(); ctx.arc(-4, 0, 2, 0, Math.PI*2); ctx.fill();
            ctx.globalAlpha = 1;
        }
        ctx.restore();

        // Thorax (Middle)
        ctx.fillStyle = chitinMid;
        ctx.beginPath();
        ctx.ellipse(0, 0, 5, 3, 0, 0, Math.PI*2);
        ctx.fill();

        // Head
        ctx.save();
        ctx.translate(5, 0);
        ctx.fillStyle = chitinDark;
        ctx.beginPath();
        ctx.moveTo(-2, -3); ctx.lineTo(4, -1); ctx.lineTo(4, 1); ctx.lineTo(-2, 3);
        ctx.fill();

        // Glowing Eyes
        ctx.fillStyle = glowColor;
        if(this.isDashing) {
            ctx.shadowBlur = 5; ctx.shadowColor = glowColor;
        }
        ctx.beginPath(); ctx.arc(2, -1.5, 1, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(2, 1.5, 1, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;

        // Mandibles (Tiny)
        ctx.strokeStyle = chitinMid;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(4, -1); ctx.lineTo(7, -0.5); // Top
        ctx.moveTo(4, 1); ctx.lineTo(7, 0.5);   // Bottom
        ctx.stroke();

        ctx.restore(); // Head Restore
        ctx.restore(); // Main Restore
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class SniperEnemy {
    constructor() {
        // --- POSITION ---
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- STATS ---
        this.radius = 15; // Increased radius for bulkier appearance
        this.hp = 20 + (wave * 5);
        this.maxHp = this.hp;
        this.bounty = 10;
        this.damage = 100; 
        
        // --- MOVEMENT ---
        this.speed = 0.7;
        this.vx = -1; 
        this.vy = 0;
        
        // --- COMBAT ---
        this.range = 450;        
        this.shootCooldown = 60;
        this.shootTimer = 0;
        this.isAiming = false;
        this.currentTarget = null;
        
        // --- VISUALS ---
        this.angle = 0;
        this.animTimer = Math.random() * 100;
        this.laserTargetX = null;
        this.laserTargetY = null;
        this.laserAlpha = 0;
    }

    update(dt) {
        this.animTimer += 0.1*dt;

        // 1. TARGETING
        let baseX = playerBase.x * CELL_SIZE + CELL_SIZE/2;
        let baseY = playerBase.y * CELL_SIZE + CELL_SIZE/2;
        
        let foundTarget = null;
        let minDist = this.range;

        // A. Base Check
        let distToBase = Math.hypot(this.x - baseX, this.y - baseY);
        if (distToBase <= this.range) {
            foundTarget = { x: baseX, y: baseY, isBase: true };
            minDist = distToBase;
        }

        // B. Soldier Check
        if (typeof allies !== 'undefined') {
            for (let ally of allies) {
                let d = Math.hypot(this.x - ally.x, this.y - ally.y);
                if (d < minDist) {
                    minDist = d;
                    foundTarget = ally;
                }
            }
        }

        // 2. STATE MACHINE
        if (foundTarget) {
            // ATTACK
            this.currentTarget = foundTarget;
            this.isAiming = true;
            this.shootTimer++;

            this.vx *= 0.5; this.vy *= 0.5;
            this.angle = Math.atan2(foundTarget.y - this.y, foundTarget.x - this.x);

            if (this.shootTimer >= this.shootCooldown) {
                this.fire(foundTarget);
                this.shootTimer = 0; 
            }

        } else {
            // MOVE
            this.isAiming = false;
            this.shootTimer = Math.max(0, this.shootTimer - 2); 
            this.currentTarget = null;

            let col = Math.floor(this.x / CELL_SIZE);
            let row = Math.floor(this.y / CELL_SIZE);
            let isBlocked = sharedMovement(this, col, row);
            if (isBlocked) sharedDestroyWalls(this, col, row, 10, 40);

            this.x += this.vx;
            this.y += this.vy;

            if (Math.abs(this.vx) > 0.05 || Math.abs(this.vy) > 0.05) {
                this.angle = Math.atan2(this.vy, this.vx);
            }
        }

        // 3. PHYSICS
        separate(this, enemies, 0.6); 
        resolveWallCollision(this);
    }

    fire(target) {
        this.laserTargetX = target.x;
        this.laserTargetY = target.y;
        this.laserAlpha = 1.0; 
        
        createParticles(target.x, target.y, "#ff4500", 8); 
        createParticles(this.x + Math.cos(this.angle)*25, this.y + Math.sin(this.angle)*25, "#ffffaa", 5); 

        if (target.isBase) takeDamage(this.damage); 
        else target.hp -= this.damage; 
    }

    draw() {
        ctx.save();
        
        // --- ANIMATION VALUES ---
        let progress = Math.min(1, this.shootTimer / this.shootCooldown);
        
        // Phase 1: Jaws Open (0% to 30%)
        let jawOpenPct = Math.min(1, Math.max(0, progress / 0.3));
        
        // Phase 2: Barrel Slides Out (20% to 80%)
        let barrelSlidePct = Math.min(1, Math.max(0, (progress - 0.2) / 0.6));
        
        // Phase 3: Vibration (80%+)
        let shake = (progress > 0.8) ? (Math.random() - 0.5) * 2 : 0;
        let kick = (this.shootTimer < 5 && this.isAiming) ? 6 : 0;

        // --- 1. LASER ---
        if (this.laserAlpha > 0) {
            ctx.globalAlpha = this.laserAlpha;
            ctx.lineCap = "round";
            ctx.shadowBlur = 20; ctx.shadowColor = "#ff2200";
            ctx.strokeStyle = `rgba(255, 69, 0, ${this.laserAlpha})`; 
            ctx.lineWidth = 6 + Math.random() * 4; 
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.laserTargetX, this.laserTargetY); ctx.stroke();
            ctx.shadowBlur = 0;
            ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; 
            ctx.beginPath(); ctx.moveTo(this.x, this.y); ctx.lineTo(this.laserTargetX, this.laserTargetY); ctx.stroke();
            ctx.globalAlpha = 1.0;
            this.laserAlpha -= 0.08; 
        }

        // --- TRANSFORM ---
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.translate(-kick, 0); 

        // --- 2. LEGS ---
        ctx.fillStyle = "#111"; 
        ctx.strokeStyle = "#444"; ctx.lineWidth = 0.5;
        for(let i = -1; i <= 1; i+=2) {
             let offset = (i===-1) ? 0 : Math.PI; 
             let walk = Math.sin(this.animTimer + offset) * 3;
             ctx.beginPath(); ctx.ellipse(-6 + walk, i * 8, 4, 2, Math.PI/4 * i, 0, Math.PI*2); ctx.fill(); ctx.stroke();
             ctx.beginPath(); ctx.ellipse(4 - walk, i * 7, 3, 2, -Math.PI/4 * i, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        }

        // ===============================================
        // === ROBUST JAWS & HEAVY BARREL ===
        // ===============================================

        // -- PART A: BOTTOM JAW (Heavy Armor) --
        ctx.save();
        let jawAngle = 0.5 * jawOpenPct; 
        ctx.rotate(jawAngle);
        
        // Main Jaw Structure
        ctx.fillStyle = "#111"; // Dark metal
        ctx.beginPath();
        ctx.moveTo(-2, 1);    // Hinge Inner
        ctx.lineTo(2, 9);     // Heavy Base Down
        ctx.lineTo(16, 7);    // Mid Armor Angle
        ctx.lineTo(24, 4);    // Blunt Tip Bottom
        ctx.lineTo(24, 2);    // Blunt Tip Top
        ctx.lineTo(20, 1);    // Inner Tooth
        ctx.lineTo(6, 1);     // Inner Grip Surface
        ctx.lineTo(-2, 1);    // Back to Hinge
        ctx.fill();

        // Armor Plate Highlight (The "Chin")
        ctx.fillStyle = "#222"; 
        ctx.beginPath(); ctx.moveTo(2, 9); ctx.lineTo(16, 7); ctx.lineTo(12, 3); ctx.lineTo(4, 3); ctx.fill();
        
        // Edge Highlight
        ctx.strokeStyle = "#666"; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(-2, 1); ctx.lineTo(2, 9); ctx.lineTo(16, 7); ctx.lineTo(24, 4); ctx.stroke();
        ctx.restore();

        // -- PART B: TOP JAW (Heavy Armor) --
        ctx.save();
        ctx.rotate(-jawAngle);
        
        // Main Jaw Structure
        ctx.fillStyle = "#111"; 
        ctx.beginPath();
        ctx.moveTo(-2, -1);   // Hinge Inner
        ctx.lineTo(2, -9);    // Heavy Base Up
        ctx.lineTo(16, -7);   // Mid Armor Angle
        ctx.lineTo(24, -4);   // Blunt Tip Top
        ctx.lineTo(24, -2);   // Blunt Tip Bottom
        ctx.lineTo(20, -1);   // Inner Tooth
        ctx.lineTo(6, -1);    // Inner Grip Surface
        ctx.lineTo(-2, -1);   // Back to Hinge
        ctx.fill();

        // Armor Plate Highlight
        ctx.fillStyle = "#222"; 
        ctx.beginPath(); ctx.moveTo(2, -9); ctx.lineTo(16, -7); ctx.lineTo(12, -3); ctx.lineTo(4, -3); ctx.fill();

        // Edge Highlight
        ctx.strokeStyle = "#666"; 
        ctx.beginPath(); ctx.moveTo(-2, -1); ctx.lineTo(2, -9); ctx.lineTo(16, -7); ctx.lineTo(24, -4); ctx.stroke();
        ctx.restore();

        // -- PART C: THE HEAVY BARREL (Slides Out) --
        if (jawOpenPct > 0.1) {
            let slide = barrelSlidePct * barrelSlidePct * (3 - 2 * barrelSlidePct); 
            let extension = slide * 16; 
            
            // 1. Heavy Rail Housing
            let grad = ctx.createLinearGradient(0, -6, 0, 6);
            grad.addColorStop(0, "#1a1a1a");
            grad.addColorStop(0.5, "#444");
            grad.addColorStop(1, "#1a1a1a");
            ctx.fillStyle = grad;
            ctx.fillRect(4, -5, 12 + extension, 10);
            
            // 2. Vents
            ctx.fillStyle = "#000";
            for(let i=0; i<3; i++) ctx.fillRect(8 + (i*4) + (extension*0.5), -4, 2, 8);

            // 3. Magma Core
            let heatColor = progress > 0.7 ? "#ffff00" : "#ff4500";
            ctx.fillStyle = heatColor;
            ctx.shadowColor = heatColor; ctx.shadowBlur = 10 * progress;
            ctx.fillRect(6, -1.5, 10 + extension, 3); 
            ctx.shadowBlur = 0;

            // 4. Muzzle
            let headX = 16 + extension; 
            ctx.fillStyle = "#2a2a2a";
            ctx.beginPath();
            ctx.moveTo(headX, -5); ctx.lineTo(headX + 4, -6); ctx.lineTo(headX + 6, -3);
            ctx.lineTo(headX + 6, 3); ctx.lineTo(headX + 4, 6); ctx.lineTo(headX, 5);
            ctx.fill();

            // 5. Charge
            if (progress > 0.6) {
                ctx.fillStyle = `rgba(255, 255, 255, ${progress})`;
                ctx.shadowColor = "#ffaa00"; ctx.shadowBlur = 20;
                ctx.beginPath(); ctx.arc(headX + 6, 0, 3 * progress + Math.random(), 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur = 0;
            }
        }
        
        // -- PART D: MECHANICAL HINGE (Pivot Point) --
        // Draws a mechanical circle where the jaws meet the body
        ctx.fillStyle = "#333";
        ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#000"; ctx.lineWidth = 1; ctx.stroke();
        ctx.fillStyle = "#555"; ctx.beginPath(); ctx.arc(0, 0, 2, 0, Math.PI*2); ctx.fill();

        // ===============================================

        // --- 3. MAIN BODY ---
        ctx.fillStyle = "#180505"; 
        ctx.beginPath(); ctx.ellipse(-4, 0, 11, 9, 0, 0, Math.PI*2); ctx.fill();
        
        // Pulsing Core
        let pulse = Math.sin(this.animTimer * 0.5) * 1.5;
        let coreColor = progress > 0.8 ? "#fff" : (progress > 0.4 ? "#ff8800" : "#a00");
        ctx.shadowBlur = 10 + (progress * 15); ctx.shadowColor = "#f00";
        ctx.fillStyle = coreColor;
        ctx.beginPath(); ctx.ellipse(-5 + shake, 0 + shake, 6 + (pulse*0.2), 4 + (pulse*0.2), 0, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;

        // Armor Shell
        ctx.fillStyle = "#222"; 
        ctx.beginPath(); ctx.moveTo(-2, -5); ctx.lineTo(-8, -8); ctx.lineTo(-13, -3); ctx.fill(); 
        ctx.beginPath(); ctx.moveTo(-2, 5); ctx.lineTo(-8, 8); ctx.lineTo(-13, 3); ctx.fill();
        ctx.strokeStyle = "#555"; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(-2, -5); ctx.lineTo(-8, -8); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(-2, 5); ctx.lineTo(-8, 8); ctx.stroke();

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class BroodmotherEnemy {
    constructor() {
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // STATS
        this.radius = 18; // Slightly larger hitbox for the new body
        this.hp = 100 + (wave * 20); 
        this.maxHp = this.hp;
        this.bounty = 20; 
        
        this.speed = 0.5; 
        this.vx = -0.5; 
        this.vy = 0;
        
        this.wallDamageCooldown = 0;

        // SUMMONING STATS
        this.state = "MOVING"; 
        this.spawnTimer = 0;
        this.spawnCooldown = 240; 
        this.spawnDuration = 60; 
        
        // Animation
        this.walkCycle = 0;
    }

    update() {
        this.walkCycle += 0.1; // Animate legs

        // 1. Spawning Mechanic
        this.spawnTimer = (this.spawnTimer || 0) + 1;
        if (this.spawnTimer > 180) { 
            this.spawnTimer = 0;
            // Spawn 2 Larvae
            for(let i=0; i<2; i++) {
                enemies.push(new LarvaEnemy(this.x - 10, this.y + Math.random()*20-10));
            }
            createParticles(this.x, this.y, "#adff2f", 15); // Goo explosion
        }

        // 2. Movement
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);

        let isBlocked = sharedMovement(this, col, row);

        if (isBlocked) sharedDestroyWalls(this, col, row, 5, 20);

        this.x += this.vx;
        this.y += this.vy;

        // 3. Physics
        separate(this, enemies, 0.2); 
        separate(this, allies, 0.1);
        resolveWallCollision(this);

        // 4. Base Damage
        let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dx, dy) < 40) { 
            takeDamage(2); 
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // 1. CALCULATE ROTATION
        // Standard Math: 0 radians = Facing Right.
        let angle = Math.atan2(this.vy, this.vx);
        
        // If the enemy is barely moving, force it to face Left (towards player base usually)
        // But since we draw Facing Right, we need Math.PI to face Left.
        if (Math.abs(this.vx) + Math.abs(this.vy) < 0.1) angle = Math.PI; 
        
        ctx.rotate(angle);

        let pct = this.hp / this.maxHp;

        // --- DRAW LEGS (6 Insect Legs) ---
        ctx.strokeStyle = "#1a2b0a"; // Dark Green/Black
        ctx.lineWidth = 2;
        ctx.lineCap = "round";
        
        for(let i = 0; i < 3; i++) { 
            let sideOffset = (i * 6) - 6; 
            let legLength = 18;
            
            // Animation: Tripod Gait
            let legSwing = Math.sin(this.walkCycle + (i%2 * Math.PI)) * 5;
            
            // Top Legs
            ctx.beginPath();
            ctx.moveTo(sideOffset, -5);
            ctx.lineTo(sideOffset - legSwing, -legLength); // Swing is inverted to match direction
            ctx.stroke();

            // Bottom Legs
            ctx.beginPath();
            ctx.moveTo(sideOffset, 5);
            ctx.lineTo(sideOffset - legSwing, legLength);
            ctx.stroke();
        }

        // --- DRAW BODY PARTS (Facing RIGHT) ---

        // 1. ABDOMEN (The Egg Sack) - REAR (Negative X)
        let spawnPressure = (this.spawnTimer / 180);
        let pulse = spawnPressure > 0.8 ? Math.sin(this.spawnTimer * 0.5) * 2 : 0;
        
        let sackR = 50 + (150 * spawnPressure);
        let sackG = 100 + (50 * spawnPressure);
        
        ctx.fillStyle = `rgb(${sackR}, ${sackG}, 20)`;
        ctx.beginPath();
        // MOVED TO NEGATIVE X (-10)
        ctx.ellipse(-10, 0, 14 + pulse, 10 + pulse, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = "#1a2b0a";
        ctx.lineWidth = 1;
        ctx.stroke();

        // Abdomen Details
        ctx.fillStyle = "rgba(0,0,0,0.2)";
        ctx.beginPath();
        ctx.arc(-8, -4, 2, 0, Math.PI*2);
        ctx.arc(-12, 3, 3, 0, Math.PI*2);
        ctx.arc(-6, 2, 2, 0, Math.PI*2);
        ctx.fill();

        // 2. THORAX (Armor) - CENTER
        let darkGreen = `rgb(${20 + 40*pct}, ${40 + 60*pct}, 20)`;
        ctx.fillStyle = darkGreen;
        ctx.beginPath();
        ctx.ellipse(4, 0, 8, 6, 0, 0, Math.PI * 2); // MOVED TO POSITIVE X
        ctx.fill();
        ctx.stroke();

        // 3. HEAD (Mandibles) - FRONT (Positive X)
        ctx.fillStyle = darkGreen;
        ctx.beginPath();
        ctx.arc(12, 0, 5, 0, Math.PI * 2); // MOVED TO POSITIVE X
        ctx.fill();
        ctx.stroke();

        // Mandibles (Pincers) - Pointing Right
        ctx.strokeStyle = "#8b0000"; 
        ctx.beginPath();
        ctx.moveTo(14, -2); ctx.lineTo(20, -4); // Point Right
        ctx.moveTo(14, 2);  ctx.lineTo(20, 4);  // Point Right
        ctx.stroke();

        // Glowing Eyes
        ctx.fillStyle = "#f00"; 
        ctx.beginPath();
        ctx.arc(14, -2, 1.5, 0, Math.PI*2);
        ctx.arc(14, 2, 1.5, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class LarvaEnemy {
    constructor(x, y) {
        this.x = x; 
        this.y = y;
        
        // Very weak, very fast
        this.radius = 5; 
        this.hp = 10; 
        this.maxHp = 10;
        this.bounty = 1; 
        
        this.speed = 1.5; 
        this.vx = (Math.random() - 0.5) * 5; 
        this.vy = (Math.random() - 0.5) * 5;
        
        this.wallDamageCooldown = 0;
        
        // Animation randomizer
        this.wiggleOffset = Math.random() * 100;
        this.wiggleTimer = 0;
    }

    update() {
        this.wiggleTimer += 0.5;

        // 1. Movement
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);

        let isBlocked = sharedMovement(this, col, row);
        if (isBlocked) sharedDestroyWalls(this, col, row, 0.2, 5);

        this.x += this.vx;
        this.y += this.vy;

        // 2. Physics
        separate(this, enemies, 0.8); 
        separate(this, allies, 0.5);
        resolveWallCollision(this);

        // 3. Attack (Suicide)
        let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dx, dy) < 20) { 
            takeDamage(1); 
            this.hp = 0; 
            createParticles(this.x, this.y, "#adff2f", 5);
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Rotate to face movement
        let angle = Math.atan2(this.vy, this.vx);
        ctx.rotate(angle);

        let wiggle = Math.sin(this.wiggleTimer + this.wiggleOffset) * 2;

        // Colors
        let pct = this.hp / this.maxHp;
        let r = 100 + (100 * pct);
        let g = 200 + (55 * pct);
        
        // Draw Maggot Body (3 overlapping circles decreasing in size)
        
        // 1. Tail (Wiggles the most)
        ctx.fillStyle = `rgb(${r-40}, ${g-40}, 0)`;
        ctx.beginPath();
        ctx.arc(-8, wiggle, 3, 0, Math.PI*2);
        ctx.fill();

        // 2. Mid-Body (Wiggles a little)
        ctx.fillStyle = `rgb(${r-20}, ${g-20}, 0)`;
        ctx.beginPath();
        ctx.arc(-4, wiggle * 0.5, 4, 0, Math.PI*2);
        ctx.fill();

        // 3. Head (Steady)
        ctx.fillStyle = `rgb(${r}, ${g}, 0)`; // Brightest
        ctx.strokeStyle = "#1a2b0a";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.ellipse(2, 0, 5, 4, 0, 0, Math.PI*2); // Oval head
        ctx.fill();
        ctx.stroke();

        // Tiny Pincers/Mouth
        ctx.strokeStyle = "black";
        ctx.beginPath();
        ctx.moveTo(6, -2); ctx.lineTo(8, 0); ctx.lineTo(6, 2);
        ctx.stroke();

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class LeaperEnemy {
    constructor() {
        // --- SPAWN LOGIC ---
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- STATS ---
        this.radius = 12;
        this.speed = 0.8; // Slow walk
        this.hp = 25 + (wave * 5); 
        this.maxHp = this.hp;
        this.bounty = 5;
        
        this.vx = -1;
        this.vy = 0;
        
        // --- JUMP MECHANICS ---
        this.state = 'RUN';
        this.jumpTimer = 0;
        this.jumpDuration = 45; 
        this.jumpCooldown = 0;  
        this.jumpHeight = 0;    
        
        // --- VISUALS ---
        this.angle = Math.PI;
        this.animTimer = Math.random() * 100;
        this.wingOpenAmount = 0; 
    }

    update(dt) {
        this.animTimer += 0.1*dt;
        if (this.jumpCooldown > 0) this.jumpCooldown--;

        let dx = (playerBase.x * CELL_SIZE + CELL_SIZE/2) - this.x;
        let dy = (playerBase.y * CELL_SIZE + CELL_SIZE/2) - this.y;
        let distToBase = Math.hypot(dx, dy);

        // --- STATE MACHINE ---
        if (this.state === 'RUN') {
            let col = Math.floor(this.x / CELL_SIZE);
            let row = Math.floor(this.y / CELL_SIZE);
            
            // 1. STANDARD MOVEMENT
            // We call sharedMovement to handle walking/pathfinding. 
            // We store 'isStuck' to know if the base is totally sealed off.
            let isStuck = sharedMovement(this, col, row);

            // 2. ROTATION (Face movement)
            if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
                let targetAngle = Math.atan2(this.vy, this.vx);
                let diff = targetAngle - this.angle;
                while (diff < -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;
                this.angle += diff * 0.05; 
            }
            if (this.wingOpenAmount > 0) this.wingOpenAmount -= 0.05;

            // --- 3. PROACTIVE JUMP CHECK ---
            // We check for a wall directly towards the base, even if 'isStuck' is false.
            if (this.jumpCooldown <= 0 && distToBase > 60) {
                
                // Look ahead 40px (approx 1 cell) towards the base
                let lookDist = 40;
                let lookX = this.x + (Math.cos(this.angle) * lookDist);
                let lookY = this.y + (Math.sin(this.angle) * lookDist);
                
                let wallCol = Math.floor(lookX / CELL_SIZE);
                let wallRow = Math.floor(lookY / CELL_SIZE);

                // Is there a wall right in front of us?
                if (wallCol >= 0 && wallCol < COLS && wallRow >= 0 && wallRow < ROWS) {
                    if (grid[wallCol][wallRow].wall) {
                        
                        // WALL FOUND! Now check the landing spot (Jump over 1 wall = ~2 cells away)
                        let landDist = 90; // 40 (wall) + 50 (landing)
                        let landX = this.x + (Math.cos(this.angle) * landDist);
                        let landY = this.y + (Math.sin(this.angle) * landDist);
                        
                        let landCol = Math.floor(landX / CELL_SIZE);
                        let landRow = Math.floor(landY / CELL_SIZE);
                        
                        let canLand = true;

                        // Check if landing spot is valid
                        if (landCol >= 0 && landCol < COLS && landRow >= 0 && landRow < ROWS) {
                            // CANNOT jump if the landing spot is ALSO a wall (Double Wall)
                            if (grid[landCol][landRow].wall) {
                                canLand = false;
                            }
                        } else {
                            canLand = false; // Don't jump off map
                        }

                        // DECISION:
                        if (canLand) {
                            // A single wall detected + clear landing -> JUMP!
                            this.vx = 0; 
                            this.vy = 0;
                            this.state = 'CHARGE';
                            this.jumpTimer = 100; // 1.6s wait
                        } 
                    }
                }
            }

            // --- 4. STUCK LOGIC ---
            // If we are stuck (base sealed) AND we didn't start a jump above, break the wall.
            if (isStuck && this.state !== 'CHARGE') {
                sharedDestroyWalls(this, col, row, 1, 5);
            }

            this.jumpHeight = 0;
        } 
        else if (this.state === 'CHARGE') {
            this.angle += (Math.random() - 0.5) * 0.1; // Shaking effect
            this.jumpTimer--;
            
            if (this.wingOpenAmount < 0.5) this.wingOpenAmount += 0.005;

            if (this.jumpTimer <= 0) {
                this.state = 'AIR';
                this.jumpTimer = this.jumpDuration;
                
                // Launch towards base
                let angleToBase = Math.atan2(dy, dx);
                let jumpDist = CELL_SIZE * 2.5; 
                let requiredSpeed = jumpDist / this.jumpDuration;

                this.vx = Math.cos(angleToBase) * requiredSpeed;
                this.vy = Math.sin(angleToBase) * requiredSpeed;
                this.angle = angleToBase;
            }
        }
        else if (this.state === 'AIR') {
            this.jumpTimer--;
            if (this.wingOpenAmount < 1) this.wingOpenAmount += 0.1;

            // Parabolic Arc
            let t = 1 - (this.jumpTimer / this.jumpDuration); 
            this.jumpHeight = Math.sin(t * Math.PI) * 60; 

            if (this.jumpTimer <= 0) {
                // Land
                this.state = 'RUN';
                this.jumpCooldown = 120; 
                this.vx = 0; 
                this.vy = 0;
                createParticles(this.x, this.y, "#00ffcc", 8); 
            }
        }

        // Apply Velocity
        this.x += this.vx;
        this.y += this.vy;

        if (distToBase < 30) { takeDamage(10); this.hp = 0; }

        // Physics (Do not collide with walls while in AIR)
        if (this.state !== 'AIR') {
            separate(this, enemies, 0.5);
            resolveWallCollision(this);
        }
    }

    draw() {
        ctx.save();
        
        let shadowSize = 8 - (this.jumpHeight / 10);
        if (shadowSize < 0) shadowSize = 0;
        ctx.fillStyle = "rgba(0,0,0,0.4)";
        ctx.beginPath();
        ctx.ellipse(this.x, this.y + 5, shadowSize, shadowSize * 0.5, 0, 0, Math.PI*2);
        ctx.fill();

        ctx.translate(this.x, this.y - this.jumpHeight);
        ctx.rotate(this.angle);

        if (this.state === 'CHARGE') {
            let scaleMod = 1.0 - (Math.sin(Date.now() / 20) * 0.05);
            ctx.scale(scaleMod, 1/scaleMod); 
        }

        const cNeon = "#00d2ff";
        const cDark = "#005566";
        const cBlack = "#002233";

        // Legs
        ctx.strokeStyle = cNeon;
        ctx.lineWidth = 3;
        ctx.lineJoin = "round";
        const drawHindLeg = (side) => {
            let legOffset = (this.state === 'RUN') ? Math.sin(this.animTimer * 2 + side) * 5 : -10;
            if (this.state === 'AIR') legOffset = 15; 
            ctx.beginPath();
            ctx.moveTo(-5, side * 5); 
            ctx.lineTo(-15 + legOffset, side * 12); 
            ctx.lineTo(-5 + legOffset, side * 15); 
            ctx.stroke();
            ctx.fillStyle = cDark;
            ctx.beginPath();
            ctx.ellipse(-10 + (legOffset/2), side * 8, 4, 2, 0.5 * side, 0, Math.PI*2);
            ctx.fill();
        };
        drawHindLeg(1);
        drawHindLeg(-1);

        // Wings
        if (this.wingOpenAmount > 0.01) {
            ctx.save();
            ctx.fillStyle = "rgba(0, 210, 255, 0.4)";
            ctx.globalCompositeOperation = "lighter";
            ctx.beginPath();
            ctx.rotate(-0.2 * this.wingOpenAmount);
            ctx.moveTo(-5, -5); ctx.quadraticCurveTo(-20, -20, -25, -5); ctx.lineTo(-5, -2); ctx.fill();
            ctx.rotate(0.4 * this.wingOpenAmount); 
            ctx.beginPath();
            ctx.moveTo(-5, 5); ctx.quadraticCurveTo(-20, 20, -25, 5); ctx.lineTo(-5, 2); ctx.fill();
            ctx.restore();
        }

        // Body
        ctx.fillStyle = cBlack;
        ctx.beginPath(); ctx.ellipse(-8, 0, 10, 5, 0, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = cNeon; ctx.lineWidth = 1;
        for(let i=0; i<3; i++) { ctx.beginPath(); ctx.arc(-6 - (i*4), 0, 4 - i, -Math.PI/2, Math.PI/2); ctx.stroke(); }
        ctx.fillStyle = cDark;
        ctx.beginPath(); ctx.ellipse(2, 0, 6, 5, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "rgba(255,255,255,0.2)";
        ctx.beginPath(); ctx.ellipse(2, -2, 4, 2, 0, 0, Math.PI*2); ctx.fill();

        // Head
        ctx.fillStyle = cBlack;
        ctx.beginPath(); ctx.moveTo(6, -3); ctx.lineTo(14, 0); ctx.lineTo(6, 3); ctx.fill();
        ctx.fillStyle = (this.state === 'CHARGE') ? "#fff" : "#ff0044"; 
        ctx.beginPath(); ctx.arc(8, -2, 1.5, 0, Math.PI*2); ctx.arc(8, 2, 1.5, 0, Math.PI*2); ctx.fill();

        let twitch = Math.sin(Date.now() / 50) * 2;
        ctx.strokeStyle = cDark; ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(14, -1); ctx.lineTo(16 + (twitch/4), -3);
        ctx.moveTo(14, 1);  ctx.lineTo(16 + (twitch/4), 3); ctx.stroke();

        // Front Legs
        ctx.strokeStyle = cNeon; ctx.lineWidth = 1.5;
        const drawFrontLeg = (side, offset) => {
            let legMove = (this.state === 'RUN') ? Math.sin(this.animTimer * 3 + offset) * 3 : 0;
            if (this.state === 'AIR') legMove = -5;
            ctx.beginPath(); ctx.moveTo(4, side * 3); ctx.lineTo(8 + legMove, side * 8); ctx.lineTo(12 + legMove, side * 10); ctx.stroke();
        };
        drawFrontLeg(1, 0); drawFrontLeg(-1, Math.PI);

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class ReviverEnemy {
    constructor() {
        // Spawn Logic
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        this.type = "REVIVER_XENOID";
        
        // STATS
        this.radius = 16; 
        this.speed = 0.55; 
        this.hp = 300 + (wave * 40); 
        this.maxHp = this.hp;
        this.bounty = 70; 
        
        this.vx = 0; 
        this.vy = 0;
        this.angle = 0; 
        
        // LOGIC
        this.reviveRadius = 180; 
        this.reviveSpeed = 1.3;  
        
        // ANIMATION STATE
        this.walkCycle = 0; 
        this.mandibleTwitch = 0;
        this.abdomenPulse = 0;
        this.isSinging = false;
        
        // VISUALS
        this.strideLength = 40; // Wider steps
    }

    update(dt) {
        // --- ANIMATION SYNC ---
        let moveSpeed = Math.hypot(this.vx, this.vy);
        
        // Much slower animation increment for a "Heavy" feel
        if (moveSpeed > 0.01) {
            this.walkCycle += 0.015; // Was 0.04
        } else {
            this.walkCycle += 0.005; // Idle breathing
        }

        this.mandibleTwitch += 0.1;
        this.abdomenPulse += 0.05;

        // --- 1. MOVEMENT ---
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);
        
        let isBlocked = sharedMovement(this, col, row);
        if (isBlocked) sharedDestroyWalls(this, col, row, 2, 12);

        this.x += this.vx;
        this.y += this.vy;
        
        // Smooth Rotation
        if (Math.abs(this.vx) > 0.01 || Math.abs(this.vy) > 0.01) {
            let targetAngle = Math.atan2(this.vy, this.vx);
            let diff = targetAngle - this.angle;
            while (diff < -Math.PI) diff += Math.PI * 2;
            while (diff > Math.PI) diff -= Math.PI * 2;
            this.angle += diff * 0.08; 
        }
        
        separate(this, enemies, 1.2); 

        // --- 2. HIVE MIND REVIVAL ---
        this.isSinging = false;
        for (let i = corpses.length - 1; i >= 0; i--) {
            let c = corpses[i];
            if (!c.active) continue;

            if (Math.hypot(c.x - this.x, c.y - this.y) < this.reviveRadius) {
                this.isSinging = true;
                if (typeof c.reviveProgress === 'undefined') c.reviveProgress = 0;
                c.reviveProgress += this.reviveSpeed;

                if (Math.random() > 0.85) createParticles(c.x, c.y, "#7c43bd", 1); 

                if (c.reviveProgress >= 100) {
                    enemies.push(new SkeletonEnemy(c.x, c.y));
                    createParticles(c.x, c.y, "#d500f9", 25); 
                    c.active = false; 
                }
            }
        }
        
        // Base Damage
        let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
        let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
        if (Math.hypot(dx, dy) < 30) {
             takeDamage(20);
             this.hp = 0;
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle); 
        
        let s = 0.5; 
        ctx.scale(s, s);

        let pulse = Math.sin(this.abdomenPulse) * 2;

        // --- 1. WIDE SPIDER LEGS ---
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        const drawLeg = (side, row) => {
            let isFront = row < 2;
            
            // INCREASED LENGTH (Was 26/20)
            let legLen = isFront ? 36 : 28; 
            
            // --- GAIT TIMING ---
            const gaitOffset = [0, 0.5, 0.25, 0.75, 0.1][row];
            let t = (this.walkCycle + gaitOffset + (side === -1 ? 0.5 : 0)) % 1.0;
            
            // --- STANCE VS SWING ---
            let cycleX = 0; 
            let cycleLift = 0; 
            
            let swingDuration = 0.3; // 30% of time spent moving forward

            if (t < swingDuration) {
                // == SWING (AIR) ==
                let p = t / swingDuration; 
                // Move from Back (-1) to Front (+1)
                cycleX = -1 + (p * 2); 
                // Higher lift for longer legs
                cycleLift = Math.sin(p * Math.PI) * 12;
            } else {
                // == STANCE (GROUND) ==
                let p = (t - swingDuration) / (1.0 - swingDuration); 
                // Move from Front (+1) to Back (-1)
                cycleX = 1 - (p * 2); 
                cycleLift = 0; 
            }

            // --- CALCULATE POSITIONS ---
            
            // 1. Mount Point
            let mountX, mountY;
            if (isFront) {
                mountX = 9 - (row * 7); 
                mountY = side * 6;
            } else {
                let backIndex = row - 2;
                mountX = -14 - (backIndex * 8); 
                mountY = side * 8; 
            }

            // 2. Neutral Angle
            // Slight adjustment to fan them out more given the length
            let baseAngle = isFront ? (0.4 - row * 0.35) : (2.7 + (row-2) * 0.35);
            
            // 3. Apply Stride
            let strideOffset = cycleX * (this.strideLength / 2);
            
            let neutralReach = legLen;
            let nx = mountX + (Math.cos(baseAngle) * neutralReach);
            let ny = mountY + (Math.sin(baseAngle) * neutralReach * side);
            
            let footX = nx + strideOffset;
            let footY = ny; 

            // 4. IK for the Knee
            let midX = (mountX + footX) / 2;
            let midY = (mountY + footY) / 2;
            let dx = footX - mountX;
            let dy = footY - mountY;
            let dist = Math.hypot(dx, dy);
            
            // KNEE OUT: Increased to handle longer legs (Was 14)
            let kneeOut = 20 + (cycleLift * 0.8); 
            
            let perpX = -dy / dist;
            let perpY = dx / dist;
            if (perpY * side < 0) { perpX = -perpX; perpY = -perpY; }

            let kneeX = midX + (perpX * kneeOut);
            let kneeY = midY + (perpY * kneeOut);

            // --- DRAW ---
            
            // Shadow
            if (cycleLift > 1) {
                ctx.fillStyle = "rgba(0,0,0,0.3)";
                ctx.beginPath();
                // Shadow location slightly under the lifted foot
                ctx.arc(footX - (cycleX * 4), footY, 3, 0, Math.PI*2); 
                ctx.fill();
            }

            // Femur
            ctx.strokeStyle = "#1a237e"; 
            ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(mountX, mountY); ctx.lineTo(kneeX, kneeY); ctx.stroke();
            
            // Tibia
            let lightness = 57 + (cycleLift * 4); 
            ctx.strokeStyle = `hsl(231, 48%, ${lightness}%)`;
            ctx.lineWidth = 2.5;
            ctx.beginPath(); ctx.moveTo(kneeX, kneeY); ctx.lineTo(footX, footY); ctx.stroke();

            // Joints
            ctx.fillStyle = "#000"; ctx.beginPath(); ctx.arc(mountX, mountY, 3, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "#4a148c"; ctx.beginPath(); ctx.arc(kneeX, kneeY, 3.5, 0, Math.PI*2); ctx.fill();
            ctx.fillStyle = "#d500f9"; ctx.beginPath(); ctx.arc(footX, footY, 2, 0, Math.PI*2); ctx.fill();
        };

        // Render Legs (Back to Front)
        for(let i=4; i>=2; i--) { drawLeg(1, i); drawLeg(-1, i); }
        
        // --- BODY ---
        ctx.strokeStyle = "#212121"; ctx.lineWidth = 10;
        ctx.beginPath(); ctx.moveTo(4, 0); ctx.lineTo(-12, 0); ctx.stroke();

        ctx.save();
        ctx.translate(-22, 0); 
        ctx.fillStyle = "#0d1b2a"; 
        ctx.beginPath(); ctx.ellipse(0, 0, 15, 11 + (pulse*0.3), 0, 0, Math.PI*2); ctx.fill();
        
        let buttGrad = ctx.createLinearGradient(0, -10, 0, 10);
        buttGrad.addColorStop(0, "#1a237e"); buttGrad.addColorStop(0.5, "#000"); buttGrad.addColorStop(1, "#1a237e");
        ctx.fillStyle = buttGrad;
        ctx.beginPath(); ctx.ellipse(3, 0, 11, 7, 0, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = this.isSinging ? "#d500f9" : "#4a148c";
        ctx.shadowBlur = 15; ctx.shadowColor = ctx.fillStyle;
        ctx.beginPath(); ctx.arc(-9, 0, 5, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
        ctx.restore();

        // Front Legs
        drawLeg(1, 1); drawLeg(-1, 1);
        drawLeg(1, 0); drawLeg(-1, 0);

        // Thorax
        ctx.fillStyle = "#1a237e";
        ctx.beginPath();
        ctx.moveTo(12, 0); ctx.lineTo(6, 8); ctx.lineTo(-4, 7); ctx.lineTo(-8, 0); ctx.lineTo(-4, -7); ctx.lineTo(6, -8);
        ctx.fill();
        ctx.fillStyle = "#304ffe";
        ctx.beginPath(); ctx.moveTo(9, 0); ctx.lineTo(0, 2); ctx.lineTo(-6, 0); ctx.lineTo(0, -2); ctx.fill();

        // Head
        ctx.save();
        ctx.translate(12, 0);
        let twitch = Math.sin(this.mandibleTwitch) * 0.2;
        ctx.fillStyle = "#283593"; ctx.strokeStyle = "#5c6bc0"; ctx.lineWidth = 1;
        
        ctx.save(); ctx.rotate(-0.4 + twitch);
        ctx.beginPath(); ctx.moveTo(0, -3); ctx.lineTo(13, -6); ctx.lineTo(10, -1); ctx.lineTo(0, 0);
        ctx.fill(); ctx.stroke(); ctx.restore();
        
        ctx.save(); ctx.rotate(0.4 - twitch);
        ctx.beginPath(); ctx.moveTo(0, 3); ctx.lineTo(13, 6); ctx.lineTo(10, 1); ctx.lineTo(0, 0);
        ctx.fill(); ctx.stroke(); ctx.restore();

        ctx.fillStyle = "#000"; ctx.beginPath(); ctx.arc(0, 0, 5.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#00e5ff"; ctx.shadowBlur = 5; ctx.shadowColor = "#00e5ff";
        ctx.beginPath(); ctx.arc(3, -2, 1.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(4, -1, 1, 0, Math.PI*2); ctx.fill(); 
        ctx.beginPath(); ctx.arc(3, 2, 1.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(4, 1, 1, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
        
        ctx.strokeStyle = "#d500f9"; ctx.lineWidth = 0.5;
        ctx.beginPath(); ctx.moveTo(5, -1); ctx.lineTo(18, -6 + Math.sin(Date.now()/60)*2); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(5, 1); ctx.lineTo(18, 6 - Math.sin(Date.now()/60)*2); ctx.stroke();
        ctx.restore();

        // Singing
        if (this.isSinging) {
            let wavePhase = (Date.now() / 150) % 10;
            ctx.lineWidth = 1.5;
            for(let w=0; w<3; w++) { 
                let r = (wavePhase + (w*4)) * 6;
                let alpha = 1 - (r/45);
                if (alpha > 0) {
                    ctx.strokeStyle = `rgba(0, 229, 255, ${alpha})`; 
                    ctx.beginPath(); ctx.arc(15, 0, r, -0.8, 0.8); ctx.stroke();
                }
            }
        }

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class SkeletonEnemy {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.type = "SKELETON_UNIT";
        
        // Stats
        this.hp = 30 + (wave * 5);
        this.maxHp = this.hp;
        this.speed = 1.6;
        this.vx = 0; 
        this.vy = 0;
        this.radius = 12;
        this.bounty = 1;
        
        this.angle = 0;
        this.walkCycle = 0;
        this.twitch = 0; // Replaced "flicker" with a muscular spasm
    }

    update(dt) {
        this.walkCycle += 0.15; // Slower, more deliberate stride
        this.twitch = Math.random() > 0.98 ? Math.random() * 2 : 0; 
        
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);
        
        let isBlocked = sharedMovement(this, col, row);
        if (isBlocked) sharedDestroyWalls(this, col, row, 5, 5);

        this.x += this.vx;
        this.y += this.vy;
        
        if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
            this.angle = Math.atan2(this.vy, this.vx);
        }
        
        separate(this, enemies, 0.5);
    }

    draw() {
        ctx.save();
        ctx.translate(this.x + this.twitch, this.y + this.twitch); // Spasmodic movement
        ctx.rotate(this.angle);

        // Biological animation variables
        let breathe = Math.sin(this.walkCycle) * 1.5;
        let limbSwing = Math.sin(this.walkCycle);
        
        // --- 1. THE SPINE (Calcified Bone) ---
        ctx.strokeStyle = "#e0e0ce"; // Aged bone color
        ctx.lineWidth = 3;
        ctx.lineCap = "round";

        // Segmented vertebrae
        for(let i = 0; i < 4; i++) {
            ctx.beginPath();
            ctx.fillStyle = i % 2 === 0 ? "#f5f5dc" : "#d2b48c";
            ctx.arc(-8 + (i * 4), 0, 2.5, 0, Math.PI * 2);
            ctx.fill();
        }

        // --- 2. ROTTING RIBCAGE ---
        ctx.strokeStyle = "#f5f5dc";
        ctx.lineWidth = 2;
        
        // Curved ribs instead of straight lines
        [1, -1].forEach(side => {
            ctx.beginPath();
            ctx.moveTo(2, side * 2);
            // Ribs expand and contract (breathing)
            ctx.quadraticCurveTo(-2, side * (8 + breathe), 4, side * (6 + breathe));
            ctx.stroke();
        });

        // --- 3. THE SKULL ---
        // Main cranium
        ctx.fillStyle = "#f5f5dc"; 
        ctx.beginPath();
        ctx.arc(6, 0, 5, 0, Math.PI * 2);
        ctx.fill();
        
        // Sunken Jaw
        ctx.beginPath();
        ctx.ellipse(8, 2, 3, 4, Math.PI/4, 0, Math.PI * 2);
        ctx.fill();

        // --- 4. THE EYE (Malevolent Glow) ---
        ctx.shadowBlur = 10;
        ctx.shadowColor = "#ff0000";
        ctx.fillStyle = "#4a0404"; // Dark socket
        ctx.beginPath();
        ctx.arc(7, -2, 2, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.fillStyle = "#ff4444"; // Pinprick pupil
        ctx.beginPath();
        ctx.arc(7.5, -2, 0.8, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // --- 5. LASHING LIMBS (Exposed Tendons) ---
        ctx.strokeStyle = "#8b0000"; // Deep blood red
        ctx.lineWidth = 2;

        // Right Arm - Swinging erratically
        ctx.beginPath();
        ctx.moveTo(2, -4); 
        let rArmX = 10 + (limbSwing * 4);
        ctx.bezierCurveTo(rArmX, -10, rArmX + 2, -5, rArmX + 4, -8); 
        ctx.stroke();

        // Left Arm
        ctx.beginPath();
        ctx.moveTo(2, 4);
        let lArmX = 10 - (limbSwing * 4);
        ctx.bezierCurveTo(lArmX, 10, lArmX + 2, 5, lArmX + 4, 8);
        ctx.stroke();

        // --- 6. MIASMA / BLOOD DRIP (Rear) ---
        ctx.fillStyle = "#660000";
        ctx.globalAlpha = 0.3 + (Math.random() * 0.2);
        ctx.beginPath();
        ctx.arc(-12, breathe, 3, 0, Math.PI * 2);
        ctx.arc(-15, -breathe, 2, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1.0;

        ctx.restore();
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class FlyingEnemy {
    constructor() {
        // Spawn off-screen
        this.x = VIRTUAL_WIDTH + 20;
        let playableHeight = VIRTUAL_HEIGHT - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- STATS ---
        this.radius = 9;       
        this.speed = 0.6;      
        this.hp = 150 + (wave * 10)* difficultyMultiplier; 
        this.maxHp = this.hp;
        this.bounty = 7;

        this.vx = 0;
        this.vy = 0;
        
        this.animOffset = Math.random() * 1000;
    }

    update(dt) {
        // 1. MOVEMENT (Straight Line)
        let baseX = (playerBase.x * CELL_SIZE) + CELL_SIZE;
        let baseY = (playerBase.y * CELL_SIZE) + CELL_SIZE;
        
        let dx = baseX - this.x;
        let dy = baseY - this.y;
        let dist = Math.hypot(dx, dy);

        if (dist > 0) {
            this.vx = (dx / dist) * this.speed;
            this.vy = (dy / dist) * this.speed;
        }

        // REMOVED: The "wobble" code was here. 
        // Now it just tracks directly towards the base.

        this.x += this.vx *dt;
        this.y += this.vy *dt;

        // 2. PHYSICS
        separate(this, enemies, 0.5);

        // 3. ATTACK
        if (dist < 30) {
            takeDamage(5); 
            this.hp = 0;   
            createParticles(this.x, this.y, "#ff3300", 10); 
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        // --- SCALING ---
        ctx.scale(0.7, 0.9); 

        // 1. ORIENTATION (Face Forward)
        let angle = Math.atan2(this.vy, this.vx);
        ctx.rotate(angle + Math.PI / 2); 

        // Animation Variables
        let time = Date.now();
        let flutterFront = Math.sin((time / 60) + this.animOffset); 
        let flutterBack = Math.cos((time / 60) + this.animOffset);

        // --- 2. WINGS ---
        ctx.save();
        ctx.fillStyle = "rgba(200, 255, 255, 0.15)";
        ctx.strokeStyle = "rgba(0, 255, 255, 0.4)";
        ctx.lineWidth = 1;

        const drawWing = (xOffset, yOffset, length, width, rot) => {
            ctx.save();
            ctx.translate(xOffset, yOffset);
            ctx.rotate(rot); 
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(width, -length * 0.2); 
            ctx.lineTo(0, -length); 
            ctx.lineTo(-width, -length * 0.2);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Inner Vein
            ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, -length * 0.8); ctx.stroke();
            ctx.restore();
        };

        // Front Wings
        drawWing(4, -5, 22, 4, 1.0 + (flutterFront * 0.3)); 
        drawWing(-4, -5, 22, 4, -1.0 - (flutterFront * 0.3));

        // Back Wings
        drawWing(3, 0, 16, 3, 2.2 + (flutterBack * 0.4));   
        drawWing(-3, 0, 16, 3, -2.2 - (flutterBack * 0.4));  
        ctx.restore();

        // --- 3. BODY & TAIL ---
        // Tail
        ctx.fillStyle = "#1a1a1a"; 
        ctx.strokeStyle = "#cc3300"; 
        ctx.lineWidth = 1;

        for(let i = 0; i < 4; i++) {
            let tailSize = 6 - i; 
            let tailY = 10 + (i * 4);
            let wiggle = Math.sin(time / 400 + (i * 0.5)) * 1; 

            ctx.beginPath();
            ctx.moveTo(wiggle, tailY);
            ctx.lineTo(wiggle + tailSize, tailY + tailSize);
            ctx.lineTo(wiggle, tailY + (tailSize * 2));
            ctx.lineTo(wiggle - tailSize, tailY + tailSize);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            if (i === 3) { 
                ctx.fillStyle = "#ff0000";
                ctx.beginPath(); ctx.arc(wiggle, tailY + 4, 2, 0, Math.PI*2); ctx.fill();
                ctx.fillStyle = "#1a1a1a";
            }
        }

        // Thorax
        ctx.fillStyle = "#222"; 
        ctx.beginPath();
        ctx.moveTo(0, -8); ctx.lineTo(6, -2); ctx.lineTo(4, 8); ctx.lineTo(-4, 8); ctx.lineTo(-6, -2);
        ctx.closePath(); ctx.fill(); ctx.stroke();

        // Head
        ctx.beginPath();
        ctx.moveTo(0, -8); ctx.lineTo(5, -14); ctx.lineTo(0, -18); ctx.lineTo(-5, -14);
        ctx.closePath(); ctx.fillStyle = "#000"; ctx.fill();

        // --- 4. FACE ---
        ctx.fillStyle = "#ff3300"; 
        ctx.shadowColor = "#ff0000"; ctx.shadowBlur = 8;
        ctx.beginPath(); ctx.ellipse(-3, -12, 2, 4, -0.3, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(3, -12, 2, 4, 0.3, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0; 

        // Mandibles
        ctx.strokeStyle = "#999"; ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(-2, -18); ctx.quadraticCurveTo(-6, -22, -1, -24);
        ctx.moveTo(2, -18); ctx.quadraticCurveTo(6, -22, 1, -24);
        ctx.stroke();

        ctx.restore();

        if (this.hp < this.maxHp) {
            const barW = 24;
            const barH = 4;
            const yOffset = 28;

            const barX = this.x - (barW / 2);
            const barY = this.y - yOffset;

            const pct = Math.max(0, Math.min(1, this.hp / this.maxHp));
            const hue = (pct * pct) * 120;

            ctx.fillStyle = "#333333";
            ctx.fillRect(barX, barY, barW, barH);

            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
            ctx.fillRect(barX, barY, barW * pct, barH);

            ctx.strokeStyle = "#000000";
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barW, barH);
        }
    }
}

class MagnetEnemy {
    constructor() {
        // --- SPAWN SETUP ---
        this.x = (typeof VIRTUAL_WIDTH !== 'undefined') ? VIRTUAL_WIDTH + 60 : 1000;
        let playableHeight = (typeof VIRTUAL_HEIGHT !== 'undefined') ? VIRTUAL_HEIGHT : 600;
        this.y = CELL_SIZE + Math.random() * (playableHeight - (CELL_SIZE * 2));

        // --- STATS ---
        this.radius = 22;          
        this.hp = 3000 + (wave * 150); 
        this.maxHp = this.hp;
        this.speed = 0.50;         
        this.bounty = 280;       
        
        // --- PHYSICS ---
        this.vx = 0;
        this.vy = 0;
        this.friction = 0.92;
        this.angle = Math.PI;      

        // --- ABILITY ---
        this.magnetRange = 340;    
        this.magnetForce = 1.6;   

        // --- VISUALS ---
        this.animTimer = 0;
        this.pulsePhase = 0;
        this.legCycle = 0;
        this.scale = 0.55; 
    }

    update(dt) {
        if (!dt) dt = 1;
        this.animTimer += dt * 0.05;
        this.pulsePhase += dt * 0.12;

        // --- MOVEMENT ---
        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);
        
        let isBlocked = false;
        if (typeof sharedMovement === 'function') {
            isBlocked = sharedMovement(this, col, row);
        }

        if (isBlocked && typeof sharedDestroyWalls === 'function') {
            sharedDestroyWalls(this, col, row, 6, 30);
        }

        // Apply Velocity
        this.x += this.vx;
        this.y += this.vy;
        this.vx *= this.friction;
        this.vy *= this.friction;

        // Calculate speed
        let speed = Math.hypot(this.vx, this.vy);
        
        // Face movement direction
        if (speed > 0.05) {
            let targetAngle = Math.atan2(this.vy, this.vx);
            let diff = targetAngle - this.angle;
            while (diff < -Math.PI) diff += Math.PI * 2;
            while (diff > Math.PI) diff -= Math.PI * 2;
            this.angle += diff * 0.08;
            
            // Leg animation
            this.legCycle += speed * 0.35; 
        }

        // --- MAGNET LOGIC (Fixed: Single Owner) ---
        if (typeof projectiles !== 'undefined') {
            for (let p of projectiles) {
                if (!p.active) continue;

                let dx = this.x - p.x;
                let dy = this.y - p.y;
                let distSq = dx*dx + dy*dy;
                let rangeSq = this.magnetRange * this.magnetRange;

                // 1. Release Lock if Out of Range
                // If I own this bullet but it's now too far away, let it go.
                if (distSq >= rangeSq) {
                    if (p.magnetOwner === this) {
                        p.magnetOwner = null;
                    }
                    continue; // Skip attraction
                }

                // 2. Check Ownership
                // If it is owned by someone else, AND that owner is still alive:
                if (p.magnetOwner && p.magnetOwner !== this) {
                    if (p.magnetOwner.hp > 0) {
                        continue; // Don't touch it
                    } else {
                        // Previous owner is dead, I can steal it
                        p.magnetOwner = null; 
                    }
                }

                // 3. Apply Attraction
                // Claim ownership
                p.magnetOwner = this;
                
                // Hijack Homing Target (if applicable)
                if (p.target && p.target !== this) p.target = this;

                let dist = Math.sqrt(distSq);

                // Stronger pull closer to center
                let strength = 1 + (1 - dist/this.magnetRange); 
                let force = this.magnetForce * strength;

                p.vx += (dx / dist) * force;
                p.vy += (dy / dist) * force;

                if (typeof p.angle !== 'undefined') {
                    let tA = Math.atan2(dy, dx);
                    let aD = tA - p.angle;
                    while (aD < -Math.PI) aD += Math.PI * 2;
                    while (aD > Math.PI) aD -= Math.PI * 2;
                    p.angle += aD * 0.2;
                }
            }
        }
        
        if (typeof separate === 'function') separate(this, enemies, 0.45);
        if (typeof resolveWallCollision === 'function') resolveWallCollision(this);
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        // --- 1. FIELD AURA ---
        let pulse = Math.sin(this.pulsePhase);
        let fieldR = this.magnetRange * (0.9 + pulse * 0.03);
        
        ctx.beginPath();
        ctx.arc(0, 0, fieldR, 0, Math.PI*2);
        let grad = ctx.createRadialGradient(0, 0, 10, 0, 0, fieldR);
        grad.addColorStop(0, "rgba(0,0,0,0)");
        grad.addColorStop(0.9, `rgba(100, 40, 160, ${0.05 + pulse * 0.02})`);
        grad.addColorStop(1, `rgba(100, 40, 160, 0)`);
        ctx.fillStyle = grad;
        ctx.fill();

        // ROTATE & SCALE
        ctx.rotate(this.angle);
        ctx.scale(this.scale, this.scale); 

        // --- 2. MULTI-JOINTED LEGS (SHORTER VERSION) ---
        const legConfig = [
            { side: 1,  yBase: -12, angle: -0.6, len: 28 },
            { side: -1, yBase: -12, angle: -0.6, len: 28 },
            { side: 1,  yBase: 0,   angle: 0,    len: 32 },
            { side: -1, yBase: 0,   angle: 0,    len: 32 },
            { side: 1,  yBase: 14,  angle: 0.8,  len: 30 },
            { side: -1, yBase: 14,  angle: 0.8,  len: 30 }
        ];

        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        legConfig.forEach((leg, index) => {
            ctx.save();
            let isGroupA = (index === 0 || index === 3 || index === 4);
            let legPhase = this.legCycle + (isGroupA ? 0 : Math.PI);
            
            let stride = Math.sin(legPhase) * 10; 
            let lift = Math.cos(legPhase) * 5;
            
            let startX = 5;
            let startY = leg.yBase;
            let baseAngle = (leg.side === 1 ? Math.PI/2 : -Math.PI/2) + (leg.angle * leg.side);
            
            let footDist = 20 + leg.len + lift;
            let footX = startX + Math.cos(baseAngle) * footDist + (stride * 0.5);
            let footY = startY + Math.sin(baseAngle) * footDist + stride;

            let coxaLen = 10;
            let coxaX = startX + Math.cos(baseAngle) * coxaLen;
            let coxaY = startY + Math.sin(baseAngle) * coxaLen;

            let dx = footX - coxaX;
            let dy = footY - coxaY;
            let dist = Math.hypot(dx, dy);
            let midX = coxaX + dx * 0.5;
            let midY = coxaY + dy * 0.5;
            
            let kneePush = 16;
            let perpX = -dy / dist;
            let perpY = dx / dist;
            if (leg.side === -1) { perpX = -perpX; perpY = -perpY; }
            
            let kneeX = midX + perpX * kneePush;
            let kneeY = midY + perpY * kneePush;

            // Draw Segments
            ctx.strokeStyle = "#150a1a";
            ctx.lineWidth = 7;
            ctx.beginPath(); ctx.moveTo(startX, startY); ctx.lineTo(kneeX, kneeY); ctx.stroke();

            ctx.strokeStyle = "#25152e";
            ctx.lineWidth = 5;
            ctx.beginPath(); ctx.moveTo(kneeX, kneeY); ctx.lineTo(footX, footY); ctx.stroke();

            // Sharp tips
            ctx.strokeStyle = "#4a2d54";
            ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(footX, footY); ctx.lineTo(footX + (footX-kneeX)*0.4, footY + (footY-kneeY)*0.4); ctx.stroke();

            ctx.fillStyle = "#3d2a45";
            ctx.beginPath(); ctx.arc(kneeX, kneeY, 4, 0, Math.PI*2); ctx.fill();

            ctx.restore();
        });

        // --- 3. BODY STRUCTURE ---

        // Abdomen
        ctx.fillStyle = "#0d0612";
        ctx.strokeStyle = "#2a1a35";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-10, -15);
        ctx.lineTo(-30, -10);
        ctx.lineTo(-40, 0);   
        ctx.lineTo(-30, 10);
        ctx.lineTo(-10, 15);
        ctx.fill();
        ctx.stroke();

        // Thorax
        ctx.fillStyle = "#1a0e21";
        ctx.beginPath();
        ctx.moveTo(0, -18);
        ctx.lineTo(15, -12);
        ctx.lineTo(20, 0);
        ctx.lineTo(15, 12);
        ctx.lineTo(0, 18);
        ctx.lineTo(-10, 10);
        ctx.lineTo(-10, -10);
        ctx.closePath();
        ctx.fill();
        
        ctx.strokeStyle = "#3c2547";
        ctx.beginPath();
        ctx.moveTo(-5, -15); ctx.lineTo(10, -10);
        ctx.moveTo(-5, 15);  ctx.lineTo(10, 10);
        ctx.stroke();

        // Head
        ctx.fillStyle = "#25142e";
        ctx.beginPath();
        ctx.moveTo(20, -8);
        ctx.lineTo(28, -10);
        ctx.lineTo(32, -4);
        ctx.lineTo(32, 4);
        ctx.lineTo(28, 10);
        ctx.lineTo(20, 8);
        ctx.fill();

        // --- 4. STATIC SHARP MANDIBLES ---
        ctx.fillStyle = "#1a1a1a"; 
        ctx.strokeStyle = "#604070"; 
        ctx.lineWidth = 1;

        // TOP MANDIBLE (Left)
        ctx.beginPath();
        ctx.moveTo(32, -5);         
        ctx.lineTo(38, -10); 
        ctx.lineTo(36, -12); 
        ctx.lineTo(55, -18); // Sharp tip
        ctx.lineTo(50, -8);  
        ctx.lineTo(32, -2);          
        ctx.fill();
        ctx.stroke();

        // BOTTOM MANDIBLE (Right)
        ctx.beginPath();
        ctx.moveTo(32, 5);
        ctx.lineTo(38, 10);
        ctx.lineTo(36, 12);
        ctx.lineTo(55, 18); // Sharp tip
        ctx.lineTo(50, 8);
        ctx.lineTo(32, 2);
        ctx.fill();
        ctx.stroke();

        // Eyes
        ctx.fillStyle = "#ff0044";
        ctx.shadowBlur = 8; 
        ctx.shadowColor = "#ff0044";
        ctx.beginPath(); ctx.arc(26, -7, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(26, 7, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;

        // --- 5. GLOWING VENTS ---
        let ventGlow = 0.5 + Math.sin(this.pulsePhase * 3) * 0.5;

        ctx.save();
        ctx.translate(-20, -6);
        ctx.rotate(-0.2);
        ctx.shadowColor = `rgba(255, 50, 80, ${ventGlow})`;
        ctx.shadowBlur = 15;
        ctx.fillStyle = `rgba(255, 50, 80, ${0.5 + ventGlow * 0.5})`;
        ctx.beginPath();
        ctx.moveTo(0, 0); ctx.lineTo(10, -2); ctx.lineTo(0, -4); ctx.fill(); 
        ctx.restore();

        ctx.save();
        ctx.translate(-20, 6);
        ctx.rotate(0.2);
        ctx.shadowColor = `rgba(50, 180, 255, ${ventGlow})`;
        ctx.shadowBlur = 15;
        ctx.fillStyle = `rgba(50, 180, 255, ${0.5 + ventGlow * 0.5})`;
        ctx.beginPath();
        ctx.moveTo(0, 0); ctx.lineTo(10, 2); ctx.lineTo(0, 4); ctx.fill(); 
        ctx.restore();

        // Final Gloss
        ctx.fillStyle = "rgba(255,255,255,0.08)";
        ctx.beginPath();
        ctx.moveTo(5, -5); ctx.lineTo(15, -8); ctx.lineTo(10, 0); ctx.fill();

        ctx.restore(); 

        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class BossEnemy {
    constructor() {
        this.col = COLS - 1;
        this.row = Math.floor(ROWS / 2);
        this.x   = this.col * CELL_SIZE + CELL_SIZE / 2;
        this.y   = this.row * CELL_SIZE + CELL_SIZE / 2;

        this.radius = 45;
        this.speed  = 0.4;
        this.maxHp  = 1000 * difficultyMultiplier * (wave * 0.3);
        this.hp     = this.maxHp;
        this.damage = 9999;
        this.bounty = 500;
        this.active = true;

        this.vx = 0; this.vy = 0;
        this.angle     = Math.PI;
        this.animTimer = 0;

        this.armorColor = "#5c5443";

        // Pre-compute constants used every frame
        this._baseSq      = (this.radius + 30) * (this.radius + 30);
        this._crushSq     = (this.radius + 15) * (this.radius + 15);
        this._gridRadius  = Math.ceil(this.radius / CELL_SIZE);
        this._halfCell    = CELL_SIZE / 2;
        this._TWO_PI      = Math.PI * 2;
    }

    update(dt) {
        const targetX = playerBase.x * CELL_SIZE + CELL_SIZE;
        const targetY = playerBase.y * CELL_SIZE + CELL_SIZE;
        const dx = targetX - this.x;
        const dy = targetY - this.y;
        const distSq = dx * dx + dy * dy;

        if (distSq > 1) {
            const invDist = 1 / Math.sqrt(distSq);
            this.x += dx * invDist * this.speed;
            this.y += dy * invDist * this.speed;

            let diff = Math.atan2(dy, dx) - this.angle;
            if (diff < -Math.PI) diff += this._TWO_PI;
            else if (diff > Math.PI) diff -= this._TWO_PI;
            this.angle += diff * 0.04;
        }

        // Wall crush â€” every other frame only
        if (gameFrame % 2 === 0) {
            const cx = Math.floor(this.x / CELL_SIZE);
            const cy = Math.floor(this.y / CELL_SIZE);
            const gr = this._gridRadius;
            const cSq = this._crushSq;
            const hc = this._halfCell;
            const tp = this._TWO_PI;

            for (let i = -gr; i <= gr; i++) {
                const col = cx + i;
                if (col < 0 || col >= COLS) continue;
                for (let j = -gr; j <= gr; j++) {
                    const row = cy + j;
                    if (row < 0 || row >= ROWS) continue;
                    const cell = grid[col][row];
                    if (!cell.wall) continue;
                    const cellX = col * CELL_SIZE + hc;
                    const cellY = row * CELL_SIZE + hc;
                    const wx = this.x - cellX;
                    const wy = this.y - cellY;
                    if (wx * wx + wy * wy < cSq) {
                        cell.wall = false;
                        cell.occupied = false;
                        for (let k = 0; k < 3; k++) {
                            particles.push({
                                x: cellX, y: cellY,
                                vx: (Math.random() - 0.5) * 10,
                                vy: (Math.random() - 0.5) * 10,
                                life: 60, color: this.armorColor,
                                size: Math.random() * 4
                            });
                        }
                    }
                }
            }
        }

        if (distSq < this._baseSq) {
            this.hp = 0;
            takeDamage(this.damage);
        }

        this.animTimer += 0.08;
    }

    draw() {
        const TWO_PI = this._TWO_PI;

        // Body (rotated)
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        const s  = 2.8;
        const s2 = 2 * s, s3 = 3 * s, s4 = 4 * s, s5 = 5 * s,
              s6 = 6 * s, s7 = 7 * s, s8 = 8 * s, s9 = 9 * s,
              s10 = 10 * s, s11 = 11 * s, s12 = 12 * s, s13 = 13 * s,
              s14 = 14 * s, s22 = 22 * s;

        const chitinDark  = "#120b05";
        const chitinMid   = "#3d3215";
        const chitinLight = "#6e5d38";
        const bone        = "#8c8260";
        const joint       = "#0f0505";
        const ventGlow    = "rgba(255, 100, 0, 0.8)";

        const breathe   = Math.sin(this.animTimer * 0.8);
        const walkCycle = this.animTimer;

        const drawLeg = (ox, oy, restX, restY, phase, side) => {
            const cycle  = walkCycle + phase;
            const lift   = Math.max(0, Math.sin(cycle));
            const stride = Math.cos(cycle);
            const sx = ox * s, sy = oy * s;
            const fx = sx + restX * s + stride * 5 * s;
            const fy = sy + restY * s + lift * -4 * side * s;
            const kx = (sx + fx) / 2 - s2;
            const ky = (sy + fy) / 2 + side * s6;

            ctx.lineCap = "round";
            ctx.strokeStyle = chitinMid; ctx.lineWidth = 3.5 * s;
            ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(kx, ky); ctx.stroke();

            ctx.strokeStyle = bone; ctx.lineWidth = s2;
            ctx.beginPath(); ctx.moveTo(kx, ky); ctx.lineTo(fx, fy); ctx.stroke();

            ctx.fillStyle = joint;
            ctx.beginPath(); ctx.arc(kx, ky, 2.2 * s, 0, TWO_PI); ctx.fill();

            ctx.fillStyle = bone;
            ctx.beginPath();
            ctx.moveTo(kx, ky);
            ctx.lineTo(kx - s, ky - side * s4);
            ctx.lineTo(kx + s, ky);
            ctx.fill();

            ctx.fillStyle = "#5e0e0e";
            ctx.beginPath(); ctx.arc(fx, fy, 0.8 * s, 0, TWO_PI); ctx.fill();
        };

        // Rear legs (dimmed)
        ctx.filter = "brightness(0.6)";
        drawLeg(-6, -3, -8, -8, 0, -1);
        drawLeg(-6,  3, -8,  8, Math.PI, 1);
        ctx.filter = "none";

        // Abdomen
        const sacPulse = 1 + breathe * 0.05;
        ctx.beginPath();
        ctx.moveTo(-4*s, -5*s);
        ctx.bezierCurveTo(-15*s, -12*s*sacPulse, -32*s, -s9, -38*s, 0);
        ctx.bezierCurveTo(-32*s,  s9,  -15*s,  12*s*sacPulse, -4*s, 5*s);
        ctx.lineTo(-4*s, -5*s);

        ctx.save();
        ctx.clip();

        const sacGrad = ctx.createRadialGradient(-20*s, 0, s2, -20*s, 0, s22);
        sacGrad.addColorStop(0,   "#ff5500");
        sacGrad.addColorStop(0.6, "#3b2010");
        sacGrad.addColorStop(1,   "#1a0f05");
        ctx.fillStyle = sacGrad;
        ctx.fill();

        ctx.strokeStyle = "rgba(0,0,0,0.5)"; ctx.lineWidth = s2;
        for (let i = 1; i <= 4; i++) {
            const rx = -s8 - i * s6;
            ctx.beginPath();
            ctx.moveTo(rx, -s10);
            ctx.quadraticCurveTo(rx - s4, 0, rx, s10);
            ctx.stroke();
        }
        ctx.restore();

        // Spinal plates
        ctx.fillStyle = chitinDark;
        ctx.strokeStyle = "rgba(110, 93, 56, 0.5)"; ctx.lineWidth = 0.5;
        for (let i = 0; i < 6; i++) {
            const spX = -s8 - i * 5 * s;
            const h   = s4 * (1 - i / 7);
            ctx.beginPath();
            ctx.moveTo(spX + s3, 0); ctx.lineTo(spX, -h);
            ctx.lineTo(spX - s3, 0); ctx.lineTo(spX,  h);
            ctx.fill();
            ctx.beginPath(); ctx.moveTo(spX, -h); ctx.lineTo(spX - s2, 0); ctx.stroke();
        }

        // Front legs
        drawLeg(-2, -4, -4, -11, Math.PI * 0.5, -1);
        drawLeg(-2,  4, -4,  11, Math.PI * 1.5,  1);
        drawLeg( 4, -4,  4, -10, 0, -1);
        drawLeg( 4,  4,  4,  10, Math.PI, 1);
        drawLeg( 8, -3, 10,  -5, Math.PI, -1);
        drawLeg( 8,  3, 10,   5, 0, 1);

        // Thorax
        const thoraxGrad = ctx.createRadialGradient(0, 0, s, 0, 0, s14);
        thoraxGrad.addColorStop(0, chitinMid);
        thoraxGrad.addColorStop(1, chitinDark);
        ctx.fillStyle = thoraxGrad;
        ctx.beginPath();
        ctx.moveTo(s10, -5*s); ctx.lineTo(s14, -s2);
        ctx.lineTo(s14,  s2);  ctx.lineTo(s10,  5*s);
        ctx.lineTo(-4*s, s7);  ctx.lineTo(-s8,  0);
        ctx.lineTo(-4*s, -s7); ctx.fill();

        ctx.fillStyle = chitinDark; ctx.strokeStyle = chitinLight; ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(s8, 0); ctx.lineTo(s2, -3.5*s);
        ctx.lineTo(-s6, 0); ctx.lineTo(s2, 3.5*s);
        ctx.closePath(); ctx.fill(); ctx.stroke();

        ctx.fillStyle = ventGlow;
        for (let i = 0; i < 3; i++) {
            const vx = i * 2.5 * s;
            ctx.beginPath(); ctx.ellipse(vx, -5.5*s, 0.6*s, 1.5*s,  0.4, 0, TWO_PI); ctx.fill();
            ctx.beginPath(); ctx.ellipse(vx,  5.5*s, 0.6*s, 1.5*s, -0.4, 0, TWO_PI); ctx.fill();
        }

        // Head
        ctx.save();
        ctx.translate(13 * s, 0);

        ctx.fillStyle = "#000000";
        ctx.beginPath(); ctx.arc(0, 0, 4.5 * s, 0, TWO_PI); ctx.fill();

        const innerTwitch = Math.sin(this.animTimer * 8) * 0.3;
        for (let dir = -1; dir <= 1; dir += 2) {
            ctx.save();
            ctx.translate(2.5 * s, dir * s);
            ctx.scale(1, dir);
            ctx.rotate(innerTwitch);
            ctx.fillStyle = "#2e1a1a";
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(s2, -0.5*s, s3, 0.5*s);
            ctx.lineTo(2.5*s, 0.8*s); ctx.lineTo(0, 0.5*s);
            ctx.fill();
            ctx.fillStyle = "#ff0000";
            ctx.beginPath(); ctx.arc(s3, 0.5*s, 0.2*s, 0, TWO_PI); ctx.fill();
            ctx.restore();
        }

        const biteOpen = 0.2 + Math.sin(this.animTimer * 1.5) * 0.15;
        const mGrad = ctx.createLinearGradient(0, 0, s14, 0);
        mGrad.addColorStop(0,   "#1a1616");
        mGrad.addColorStop(0.5, "#4a0a0a");
        mGrad.addColorStop(1,   "#000000");

        const drawNightmareMandible = (scaleY) => {
            ctx.save();
            ctx.scale(1, scaleY);
            ctx.rotate(-biteOpen);
            ctx.fillStyle = mGrad; ctx.strokeStyle = "#0d0505"; ctx.lineWidth = 0.3 * s;
            ctx.beginPath();
            ctx.moveTo(0, -s2);
            ctx.bezierCurveTo(s3, -3.5*s, s5, -3.5*s, s7, -s2);
            ctx.lineTo(7.2*s, -2.2*s);
            ctx.bezierCurveTo(s9, -s3, s12, -1.5*s, s14, 0.5*s);
            ctx.lineTo(s13, 0.8*s); ctx.lineTo(s11, 0);
            ctx.lineTo(10.5*s, 0.8*s); ctx.lineTo(s9, 0.2*s);
            ctx.lineTo(s8, 1.2*s);    ctx.lineTo(s6, 0.5*s);
            ctx.lineTo(s5, 1.5*s);    ctx.lineTo(0, 1.5*s);
            ctx.closePath(); ctx.fill(); ctx.stroke();
            ctx.strokeStyle = "rgba(0,0,0,0.5)"; ctx.lineWidth = 0.15 * s;
            ctx.beginPath();
            ctx.moveTo(s2, -s); ctx.quadraticCurveTo(s7, -1.5*s, s12, 0.2*s); ctx.stroke();
            ctx.restore();
        };

        ctx.save(); ctx.translate(s3, -1.5*s); drawNightmareMandible( 1); ctx.restore();
        ctx.save(); ctx.translate(s3,  1.5*s); drawNightmareMandible(-1); ctx.restore();

        // Head carapace
        const skullGrad = ctx.createRadialGradient(s2, 0, s, s4, 0, s8);
        skullGrad.addColorStop(0, "#2a2222");
        skullGrad.addColorStop(1, "#0a0a0a");
        ctx.fillStyle = skullGrad;
        ctx.beginPath();
        ctx.moveTo(-s2, -s4);
        ctx.bezierCurveTo(s3, -4.5*s, s6, -s3, s8, 0);
        ctx.bezierCurveTo(s6,  s3,    s3,  4.5*s, -s2, s4);
        ctx.lineTo(-2.5*s, 0); ctx.fill();

        // Eyes
        const drawEye = (x, y, r) => {
            const ex = x * s, ey = y * s;
            ctx.fillStyle = "#000";
            ctx.beginPath(); ctx.arc(ex, ey, r * s, 0, TWO_PI); ctx.fill();
            ctx.fillStyle = "#aaff00";
            ctx.beginPath(); ctx.arc(ex, ey, r * 0.6 * s, 0, TWO_PI); ctx.fill();
        };
        drawEye(4, -2, 1); drawEye(4, 2, 1);
        drawEye(2.5, -3.5, 0.6); drawEye(2.5, 3.5, 0.6);

        ctx.restore(); // head
        ctx.restore(); // body

        // Health bar (unrotated)
        ctx.save();
        ctx.translate(this.x, this.y);

        const barY = -(20 * s);
        const barW = 100;
        const hpPct = this.hp / this.maxHp;

        ctx.fillStyle = "rgba(0,0,0,0.8)";
        ctx.beginPath(); ctx.roundRect(-50, barY, barW, 8, 3); ctx.fill();

        const barGrad = ctx.createLinearGradient(-50, 0, 50, 0);
        barGrad.addColorStop(0, "#ff3300");
        barGrad.addColorStop(1, "#ccff00");
        ctx.fillStyle = barGrad;
        ctx.beginPath();
        ctx.roundRect(-49, barY + 1, Math.max(0, 98 * hpPct), 6, 2);
        ctx.fill();

        ctx.fillStyle = "#fff";
        ctx.font = "bold 12px Arial";
        ctx.textAlign = "center";
        ctx.fillText("HIVE QUEEN", 0, barY - 5);

        ctx.restore();
    }
}

function spawnBoss() {
    let boss = new BossEnemy();
    enemies.push(boss);
    
    // Optional: Announcement text
    currentAnnouncement = {
        text: "WARNING: BOSS DETECTED",
        life: 180,
        color: "#ff0000",
        update: function(dt) { this.life--; if(this.life<=0) this.active=false; },
        draw: function() {
            if(this.life > 0) {
                ctx.fillStyle = this.color;
                ctx.font = "bold 40px Segoe UI";
                ctx.textAlign = "center";
                ctx.fillText(this.text, canvas.width/2, 100);
            }
        },
        active: true
    };
}

class ShielderEnemy {
    constructor() {
        // --- SPAWN POSITION ---
        let boundW = (typeof VIRTUAL_WIDTH !== 'undefined') ? VIRTUAL_WIDTH : canvas.width;
        let boundH = (typeof VIRTUAL_HEIGHT !== 'undefined') ? VIRTUAL_HEIGHT : canvas.height;

        this.x = boundW + 20; 
        let playableHeight = boundH - (CELL_SIZE * 2);
        this.y = CELL_SIZE + (Math.random() * playableHeight);

        // --- STATS (Maintained Shielder Stats) ---
        this.radius = 16;            
        this.speed = 0.5;            
        this.hp = 400 + (wave * 25); 
        this.maxHp = this.hp;
        this.bounty = 40;
        
        // Initial Velocity
        this.vx = -0.5; 
        this.vy = 0;

        // --- COOLDOWNS ---
        this.attackCooldown = 0; 
        this.wallDamageCooldown = 0;

        // --- SHIELD ABILITY ---
        this.shieldRadius = 140;
        this.isShieldActive = true;
        
        // Timer (Frames)
        this.frameTimer = 0;
        this.onDuration = 300; 
        this.offDuration = 180;
        this.totalCycle = this.onDuration + this.offDuration;

        // --- VISUALS (Stag Beetle) ---
        this.angle = Math.PI; 
        this.animTimer = Math.random() * 10; 
        
        this.colors = {
            shell: "#1a1a2e", highlight: "#303045", core: "#00d2ff", legs: "#111"
        };
    }

    update(dt) {
        // --- 1. SHIELD TIMER LOGIC ---
        this.frameTimer+=dt;
        if (this.frameTimer >= this.totalCycle) this.frameTimer = 0;
        this.isShieldActive = (this.frameTimer < this.onDuration);

        // --- 2. MOVEMENT & WALL LOGIC (Updated to match your snippet) ---
        
        // Animation speed
        this.animTimer += 0.3 * dt; 

        let col = Math.floor(this.x / CELL_SIZE);
        let row = Math.floor(this.y / CELL_SIZE);

        let isBlocked = sharedMovement(this, col, row);
        
        // Wall Destruction Logic (Matches provided snippet)
        if (isBlocked) {
            sharedDestroyWalls(this, col, row, 2, 10);
        }

        if (Math.abs(this.vx) > 0.1 || Math.abs(this.vy) > 0.1) {
            this.angle = Math.atan2(this.vy, this.vx);
        }

        this.x += this.vx;
        this.y += this.vy;

        // Separation & Collision
        if (typeof enemies !== 'undefined') separate(this, enemies, 0.5); 
        if (typeof allies !== 'undefined') separate(this, allies, 0.8);
        
        // This ensures they don't walk through walls
        resolveWallCollision(this);

        // Base Damage Logic
        if (this.attackCooldown > 0) this.attackCooldown -= dt;
        
        if (typeof playerBase !== 'undefined') {
            let dx = this.x - (playerBase.x * CELL_SIZE + CELL_SIZE/2);
            let dy = this.y - (playerBase.y * CELL_SIZE + CELL_SIZE/2);
            if (Math.hypot(dx, dy) < 30) { 
                takeDamage(5); // Damage the player
                this.hp = 0;   // Suicide attack
            }
        }

        // --- 3. SHIELD EFFECT ---
        if (this.isShieldActive && typeof enemies !== 'undefined') {
            for (let e of enemies) {
                if (e === this) continue; 
                if (Math.hypot(e.x - this.x, e.y - this.y) < this.shieldRadius) {
                    e.isInvincible = true;
                    // Visual link
                    if (Math.random() < 0.05) {
                         particles.push({
                            x: e.x, y: e.y, 
                            vx: (this.x - e.x)*0.02, vy: (this.y - e.y)*0.02,
                            life: 15, color: this.colors.core, size: 1
                        });
                    }
                }
            }
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // --- DRAW SHIELD ---
        if (this.isShieldActive) {
            ctx.beginPath();
            ctx.arc(0, 0, this.shieldRadius, 0, Math.PI*2);
            ctx.strokeStyle = "rgba(0, 210, 255, 0.5)";
            ctx.lineWidth = 2;
            ctx.setLineDash([20, 15]);
            ctx.stroke();
            ctx.setLineDash([]); 
            ctx.fillStyle = "rgba(0, 210, 255, 0.05)";
            ctx.fill();
        } else {
            let pct = (this.frameTimer - this.onDuration) / this.offDuration; 
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI * 2 * (1-pct));
            ctx.strokeStyle = "#ff4444";
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        // --- DRAW BODY (Maintained Stag Beetle Visuals) ---
        ctx.rotate(this.angle);

        // 1. LEGS
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        const drawLeg = (ox, oy, restX, restY, phase, side) => {
            let cycle = this.animTimer + phase;
            let footX = ox + restX + (Math.cos(cycle) * 3);
            let footY = oy + restY + (Math.abs(Math.sin(cycle)) * -2.0 * side);
            let kneeX = (ox + footX) / 2 - 2;
            let kneeY = (oy + footY) / 2 + (side * 6); 

            ctx.strokeStyle = "#000"; ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(kneeX, kneeY); ctx.lineTo(footX, footY); ctx.stroke();
            ctx.strokeStyle = "#333"; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(kneeX, kneeY); ctx.lineTo(footX, footY); ctx.stroke();
            ctx.fillStyle = this.colors.core; ctx.beginPath(); ctx.arc(kneeX, kneeY, 1.5, 0, Math.PI*2); ctx.fill();
        };

        drawLeg(4, -5,  4, -10, 0, -1);
        drawLeg(4,  5,  4,  10, Math.PI, 1);
        drawLeg(-2, -6, -2, -12, Math.PI, -1);
        drawLeg(-2,  6, -2,  12, 0, 1);
        drawLeg(-8, -5, -6, -10, 0, -1);
        drawLeg(-8,  5, -6,  10, Math.PI, 1);

        // 2. SEGMENTED BODY
        ctx.fillStyle = this.colors.shell;
        ctx.strokeStyle = this.colors.highlight;
        ctx.lineWidth = 2;

        // Rear
        ctx.beginPath(); ctx.moveTo(-6, -5); ctx.lineTo(-14, -3); ctx.lineTo(-18, 0); ctx.lineTo(-14, 3); ctx.lineTo(-6, 5); ctx.fill(); ctx.stroke();
        // Mid
        ctx.beginPath(); ctx.moveTo(2, -8); ctx.lineTo(-8, -7); ctx.lineTo(-10, 0); ctx.lineTo(-8, 7); ctx.lineTo(2, 8); ctx.fill(); ctx.stroke();
        // Vents
        ctx.fillStyle = "#111"; ctx.beginPath(); ctx.moveTo(-4, -4); ctx.lineTo(-2, -4); ctx.lineTo(-2, 4); ctx.lineTo(-4, 4); ctx.fill(); ctx.fillStyle = this.colors.shell; 
        // Front
        ctx.beginPath(); ctx.moveTo(10, -5); ctx.lineTo(8, -11); ctx.lineTo(0, -9); ctx.lineTo(-2, -6); ctx.lineTo(-2, 6); ctx.lineTo(0, 9); ctx.lineTo(8, 11); ctx.lineTo(10, 5); ctx.fill(); ctx.stroke();

        // 3. CORE
        let coreColor = this.isShieldActive ? this.colors.core : "#444";
        ctx.shadowBlur = this.isShieldActive ? 15 : 0;
        ctx.shadowColor = coreColor;
        ctx.fillStyle = coreColor;
        ctx.beginPath(); ctx.moveTo(2, -4); ctx.lineTo(7, 0); ctx.lineTo(2, 4); ctx.lineTo(-3, 0); ctx.fill();
        ctx.shadowBlur = 0; 

        // 4. HEAD
        ctx.fillStyle = "#0a0a10"; 
        ctx.beginPath();
        ctx.moveTo(8, -4); ctx.quadraticCurveTo(16, -8, 22, -3); ctx.lineTo(18, -1); ctx.quadraticCurveTo(14, -4, 8, -2);
        ctx.moveTo(8, 4); ctx.quadraticCurveTo(16, 8, 22, 3); ctx.lineTo(18, 1); ctx.quadraticCurveTo(14, 4, 8, 2); 
        ctx.fill();

        ctx.fillStyle = this.colors.shell;
        ctx.strokeStyle = this.colors.highlight;
        ctx.beginPath();
        ctx.moveTo(6, -6); ctx.lineTo(14, -3); ctx.lineTo(14, 3); ctx.lineTo(6, 6);
        ctx.fill(); ctx.stroke();

        ctx.fillStyle = "#ff0044"; 
        ctx.shadowBlur = 5; ctx.shadowColor = "#ff0044";
        ctx.beginPath(); ctx.moveTo(10, -5); ctx.lineTo(12, -4); ctx.lineTo(12, -2); ctx.lineTo(10, -3); ctx.fill();
        ctx.beginPath(); ctx.moveTo(10, 5); ctx.lineTo(12, 4); ctx.lineTo(12, 2); ctx.lineTo(10, 3); ctx.fill();
        ctx.shadowBlur = 0;

        ctx.restore();

        // --- HEALTH BAR ---
        drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class SwordTroop {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.radius = 11; 
        this.type = "SWORD_ALLY";
        
        // STATS
        this.hp = 250; this.maxHp = 250; 
        this.range = 45; 
        this.damage = 50 + (hasSkill('sword_dmg') ? 20 : 0); 
        this.lifeTimer = 1800; // 30s

        // MOVEMENT
        this.speed = 2.2 * (hasSkill('sword_move_spd') ? 1.2 : 1); 
        this.vx = 0; this.vy = 0;
        this.friction = 0.12;
        this.angle = 0; 

        // ANIMATION STATE
        this.cooldown = 0;
        this.maxCooldown = 50 * (hasSkill('sword_atk_spd') ? 0.85 : 1); 
        this.swingState = "IDLE"; 
        this.swingProgress = 0;
        
        // Animation Variables
        this.swordAngle = 0.5; 
        this.bodyLean = 0; 
        this.impactAlpha = 0;

        // AI VARS
        this.pathTimer = Math.random() * 30;
        this.pathRefreshRate = 20; 
        this.currentPath = [];
        this.nodeReachThreshold = 15;
        this.target = null;
        this.walkCycle = 0;
    }

    update(dt) {
        this.lifeTimer--;
        if (this.lifeTimer <= 0) this.hp = 0;

        // --- TARGETING ---
        if (!this.target || this.target.hp <= 0 || Math.random() < 0.05) {
            let nearest = null;
            let minDist = Infinity;
            for (let e of enemies) {
                let d = (e.x - this.x)**2 + (e.y - this.y)**2;
                if (d < minDist) { minDist = d; nearest = e; }
            }
            this.target = nearest;
        }

        let moving = false;

        if (this.target) {
            let dx = this.target.x - this.x;
            let dy = this.target.y - this.y;
            let distToTarget = Math.hypot(dx, dy);

            // COMBAT
            if (distToTarget < this.range) {
                this.vx *= 0.5; this.vy *= 0.5;
                this.angle = Math.atan2(dy, dx);

                if (this.cooldown <= 0 && this.swingState === "IDLE") {
                    this.swingState = "LIFT";
                    this.swingProgress = 0;
                    this.cooldown = this.maxCooldown;
                }
            }
            // MOVEMENT
            else {
                let moveX = this.target.x;
                let moveY = this.target.y;
                let usingPath = false;
                let canSee = typeof hasLineOfSight === 'function' ? hasLineOfSight(this.x, this.y, this.target.x, this.target.y) : true;

                if (!canSee && typeof findPath === 'function') {
                    this.pathTimer--;
                    if (this.pathTimer <= 0) {
                        this.currentPath = findPath(this, this.target);
                        this.pathTimer = this.pathRefreshRate;
                    }
                    if (this.currentPath && this.currentPath.length > 0) {
                        let nextNode = this.currentPath[0];
                        moveX = nextNode.x;
                        moveY = nextNode.y;
                        usingPath = true;
                        if (Math.hypot(nextNode.x - this.x, nextNode.y - this.y) < this.nodeReachThreshold) this.currentPath.shift();
                    }
                }
                if (!usingPath && canSee) this.currentPath = [];

                let mdx = moveX - this.x;
                let mdy = moveY - this.y;
                let mDist = Math.hypot(mdx, mdy);

                if (mDist > 1) {
                    let dirX = mdx / mDist;
                    let dirY = mdy / mDist;
                    this.vx += (dirX * this.speed - this.vx) * this.friction;
                    this.vy += (dirY * this.speed - this.vy) * this.friction;
                    moving = true;
                    if (Math.hypot(this.vx, this.vy) > 0.5) this.angle = Math.atan2(this.vy, this.vx);
                }
            }
        }

        if (!moving) { this.vx *= 0.8; this.vy *= 0.8; }
        if (this.cooldown > 0) this.cooldown--;
        if (this.impactAlpha > 0) this.impactAlpha -= 0.15; 

        if (moving) this.walkCycle += 0.35; else this.walkCycle = 0;

        this.updateNewAnimation();

        this.x += this.vx * dt;
        this.y += this.vy * dt;

        if(typeof separate === 'function') { separate(this, allies, 0.6); separate(this, enemies, 0.4); }
        if(typeof resolveWallCollision === 'function') resolveWallCollision(this);
    }

    updateNewAnimation() {
        let baseAngle = 0.4; 

        if (this.swingState !== "IDLE") {
            this.swingProgress++;

            // --- PHASE 1: LIFT (Two-handed wind up) ---
            if (this.swingState === "LIFT") {
                let duration = 12;
                let t = this.swingProgress / duration;
                let ease = t * t; 
                
                this.swordAngle = baseAngle - (ease * 2.6); 
                this.bodyLean = -3 * ease;

                if (this.swingProgress >= duration) {
                    this.swingState = "CHOP";
                    this.swingProgress = 0;
                }
            }
            // --- PHASE 2: CHOP ---
            else if (this.swingState === "CHOP") {
                let duration = 6;
                let t = this.swingProgress / duration;
                
                this.swordAngle = -2.2 + (t * 4.2); 
                this.bodyLean = -3 + (t * 8);

                if (this.swingProgress === 3) {
                     this.impactAlpha = 1.0;
                     if (this.target) {
                        let d = Math.hypot(this.target.x - this.x, this.target.y - this.y);
                        if (d < this.range + 15) {
                            this.target.hp -= this.damage;
                            if(typeof createParticles === 'function') {
                                createParticles(this.target.x, this.target.y, "#ffffff", 8);
                                createParticles(this.target.x, this.target.y, "#aa00ff", 6);
                            }
                            this.target.vx += Math.cos(this.angle) * 5;
                            this.target.vy += Math.sin(this.angle) * 5;
                        }
                    }
                }

                if (this.swingProgress >= duration) {
                    this.swingState = "RECOVER";
                    this.swingProgress = 0;
                }
            }
            // --- PHASE 3: RECOVER ---
            else if (this.swingState === "RECOVER") {
                let duration = 15;
                let t = this.swingProgress / duration;
                let ease = 1 - Math.pow(1 - t, 3);
                
                this.swordAngle = 2.0 - (ease * 1.6); 
                this.bodyLean = 5 * (1 - ease);

                if (this.swingProgress >= duration) {
                    this.swingState = "IDLE";
                    this.swordAngle = baseAngle;
                    this.bodyLean = 0;
                }
            }
        } else {
            this.bodyLean = 0;
            this.swordAngle = baseAngle + Math.sin(Date.now() / 250) * 0.05;
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // --- SHADOW ---
        ctx.fillStyle = "rgba(0,0,0,0.8)";
        ctx.beginPath();
        ctx.ellipse(-2 + (this.bodyLean * 0.5), 2, 11, 8, 0, 0, Math.PI*2);
        ctx.fill();

        // --- LEGS ---
        let leftLeg = Math.sin(this.walkCycle) * 5;
        let rightLeg = Math.sin(this.walkCycle + Math.PI) * 5;
        
        ctx.fillStyle = "#2a2a2a"; 
        ctx.beginPath(); ctx.arc(-4 + leftLeg + (this.bodyLean * 0.3), -5, 4, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(-4 + rightLeg + (this.bodyLean * 0.3), 5, 4, 0, Math.PI*2); ctx.fill();
        
        ctx.fillStyle = "#4a4a55"; 
        ctx.fillRect(-6 + leftLeg + (this.bodyLean * 0.3), -7, 6, 4);
        ctx.fillRect(-6 + rightLeg + (this.bodyLean * 0.3), 3, 6, 4);
        ctx.strokeStyle = "#888"; ctx.lineWidth = 0.5;
        ctx.strokeRect(-6 + leftLeg + (this.bodyLean * 0.3), -7, 6, 4);
        ctx.strokeRect(-6 + rightLeg + (this.bodyLean * 0.3), 3, 6, 4);

        // --- BODY ---
        ctx.save();
        ctx.translate(this.bodyLean, 0); 

        // Chest
        let chestGrad = ctx.createLinearGradient(-5, -5, 10, 5);
        chestGrad.addColorStop(0.0, "#666"); 
        chestGrad.addColorStop(0.4, "#222"); 
        chestGrad.addColorStop(1.0, "#444"); 
        
        ctx.fillStyle = chestGrad;
        ctx.beginPath();
        ctx.moveTo(-6, -7); ctx.lineTo(6, -7);
        ctx.lineTo(8, 0); ctx.lineTo(6, 7);
        ctx.lineTo(-6, 7);
        ctx.fill();
        ctx.strokeStyle = "#a0a0b0"; ctx.lineWidth = 1; ctx.stroke();

        // Shoulders
        let shoulderGrad = ctx.createRadialGradient(-2, -9, 0, 0, -7, 6);
        shoulderGrad.addColorStop(0, "#fff"); shoulderGrad.addColorStop(1, "#111");
        ctx.fillStyle = shoulderGrad;
        ctx.beginPath(); ctx.arc(0, -7, 5, 0, Math.PI*2); ctx.fill(); 
        ctx.beginPath(); ctx.arc(0, 7, 5, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#8899aa"; ctx.stroke(); ctx.beginPath(); ctx.arc(0, 7, 5, 0, Math.PI*2); ctx.stroke(); 

        // Head
        ctx.save();
        ctx.translate(2, 0); 
        ctx.fillStyle = "#222"; ctx.beginPath(); ctx.arc(0, 0, 5.5, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#aaa"; ctx.lineWidth = 1; ctx.stroke();
        ctx.fillStyle = "rgba(255,255,255,0.4)"; ctx.beginPath(); ctx.ellipse(-2, -2, 2, 1, Math.PI/-4, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#fff"; ctx.shadowColor = "#aa00ff"; ctx.shadowBlur = 10;
        ctx.beginPath(); ctx.fillRect(2, -3, 3, 6); ctx.shadowBlur = 0;
        ctx.restore();

        // --- TWO-HANDED SWORD GRIP ---
        ctx.save();
        ctx.translate(0, 0); // Rotate from center of body/shoulders
        ctx.rotate(this.swordAngle); 

        // 1. LEFT ARM (The supporting arm, underneath)
        // Reaches slightly shorter than the right arm
        ctx.fillStyle = "#222"; 
        ctx.fillRect(0, 4, 8, 4); // Arm segment
        ctx.strokeRect(0, 4, 8, 4);

        // 2. RIGHT ARM (The main arm, on top)
        // Reaches further out
        ctx.fillStyle = "#333"; 
        ctx.fillRect(0, -4, 11, 4); // Arm segment
        ctx.strokeRect(0, -4, 11, 4);

        // 3. HANDS (Gauntlets)
        // Left Hand (Closer to body)
        ctx.fillStyle = "#111"; 
        ctx.translate(8, 6); // Move to Left Hand pos
        ctx.beginPath(); ctx.arc(0, 0, 3.5, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = "#888"; ctx.stroke();
        
        // Right Hand (Further out)
        ctx.translate(4, -8); // Move relative to Left Hand to get to Right Hand pos
        ctx.fillStyle = "#111";
        ctx.beginPath(); ctx.arc(0, 0, 4, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = "#aaa"; ctx.stroke();

        // 4. THE SWORD (Held by both hands)
        // We are now at the Right Hand position.
        // Rotate 90 degrees so sword points out
        ctx.rotate(Math.PI / 2); 

        // Hilt (Extended for two hands)
        // Goes "down" (backwards) to reach the Left hand
        ctx.fillStyle = "#444";
        ctx.fillRect(-2, -4, 4, 16); // Longer handle
        ctx.fillStyle = "#888"; 
        ctx.fillRect(-4, 10, 8, 2); // Pommel (at the bottom/back)

        // --- SWOOSH TRAIL ---
        if (this.swingState === "CHOP") {
            ctx.save();
            ctx.beginPath();
            ctx.arc(-8, -6, 40, Math.PI, 0, false); 
            ctx.strokeStyle = "rgba(200, 150, 255, 0.5)";
            ctx.lineWidth = 12;
            ctx.lineCap = "round";
            ctx.shadowColor = "#d000ff";
            ctx.shadowBlur = 15;
            ctx.stroke();
            ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
            ctx.lineWidth = 4;
            ctx.stroke();
            ctx.restore();
        }

        // Blade
        ctx.shadowColor = "#d000ff"; ctx.shadowBlur = 15;
        let bladeGrad = ctx.createLinearGradient(0, -6, 0, -45);
        bladeGrad.addColorStop(0, "#ffffff"); bladeGrad.addColorStop(0.3, "#e0c0ff"); bladeGrad.addColorStop(1, "#8800ff");
        ctx.fillStyle = bladeGrad;
        ctx.beginPath();
        ctx.moveTo(-2, -6); ctx.lineTo(-2, -42); ctx.lineTo(0, -46); ctx.lineTo(2, -42); ctx.lineTo(2, -6);
        ctx.fill();
        ctx.shadowBlur = 0; 

        ctx.restore(); // End Arm/Sword Group
        ctx.restore(); // End Body
        
        // --- GROUND IMPACT FLASH ---
        if (this.impactAlpha > 0.01) {
            ctx.globalAlpha = this.impactAlpha;
            ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
            ctx.translate(30, 0); 
            ctx.beginPath();
            for(let i=0; i<8; i++) {
                let ang = (i/8)*Math.PI*2;
                let r = (i%2==0) ? 25 : 10;
                ctx.lineTo(Math.cos(ang)*r, Math.sin(ang)*r);
            }
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }

        ctx.restore(); // End Global

        // HP BAR
        if (this.hp < this.maxHp) {
            const barW = 24; const barH = 4;
            const barX = this.x - (barW / 2); const barY = this.y - 28;
            const pct = Math.max(0, this.hp / this.maxHp);
            const hue = (pct * pct) * 120; 
            ctx.fillStyle = "#000"; ctx.fillRect(barX, barY, barW, barH);
            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`; ctx.fillRect(barX, barY, barW * pct, barH);
            ctx.strokeStyle = "#fff"; ctx.lineWidth = 1; ctx.strokeRect(barX, barY, barW, barH);
        }
    }
}

class ShieldSoldier {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.radius = 15; 
        this.type = "SHIELD_ALLY";
        
        // --- STATS ---
        this.hp = 600 + (hasSkill('shield_hp') ? 200 : 0);      
        this.maxHp = 600 + (hasSkill('shield_hp') ? 200 : 0);
        this.range = 45;     
        this.damage = 15;   
        this.lifeTimer = 1800; 

        // --- MOVEMENT ---
        this.speed = 1.6;    
        this.vx = 0; this.vy = 0;
        this.friction = 0.12;
        this.angle = 0;

        // --- COMBAT / ANIMATION ---
        this.cooldown = 0;
        this.maxCooldown = 50; 
        this.pushState = "IDLE"; 
        this.pushProgress = 0;
        this.shieldOffset = 18; 

        // --- AI VARS ---
        this.pathTimer = Math.random() * 30; 
        this.pathRefreshRate = 30; 
        this.currentPath = [];
        this.nodeReachThreshold = 15; 
        
        // --- VISUAL PALETTE ---
        this.walkCycle = 0;
        this.colors = {
            armorDark:  "#1c2630", 
            armorLight: "#2e3d4d", 
            vest:       "#111820", 
            skin:       "#eebb99",
            energyCore: "rgba(0, 220, 255, 0.4)",
            energyEdge: "#00ffff",
            emitter:    "#111"
        };
    }

    update(dt) {
        this.lifeTimer--;
        if (this.lifeTimer <= 0) this.hp = 0;

        // --- TARGETING ---
        let nearest = null;
        let minDist = Infinity;
        if (typeof enemies !== 'undefined') {
            for (let e of enemies) {
                let d = (e.x - this.x)**2 + (e.y - this.y)**2;
                if (d < minDist) { minDist = d; nearest = e; }
            }
        }
        
        let moving = false;

        if (nearest) {
            let distToEnemy = Math.sqrt(minDist);
            let canSeeEnemy = typeof hasLineOfSight === 'function' ? hasLineOfSight(this.x, this.y, nearest.x, nearest.y) : true;

            // 1. COMBAT: Stop and Bash if closest enemy is in range
            if (distToEnemy < this.range && canSeeEnemy) {
                this.vx *= 0.5; this.vy *= 0.5;
                this.angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);

                if (this.cooldown <= 0 && this.pushState === "IDLE") {
                    this.pushState = "WINDUP";
                    this.pushProgress = 0;
                    this.cooldown = this.maxCooldown;
                }
            } 
            // 2. MOVEMENT (Pathfinding)
            else {
                let targetX = nearest.x;
                let targetY = nearest.y;
                let usingPath = false;

                if (!canSeeEnemy && typeof findPath === 'function') {
                    this.pathTimer--;
                    if (this.pathTimer <= 0) {
                        this.currentPath = findPath(this, nearest);
                        this.pathTimer = this.pathRefreshRate;
                    }
                    if (this.currentPath && this.currentPath.length > 0) {
                        let nextNode = this.currentPath[0];
                        targetX = nextNode.x;
                        targetY = nextNode.y;
                        usingPath = true;
                        if (Math.hypot(nextNode.x - this.x, nextNode.y - this.y) < this.nodeReachThreshold) {
                            this.currentPath.shift(); 
                        }
                    }
                }
                
                if (!usingPath && canSeeEnemy) this.currentPath = []; 

                let dx = targetX - this.x;
                let dy = targetY - this.y;
                let dist = Math.hypot(dx, dy);

                if (dist > 5) {
                    let dirX = dx / dist;
                    let dirY = dy / dist;
                    this.vx += (dirX * this.speed - this.vx) * this.friction;
                    this.vy += (dirY * this.speed - this.vy) * this.friction;
                    moving = true;
                    if (Math.hypot(this.vx, this.vy) > 0.1) this.angle = Math.atan2(this.vy, this.vx);
                }
            }
        } else {
            this.vx *= 0.8; this.vy *= 0.8;
        }

        if (this.cooldown > 0) this.cooldown--;
        if (moving) this.walkCycle += 0.3; else this.walkCycle = 0;
        
        this.updateAnimation(); 
        
        this.x += this.vx;
        this.y += this.vy;
        
        if(typeof separate === 'function') { separate(this, allies || [], 0.6); separate(this, enemies || [], 0.4); }
        if(typeof resolveWallCollision === 'function') resolveWallCollision(this);
    }

    updateAnimation() {
        if (this.pushState !== "IDLE") {
            this.pushProgress++;
            
            // --- WINDUP ---
            if (this.pushState === "WINDUP") {
                this.shieldOffset = 18 - (this.pushProgress / 10) * 10; 
                if (this.pushProgress >= 10) { this.pushState = "SLAM"; this.pushProgress = 0; }
            } 
            // --- SLAM (DAMAGE FRAME) ---
            else if (this.pushState === "SLAM") {
                this.shieldOffset = 8 + (this.pushProgress / 5) * 22; 
                
                // ** AOE DAMAGE LOGIC **
                if (this.pushProgress === 2) {
                    if (typeof enemies !== 'undefined') {
                        for (let e of enemies) {
                            // 1. Distance Check
                            let dx = e.x - this.x;
                            let dy = e.y - this.y;
                            let dist = Math.hypot(dx, dy);
                            
                            // Hit everything slightly further than normal range (Reach bonus)
                            if (dist < this.range + 35) {
                                
                                // 2. Angle Check (Are they in front?)
                                let angleToEnemy = Math.atan2(dy, dx);
                                let angleDiff = angleToEnemy - this.angle;
                                
                                // Normalize angle to -PI to PI to prevent wrapping errors
                                while (angleDiff <= -Math.PI) angleDiff += Math.PI * 2;
                                while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;

                                // If within ~60 degrees left/right (1.0 radians), HIT
                                if (Math.abs(angleDiff) < 1.0) {
                                    e.hp -= this.damage;
                                    // Knockback is applied based on Shield Facing, not relative angle
                                    // This pushes everyone uniformly away
                                    e.vx += Math.cos(this.angle) * 15;
                                    e.vy += Math.sin(this.angle) * 15;
                                }
                            }
                        }
                    }
                }
                
                if (this.pushProgress >= 8) { this.pushState = "RECOVER"; this.pushProgress = 0; }
            } 
            // --- RECOVER ---
            else if (this.pushState === "RECOVER") {
                this.shieldOffset = 30 - (this.pushProgress / 15) * 12;
                if (this.pushProgress >= 15) { this.pushState = "IDLE"; this.shieldOffset = 18; }
            }
        } else {
            this.shieldOffset = 18 + Math.sin(Date.now() / 300) * 0.5; 
        }
    }


    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // Legs
        let legL = Math.sin(this.walkCycle) * 5;
        let legR = Math.sin(this.walkCycle + Math.PI) * 5;
        ctx.fillStyle = "#111"; 
        ctx.beginPath(); ctx.roundRect(-6 + legL, -9, 6, 4, 2); ctx.fill();
        ctx.beginPath(); ctx.roundRect(-6 + legR, 5, 6, 4, 2); ctx.fill();
        ctx.fillStyle = this.colors.armorLight;
        ctx.beginPath(); ctx.arc(-4 + legL, -7, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(-4 + legR, 7, 2.5, 0, Math.PI*2); ctx.fill();

        // Body
        ctx.fillStyle = this.colors.armorDark;
        ctx.beginPath(); ctx.roundRect(-9, -11, 16, 22, 5); ctx.fill();
        ctx.fillStyle = this.colors.vest;
        ctx.fillRect(-5, -8, 9, 16);
        ctx.strokeStyle = "#333"; ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-4, -4); ctx.lineTo(3, -4);
        ctx.moveTo(-4, 0); ctx.lineTo(3, 0);
        ctx.moveTo(-4, 4); ctx.lineTo(3, 4);
        ctx.stroke();

        // Helmet
        ctx.fillStyle = this.colors.skin;
        ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI*2); ctx.fill();
        let helmGrad = ctx.createRadialGradient(-2, -2, 1, 0, 0, 8);
        helmGrad.addColorStop(0, this.colors.armorLight);
        helmGrad.addColorStop(1, this.colors.armorDark);
        ctx.fillStyle = helmGrad;
        ctx.beginPath(); ctx.arc(0, 0, 7.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#222"; 
        ctx.fillRect(-2, -8.5, 5, 2); ctx.fillRect(-2, 6.5, 5, 2);  
        ctx.fillStyle = "#111"; 
        ctx.beginPath(); ctx.roundRect(3, -5, 3, 10, 2); ctx.fill();
        ctx.fillStyle = "#0ff"; 
        ctx.globalAlpha = 0.6; ctx.fillRect(4, -3, 1, 3); ctx.globalAlpha = 1.0;

        // --- ARMS (Always Centered) ---
        let handleX = this.shieldOffset - 3;
        let handleY = 0; 

        // Right Arm
        ctx.save();
        ctx.translate(3, 10); 
        let rAngle = Math.atan2(handleY - 10, handleX - 3);
        let rDist = Math.hypot(handleX - 3, handleY - 10);
        ctx.rotate(rAngle);
        ctx.fillStyle = this.colors.vest;
        ctx.beginPath(); ctx.roundRect(0, -2, rDist/2, 4, 2); ctx.fill();
        ctx.fillStyle = this.colors.armorLight;
        ctx.beginPath(); ctx.roundRect(rDist/2, -2.5, rDist/2, 5, 2); ctx.fill();
        ctx.fillStyle = "#111";
        ctx.beginPath(); ctx.arc(rDist, 0, 3, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = this.colors.armorDark;
        ctx.beginPath(); ctx.arc(0, 0, 5.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = this.colors.armorLight;
        ctx.beginPath(); ctx.arc(0, 0, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.restore();

        // Left Arm
        ctx.save();
        ctx.translate(3, -10); 
        let lAngle = Math.atan2(handleY - (-10), handleX - 3);
        let lDist = Math.hypot(handleX - 3, handleY - (-10));
        ctx.rotate(lAngle);
        ctx.fillStyle = this.colors.vest;
        ctx.beginPath(); ctx.roundRect(0, -2, lDist/2, 4, 2); ctx.fill();
        ctx.fillStyle = this.colors.armorLight;
        ctx.beginPath(); ctx.roundRect(lDist/2, -2.5, lDist/2, 5, 2); ctx.fill();
        ctx.fillStyle = "#111";
        ctx.beginPath(); ctx.arc(lDist, 0, 3.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = this.colors.armorDark;
        ctx.beginPath(); ctx.arc(0, 0, 5.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = this.colors.armorLight;
        ctx.beginPath(); ctx.arc(0, 0, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.restore();

        // --- SHIELD ---
        ctx.save();
        ctx.translate(this.shieldOffset, 0);
        ctx.fillStyle = this.colors.emitter;
        ctx.fillRect(0, -22, 4, 44); 
        ctx.fillStyle = this.colors.energyEdge;
        ctx.fillRect(1, -21, 2, 2); 
        ctx.fillRect(1, 19, 2, 2); 
        ctx.fillStyle = "#222";
        ctx.fillRect(-4, -6, 4, 12); 

        let glowIntensity = (this.pushState === "SLAM") ? 20 : 8;
        let energyAlpha = (this.pushState === "SLAM") ? 0.7 : 0.35;

        ctx.shadowColor = this.colors.energyEdge;
        ctx.shadowBlur = glowIntensity;
        let eGrad = ctx.createLinearGradient(0, -25, 0, 25);
        eGrad.addColorStop(0, `rgba(0, 200, 255, ${energyAlpha/2})`);
        eGrad.addColorStop(0.5, `rgba(200, 255, 255, ${energyAlpha})`); 
        eGrad.addColorStop(1, `rgba(0, 200, 255, ${energyAlpha/2})`);
        ctx.fillStyle = eGrad;
        ctx.strokeStyle = this.colors.energyEdge;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(4, -22);
        ctx.quadraticCurveTo(8, 0, 4, 22); 
        ctx.lineTo(2, 22);
        ctx.quadraticCurveTo(6, 0, 2, -22); 
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.shadowBlur = 0; 
        ctx.strokeStyle = "rgba(100, 255, 255, 0.3)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        for(let i = -16; i < 16; i+=8) {
             ctx.moveTo(3, i); ctx.lineTo(7, i+4);
             ctx.moveTo(3, i); ctx.lineTo(7, i-4);
        }
        ctx.stroke();
        ctx.restore(); 

        ctx.restore(); 

        if (typeof drawHealth === 'function') drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class BardTroop {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.radius = 12;
        this.color = "#d633ff"; 
        this.hp = 100 + (hasSkill('bard_durability') ? 100 : 0);
        this.maxHp = 100 + (hasSkill('bard_durability') ? 100 : 0);

        // --- STATS ---
        this.lifeTimer = 600; 
        this.tauntRange = 160 * (hasSkill('bard_range') ? 1.3 : 1.0);
        this.fleeThreshold = 120; 

        // --- PATHFINDING & PHYSICS ---
        this.speed = 1;         
        this.vx = 0; 
        this.vy = 0;
        this.friction = 0.12;  
        
        this.pathTimer = Math.random() * 30; 
        this.pathRefreshRate = 30; 
        this.currentPath = [];
        this.nodeReachThreshold = 15;

        // --- ANIMATION ---
        this.angle = 0;      
        this.walkCycle = 0;  
        this.targetAngle = 0;
    }

    update(dt) {
        if (typeof dt === 'undefined') dt = 1;

        this.lifeTimer--;
        if (this.lifeTimer <= 0) this.hp = 0;

        // 1. SCAN ENVIRONMENT
        let nearest = null;
        let minDist = Infinity;
        let fleeCount = 0;

        for (let e of enemies) {
            let d = (e.x - this.x)**2 + (e.y - this.y)**2;
            let dist = Math.sqrt(d);

            // A. SEEKING: Track nearest enemy (even through walls)
            if (d < minDist) { minDist = d; nearest = e; }

            // B. INTERACTION: Check Line of Sight for Taunt/Flee
            let canSee = true;
            if (typeof hasLineOfSight === 'function') {
                canSee = hasLineOfSight(this.x, this.y, e.x, e.y);
            }

            if (canSee) {
                if (dist < this.tauntRange) e.tauntTarget = this;
                if (dist < this.fleeThreshold) fleeCount++;
            }
        }

        // 2. DETERMINE TARGET DESTINATION
        let targetX = this.x;
        let targetY = this.y;
        let moving = false;
        let mode = 'IDLE';

        if (fleeCount > 0) {
            // --- MODE: FLEE (RUN TO RIGHT SIDE) ---
            mode = 'FLEE';
            
            // Target the far right edge of the map
            // We assume COLS global exists, otherwise fallback to a large number
            const rightEdge = (typeof COLS !== 'undefined') ? (COLS * CELL_SIZE) - 25 : 2000;
            
            targetX = rightEdge;
            targetY = this.y; // Maintain current height, run straight right
            
        } else if (nearest) {
            // --- MODE: SEEK ---
            mode = 'SEEK';
            targetX = nearest.x;
            targetY = nearest.y;
        }

        // 3. APPLY PATHFINDING
        if (mode !== 'IDLE') {
            let usingPath = false;
            
            // Check Line of Sight to TARGET DESTINATION
            let canSeeTarget = true;
            if (typeof hasLineOfSight === 'function') {
                 canSeeTarget = hasLineOfSight(this.x, this.y, targetX, targetY);
            }

            // If target blocked (by wall), use Pathfinding
            if (!canSeeTarget && typeof findPath === 'function') {
                this.pathTimer--;

                if (this.pathTimer <= 0) {
                    this.currentPath = findPath(this, {x: targetX, y: targetY});
                    this.pathTimer = this.pathRefreshRate;
                }

                if (this.currentPath && this.currentPath.length > 0) {
                    let nextNode = this.currentPath[0];
                    targetX = nextNode.x;
                    targetY = nextNode.y;
                    usingPath = true;

                    let dNode = Math.hypot(nextNode.x - this.x, nextNode.y - this.y);
                    if (dNode < this.nodeReachThreshold) {
                        this.currentPath.shift();
                    }
                }
            }

            if (!usingPath && canSeeTarget) {
                this.currentPath = [];
            }

            // 4. PHYSICS MOVEMENT
            let dx = targetX - this.x;
            let dy = targetY - this.y;
            let dist = Math.hypot(dx, dy);

            if (dist > 5) {
                let dirX = dx / dist;
                let dirY = dy / dist;
                
                // Flee slightly faster
                let currentSpeed = (mode === 'FLEE') ? this.speed * 1.2 : this.speed;

                this.vx += (dirX * currentSpeed - this.vx) * this.friction;
                this.vy += (dirY * currentSpeed - this.vy) * this.friction;
                moving = true;

                if (Math.hypot(this.vx, this.vy) > 0.1) {
                    let desiredAngle = Math.atan2(this.vy, this.vx);
                    let diff = desiredAngle - this.angle;
                    while (diff < -Math.PI) diff += Math.PI * 2;
                    while (diff > Math.PI) diff -= Math.PI * 2;
                    this.angle += diff * 0.15;
                }
            }
        }

        if (!moving) {
            this.vx *= 0.8;
            this.vy *= 0.8;
        }

        if (moving) this.walkCycle += 0.25;
        else this.walkCycle = 0;

        this.x += this.vx * dt;
        this.y += this.vy * dt;

        if(typeof separate === 'function') { separate(this, allies, 0.5); } 
        if(typeof resolveWallCollision === 'function') resolveWallCollision(this);
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // Animation Variables
        const bounce = Math.abs(Math.sin(this.walkCycle)) * 2;
        const sway = Math.sin(this.walkCycle) * 0.15; 
        const featherLag = Math.sin(this.walkCycle - 1.5) * 0.4; 

        // --- 1. SOFT SHADOW ---
        let shadowGrad = ctx.createRadialGradient(0, 4, 2, 0, 4, 10);
        shadowGrad.addColorStop(0, "rgba(0,0,0,0.5)");
        shadowGrad.addColorStop(1, "rgba(0,0,0,0)");
        ctx.fillStyle = shadowGrad;
        ctx.beginPath();
        ctx.scale(1, 0.6);
        ctx.arc(0, 7, 10 - (bounce * 0.5), 0, Math.PI*2);
        ctx.fill();
        ctx.scale(1, 1 / 0.6); 

        // --- 2. LEGS & BOOTS ---
        let lPhase = Math.sin(this.walkCycle);
        let rPhase = Math.sin(this.walkCycle + Math.PI);
        
        ctx.fillStyle = "#2d1b0e"; 
        
        const drawBoot = (x, y, phase) => {
            ctx.save();
            ctx.translate(x, y + (phase * 3)); 
            ctx.rotate(phase * 0.2); 
            ctx.beginPath();
            ctx.ellipse(0, 0, 3.5, 2.5, 0, 0, Math.PI*2);
            ctx.fill();
            ctx.fillStyle = "#4e342e";
            ctx.beginPath();
            ctx.ellipse(1, -1, 1.5, 1, 0, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        };

        drawBoot(-4, 0, lPhase);
        drawBoot(4, 0, rPhase);

        // --- APPLY BODY BOUNCE & SWAY ---
        ctx.translate(0, -bounce);
        ctx.rotate(sway);

        // --- 3. BODY ---
        let bodyGrad = ctx.createLinearGradient(-6, -6, 6, 6);
        bodyGrad.addColorStop(0, "#e056fd"); 
        bodyGrad.addColorStop(1, "#8e24aa"); 
        
        ctx.fillStyle = bodyGrad;
        ctx.beginPath();
        ctx.roundRect(-6, -6, 12, 12, 4);
        ctx.fill();
        
        ctx.strokeStyle = "#FFD700";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-6, 6); ctx.lineTo(6, 6); 
        ctx.stroke();

        ctx.fillStyle = "#3e2723";
        ctx.fillRect(-6.5, 0, 13, 2.5);
        ctx.fillStyle = "#ffb300";
        ctx.fillRect(-2, -0.5, 4, 3.5);
        ctx.fillStyle = "#000"; 
        ctx.fillRect(-1, 0.5, 2, 1.5);

        // --- 4. THE LUTE ---
        ctx.save();
        ctx.translate(5, 2); 
        ctx.rotate(0.3); 

        let luteGrad = ctx.createRadialGradient(-2, -2, 1, 0, 0, 8);
        luteGrad.addColorStop(0, "#D2691E"); 
        luteGrad.addColorStop(1, "#5D4037"); 
        ctx.fillStyle = luteGrad;
        
        ctx.beginPath();
        ctx.ellipse(0, 0, 7.5, 6, 0, 0, Math.PI*2); 
        ctx.fill();

        ctx.fillStyle = "#DEB887";
        ctx.beginPath(); ctx.ellipse(0, -0.5, 6.5, 5, 0, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = "#3e2723";
        ctx.beginPath(); ctx.arc(0, -1, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#8d6e63"; ctx.lineWidth = 0.5;
        ctx.beginPath(); ctx.moveTo(-2.5, -1); ctx.lineTo(2.5, -1); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(0, -3.5); ctx.lineTo(0, 1.5); ctx.stroke();

        ctx.fillStyle = "#3e2723";
        ctx.fillRect(-3, 3, 6, 1.5);

        ctx.save();
        ctx.rotate(-0.1); 
        
        ctx.fillStyle = "#1a1a1a"; 
        ctx.fillRect(-16, -2, 12, 3.5);
        
        ctx.strokeStyle = "#888";
        ctx.lineWidth = 0.5;
        for(let i=0; i<4; i++) {
            let fx = -6 - (i*2.5);
            ctx.beginPath(); ctx.moveTo(fx, -2); ctx.lineTo(fx, 1.5); ctx.stroke();
        }

        ctx.translate(-16, -0.5); 
        ctx.rotate(-1.2); 
        ctx.fillStyle = "#5D4037";
        ctx.fillRect(0, -2, 6, 4); 
        
        ctx.fillStyle = "#fff";
        ctx.beginPath(); ctx.arc(2, -2, 1, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(4, -2, 1, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(2, 2, 1, 0, Math.PI*2); ctx.fill();
        ctx.restore(); 

        ctx.strokeStyle = "rgba(255,255,255,0.7)";
        ctx.lineWidth = 0.4;
        ctx.beginPath();
        ctx.moveTo(-16, -1); ctx.lineTo(0, -1);
        ctx.moveTo(-16, 0); ctx.lineTo(0, 0);
        ctx.moveTo(-16, 1); ctx.lineTo(0, 1);
        ctx.stroke();

        // --- RIGHT HAND ---
        let strumSpeed = Math.sin(Date.now() / 60) * 2; 
        
        ctx.save();
        ctx.translate(1, 1); 
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(-2, -2, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.rotate(0.5 + (strumSpeed * 0.2)); 
        ctx.fillStyle = "#ffcc80"; 
        ctx.beginPath();
        ctx.ellipse(0, 0, 2.5, 2, 0, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = "#e6b975"; 
        ctx.beginPath();
        ctx.ellipse(1, -1, 1.5, 0.8, 0.5, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.moveTo(1, 0); ctx.lineTo(4, 1); ctx.lineTo(2, 2); ctx.fill();
        ctx.restore(); 

        // --- LEFT HAND ---
        ctx.save();
        ctx.translate(-10, -1); 
        ctx.fillStyle = this.color;
        ctx.beginPath(); ctx.arc(2, 4, 3, 0, Math.PI*2); ctx.fill(); 
        ctx.fillStyle = "#dcbfa6"; 
        ctx.beginPath(); ctx.arc(0, 0, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = "#ffcc80"; 
        ctx.beginPath(); ctx.roundRect(-1, -2.5, 1.5, 3, 1); ctx.fill();
        ctx.beginPath(); ctx.roundRect(0.5, -2.2, 1.5, 3, 1); ctx.fill();
        ctx.beginPath(); ctx.roundRect(2, -1.8, 1.5, 2.5, 1); ctx.fill();
        ctx.restore(); 
        ctx.restore(); 


        // --- 5. HEAD & HAT ---
        ctx.save();
        ctx.translate(0, -5); 
        ctx.rotate(sway * 0.5); 
        
        let faceGrad = ctx.createRadialGradient(-1, -2, 1, 0, 0, 6);
        faceGrad.addColorStop(0, "#ffcc80"); 
        faceGrad.addColorStop(1, "#e6b975"); 
        ctx.fillStyle = faceGrad;
        ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI*2); ctx.fill();
        
        ctx.fillStyle = "#3e2723";
        ctx.beginPath(); ctx.arc(-1.5, 1, 5.5, 0, Math.PI*2); ctx.fill();
        
        ctx.fillStyle = "#2e7d32";
        ctx.beginPath();
        ctx.moveTo(-6, -2); ctx.quadraticCurveTo(0, -7, 6, -2); ctx.lineTo(7, 0); ctx.quadraticCurveTo(0, -2, -7, 0); ctx.fill();
        
        ctx.save();
        ctx.translate(-3, -3); 
        ctx.rotate(featherLag); 
        ctx.fillStyle = "#d32f2f"; 
        ctx.beginPath();
        ctx.moveTo(0, 0); ctx.quadraticCurveTo(-4, -6, -8, -2); ctx.quadraticCurveTo(-4, -2, 0, 0); ctx.fill();
        ctx.strokeStyle = "#b71c1c";
        ctx.lineWidth = 0.5;
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-6, -3); ctx.stroke();
        ctx.restore();
        ctx.restore(); 

        ctx.restore(); 

        // --- 6. HP BAR ---
        if (typeof drawHealth === 'function') {
            drawHealth(this.x, this.y, this.hp, this.maxHp);
        }
    }
}

class Soldier {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.radius = 9; 
        this.range = 250;
        this.damage = 15;

        // MOVEMENT
        this.speed = 1.8;
        this.vx = 0; this.vy = 0;
        this.friction = 0.12;
        this.angle = 0; 
        
        // ATTACK
        this.cooldown = 0;
        this.maxCooldown = 90;
        this.hp = 50; this.maxHp = 50;
        this.lifeTimer = 1200;

        // --- IMPROVED AI VARS ---
        this.pathTimer = Math.random() * 30; // Randomize start to spread CPU load
        this.pathRefreshRate = 30; // Re-calculate path every 30 frames (0.5s)
        this.currentPath = [];
        this.nodeReachThreshold = 15; // How close to a node before moving to the next
        
        // VISUALS
        this.walkCycle = 0; 
        this.hairColor = Math.random() > 0.5 ? "#4a3b2a" : (Math.random() > 0.5 ? "#2a2a2a" : "#e6bc2d");
        this.skinColor = "#ffdbac"; 
    }

    update(dt) {
        this.lifeTimer--;

        // --- TARGETING ---
        let nearest = null;
        let minDist = Infinity;
        for (let e of enemies) {
            let d = (e.x - this.x)**2 + (e.y - this.y)**2;
            if (d < minDist) { minDist = d; nearest = e; }
        }

        let moving = false;

        if (nearest) {
            let distToEnemy = Math.sqrt(minDist);
            // Check Line of Sight (LOS)
            let canSeeEnemy = typeof hasLineOfSight === 'function' ? hasLineOfSight(this.x, this.y, nearest.x, nearest.y) : true;

            // 1. COMBAT STATE: If inside range and we can see them, stop and shoot.
            if (distToEnemy < this.range && canSeeEnemy) {
                // Slow down quickly when shooting
                this.vx *= 0.5; this.vy *= 0.5;
                this.angle = Math.atan2(nearest.y - this.y, nearest.x - this.x);

                if (this.cooldown <= 0) {
                    let gunOffsetX = Math.cos(this.angle) * 20 - Math.sin(this.angle) * 6;
                    let gunOffsetY = Math.sin(this.angle) * 20 + Math.cos(this.angle) * 6;
                    
                    if(typeof Bullet !== 'undefined') {
                        projectiles.push(new Bullet(this.x + gunOffsetX, this.y + gunOffsetY, nearest, this.damage));
                    }
                    this.cooldown = this.maxCooldown;
                }
            }
            
            // 2. MOVEMENT STATE
            else {
                let targetX = nearest.x;
                let targetY = nearest.y;
                let usingPath = false;

                // If blocked, use Pathfinding
                if (!canSeeEnemy && typeof findPath === 'function') {
                    this.pathTimer--;

                    // A. Calculate Path (Periodically)
                    if (this.pathTimer <= 0) {
                        // Assuming findPath returns array of objects {x, y} in WORLD coordinates
                        this.currentPath = findPath(this, nearest);
                        this.pathTimer = this.pathRefreshRate;
                    }

                    // B. Follow Path (Waypoint Consumption)
                    if (this.currentPath && this.currentPath.length > 0) {
                        let nextNode = this.currentPath[0];
                        targetX = nextNode.x;
                        targetY = nextNode.y;
                        usingPath = true;

                        // Check distance to the current waypoint
                        let dNode = Math.hypot(nextNode.x - this.x, nextNode.y - this.y);
                        
                        // If we are close enough to the node, remove it and target the next one immediately
                        if (dNode < this.nodeReachThreshold) {
                            this.currentPath.shift(); // Remove first element
                        }
                    }
                }
                
                // If we see the enemy, or pathfinding failed, or path is empty, we go Direct
                if (!usingPath && canSeeEnemy) {
                    this.currentPath = []; // Clear path if we can see target directly
                }

                // C. Apply Physics
                let dx = targetX - this.x;
                let dy = targetY - this.y;
                let dist = Math.hypot(dx, dy);

                if (dist > 5) {
                    let dirX = dx / dist;
                    let dirY = dy / dist;
                    this.vx += (dirX * this.speed - this.vx) * this.friction;
                    this.vy += (dirY * this.speed - this.vy) * this.friction;
                    moving = true;
                    
                    // Only rotate if moving significantly
                    if (Math.hypot(this.vx, this.vy) > 0.1) {
                         this.angle = Math.atan2(this.vy, this.vx);
                    }
                }
            }
        }

        if (!moving) { this.vx *= 0.8; this.vy *= 0.8; }
        if (this.cooldown > 0) this.cooldown--;
        
        // Animate Legs
        if (moving) this.walkCycle += 0.25;
        else this.walkCycle = 0;

        this.x += this.vx *dt;
        this.y += this.vy *dt;

        // Collision
        if(typeof separate === 'function') { separate(this, allies, 0.5); separate(this, enemies, 0.5); }
        if(typeof resolveWallCollision === 'function') resolveWallCollision(this);
    }

    // ... DRAW METHOD REMAINS EXACTLY THE SAME AS YOUR INPUT ...
    draw() {
        // (Paste your existing draw code here)
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // --- 0. RECOIL PHYSICS MATH (Kept your logic) ---
        let timeSinceFire = this.maxCooldown - this.cooldown;
        let kick = 0; 
        let lift = 0; 

        // Frame 0-3: SNAP BACK
        if (timeSinceFire >= 0 && timeSinceFire < 4) {
            kick = 8;       
            lift = -0.25;   
        } 
        // Frame 4-8: RECOVERY
        else if (timeSinceFire >= 4 && timeSinceFire < 10) {
            kick = 4;       
            lift = -0.1;    
        }

        // --- 1. SHADOW (Slightly more dynamic) ---
        ctx.fillStyle = "rgba(0,0,0,0.4)";
        ctx.beginPath();
        // Shadow moves slightly opposite to lift to ground the unit
        ctx.ellipse(0 - kick/2, 2, 9, 7, 0, 0, Math.PI*2);
        ctx.fill();

        // --- 2. LEGS (Standardized colors) ---
        let leftLeg = Math.sin(this.walkCycle) * 4;
        let rightLeg = Math.sin(this.walkCycle + Math.PI) * 4;
        
        // Pants
        ctx.fillStyle = "#2e3b2a"; 
        ctx.beginPath(); ctx.arc(-4 + leftLeg, -5, 4, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(-4 + rightLeg, 5, 4, 0, Math.PI*2); ctx.fill();
        // Boots with treads
        ctx.fillStyle = "#0a0a0a";
        ctx.beginPath(); ctx.arc(-3 + leftLeg, -5, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(-3 + rightLeg, 5, 2.5, 0, Math.PI*2); ctx.fill();

        // --- 3. ARMS (Adjusted for new Gun Bulk) ---
        // Create a slight gradient for skin to look rounder
        let skinGrad = ctx.createRadialGradient(0,0,0, 0,0, 4);
        skinGrad.addColorStop(0, this.skinColor);
        skinGrad.addColorStop(1, "#dcb"); // Highlight

        ctx.fillStyle = this.skinColor;
        
        // Left Arm (Support Hand - holding the handguard)
        ctx.save();
        ctx.translate(5 - kick, -4); // Moved forward to grab the new handguard
        ctx.rotate(0.4 + lift); 
        ctx.fillRect(0, -2.5, 14, 5); 
        ctx.beginPath(); ctx.arc(14, 0, 3.5, 0, Math.PI*2); ctx.fill(); // Hand
        ctx.restore();

        // Right Arm (Trigger Hand)
        ctx.save();
        ctx.translate(-2 - kick, 6); 
        ctx.rotate(-0.3 + lift); 
        ctx.fillRect(0, -2.5, 10, 5); 
        ctx.beginPath(); ctx.arc(10, 0, 3.5, 0, Math.PI*2); ctx.fill(); // Hand
        ctx.restore();

        // --- 4. THE HIGH-DETAIL RIFLE ---
        ctx.save();
        ctx.translate(6 - kick, 4); 
        ctx.rotate(lift); 
        
        // -- A. DEFINE GRADIENTS --
        // Gun Metal (Dark Grey to Light Grey to Dark)
        let metalGrad = ctx.createLinearGradient(0, -5, 0, 5);
        metalGrad.addColorStop(0, "#1a1a1a");
        metalGrad.addColorStop(0.4, "#555"); // Highlight on top ridge
        metalGrad.addColorStop(1, "#111");

        // Polymer/Plastic (Matte Black)
        let polyGrad = ctx.createLinearGradient(0, -5, 0, 5);
        polyGrad.addColorStop(0, "#222");
        polyGrad.addColorStop(1, "#000");

        // -- B. STOCK (Tactical Skeletal Stock) --
        ctx.fillStyle = polyGrad;
        ctx.beginPath();
        ctx.moveTo(-10, -3);
        ctx.lineTo(-4, -3); // Connect to body
        ctx.lineTo(-4, 3);
        ctx.lineTo(-10, 5); // Angled bottom
        ctx.lineTo(-12, 4); // Buttpad bottom
        ctx.lineTo(-12, -2); // Buttpad top
        ctx.fill();
        // Stock Cheek Rest
        ctx.fillStyle = "#333";
        ctx.fillRect(-11, -3, 6, 2);

        // -- C. MAGAZINE (Curved Banana Clip) --
        ctx.save();
        ctx.translate(2, 2);
        ctx.rotate(0.3); // Angle the mag forward
        ctx.fillStyle = "#151515";
        // Draw Curved Mag shape
        ctx.beginPath();
        ctx.moveTo(0,0);
        ctx.lineTo(5,0);
        ctx.lineTo(4, 8); // Taper in
        ctx.quadraticCurveTo(2.5, 9, 1, 8); // Curved bottom
        ctx.lineTo(0,0);
        ctx.fill();
        // Mag Ribs (Texture)
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(1, 2); ctx.lineTo(4, 2);
        ctx.moveTo(1.5, 4); ctx.lineTo(3.5, 4);
        ctx.moveTo(2, 6); ctx.lineTo(3, 6);
        ctx.stroke();
        ctx.restore();

        // -- D. MAIN BODY (Receiver) --
        ctx.fillStyle = metalGrad;
        ctx.beginPath();
        // Receiver shape with mag well dip
        ctx.moveTo(-4, -4);
        ctx.lineTo(8, -4);
        ctx.lineTo(8, 2); // Mag well front
        ctx.lineTo(2, 2); // Mag well back
        ctx.lineTo(-2, 4); // Grip area
        ctx.lineTo(-4, 4);
        ctx.fill();

        // Ejection Port (Grey detail on side)
        ctx.fillStyle = "#444";
        ctx.fillRect(0, -2, 4, 2);
        ctx.fillStyle = "#000"; // Bolt line
        ctx.fillRect(1, -1.5, 2, 1);

        // -- E. HANDGUARD & BARREL --
        // Handguard (Rails)
        ctx.fillStyle = "#2a2a2a";
        ctx.fillRect(8, -3, 10, 5);
        
        // Cooling Vents (Holes in handguard)
        ctx.fillStyle = "#000";
        for(let i=0; i<3; i++) {
            ctx.beginPath();
            ctx.arc(10 + (i*3), -0.5, 1, 0, Math.PI*2);
            ctx.fill();
        }

        // Exposed Barrel
        ctx.fillStyle = "#111";
        ctx.fillRect(18, -1.5, 4, 2);

        // Muzzle Brake (The tip)
        ctx.fillStyle = "#333";
        ctx.fillRect(22, -2, 3, 3); // Thicker tip

        // -- F. ATTACHMENTS --
        
        // Laser Sight Module (Side)
        ctx.fillStyle = "#111";
        ctx.fillRect(14, 2, 4, 2);
        // Laser Beam (Faint red line)
        ctx.strokeStyle = "rgba(255, 0, 0, 0.4)";
        ctx.lineWidth = 0.5;
        ctx.beginPath();
        ctx.moveTo(18, 3);
        ctx.lineTo(100, 3); // Shoots far out
        ctx.stroke();

        // Holographic Sight (Top)
        ctx.fillStyle = "#222";
        ctx.fillRect(0, -6, 6, 2); // Mount
        ctx.fillStyle = "#000";
        ctx.fillRect(0, -9, 1, 3); // Rear post
        ctx.fillRect(5, -9, 1, 3); // Front post
        ctx.fillStyle = "rgba(0, 255, 255, 0.3)"; // Blue Glass
        ctx.fillRect(1, -8, 4, 2);
        // Red Dot inside glass
        ctx.fillStyle = "red";
        ctx.beginPath(); ctx.arc(3, -7, 0.8, 0, Math.PI*2); ctx.fill();


        // -- G. MUZZLE FLASH (Enhanced) --
        if (timeSinceFire < 3) {
            // Inner Core (White)
            ctx.fillStyle = "#fff";
            ctx.beginPath();
            ctx.moveTo(25, -0.5);
            ctx.lineTo(50, -3); 
            ctx.lineTo(50, 2);
            ctx.fill();

            // Star Burst (Orange)
            ctx.fillStyle = "rgba(255, 200, 50, 0.7)";
            ctx.beginPath();
            const flashX = 25;
            const flashY = -0.5;
            // Draw a spiky shape
            for (let i = 0; i < 8; i++) {
                let angle = (i / 8) * Math.PI * 2;
                let r = (i % 2 === 0) ? 15 : 8; // Spike length varies
                ctx.lineTo(flashX + Math.cos(angle) * r, flashY + Math.sin(angle) * r);
            }
            ctx.fill();
            
            // Smoke puff (Grey)
            ctx.fillStyle = "rgba(100, 100, 100, 0.3)";
            ctx.beginPath();
            ctx.arc(35, -5, 6, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.restore(); // End Rifle transform

        // --- 5. SHOULDERS & VEST (Tactical Armor) ---
        ctx.fillStyle = "#2f3a25"; // Vest Color
        ctx.beginPath(); ctx.ellipse(-2, -6, 5, 4, 0, 0, Math.PI*2); ctx.fill(); // L Shoulder
        ctx.beginPath(); ctx.ellipse(-2, 6, 5, 4, 0, 0, Math.PI*2); ctx.fill(); // R Shoulder
        
        // Vest Body
        ctx.fillRect(-6, -5, 10, 10);
        // Vest Plate Detail
        ctx.fillStyle = "#1e2b1a";
        ctx.fillRect(-4, -3, 6, 6);

        // --- 6. HEAD (With Helmet option or Hair) ---
        let headShake = (kick > 0) ? (Math.random() * 2 - 1) : 0;

        // Skin (Neck)
        ctx.fillStyle = this.skinColor;
        ctx.beginPath(); ctx.arc(-2 + headShake, 0, 3.5, 0, Math.PI*2); ctx.fill();

        // Helmet / Hair
        ctx.fillStyle = this.hairColor; // Or make this a helmet color like #222
        ctx.beginPath();
        ctx.arc(-1 + headShake, 0, 5.5, 0, Math.PI*2); 
        ctx.fill();
        
        // If NOT wearing a helmet, draw skin face area
        ctx.fillStyle = this.skinColor; 
        ctx.beginPath();
        // Slightly offset ellipse for top-down face look
        ctx.ellipse(2 + headShake, 0, 3, 4, 0, 0, Math.PI*2); 
        ctx.fill();

        ctx.restore(); // End Player transform

        // --- HP BAR (Cleaned up) ---
        if (this.hp < this.maxHp) {
            const barW = 24;
            const barH = 4;
            const yOffset = 28;

            const barX = this.x - (barW / 2);
            const barY = this.y - yOffset;

            const pct = Math.max(0, Math.min(1, this.hp / this.maxHp));
            const hue = (pct * pct) * 120;

            ctx.fillStyle = "#333333";
            ctx.fillRect(barX, barY, barW, barH);

            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
            ctx.fillRect(barX, barY, barW * pct, barH);

            ctx.strokeStyle = "#000000";
            ctx.lineWidth = 1;
            ctx.strokeRect(barX, barY, barW, barH);
        }
    }
}

    // -- BUILDINGS --

    class Barracks {
    constructor(col, row) {
        this.col = col;
        this.row = row;
        this.timer = 0;
        this.spawnRate = 600 * (hasSkill('barracks_speed') ? 0.8 : 1); // Keeps 600 (approx 10 sec at 60fps baseline)
        
        // Animation Variables
        this.angleOuter = 0;
        this.angleInner = 0;
        this.pistonOffset = 0;
    }

    update(dt) {
        // 1. INCREMENT TIMER BY DT
        // Since dt is roughly 1.0, this counts up exactly like before,
        // but compensates for lag.
        this.timer += dt; 
        
        let progress = this.timer / this.spawnRate;

        // 2. DYNAMIC ROTATION
        // Multiply "speed" by dt so rotation is smooth regardless of framerate
        let speed = 0.02 + (progress * 0.15); 
        this.angleOuter += speed * dt;
        this.angleInner -= (speed * 1.5) * dt; 

        // 3. PISTON ANIMATION
        // We don't multiply by dt inside Math.sin because 'this.timer' 
        // has already been adjusted by dt above.
        this.pistonOffset = Math.sin(this.timer * 0.1) * 3;

        // 4. SPAWN LOGIC
        if (this.timer >= this.spawnRate) {
            this.timer = 0;
            
            let sx = this.col * CELL_SIZE + CELL_SIZE/2;
            let sy = this.row * CELL_SIZE + CELL_SIZE/2;
            
            // Check if allies array exists before pushing
            if (typeof allies !== 'undefined') {
                allies.push(new Soldier(sx, sy));
            }
            
            // SPAWN EFFECTS
            if (typeof createParticles !== 'undefined') {
                createParticles(sx, sy, "#00ffff", 12); 
                createParticles(sx, sy, "#ffffff", 6);
            }
        }
    }

    draw() {
        let x = this.col * CELL_SIZE;
        let y = this.row * CELL_SIZE;
        let cx = x + CELL_SIZE / 2;
        let cy = y + CELL_SIZE / 2;
        let size = CELL_SIZE - 4;

        ctx.save();
        ctx.translate(cx, cy);

        // --- TECH BASE ---
        ctx.fillStyle = "#1a1a2e"; 
        this.drawOctagon(ctx, 0, 0, size/2 + 2);
        
        ctx.strokeStyle = "#16213e";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-size/2, -size/2); ctx.lineTo(size/2, size/2);
        ctx.moveTo(size/2, -size/2); ctx.lineTo(-size/2, size/2);
        ctx.stroke();

        // --- PISTONS ---
        ctx.fillStyle = "#444";
        for (let i = 0; i < 4; i++) {
            ctx.save();
            ctx.rotate((Math.PI / 2) * i); 
            
            ctx.fillRect(-6, -size/2, 12, 10);
            
            let py = -size/2 + 8 + this.pistonOffset;
            ctx.fillStyle = "#888"; 
            ctx.fillRect(-3, py, 6, 8);
            
            ctx.strokeStyle = "#222";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, -size/2 + 5);
            ctx.lineTo(0, py);
            ctx.stroke();
            
            ctx.restore();
        }

        // --- REACTOR CORE ---
        let pct = Math.min(this.timer / this.spawnRate, 1);
        let glowSize = 5 + (pct * 10); 
        
        ctx.shadowBlur = 15 + (pct * 20); 
        ctx.shadowColor = "#00d2ff";
        ctx.fillStyle = `rgba(0, 210, 255, ${0.2 + pct * 0.8})`;
        
        ctx.beginPath();
        ctx.arc(0, 0, glowSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0; 

        // --- PLASMA RINGS ---
        // Outer
        ctx.save();
        ctx.rotate(this.angleOuter);
        ctx.strokeStyle = "#00d2ff"; 
        ctx.lineWidth = 2;
        ctx.setLineDash([10, 8]); 
        ctx.beginPath();
        ctx.arc(0, 0, size/2 - 6, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();

        // Inner
        ctx.save();
        ctx.rotate(this.angleInner);
        ctx.strokeStyle = "#ff00ff"; 
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]); 
        ctx.beginPath();
        ctx.arc(0, 0, size/2 - 12, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
        
        // --- HOLOGRAPHIC PROJECTION ---
        if (pct > 0.5) {
            ctx.save();
            if (Math.random() > 0.1) {
                ctx.fillStyle = "rgba(255, 255, 255, 0.5)";
                ctx.fillRect(-2, -2, 4, 4);
                
                // Hologram Scan Line
                // Use timer directly (it's now a float, but modulo works on floats in JS)
                let scanY = -10 + (20 * ((this.timer % 40)/40));
                
                ctx.strokeStyle = "rgba(0, 255, 0, 0.8)";
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(-8, scanY);
                ctx.lineTo(8, scanY);
                ctx.stroke();
            }
            ctx.restore();
        }

        ctx.restore();
    }

    drawOctagon(ctx, x, y, radius) {
        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
            let angle = (Math.PI / 4) * i;
            ctx.lineTo(x + Math.cos(angle) * radius, y + Math.sin(angle) * radius);
        }
        ctx.closePath();
        ctx.fill();
    }
}

   class Mortar {
    constructor(col, row) {
        this.col = col;
        this.row = row;

        // --- Stats ---
        this.timer = 0;
        this.cooldown = 200;
        this.range = 550;
        this.shellSpeed = 3.5;

        // --- Visual State ---
        this.recoil = 0;
        this.smoke = [];

        // --- Palette: Industrial Grays ---
        this.cMatteDark = "#2b2b2b";
        this.cMatteMid  = "#4a4a4a";
        this.cChrome    = "#a0a0a0";
        this.cCarbon    = "#1a1a1a";
        this.cAccent    = "#ffffff";
    }

    update(dt) {
        if (this.timer > 0) this.timer--;
        
        // Mechanical Recoil Recovery
        this.recoil = Math.max(0, this.recoil * 0.9);

        // Update Smoke
        for (let i = this.smoke.length - 1; i >= 0; i--) {
            let p = this.smoke[i];
            p.x += p.vx; p.y += p.vy;
            p.size += 0.3; p.life -= 0.02;
            if (p.life <= 0) this.smoke.splice(i, 1);
        }

        // Firing Logic
        if (this.timer <= 0) {
            let target = this.findTarget();
            if (target) {
                const cx = this.col * CELL_SIZE + CELL_SIZE / 2;
                const cy = this.row * CELL_SIZE + CELL_SIZE / 2;

                // --- TUNED PREDICTION ALGORITHM ---
                
                // 1. Get Enemy Velocity
                let tvx = target.vx || 0;
                let tvy = target.vy || 0;

                // 2. Calculate "Perfect" Time to Impact
                // We use the iterative method to find the exact flight time
                let t = 0;
                let predX = target.x;
                let predY = target.y;
                
                // Iteration 1: Simple distance check
                let dist = Math.hypot(target.x - cx, target.y - cy);
                t = dist / this.shellSpeed;

                // Iteration 2: Refine based on movement
                let futureX = target.x + tvx * t;
                let futureY = target.y + tvy * t;
                dist = Math.hypot(futureX - cx, futureY - cy);
                t = dist / this.shellSpeed;

                // 3. APPLY DAMPENING (The Fix)
                // Instead of shooting EXACTLY where they will be in 't' frames,
                // we only lead them by a percentage. This prevents overshooting 
                // when enemies turn corners.
                const PREDICTION_FACTOR = 0.6; // 0.0 = At enemy, 1.0 = Full Lead, 0.6 = Balanced
                
                let finalX = target.x + (tvx * t * PREDICTION_FACTOR);
                let finalY = target.y + (tvy * t * PREDICTION_FACTOR);

                projectiles.push(new MortarShell(cx, cy, finalX, finalY));

                this.timer = this.cooldown;
                this.recoil = 30; 

                // Smoke Logic
                const tipY = cy - (CELL_SIZE * 0.8) + this.recoil; 
                for (let i = 0; i < 12; i++) {
                    let angle = (Math.random() - 0.5) * 1.5;
                    let speed = 2 + Math.random() * 4;
                    this.smoke.push({
                        x: cx,
                        y: tipY,
                        vx: Math.sin(angle) * speed,
                        vy: -Math.cos(angle) * speed,
                        size: 4 + Math.random() * 6,
                        life: 1.0,
                        color: Math.random() > 0.5 ? 'rgba(200,200,200,' : 'rgba(80,80,80,'
                    });
                }
            }
        }
    }

    findTarget() {
        const cx = this.col * CELL_SIZE + CELL_SIZE / 2;
        const cy = this.row * CELL_SIZE + CELL_SIZE / 2;
        let closest = null;
        let recordDist = Infinity;
        for (let e of enemies) {
            let d = Math.hypot(e.x - cx, e.y - cy);
            if (d < this.range && d < recordDist) {
                recordDist = d; closest = e;
            }
        }
        return closest;
    }

    draw() {
        const cx = this.col * CELL_SIZE + CELL_SIZE / 2;
        const cy = this.row * CELL_SIZE + CELL_SIZE / 2;
        const size = CELL_SIZE;

        ctx.save();
        ctx.translate(cx, cy);

        // --- LAYER 1: Industrial Base ---
        ctx.fillStyle = this.cMatteDark;
        ctx.beginPath();
        for(let i=0; i<8; i++){
            let ang = i * Math.PI / 4;
            ctx.lineTo(size*0.45 * Math.cos(ang), size*0.45 * Math.sin(ang));
        }
        ctx.fill();
        
        ctx.strokeStyle = this.cMatteMid;
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(0,0, size*0.35, 0, Math.PI*2); ctx.stroke();
        
        ctx.fillStyle = "#111";
        [0, 2, 4, 6].forEach(i => {
            let a = i * Math.PI / 4;
            ctx.beginPath(); 
            ctx.rect(size*0.38*Math.cos(a)-2, size*0.38*Math.sin(a)-2, 4, 4); 
            ctx.fill();
        });

        // --- LAYER 2: THE BARREL (Sandwiched) ---
        ctx.save();
        ctx.translate(0, size * 0.1); 

        const totalLen = size * 0.9;
        
        // 2a. Breech Block
        const breechW = size * 0.42;
        const breechH = size * 0.25;
        this.drawMachinedBlock(0, 0, breechW, breechH, this.cMatteDark);
        
        // 2b. Segment 1: Outer Shielding
        const seg1W = size * 0.34;
        const seg1H = totalLen * 0.3;
        this.drawCylinder(0, -breechH, seg1W, seg1H, this.cMatteMid, this.cCarbon);

        // 2c. Segment 2: Polished Hydraulic Piston
        const seg2W = size * 0.26;
        const seg2H = totalLen * 0.3;
        const r2 = this.recoil * 0.5;
        this.drawCylinder(0, -breechH - seg1H + r2, seg2W, seg2H, "#ffffff", "#888888"); 

        // 2d. Segment 3: Magnetic Rail / Tip
        const seg3W = size * 0.18;
        const seg3H = totalLen * 0.4;
        const r3 = this.recoil;
        const tipY = -breechH - seg1H - seg2H + r3;
        
        this.drawCylinder(0, tipY, seg3W, seg3H, this.cMatteMid, "#000");
        
        // Muzzle Flash
        if (this.recoil > 15) {
            ctx.globalCompositeOperation = 'lighter';
            ctx.shadowBlur = 30;
            ctx.shadowColor = "#ff3300"; 
            ctx.fillStyle = "rgba(255, 60, 30, 0.6)";
            ctx.beginPath();
            ctx.ellipse(0, tipY - seg3H - 15, size/2.5, size/2, 0, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;
            ctx.globalCompositeOperation = 'source-over';
        }
        ctx.restore();

        // --- LAYER 3: HEAVY SIDE PLATING ---
        const mountW = size * 0.14;
        const mountH = size * 0.5;
        const spread = size * 0.24;
        
        this.drawHeavyMount(-spread, 0, mountW, mountH, size);
        this.drawHeavyMount(spread, 0, mountW, mountH, size);

        // --- LAYER 4: The Axle ---
        ctx.fillStyle = "#111";
        ctx.fillRect(-spread, -4, spread*2, 8);
        this.drawHex( -spread - 2, 0, 5, "#333");
        this.drawHex( spread + 2, 0, 5, "#333");

        ctx.restore();

        // --- LAYER 5: Smoke ---
        for (let p of this.smoke) {
            ctx.fillStyle = `${p.color} ${p.life * 0.5})`; 
            ctx.beginPath();
            ctx.arc(p.x - cx, p.y - cy, p.size, 0, Math.PI*2);
            ctx.fill();
        }
    }

    drawMachinedBlock(x,y,w,h, color) {
        ctx.save();
        ctx.translate(x,y);
        ctx.fillStyle = color;
        ctx.fillRect(-w/2, -h, w, h);
        ctx.fillStyle = "rgba(255,255,255,0.1)";
        ctx.fillRect(-w/2, -h, 2, h); 
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.fillRect(w/2 - 2, -h, 2, h); 
        ctx.fillStyle = "#111";
        ctx.fillRect(-w/4, -h/2, w/2, 2);
        ctx.fillRect(-w/4, -h/2 + 4, w/2, 2);
        ctx.restore();
    }

    drawCylinder(x, y, w, h, cLight, cDark) {
        ctx.save();
        ctx.translate(x, y);
        let grad = ctx.createLinearGradient(-w/2, 0, w/2, 0);
        grad.addColorStop(0, cDark);
        grad.addColorStop(0.2, cDark);
        grad.addColorStop(0.4, cLight); 
        grad.addColorStop(0.5, cLight);
        grad.addColorStop(0.8, cDark);
        grad.addColorStop(1.0, "#000");
        ctx.fillStyle = grad;
        ctx.fillRect(-w/2, -h, w, h);
        ctx.fillStyle = "rgba(0,0,0,0.5)";
        ctx.fillRect(-w/2, -h, w, 1);
        ctx.restore();
    }
    
    drawHeavyMount(x, y, w, h, size) {
        ctx.save();
        ctx.translate(x, y);
        ctx.fillStyle = this.cMatteMid;
        ctx.strokeStyle = "#111";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-w/2, size/4); 
        ctx.lineTo(-w/2, -h/4);   
        ctx.lineTo(0, -h/2);      
        ctx.lineTo(w/2, -h/4);    
        ctx.lineTo(w/2, size/4);  
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = this.cMatteDark;
        ctx.beginPath();
        ctx.arc(0, size/5, 3, 0, Math.PI*2); 
        ctx.fill();
        ctx.fillStyle = this.cAccent; 
        ctx.fillRect(-2, -h/3, 4, 4);
        ctx.restore();
    }
    
    drawHex(x, y, r, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        for(let i=0; i<6; i++) {
            ctx.lineTo(x + r*Math.cos(i*Math.PI/3), y + r*Math.sin(i*Math.PI/3));
        }
        ctx.fill();
    }
}

    // -- PROJECTILES --

    class HealingVomit {
    constructor(startX, startY, target, healAmount) {
        this.x = startX;
        this.y = startY;
        this.target = target;
        this.healAmount = healAmount;
        this.speed = 8; // Faster projectile to catch running targets
        this.active = true;
        this.radius = 4;
        this.trail = [];
    }

    update(dt) {
        if (!this.target || this.target.hp <= 0) {
            this.active = false;
            return;
        }

        let dx = this.target.x - this.x;
        let dy = this.target.y - this.y;
        let dist = Math.hypot(dx, dy);

        // SAFETY FIX: If target has no radius, assume 15
        let hitDist = (this.target.radius || 15) + 10; 

        if (dist < hitDist) {
            this.target.hp = Math.min(this.target.maxHp, this.target.hp + this.healAmount);
            if(typeof createParticles === 'function') createParticles(this.target.x, this.target.y, "#00ffcc", 5);
            this.active = false;
        } else {
            this.x += (dx / dist) * this.speed;
            this.y += (dy / dist) * this.speed;
            this.trail.push({x: this.x, y: this.y, r: Math.random() * 3 + 1});
            if(this.trail.length > 5) this.trail.shift();
        }
    }

    draw() {
        ctx.save();
        ctx.fillStyle = "#00ffcc";
        for(let t of this.trail) {
            ctx.globalAlpha = 0.5;
            ctx.beginPath(); ctx.arc(t.x, t.y, t.r, 0, Math.PI*2); ctx.fill();
        }
        ctx.globalAlpha = 1;
        ctx.shadowBlur = 6; ctx.shadowColor = "#00ffcc";
        ctx.beginPath(); ctx.arc(this.x, this.y, 4, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0; ctx.restore();
    }
}

class MinigunBullet {
    constructor(x, y, angle, damage, speed) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.damage = damage;
        this.speed = speed;
        this.active = true;
        this.life = 140; 
        
        // VISUALS: Size 0.7 as requested
        this.size = 0.7; 
    }

    update(dt) {
        // Move in straight line
        this.x += Math.cos(this.angle) * this.speed;
        this.y += Math.sin(this.angle) * this.speed;
        
        this.life -= dt;
        if (this.life <= 0) this.active = false;

        // --- CUSTOM COLLISION LOGIC ---
        for (let e of enemies) {
            let dist = Math.hypot(e.x - this.x, e.y - this.y);
            
            // Hitbox check
            if (dist < e.radius + 10) {
                // --- NEW SHIELD LOGIC ---
                if (e.isInvincible) {
                    // BLOCKED! Blue particles indicate shield hit
                    if (typeof createParticles === 'function') {
                        createParticles(this.x, this.y, "#00d2ff", 4); 
                    }
                } else {
                    // NORMAL HIT: Apply damage
                    e.hp -= this.damage;
                    
                    // Visual Hit Effect (Orange/Gold)
                    if (typeof createParticles === 'function') {
                        createParticles(this.x, this.y, "#ffaa00", 3);
                    }
                }

                this.active = false; // Bullet is destroyed either way
                break; // Hit one enemy per bullet
            }
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // Glowing Tracer Round
        ctx.shadowBlur = 8;
        ctx.shadowColor = "#ffaa00";
        ctx.fillStyle = "#ffffaa";

        ctx.fillRect(-5, -1, 10, 2); 

        ctx.restore();
    }
}


    class Bullet {
    constructor(x, y, target, damage, size = 1) {
        this.x = x; this.y = y;
        this.target = target;
        this.damage = damage;
        this.size = size; 
        
        this.speed = 12;
        this.active = true;
        this.type = 'bullet';
        
        this.angle = 0;
    }

    update(dt) {
        if (!this.target || this.target.hp <= 0) {
            this.active = false;
            return;
        }

        let dx = this.target.x - this.x;
        let dy = this.target.y - this.y;
        let dist = Math.sqrt(dx*dx + dy*dy);
        
        // Update angle to face the target
        this.angle = Math.atan2(dy, dx);

        // HIT CHECK:
        if (dist < this.speed + (this.size * 4)) {
            
            // --- NEW SHIELD LOGIC ---
            if (this.target.isInvincible) {
                // BLOCKED! Blue particles
                if (typeof createParticles === 'function') {
                    createParticles(this.target.x, this.target.y, "#00d2ff", 6 * this.size);
                }
            } else {
                // NORMAL HIT
                this.target.hp -= this.damage;
                
                // Death check
                if(this.target.hp <= 0 && this.target.hp > -100) {
                    createParticles(this.target.x, this.target.y, "#ffaa00", 6 * this.size);
                    this.target.hp = -999; 
                }
            }
            
            this.active = false; // Bullet destroyed
        } else {
            this.x += (dx/dist) * this.speed;
            this.y += (dy/dist) * this.speed;
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        
        ctx.scale(this.size, this.size);
        ctx.globalCompositeOperation = "lighter";

        // Trail
        let grad = ctx.createLinearGradient(0, 0, -25, 0);
        grad.addColorStop(0, "rgba(255, 200, 50, 0.8)"); 
        grad.addColorStop(1, "rgba(255, 50, 0, 0)");     
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.moveTo(2, 0);    
        ctx.lineTo(-4, 2);    
        ctx.lineTo(-25, 0);   
        ctx.lineTo(-4, -2);   
        ctx.fill();

        // Core
        ctx.shadowColor = "#ffaa00";
        ctx.shadowBlur = 10; 
        ctx.fillStyle = "#ffffff";
        
        ctx.beginPath();
        ctx.ellipse(0, 0, 6, 1.5, 0, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
    }
}
    
    class MortarShell {
    constructor(x, y, tx, ty) {
        this.x = x; 
        this.y = y;
        this.tx = tx; 
        this.ty = ty;
        
        // 1. Calculate Geometry
        this.startDist = Math.hypot(tx - x, ty - y);
        // Yaw is the angle across the ground (2D plane)
        this.yaw = Math.atan2(ty - y, tx - x); 
        
        // 2. Flight Logic
        const flightTime = 60; // Frames to reach target
        this.speed = this.startDist / flightTime;
        // Enforce minimum speed to prevent floating shells
        if (this.speed < 2) this.speed = 2; 

        this.active = true;
        
        // 3. Stats (Passed to explosion)
        this.damage = 50 + (hasSkill('mortar_dmg') ? 30 : 0);
        this.blastRadius = 150 * (hasSkill('mortar_area') ? 1.25 : 1);

        // 4. Visuals
        this.z = 0; // Height off ground
        this.trail = []; 
    }

    update(dt) {
        if (!dt) dt = 1;

        let dx = this.tx - this.x;
        let dy = this.ty - this.y;
        let dist = Math.sqrt(dx*dx + dy*dy);

        // --- Trail Logic ---
        // Only spawn trail particles while moving
        if (dist > this.speed) {
             this.trail.push({x: this.x, y: this.y - this.z, alpha: 1.0});
             if(this.trail.length > 25) this.trail.shift(); 
        }
        // Fade out existing trail segments
        for(let p of this.trail) p.alpha -= 0.04;

        // --- Target Reached Logic ---
        if (dist <= this.speed) {
            this.active = false;
            
            // DAMAGE TRIGGER:
            // We pass this shell's specific damage and radius to the global function
            if (typeof createExplosion === 'function') {
                createExplosion(this.tx, this.ty, this.damage, this.blastRadius);
            }
        } else {
            // Move towards target
            this.x += (dx/dist) * this.speed * dt;
            this.y += (dy/dist) * this.speed * dt;
        }
    }

    // Helper: Calculates how high the shell is based on distance traveled
    getArcHeight(distTraveled) {
        let progress = distTraveled / this.startDist;
        // Clamp progress between 0 and 1
        progress = Math.max(0, Math.min(1, progress));
        
        // Parabola height logic
        let maxArcHeight = 50 + (this.startDist * 0.15); 
        return Math.sin(progress * Math.PI) * maxArcHeight;
    }

    draw() {
        // --- 1. Calculate Physics State ---
        let distRemaining = Math.hypot(this.tx - this.x, this.ty - this.y);
        let distTraveled = this.startDist - distRemaining;
        this.z = this.getArcHeight(distTraveled);

        // --- 2. Calculate Visual Rotation ---
        // Predict where the shell will be in the next frame to point it correctly
        let lookAhead = this.speed; 
        let nextDistTraveled = distTraveled + lookAhead;
        
        // Future ground position
        let nextX = this.x + Math.cos(this.yaw) * lookAhead;
        let nextY = this.y + Math.sin(this.yaw) * lookAhead;
        
        // Future screen position (Y - Z)
        let nextZ = this.getArcHeight(nextDistTraveled);
        
        // Angle between current screen pos and next screen pos
        let currentScreenY = this.y - this.z;
        let nextScreenY = nextY - nextZ;
        
        let visualRotation = Math.atan2(nextScreenY - currentScreenY, nextX - this.x);

        // --- 3. Draw Shadow (Ground Level) ---
        let scale = 1.0 + (this.z / 300); // Slight size increase with height
        let shadowSize = 6 * (1 - (this.z / 200)); 
        let shadowAlpha = 0.4 * (1 - (this.z / 150));
        
        if (shadowSize > 0) {
            ctx.save();
            ctx.fillStyle = `rgba(0,0,0,${Math.max(0, shadowAlpha)})`;
            ctx.beginPath();
            // Shadow stays on the ground, rotated by Yaw
            ctx.ellipse(this.x, this.y, shadowSize * 1.5, shadowSize * 0.8, this.yaw, 0, Math.PI*2);
            ctx.fill();
            ctx.restore();
        }

        // --- 4. Draw Trail ---
        ctx.lineWidth = 3 * scale;
        ctx.lineCap = "round";
        // Draw segments connecting trail points
        for (let i = 0; i < this.trail.length - 1; i++) {
            let p1 = this.trail[i];
            let p2 = this.trail[i+1];
            if(p1.alpha <= 0) continue;
            
            ctx.strokeStyle = `rgba(200, 200, 200, ${p1.alpha * 0.5})`;
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
        }

        // --- 5. Draw Shell Sprite ---
        ctx.save();
        
        // Translate to actual visual position (Ground Y - Height Z)
        ctx.translate(this.x, this.y - this.z);
        ctx.rotate(visualRotation);
        ctx.scale(scale, scale); 

        // Shell Body Shape
        ctx.fillStyle = "#333";
        ctx.beginPath();
        ctx.moveTo(14, 0);   // Nose
        ctx.lineTo(-8, 4.5);  // Back Bottom
        ctx.lineTo(-8, -4.5); // Back Top
        ctx.fill();

        // Driving Band (Copper ring detail)
        ctx.fillStyle = "#b87333"; 
        ctx.fillRect(-5, -4.5, 4, 9);

        // Metallic Highlight
        ctx.fillStyle = "rgba(255,255,255,0.4)";
        ctx.fillRect(-7, -1.5, 18, 3);

        // Engine/Thruster Glow
        ctx.shadowBlur = 8;
        ctx.shadowColor = "#ff5500";
        ctx.fillStyle = "#ff5500";
        ctx.beginPath(); 
        ctx.arc(-8, 0, 3, 0, Math.PI*2); 
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.restore();
    }
}

function drawBlueprint() {
    let col = Math.floor(mouseX / CELL_SIZE);
    let row = Math.floor(mouseY / CELL_SIZE);

    if (currentTool === 'wall') {
        // ... (Existing Wall Logic) ...
        // 1. Grid Snap Calculations
        let col = Math.floor(mouseX / CELL_SIZE);
        let row = Math.floor(mouseY / CELL_SIZE);

        // Ensure we are inside the grid
        if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {

            // 2. Setup Colors (Simulate 100% Health)
            let hpPct = 1.0; 
            let gray = Math.floor(60 + (60 * hpPct)); // 120
            let colMain = `rgb(${gray}, ${gray}, ${gray})`;
            let colLight = `rgb(${gray + 40}, ${gray + 40}, ${gray + 40})`;
            let colDark = `rgb(${gray - 40}, ${gray - 40}, ${gray - 40})`;
            let colDetail = `rgb(${gray - 20}, ${gray - 20}, ${gray - 20})`;

            // 3. Check Neighbors (To draw connections)
            let nUp = (row > 0 && grid[col][row - 1].wall);
            let nDown = (row < ROWS - 1 && grid[col][row + 1].wall);
            let nLeft = (col > 0 && grid[col - 1][row].wall);
            let nRight = (col < COLS - 1 && grid[col + 1][row].wall);

            // 4. Geometry Calculations
            let drawX = col * CELL_SIZE;
            let drawY = row * CELL_SIZE;
            let coreSize = CELL_SIZE * 0.85; 
            let offset = (CELL_SIZE - coreSize) / 2;
            
            let cX = drawX + offset;
            let cY = drawY + offset;
            let cW = coreSize;
            let cH = coreSize;

            // --- DRAWING ---

            // A. Base Layer (Main Block + Arms)
            ctx.fillStyle = colMain;
            ctx.fillRect(cX, cY, cW, cH); // Center
            
            if (nUp) ctx.fillRect(cX, drawY, cW, offset);
            if (nDown) ctx.fillRect(cX, cY + cH, cW, offset);
            if (nLeft) ctx.fillRect(drawX, cY, offset, cH);
            if (nRight) ctx.fillRect(cX + cW, cY, offset, cH);

            // B. Grip Lines (Texture on the arms only)
            ctx.fillStyle = colDark;
            let lineSpace = 4;
            if (nUp) for(let i = drawY + 2; i < cY; i+=lineSpace) ctx.fillRect(cX + 2, i, cW - 4, 1);
            if (nDown) for(let i = cY + cH + 2; i < drawY + CELL_SIZE; i+=lineSpace) ctx.fillRect(cX + 2, i, cW - 4, 1);
            if (nLeft) for(let i = drawX + 2; i < cX; i+=lineSpace) ctx.fillRect(i, cY + 2, 1, cH - 4);
            if (nRight) for(let i = cX + cW + 2; i < drawX + CELL_SIZE; i+=lineSpace) ctx.fillRect(i, cY + 2, 1, cH - 4);

            // C. 3D Bevels (Outer Edges)
            let drawLine = (x1, y1, x2, y2, color) => {
                ctx.beginPath(); ctx.strokeStyle = color; ctx.lineWidth = 2;
                ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
            };
            
            drawLine(cX, cY, cX + cW, cY, colLight);       // Top Highlight
            drawLine(cX, cY, cX, cY + cH, colLight);       // Left Highlight
            drawLine(cX + cW, cY, cX + cW, cY + cH, colDark); // Right Shadow
            drawLine(cX, cY + cH, cX + cW, cY + cH, colDark); // Bottom Shadow

            // D. Inner Reinforced Plate (Clean Square)
            let pad = 6;
            ctx.fillStyle = colDetail;
            ctx.fillRect(cX + pad, cY + pad, cW - pad*2, cH - pad*2);
            
            // Inner Shadow (Inset look)
            ctx.strokeStyle = colDark;
            ctx.lineWidth = 1;
            ctx.strokeRect(cX + pad, cY + pad, cW - pad*2, cH - pad*2);
        }
    }
    else if (currentTool === 'barracks') {
        if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
            const x = col * CELL_SIZE + CELL_SIZE / 2;
            const y = row * CELL_SIZE + CELL_SIZE / 2;
            const size = CELL_SIZE - 4;
            
            const isOccupied = grid[col][row].occupied || grid[col][row].wall;
            const canAfford = money >= 200; // Adjust to match your UI cost

            ctx.save();
            ctx.translate(x, y);
            ctx.globalAlpha = 0.5; // Transparent "Ghost" mode

            // --- 1. TECH BASE ---
            // Draw Octagon inline to avoid dependency issues
            ctx.fillStyle = "#1a1a2e"; 
            ctx.beginPath();
            for (let i = 0; i < 8; i++) {
                let angle = (Math.PI / 4) * i;
                let rad = size/2 + 2;
                ctx.lineTo(Math.cos(angle) * rad, Math.sin(angle) * rad);
            }
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = "#16213e";
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(-size/2, -size/2); ctx.lineTo(size/2, size/2);
            ctx.moveTo(size/2, -size/2); ctx.lineTo(-size/2, size/2);
            ctx.stroke();

            // --- 2. PISTONS (Static) ---
            ctx.fillStyle = "#444";
            for (let i = 0; i < 4; i++) {
                ctx.save();
                ctx.rotate((Math.PI / 2) * i); 
                
                // Base
                ctx.fillRect(-6, -size/2, 12, 10);
                
                // Rod (Static position)
                let py = -size/2 + 8;
                ctx.fillStyle = "#888"; 
                ctx.fillRect(-3, py, 6, 8);
                
                // Wire
                ctx.strokeStyle = "#222";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, -size/2 + 5);
                ctx.lineTo(0, py);
                ctx.stroke();
                
                ctx.restore();
            }

            // --- 3. REACTOR CORE ---
            // Static moderate glow
            ctx.shadowBlur = 15; 
            ctx.shadowColor = "#00d2ff";
            ctx.fillStyle = `rgba(0, 210, 255, 0.6)`;
            
            ctx.beginPath();
            ctx.arc(0, 0, 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0; 

            // --- 4. PLASMA RINGS ---
            // Outer Ring
            ctx.strokeStyle = "#00d2ff"; 
            ctx.lineWidth = 2;
            ctx.setLineDash([10, 8]); 
            ctx.beginPath();
            ctx.arc(0, 0, size/2 - 6, 0, Math.PI * 2);
            ctx.stroke();

            // Inner Ring
            ctx.strokeStyle = "#ff00ff"; 
            ctx.setLineDash([5, 5]); 
            ctx.beginPath();
            ctx.arc(0, 0, size/2 - 12, 0, Math.PI * 2);
            ctx.stroke();
            ctx.setLineDash([]); // Reset dash

            ctx.restore();
        }
    }
    else if (currentTool === 'wall_turret') {
        // ... (Existing Turret Logic) ...
        // --- 1. CALCULATE GRID SNAP ---
        let col = Math.floor(mouseX / CELL_SIZE);
        let row = Math.floor(mouseY / CELL_SIZE);
        
        // Center the blueprint on the grid cell
        let snapX = col * CELL_SIZE + CELL_SIZE / 2;
        let snapY = row * CELL_SIZE + CELL_SIZE / 2;

        // --- 2. DRAW RANGE CONE (Centered on Snap) ---
        ctx.save();
        ctx.translate(snapX, snapY); 
        
        ctx.beginPath();
        ctx.fillStyle = "rgba(0, 255, 0, 0.1)";
        ctx.strokeStyle = "rgba(0, 255, 0, 0.5)";
        ctx.moveTo(0, 0);
        // Note: Adjusted radius to 210 to match the new turret range
        ctx.arc(0, 0, 210 * (hasSkill('turret_range') ? 1.4 : 1), buildRotation - Math.PI / 3, buildRotation + Math.PI / 3);
        ctx.lineTo(0, 0);
        ctx.fill();
        ctx.stroke();
        ctx.restore();

        // --- 3. DRAW TURRET VISUALS (Updated to Match New Class) ---
        ctx.save();
        ctx.translate(snapX, snapY); 
        ctx.rotate(buildRotation);

        // A. Industrial Hex Base
        ctx.fillStyle = "#263238"; 
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            ctx.lineTo(15 * Math.cos(i * Math.PI / 3), 15 * Math.sin(i * Math.PI / 3));
        }
        ctx.fill();
        ctx.strokeStyle = "#37474f"; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI*2); ctx.stroke();

        // B. The Heavy Cannon
        // Breech
        ctx.fillStyle = "#1c1c1c"; ctx.fillRect(0, -7, 12, 14);
        // Barrel
        ctx.fillStyle = "#455a64"; ctx.fillRect(10, -5, 30, 10);
        // Thermal Sleeve
        ctx.fillStyle = "#37474f"; ctx.fillRect(22, -6, 10, 12); 
        ctx.fillStyle = "#546e7a"; ctx.fillRect(26, -6, 2, 12);
        // Muzzle Brake
        ctx.fillStyle = "#212121";
        ctx.beginPath();
        ctx.moveTo(38, -8); ctx.lineTo(46, -8); 
        ctx.lineTo(48, -6); ctx.lineTo(48, 6);
        ctx.lineTo(46, 8);  ctx.lineTo(38, 8);
        ctx.closePath(); ctx.fill();
        // White Hot Tip
        ctx.fillStyle = "#ffffff"; 
        ctx.fillRect(47, -5, 2, 10);

        // C. Complex Triangular Housing
        // Lower Armor Plate (Darker)
        ctx.fillStyle = "#37474f"; 
        ctx.beginPath();
        ctx.moveTo(16, 0);       // Nose
        ctx.lineTo(0, -10);      // Shoulder
        ctx.lineTo(-10, -18);    // Wing Tip
        ctx.lineTo(-14, -12);    // Cut
        ctx.lineTo(-18, 0);      // Rear
        ctx.lineTo(-14, 12);     // Cut
        ctx.lineTo(-10, 18);     // Wing Tip
        ctx.lineTo(0, 10);       // Shoulder
        ctx.closePath();
        ctx.fill();

        // Upper Armor Plate (Lighter)
        ctx.fillStyle = "#546e7a"; 
        ctx.beginPath();
        ctx.moveTo(14, 0);       
        ctx.lineTo(-12, -8);     
        ctx.lineTo(-16, 0);      
        ctx.lineTo(-12, 8);      
        ctx.closePath();
        ctx.fill();

        // Spine Detail
        ctx.strokeStyle = "rgba(0,0,0,0.2)";
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.moveTo(-16, 0); ctx.lineTo(14, 0); ctx.stroke();

        // Optics / Status Light
        ctx.fillStyle = "#00e676"; 
        ctx.fillRect(-10, -3, 4, 6);

        ctx.restore();
    }
    else if (currentTool === 'mortar') {
        // ... (Existing Mortar Logic) ...
        // 1. Grid Snap Calculations
        let col = Math.floor(mouseX / CELL_SIZE);
        let row = Math.floor(mouseY / CELL_SIZE);
        
        let x = col * CELL_SIZE; 
        let y = row * CELL_SIZE;
        let centerX = x + CELL_SIZE / 2;
        let centerY = y + CELL_SIZE / 2;
        let size = CELL_SIZE;

        // 2. Range Circle (Kept Green as requested)
        ctx.beginPath();
        ctx.fillStyle = "rgba(0, 255, 0, 0.1)";
        ctx.strokeStyle = "rgba(0, 255, 0, 0.5)";
        ctx.arc(centerX, centerY, 550, 0, Math.PI * 2); // Match stats range (550)
        ctx.fill();
        ctx.stroke();

        // 3. Mortar Visuals (Ported from Class)
        ctx.save();
        ctx.translate(centerX, centerY);

        // --- Palette ---
        const cMatteDark = "#2b2b2b";
        const cMatteMid  = "#4a4a4a";
        const cCarbon    = "#1a1a1a";
        const cAccent    = "#ffffff";

        // --- LAYER 1: Industrial Base ---
        ctx.fillStyle = cMatteDark;
        ctx.beginPath();
        for(let i=0; i<8; i++){
            let ang = i * Math.PI / 4;
            ctx.lineTo(size*0.45 * Math.cos(ang), size*0.45 * Math.sin(ang));
        }
        ctx.fill();
        
        ctx.strokeStyle = cMatteMid;
        ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(0,0, size*0.35, 0, Math.PI*2); ctx.stroke();
        
        // Bolts
        ctx.fillStyle = "#111";
        [0, 2, 4, 6].forEach(i => {
            let a = i * Math.PI / 4;
            ctx.beginPath(); 
            ctx.rect(size*0.38*Math.cos(a)-2, size*0.38*Math.sin(a)-2, 4, 4); 
            ctx.fill();
        });

        // --- LAYER 2: THE BARREL ---
        // We simulate the helper functions here locally
        ctx.save();
        ctx.translate(0, size * 0.1); // Pivot offset

        const totalLen = size * 0.9;
        const breechW = size * 0.42;
        const breechH = size * 0.25;

        // 2a. Breech Block
        ctx.fillStyle = cMatteDark;
        ctx.fillRect(-breechW/2, -breechH, breechW, breechH);
        
        // 2b. Barrel Segments (Helper logic inlined for gradients)
        const drawGradCyl = (gx, gy, w, h, c1, c2) => {
            let grad = ctx.createLinearGradient(gx-w/2, 0, gx+w/2, 0);
            grad.addColorStop(0, c2); grad.addColorStop(0.4, c1); 
            grad.addColorStop(0.5, c1); grad.addColorStop(1.0, "#000");
            ctx.fillStyle = grad;
            ctx.fillRect(gx-w/2, gy-h, w, h);
            ctx.fillStyle = "rgba(0,0,0,0.5)";
            ctx.fillRect(gx-w/2, gy-h, w, 1); // Segment line
        };

        const seg1W = size * 0.34; const seg1H = totalLen * 0.3;
        const seg2W = size * 0.26; const seg2H = totalLen * 0.3;
        const seg3W = size * 0.18; const seg3H = totalLen * 0.4;

        // Draw segments (No recoil in preview)
        drawGradCyl(0, -breechH, seg1W, seg1H, cMatteMid, cCarbon);
        drawGradCyl(0, -breechH - seg1H, seg2W, seg2H, "#ffffff", "#888888");
        const tipY = -breechH - seg1H - seg2H;
        drawGradCyl(0, tipY, seg3W, seg3H, cMatteMid, "#000");

        // Muzzle Device
        ctx.fillStyle = cCarbon;
        ctx.fillRect(-seg3W/2 - 2, tipY - seg3H, seg3W + 4, 10);
        ctx.fillStyle = cAccent;
        ctx.fillRect(-2, tipY - seg3H + 4, 4, 2); 

        ctx.restore(); // End Barrel

        // --- LAYER 3: HEAVY SIDE PLATING ---
        const mountW = size * 0.14;
        const mountH = size * 0.5;
        const spread = size * 0.24;

        const drawMount = (mx) => {
            ctx.save();
            ctx.translate(mx, 0);
            ctx.fillStyle = cMatteMid;
            ctx.strokeStyle = "#111";
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(-mountW/2, size/4); 
            ctx.lineTo(-mountW/2, -mountH/4);   
            ctx.lineTo(0, -mountH/2);       
            ctx.lineTo(mountW/2, -mountH/4);    
            ctx.lineTo(mountW/2, size/4);   
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Bolt
            ctx.fillStyle = cMatteDark;
            ctx.beginPath(); ctx.arc(0, size/5, 3, 0, Math.PI*2); ctx.fill();
            // Light
            ctx.fillStyle = cAccent; ctx.fillRect(-2, -mountH/3, 4, 4);
            ctx.restore();
        };

        drawMount(-spread);
        drawMount(spread);

        // --- LAYER 4: The Axle ---
        ctx.fillStyle = "#111";
        ctx.fillRect(-spread, -4, spread*2, 8);

        ctx.restore(); // End Translation
    }
    else if (currentTool === 'trap') {
        // ... (Existing Trap Logic) ...
        // 1. Grid Snap Calculations
        let col = Math.floor(mouseX / CELL_SIZE);
        let row = Math.floor(mouseY / CELL_SIZE);
        let snapX = col * CELL_SIZE + CELL_SIZE / 2;
        let snapY = row * CELL_SIZE + CELL_SIZE / 2;

        ctx.save();
        ctx.translate(snapX, snapY);

        // 2. Trigger Radius (Visual Aid)
        ctx.beginPath();
        ctx.fillStyle = "rgba(255, 50, 50, 0.2)";
        ctx.strokeStyle = "rgba(255, 50, 50, 0.6)";
        ctx.arc(0, 0, 22, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // 3. Trap Visuals (Ready State - Retracted)
        const size = CELL_SIZE - 4;
        const half = size / 2;

        // --- A. Base Plate ---
        ctx.beginPath();
        ctx.moveTo(-half + 6, -half);
        ctx.lineTo(half - 6, -half);
        ctx.lineTo(half, -half + 6);
        ctx.lineTo(half, half - 6);
        ctx.lineTo(half - 6, half);
        ctx.lineTo(-half + 6, half);
        ctx.lineTo(-half, half - 6);
        ctx.lineTo(-half, -half + 6);
        ctx.closePath();

        // Gradient: Titanium/Slate
        let baseGrad = ctx.createLinearGradient(-half, -half, half, half);
        baseGrad.addColorStop(0, "#6a6a70"); 
        baseGrad.addColorStop(1, "#3a3a40"); 
        ctx.fillStyle = baseGrad;
        ctx.fill();
        
        ctx.strokeStyle = "#889"; 
        ctx.lineWidth = 1;
        ctx.stroke();

        // Inner Panel
        ctx.fillStyle = "#222"; 
        ctx.fillRect(-half + 5, -half + 5, size - 10, size - 10);
        ctx.strokeStyle = "#111";
        ctx.strokeRect(-half + 5, -half + 5, size - 10, size - 10);

        // --- B. Spike Housings (Empty/Retracted) ---
        const spikeOffset = 9;
        const spikePositions = [
            {x: -spikeOffset, y: -spikeOffset}, 
            {x: spikeOffset, y: -spikeOffset},  
            {x: -spikeOffset, y: spikeOffset},  
            {x: spikeOffset, y: spikeOffset}    
        ];

        for(let pos of spikePositions) {
            let isBack = pos.y < 0;
            // Draw the empty hole
            ctx.fillStyle = "#111"; 
            ctx.beginPath(); ctx.arc(pos.x, pos.y, 4.5, 0, Math.PI*2); ctx.fill();
            // Draw the rim
            ctx.strokeStyle = isBack ? "#555" : "#777";
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // --- C. Center Light (Green for Ready) ---
        ctx.fillStyle = "#111";
        ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI*2); ctx.fill();

        ctx.fillStyle = "#00ff00"; 
        ctx.beginPath(); ctx.arc(0, 0, 1.5, 0, Math.PI*2); ctx.fill();
        ctx.shadowColor = "#0f0";
        ctx.shadowBlur = 8;
        ctx.fill();
        ctx.shadowBlur = 0;

        ctx.restore();
    }
    else if (currentTool === 'minigun') {
        if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
            const x = col * CELL_SIZE + CELL_SIZE / 2;
            const y = row * CELL_SIZE + CELL_SIZE / 2;
            const isOccupied = grid[col][row].occupied || grid[col][row].wall;
            const canAfford = money >= 400; // Cost matches UI

            ctx.save();
            ctx.translate(x, y);
            ctx.globalAlpha = 0.65; // Ghost transparency

            // --- 1. INDUSTRIAL BASE ---
            // Drop shadow
            ctx.fillStyle = "rgba(0,0,0,0.3)";
            ctx.beginPath(); ctx.arc(2, 2, 22, 0, Math.PI * 2); ctx.fill();

            // Main X-Stand
            ctx.fillStyle = "#1a1a1a";
            
            for(let i=0; i<4; i++) {
                ctx.save(); 
                ctx.rotate((Math.PI/4) + (i * Math.PI/2));
                
                // Leg Strut
                ctx.fillRect(-6, -6, 12, 24); 
                
                // Foot Pad
                ctx.fillStyle ="#333";
                ctx.beginPath();
                ctx.moveTo(-8, 18); ctx.lineTo(8, 18);
                ctx.lineTo(10, 24); ctx.lineTo(-10, 24);
                ctx.fill();
                
                // Bolt
                ctx.fillStyle = "#555";
                ctx.beginPath(); ctx.arc(0, 12, 2, 0, Math.PI*2); ctx.fill();
                
                ctx.restore();
            }

            // Central Bearing Ring
            ctx.fillStyle = "#222";
            ctx.beginPath(); ctx.arc(0,0, 16, 0, Math.PI*2); ctx.fill();
            ctx.strokeStyle = "#444"; ctx.lineWidth = 2; ctx.stroke();
            
            // Rivets
            ctx.fillStyle = "#666";
            for(let i=0; i<8; i++){
                let ra = i * (Math.PI*2)/8;
                ctx.beginPath(); ctx.arc(Math.cos(ra)*12, Math.sin(ra)*12, 1.5, 0, Math.PI*2); ctx.fill();
            }

            // --- 2. AMMO SYSTEM ---
            const ammoX = -28;
            const ammoY = 18;
            const angle = 0; // Static angle for blueprint
            
            let feedPortX = Math.cos(angle - 0.5) * 8; 
            let feedPortY = Math.sin(angle - 0.5) * 8;

            // Belt Curve
            ctx.beginPath();
            ctx.moveTo(ammoX, ammoY);
            ctx.quadraticCurveTo(ammoX, ammoY - 25, feedPortX, feedPortY);
            
            ctx.lineWidth = 7; ctx.strokeStyle = "#111"; ctx.stroke(); 
            ctx.lineWidth = 4; ctx.strokeStyle = "#d4af37"; ctx.setLineDash([2, 3]); ctx.stroke(); 
            ctx.setLineDash([]);

            // Ammo Box
            ctx.fillStyle = "#2f3f2f";
            ctx.fillRect(ammoX - 10, ammoY - 10, 24, 20);
            ctx.fillStyle = "#4a5b4a"; 
            ctx.fillRect(ammoX - 8, ammoY - 12, 20, 4);

            // --- 3. TURRET HEAD (Static) ---
            ctx.rotate(angle);

            // Rear Motor Housing
            ctx.fillStyle = "#222";
            ctx.beginPath();
            ctx.arc(-12, 0, 11, Math.PI/2, -Math.PI/2); 
            ctx.fill();
            ctx.fillRect(-12, -11, 10, 22);

            // Main Receiver Body
            ctx.fillStyle = "#3a3a3a"; 
            ctx.beginPath();
            ctx.moveTo(-5, -10);
            ctx.lineTo(15, -10);
            ctx.lineTo(15, 10);
            ctx.lineTo(-5, 10);
            ctx.fill();
            
            ctx.fillStyle = "#1a1a1a";
            ctx.fillRect(-2, -11, 6, 22);

            // Barrel Bundle
            const bW = 46; const bH = 14; const bX = 15; const bY = -bH/2;
            ctx.fillStyle = "#050505";
            ctx.fillRect(bX, bY, bW, bH);

            // Static Barrels (No heat color)
            ctx.fillStyle = "#444"; 
            const spacing = 5;
            for(let i = -spacing; i < bH + spacing; i += spacing) {
                let yPos = bY + i;
                if(yPos < bY + bH && yPos > bY) {
                     ctx.fillRect(bX, yPos, bW, 2);
                }
            }

            // Barrel Details
            ctx.fillStyle = "#222";
            ctx.fillRect(bX + 20, bY - 1, 4, bH + 2); // Clamp
            ctx.fillStyle = "#111";
            ctx.fillRect(bX + bW - 2, bY - 1, 3, bH + 2); // Muzzle

            ctx.restore();

            // --- 4. RANGE INDICATOR ---
            ctx.beginPath();
            ctx.arc(x, y, 280, 0, Math.PI * 2); // Range matches class stats (280)
            ctx.strokeStyle ="rgba(255, 255, 255, 0.5)";
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }
    else if (currentTool === 'money_farm') {
        // ... (Existing Money Farm Logic) ...
        if (col >= 0 && col < COLS - 1 && row >= 0 && row < ROWS - 1) {
            // Calculate center coordinates based on the grid column/row
            let x = col * CELL_SIZE;
            let y = row * CELL_SIZE;
            let cx = x + CELL_SIZE;
            let cy = y + CELL_SIZE;
            let radius = CELL_SIZE - 5;

            ctx.save(); // Save context to handle transparency safely
            ctx.globalAlpha = 0.7; // Make the whole preview slightly transparent

            // --- 1. BASE PAD (Static) ---
            ctx.fillStyle = "#1a1a22";
            ctx.beginPath();
            ctx.arc(cx, cy, radius, 0, Math.PI * 2);
            ctx.fill();

            // --- 2. TECH PATTERNS (Static) ---
            ctx.strokeStyle = "#330066";
            ctx.lineWidth = 2;
            ctx.beginPath();
            // Inner rings
            ctx.arc(cx, cy, radius * 0.8, 0, Math.PI * 2);
            ctx.arc(cx, cy, radius * 0.5, 0, Math.PI * 2);
            // Spokes
            for (let i = 0; i < 8; i++) {
                let angle = (Math.PI / 4) * i;
                ctx.moveTo(cx + Math.cos(angle) * (radius * 0.5), cy + Math.sin(angle) * (radius * 0.5));
                ctx.lineTo(cx + Math.cos(angle) * radius, cy + Math.sin(angle) * radius);
            }
            ctx.stroke();

            // --- 3. GAUGE TRACK (Empty/Static) ---
            // Just drawing the background track, no progress fill
            let gaugeRadius = radius * 0.75;
            ctx.strokeStyle = "rgba(100, 0, 200, 0.4)";
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.arc(cx, cy, gaugeRadius, 0, Math.PI * 2);
            ctx.stroke();

            // --- 4. THE PLANT (Static/No Rotation) ---
            let plantSize = radius * 0.4;
            
            // Outer Petals
            ctx.fillStyle = "#7700aa"; // Static dark crystal color
            ctx.beginPath();
            for (let i = 0; i < 8; i += 2) {
                let angle = (Math.PI * 2 / 8) * i; // Fixed angle (no rotation)
                ctx.moveTo(cx, cy);
                ctx.lineTo(cx + Math.cos(angle - 0.3) * plantSize, cy + Math.sin(angle - 0.3) * plantSize);
                ctx.lineTo(cx + Math.cos(angle) * plantSize * 1.2, cy + Math.sin(angle) * plantSize * 1.2);
                ctx.lineTo(cx + Math.cos(angle + 0.3) * plantSize, cy + Math.sin(angle + 0.3) * plantSize);
            }
            ctx.fill();

            // Inner Core (Static size, no pulse)
            ctx.fillStyle = "#ff00aa"; // Static magenta
            ctx.beginPath();
            let coreSize = plantSize * 0.5;
            for (let i = 0; i < 6; i++) {
                let angle = (Math.PI * 2 / 6) * i;
                let px = cx + Math.cos(angle) * coreSize;
                let py = cy + Math.sin(angle) * coreSize;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.fill();

            // --- 5. SELECTION BORDER ---
            // Keeps the user aware of the 2x2 footprint
            ctx.strokeStyle = "rgba(0, 255, 255, 0.5)";
            ctx.lineWidth = 2;
            ctx.strokeRect(x, y, CELL_SIZE * 2, CELL_SIZE * 2);

            ctx.restore(); // Restore context to remove transparency
        }
    }
    else if (currentTool === 'bounty') {
        // 1. Grid Snap Calculations
        let col = Math.floor(mouseX / CELL_SIZE);
        let row = Math.floor(mouseY / CELL_SIZE);
        let snapX = col * CELL_SIZE + CELL_SIZE / 2;
        let snapY = row * CELL_SIZE + CELL_SIZE / 2;

        ctx.save();
        ctx.translate(snapX, snapY);

        // 2. Trigger Radius (150 range)
        ctx.beginPath();
        ctx.fillStyle = "rgba(0, 210, 255, 0.15)"; // Neon blue tint
        ctx.strokeStyle = "rgba(0, 210, 255, 0.5)";
        ctx.arc(0, 0, 150, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // 3. Bounty Tower Visuals (Blueprint preview)
        ctx.globalAlpha = 0.8; // Make it slightly transparent 
        
        // Draw Tower Base
        ctx.fillStyle = "#222";
        ctx.fillRect(-15, -15, 30, 30);

        // Draw Roof (Closed state)
        ctx.fillStyle = "#00d2ff"; // Neon blue roof
        // Left Roof Half
        ctx.fillRect(-15, -15, 15, 30);
        // Right Roof Half
        ctx.fillRect(0, -15, 15, 30);
        
        // Draw a slight seam line down the middle where it opens
        ctx.strokeStyle = "#050505";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, -15);
        ctx.lineTo(0, 15);
        ctx.stroke();

        ctx.restore();
    }
    else if (currentTool === 'cryo_tower') {
        if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
            const x = col * CELL_SIZE + CELL_SIZE / 2;
            const y = row * CELL_SIZE + CELL_SIZE / 2;
            const isOccupied = grid[col][row].occupied || grid[col][row].wall;
            const canAfford = money >= 150; // Adjust cost to match your UI

            ctx.save();
            ctx.translate(x, y);
            ctx.globalAlpha = 0.5; // Transparent "Ghost" mode

            // Note: We do NOT tint it red for invalid placement, 
            // keeping natural colors as requested.

            // --- 1. FROST AURA FLOOR ---
            const r = 160 * (hasSkill('cryo_range') ? 1.25 : 1); // Range
            let grad = ctx.createRadialGradient(0, 0, 10, 0, 0, r * 0.7);
            grad.addColorStop(0, "rgba(200, 240, 255, 0.1)");
            grad.addColorStop(1, "rgba(0, 0, 0, 0)");
            ctx.fillStyle = grad;
            ctx.beginPath(); ctx.arc(0, 0, r, 0, Math.PI*2); ctx.fill();

            // --- 2. STATIC BASE ---
            // Tech Rune Ring
            ctx.strokeStyle = "rgba(0, 225, 255, 0.3)";
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]); 
            ctx.beginPath(); ctx.arc(0, 0, 25, 0, Math.PI*2); ctx.stroke();
            ctx.setLineDash([]); 

            // Ice Floor Cracks
            ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
            for(let i=0; i<8; i++) {
                ctx.save();
                ctx.rotate((i / 8) * Math.PI * 2);
                ctx.beginPath();
                ctx.moveTo(6, 0); 
                ctx.lineTo(18, 0); 
                ctx.stroke();
                ctx.restore();
            }

            // Mechanical Base Legs
            ctx.fillStyle = "#546e7a"; 
            for (let i = 0; i < 3; i++) {
                ctx.save();
                ctx.rotate((i * Math.PI * 2) / 3);
                ctx.beginPath();
                ctx.moveTo(-3, 5); ctx.lineTo(3, 5);
                ctx.lineTo(5, 14); ctx.lineTo(-5, 14);
                ctx.fill();
                ctx.fillStyle = "#00e5ff";
                ctx.fillRect(-1.5, 10, 3, 2); 
                ctx.fillStyle = "#546e7a";
                ctx.restore();
            }

            // --- 3. THE CRYSTAL (Floating) ---
            ctx.translate(0, -12); // Static hover height

            // Glow (Simple radial, no heavy shadowBlur)
            let glow = ctx.createRadialGradient(0, 0, 0, 0, 0, 20);
            glow.addColorStop(0, `rgba(0, 255, 255, 0.3)`);
            glow.addColorStop(1, "rgba(0, 255, 255, 0)");
            ctx.fillStyle = glow;
            ctx.beginPath(); ctx.arc(0, 0, 20, 0, Math.PI*2); ctx.fill();

            // Crystal Shape
            // Re-create gradient locally for the blueprint
            let crystalGrad = ctx.createLinearGradient(-6, -12, 6, 12);
            crystalGrad.addColorStop(0, "#e0f7fa");
            crystalGrad.addColorStop(0.5, "#00bcd4"); 
            crystalGrad.addColorStop(1, "#006064");
            ctx.fillStyle = crystalGrad;

            ctx.beginPath();
            ctx.moveTo(0, -14); ctx.lineTo(7, 0); ctx.lineTo(0, 14); ctx.lineTo(-7, 0);
            ctx.closePath();
            ctx.fill();
            
            ctx.strokeStyle = "rgba(255,255,255,0.9)";
            ctx.lineWidth = 1;
            ctx.stroke();

            // Inner Core
            ctx.fillStyle = "#ffffff";
            ctx.beginPath();
            ctx.rect(-3.5, -3.5, 7, 7); 
            ctx.fill();

            // Orbit Ring
            ctx.save();
            ctx.scale(1, 0.35); 
            ctx.strokeStyle = `rgba(0, 229, 255, 0.6)`;
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI*2); 
            ctx.stroke();
            ctx.restore();

            ctx.restore(); // Restore main context

            // --- 4. RANGE INDICATOR ---
            // Only the range line indicates validity (Red/White)
            ctx.beginPath();
            ctx.arc(x, y, 160, 0, Math.PI * 2);
            ctx.strokeStyle ="rgba(255, 255, 255, 0.5)";
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
        }
    }
}

function createExplosion(x, y, damage = 50, blastRadius = 60) {
    // 1. VISUALS
    // Add a simple particle burst if you have a particle system, otherwise just the circle
    if (typeof particles !== 'undefined') {
        // Example: Orange sparks
        for(let i=0; i<8; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10,
                life: 20, color: "orange"
            });
        }
    }
    
    // Draw the blast circle (flash)
    ctx.fillStyle = "rgba(255, 100, 0, 0.5)";
    ctx.beginPath();
    ctx.arc(x, y, blastRadius, 0, Math.PI * 2); 
    ctx.fill();

    // 2. DAMAGE LOGIC
    if (typeof enemies === 'undefined') return;

    for (let enemy of enemies) {
        // Safety Check
        if (!enemy || enemy.hp <= 0) continue;

        let dist = Math.hypot(enemy.x - x, enemy.y - y);

        // Check if inside explosion range
        if (dist < blastRadius) {
            if (enemy.isInvincible) {
                // BLOCKED!
                if (typeof createParticles === 'function') {
                    createParticles(enemy.x, enemy.y, "#00d2ff", 5); 
                }
            } else {
                // FIXED: Use the argument 'damage', not 'this.damage'
                enemy.hp -= damage;
            }
        }
    }
}

class Trap {
    constructor(x, y) {
        this.col = Math.floor(x / CELL_SIZE);
        this.row = Math.floor(y / CELL_SIZE);
        this.x = this.col * CELL_SIZE + CELL_SIZE / 2;
        this.y = this.row * CELL_SIZE + CELL_SIZE / 2;

        this.type = "TRAP";
        this.hp = 150;
        this.damage = 80 * (hasSkill('spike_dmg') ? 1.5 : 1.0);
        this.radius = 22;
        
        this.state = "READY";
        this.cooldown = 0;
        this.maxCooldown = 160;
    }

    update(dt) {
        if (this.state === "COOLDOWN") {
            this.cooldown--;
            if (this.cooldown <= 0) {
                this.state = "READY";
            }
        } 
        else if (this.state === "READY") {
            for (let e of enemies) {
                let d = Math.hypot(e.x - this.x, e.y - this.y);
                if (d < this.radius) {
                    this.trigger();
                    break; 
                }
            }
        }
    }

    trigger() {
        this.state = "COOLDOWN";
        this.cooldown = this.maxCooldown;

        if(typeof createParticles === 'function') {
            createParticles(this.x, this.y, "#ffffff", 8);
            createParticles(this.x, this.y, "#888888", 6);
        }

        for (let e of enemies) {
            let d = Math.hypot(e.x - this.x, e.y - this.y);
            if (d < this.radius + 8) { 
                e.hp -= this.damage;
                e.vx += (Math.random() - 0.5) * 10; 
                e.vy += (Math.random() - 0.5) * 10;
            }
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);

        // --- 1. TITANIUM BASE (Lighter for visibility) ---
        const size = CELL_SIZE - 4;
        const half = size / 2;

        // Base Plate Shape
        ctx.beginPath();
        ctx.moveTo(-half + 6, -half);
        ctx.lineTo(half - 6, -half);
        ctx.lineTo(half, -half + 6);
        ctx.lineTo(half, half - 6);
        ctx.lineTo(half - 6, half);
        ctx.lineTo(-half + 6, half);
        ctx.lineTo(-half, half - 6);
        ctx.lineTo(-half, -half + 6);
        ctx.closePath();

        // Gradient: Mid-Grey to Slate (Contrast against black BG)
        let baseGrad = ctx.createLinearGradient(-half, -half, half, half);
        baseGrad.addColorStop(0, "#6a6a70"); // Lighter top-left
        baseGrad.addColorStop(1, "#3a3a40"); // Darker bottom-right
        ctx.fillStyle = baseGrad;
        ctx.fill();

        // Bright Edge Highlight
        ctx.strokeStyle = "#889"; 
        ctx.lineWidth = 1;
        ctx.stroke();

        // Inner Panel (Darker but not black)
        ctx.fillStyle = "#222"; 
        ctx.fillRect(-half + 5, -half + 5, size - 10, size - 10);
        ctx.strokeStyle = "#111";
        ctx.strokeRect(-half + 5, -half + 5, size - 10, size - 10);

        // --- 2. SPIKE HOUSINGS ---
        const spikeOffset = 9;
        const spikePositions = [
            {x: -spikeOffset, y: -spikeOffset}, 
            {x: spikeOffset, y: -spikeOffset},  
            {x: -spikeOffset, y: spikeOffset},  
            {x: spikeOffset, y: spikeOffset}    
        ];

        for(let pos of spikePositions) {
            let isBack = pos.y < 0;

            // Housing Hole
            ctx.fillStyle = "#111"; // Not pure black
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 4.5, 0, Math.PI*2);
            ctx.fill();
            
            // Bright Rim (So holes are visible on the dark panel)
            ctx.strokeStyle = isBack ? "#555" : "#777";
            ctx.lineWidth = 1;
            ctx.stroke();
        }

        // --- 3. ANIMATION LOGIC ---
        let extension = 0;
        if (this.state === "COOLDOWN") {
            let pct = this.cooldown / this.maxCooldown;
            if (pct > 0.85) extension = (1 - pct) / 0.15; 
            else if (pct > 0.3) extension = 1.0;          
            else extension = pct / 0.3;                   
        }

        // --- 4. HIGH-CONTRAST SPIKES ---
        if (extension > 0.01) {
            const h = 24 * extension; 
            const w = 3;              

            for(let pos of spikePositions) {
                let sx = pos.x;
                let sy = pos.y;
                let tipY = sy - h;
                let isBack = sy < 0;

                // Shadow
                ctx.fillStyle = "rgba(0,0,0,0.6)";
                ctx.beginPath();
                ctx.ellipse(sx, sy + 3, w+1, w/1.5, 0, 0, Math.PI*2);
                ctx.fill();

                // Spike Gradient (Much brighter now)
                let steelGrad = ctx.createLinearGradient(sx - w, sy, sx + w, sy);
                
                if (isBack) {
                    // Back Row: Medium Steel
                    steelGrad.addColorStop(0.0, "#222");
                    steelGrad.addColorStop(0.2, "#444");
                    steelGrad.addColorStop(0.4, "#aaa"); // Highlight
                    steelGrad.addColorStop(0.7, "#666");
                    steelGrad.addColorStop(1.0, "#222");
                } else {
                    // Front Row: Bright Chrome
                    steelGrad.addColorStop(0.0, "#333");
                    steelGrad.addColorStop(0.2, "#666");
                    steelGrad.addColorStop(0.4, "#fff"); // Pure white shine
                    steelGrad.addColorStop(0.7, "#999");
                    steelGrad.addColorStop(1.0, "#333");
                }

                ctx.fillStyle = steelGrad;
                ctx.beginPath();
                ctx.moveTo(sx - w, sy);
                ctx.lineTo(sx + w, sy);
                ctx.lineTo(sx + w, tipY + 5); 
                ctx.lineTo(sx, tipY);       
                ctx.lineTo(sx - w, tipY + 5); 
                ctx.fill();
            }
        }

        // --- 5. CENTER INDICATOR (Bright LED) ---
        ctx.fillStyle = "#111";
        ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI*2); ctx.fill();

        // Neon Green or Bright Red
        let lightColor = (this.state === "READY") ? "#00ff00" : "#ff3333"; 
        ctx.fillStyle = lightColor;
        ctx.beginPath(); ctx.arc(0, 0, 1.5, 0, Math.PI*2); ctx.fill();
        
        if (this.state === "READY") {
            ctx.shadowColor = "#0f0";
            ctx.shadowBlur = 8; // Stronger glow
            ctx.fill();
            ctx.shadowBlur = 0;
        }

        ctx.restore();
    }
}

class CryoTower {
    constructor(col, row) {
        this.col = col;
        this.row = row;
        this.x = col * CELL_SIZE + CELL_SIZE / 2;
        this.y = row * CELL_SIZE + CELL_SIZE / 2;
        this.type = "CRYO";
        this.range = 160 * (hasSkill('cryo_range') ? 1.25 : 1);
        this.slowFactor = 0.5 + (hasSkill('cryo_slow') ? 0.15 : 0);

        // Animation State
        this.hoverY = 0;
        this.hoverTime = Math.random() * 100;
        this.spin = 0;
        this.pulse = 0;
        this.isFiring = false; 

        // --- OPTIMIZATION 1: RENDER STATIC BASE ONCE (Per instance) ---
        this.cacheCanvas = document.createElement('canvas');
        this.cacheCanvas.width = this.range * 2;
        this.cacheCanvas.height = this.range * 2;
        this.cacheCtx = this.cacheCanvas.getContext('2d');
        this.renderStaticBase(); 

        // --- OPTIMIZATION 2: INIT SHARED ASSETS (Run once for the whole class) ---
        // We create the heavy "Frost Field" and "Crystal Gradient" only once.
        // All CryoTowers will share these images instead of recalculating them.
        if (!CryoTower.cachedField) {
            CryoTower.createSharedAssets(this.range);
        }
    }

    // This creates the heavy graphics once and stores them in static properties
    static createSharedAssets(range) {
        // A. Cache the Frost Field (The big blue circle)
        const size = range * 2;
        const canvas = document.createElement('canvas');
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext('2d');
        const cx = range; 
        const cy = range;

        // 1. The Outer Ring
        ctx.beginPath();
        ctx.arc(cx, cy, range - 2, 0, Math.PI * 2); // -2 to keep inside canvas
        ctx.strokeStyle = "rgb(100, 240, 255)"; // Base color, opacity handled in draw
        ctx.lineWidth = 2;
        ctx.stroke();

        // 2. The Inner Gradient
        let grad = ctx.createRadialGradient(cx, cy, 10, cx, cy, range);
        grad.addColorStop(0, "rgba(255, 255, 255, 0)"); 
        grad.addColorStop(0.6, "rgba(0, 200, 255, 0.1)");
        grad.addColorStop(1, "rgba(200, 240, 255, 0.25)");
        ctx.fillStyle = grad;
        ctx.fill();

        CryoTower.cachedField = canvas;

        // B. Cache the Crystal Gradient (The teal look)
        // We create a tiny canvas just to generate the gradient object or store the data
        // Actually, we can just store the gradient function logic or create it on a temp canvas
        const gCanvas = document.createElement('canvas');
        const gCtx = gCanvas.getContext('2d');
        let crystalGrad = gCtx.createLinearGradient(-6, -12, 6, 12);
        crystalGrad.addColorStop(0, "#e0f7fa");
        crystalGrad.addColorStop(0.5, "#00bcd4"); 
        crystalGrad.addColorStop(1, "#006064");
        CryoTower.cachedCrystalGrad = crystalGrad;
    }

    renderStaticBase() {
        const c = this.cacheCtx;
        const r = this.range;
        const cx = r; 
        const cy = r; 

        // 1. Frost Aura Floor
        let grad = c.createRadialGradient(cx, cy, 10, cx, cy, r * 0.7);
        grad.addColorStop(0, "rgba(200, 240, 255, 0.1)");
        grad.addColorStop(1, "rgba(0, 0, 0, 0)");
        c.fillStyle = grad;
        c.beginPath(); c.arc(cx, cy, r, 0, Math.PI*2); c.fill();

        // 2. Tech Rune Ring
        c.save();
        c.translate(cx, cy);
        c.strokeStyle = "rgba(0, 225, 255, 0.15)";
        c.lineWidth = 1;
        c.setLineDash([4, 4]); 
        c.beginPath(); c.arc(0, 0, 25, 0, Math.PI*2); c.stroke();
        c.setLineDash([]); 
        c.restore();

        // 3. Ice Floor Cracks
        c.strokeStyle = "rgba(255, 255, 255, 0.4)";
        c.lineWidth = 1; 
        for(let i=0; i<8; i++) {
            c.save();
            c.translate(cx, cy);
            c.rotate((i / 8) * Math.PI * 2);
            c.beginPath();
            c.moveTo(6, 0); 
            c.lineTo(18 + Math.random() * 5, (Math.random()-0.5) * 4); 
            c.stroke();
            c.restore();
        }

        // 4. Mechanical Base Legs
        c.translate(cx, cy);
        c.fillStyle = "#546e7a"; 
        for (let i = 0; i < 3; i++) {
            c.save();
            c.rotate((i * Math.PI * 2) / 3);
            c.beginPath();
            c.moveTo(-3, 5); c.lineTo(3, 5);
            c.lineTo(5, 14); c.lineTo(-5, 14);
            c.fill();
            c.fillStyle = "#00e5ff";
            c.fillRect(-1.5, 10, 3, 2); 
            c.fillStyle = "#546e7a";
            c.restore();
        }
    }

    update(dt) {
        if (this.hp <= 0) this.active = false;
        // Assuming 'grid' and 'enemies' are global variables
        if (!grid[this.col][this.row].occupied) this.active = false;
        this.hoverTime += 0.05 *dt;
        this.hoverY = Math.sin(this.hoverTime) * 3;
        
        let spinSpeed = this.isFiring ? 0.10 : 0.02;
        this.spin += spinSpeed;
        this.pulse = (Math.sin(this.hoverTime * 3) + 1) / 2; 

        this.isFiring = false; 

        // Optimization: Simple distance check
        for (let e of enemies) {
            // Pre-check rect collision (faster than hypot) to skip far enemies
            if (Math.abs(e.x - this.x) > this.range || Math.abs(e.y - this.y) > this.range) continue;

            let dist = Math.hypot(e.x - this.x, e.y - this.y);
            if (dist < this.range) {
                e.isSlowed = true;
                this.isFiring = true; 
                
                if (Math.random() < 0.05 && typeof createParticles === 'function') {
                    createParticles(e.x, e.y, "#caf0f8", 1); 
                }
            }
        }
    }

    drawFrostField() {
        if (!this.isFiring) return;

        // Optimization: Draw the Pre-rendered image instead of calculating gradient
        ctx.globalAlpha = 0.3 + (this.pulse * 0.2); // Pulse opacity
        ctx.drawImage(CryoTower.cachedField, this.x - this.range, this.y - this.range);
        ctx.globalAlpha = 1.0; // Reset
    }

    draw() {
        // 1. Static Base (Cached instance)
        ctx.drawImage(this.cacheCanvas, this.x - this.range, this.y - this.range);

        // 2. Frost Field (Cached shared)
        this.drawFrostField();

        // 3. The Crystal
        ctx.save();
        ctx.translate(this.x, this.y + this.hoverY - 12); 

        // OPTIMIZATION: "Fake" Glow using Radial Gradient instead of shadowBlur
        // shadowBlur is very laggy. This looks 95% the same but is instant.
        const glowSize = this.isFiring ? 30 : 20;
        const glowOpacity = this.isFiring ? 0.6 : 0.3;
        
        // Draw the glow *behind* the crystal
        let glow = ctx.createRadialGradient(0, 0, 0, 0, 0, glowSize);
        glow.addColorStop(0, `rgba(0, 255, 255, ${glowOpacity})`);
        glow.addColorStop(1, "rgba(0, 255, 255, 0)");
        ctx.fillStyle = glow;
        ctx.beginPath(); 
        ctx.arc(0, 0, glowSize, 0, Math.PI*2); 
        ctx.fill();

        ctx.globalCompositeOperation = "lighter"; 
        
        // Rotating Shell
        ctx.save();
        ctx.rotate(this.spin);
        
        // Use the SHARED Cached Gradient
        ctx.fillStyle = CryoTower.cachedCrystalGrad;
        
        ctx.beginPath();
        ctx.moveTo(0, -14); ctx.lineTo(7, 0); ctx.lineTo(0, 14); ctx.lineTo(-7, 0);
        ctx.closePath();
        ctx.fill();
        
        ctx.strokeStyle = "rgba(255,255,255,0.9)";
        ctx.lineWidth = 1;
        ctx.stroke();
        ctx.restore();

        // Inner Core
        ctx.save();
        ctx.rotate(-this.spin * 1.5); 
        ctx.fillStyle = "#ffffff";
        ctx.globalAlpha = 0.8 + (this.pulse * 0.2); 
        ctx.beginPath();
        ctx.rect(-3.5, -3.5, 7, 7); 
        ctx.fill();
        ctx.restore();

        // Rings
        ctx.globalCompositeOperation = "source-over"; 
        // Removed shadowBlur here too
        
        ctx.save();
        ctx.scale(1, 0.35); 
        ctx.strokeStyle = `rgba(0, 229, 255, ${0.4 + this.pulse * 0.4})`;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(0, 0, 20, 0, Math.PI*2); 
        ctx.stroke();
        ctx.restore();

        ctx.restore();
    }
}

class WallTurret {
    constructor(col, row, angle) {
        // Positioning
        this.col = col;
        this.row = row;
        this.x = col * CELL_SIZE + CELL_SIZE / 2;
        this.y = row * CELL_SIZE + CELL_SIZE / 2;

        // Angles
        this.baseAngle = angle;    
        this.headAngle = angle;    
        this.fov = 120 * (Math.PI / 180); 

        // Combat Stats
        this.range = 400 * (hasSkill('turret_range') ? 1.4 : 1); 
        this.damage = 75 + (hasSkill('turret_dmg') ? 25 : 0); 
        this.cooldown = 0;
        this.maxCooldown = 90 * (hasSkill('turret_fire_rate') ? 0.8 : 1.0); 
        this.active = true;

        // Health
        this.hp = 300; 

        // Visual States
        this.recoil = 0;       
        this.flashTimer = 0;   
    }

    update(dt) {
        let cell = grid[this.col][this.row];

        // 1. DEATH CHECK
        if (!cell.wall) {
            this.active = false;
            createParticles(this.x, this.y, "#333", 12); 
            return;
        }

        this.hp = cell.wallHp;

        // 2. TIMERS
        if (this.cooldown > 0) this.cooldown--;
        if (this.recoil > 0) this.recoil -= 0.5; 
        if (this.flashTimer > 0) this.flashTimer--; 

        // 3. TARGETING
        let targetAngle = this.baseAngle; 
        
        for (let e of enemies) {
            let dx = e.x - this.x;
            let dy = e.y - this.y;
            let dist = Math.hypot(dx, dy);

            if (dist < this.range) {
                let angleToEnemy = Math.atan2(dy, dx);
                let diff = angleToEnemy - this.baseAngle;
                while (diff < -Math.PI) diff += Math.PI * 2;
                while (diff > Math.PI) diff -= Math.PI * 2;

                if (Math.abs(diff) < this.fov / 2) {
                    targetAngle = angleToEnemy; 

                    // FIRE LOGIC
                    if (this.cooldown <= 0) {
                        projectiles.push(new Bullet(this.x, this.y, e, this.damage, 1.8));
                        
                        this.cooldown = this.maxCooldown;
                        this.recoil = 14;     
                        this.flashTimer = 6; 
                        
                        // Muzzle debris
                        let tipX = this.x + Math.cos(this.headAngle) * 40;
                        let tipY = this.y + Math.sin(this.headAngle) * 40;
                        createParticles(tipX, tipY, "#ff9800", 6); 
                        createParticles(tipX, tipY, "#777", 4);    
                    }
                    break; 
                }
            }
        }

        // 4. SMOOTH ROTATION
        let rotDiff = targetAngle - this.headAngle;
        while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
        while (rotDiff > Math.PI) rotDiff -= Math.PI * 2;
        this.headAngle += rotDiff * 0.15; 
    }

    draw() {
        // --- LAYER 1: HEAVY MOUNT ---
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.baseAngle); 
        
        // Base Shadow
        ctx.fillStyle = "rgba(0,0,0,0.6)"; 
        ctx.beginPath(); ctx.arc(0, 0, 16, 0, Math.PI*2); ctx.fill();

        // Industrial Hex Base
        ctx.fillStyle = "#263238"; 
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            ctx.lineTo(15 * Math.cos(i * Math.PI / 3), 15 * Math.sin(i * Math.PI / 3));
        }
        ctx.fill();
        ctx.strokeStyle = "#37474f"; ctx.lineWidth = 3;
        ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI*2); ctx.stroke();
        ctx.restore();


        // --- LAYER 2: THE TRIANGULAR TANK KILLER ---
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.headAngle);

        // A. Laser Rangefinder (CHANGED TO WHITE)
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(this.range, 0);
        ctx.strokeStyle = "rgba(255, 255, 255, 0.3)"; // White beam
        ctx.lineWidth = 1;
        ctx.setLineDash([20, 20]); ctx.stroke(); ctx.setLineDash([]); 

        // B. Shadow 
        ctx.fillStyle = "rgba(0,0,0,0.5)"; 
        ctx.beginPath();
        ctx.moveTo(14, 0); ctx.lineTo(-12, -16); ctx.lineTo(-12, 16);
        ctx.fill();

        // C. RECOIL
        let kick = -this.recoil; 

        // --- D. THE HEAVY CANNON ---
        ctx.fillStyle = "#1c1c1c"; ctx.fillRect(0 + kick, -7, 12, 14); // Breech
        ctx.fillStyle = "#455a64"; ctx.fillRect(10 + kick, -5, 30, 10); // Barrel
        
        // Thermal Sleeve
        ctx.fillStyle = "#37474f"; ctx.fillRect(22 + kick, -6, 10, 12); 
        ctx.fillStyle = "#546e7a"; ctx.fillRect(26 + kick, -6, 2, 12);

        // Muzzle Brake
        ctx.fillStyle = "#212121";
        ctx.beginPath();
        ctx.moveTo(38 + kick, -8); ctx.lineTo(46 + kick, -8); 
        ctx.lineTo(48 + kick, -6); ctx.lineTo(48 + kick, 6);
        ctx.lineTo(46 + kick, 8);  ctx.lineTo(38 + kick, 8);
        ctx.closePath(); ctx.fill();
        
        // Heat Tip (CHANGED TO WHITE)
        ctx.fillStyle = "#ffffff"; // Pure White (White Hot Metal)
        ctx.shadowColor = "white"; 
        ctx.shadowBlur = 5;
        ctx.fillRect(47 + kick, -5, 2, 10);
        ctx.shadowBlur = 0; // Reset shadow

        // --- E. COMPLEX TRIANGULAR HOUSING ---
        
        // 1. Lower Armor Plate (Wide Delta Wing)
        ctx.fillStyle = "#37474f"; 
        ctx.beginPath();
        ctx.moveTo(16 + kick, 0);       
        ctx.lineTo(0 + kick, -10);      
        ctx.lineTo(-10 + kick, -18);    
        ctx.lineTo(-14 + kick, -12);    
        ctx.lineTo(-18 + kick, 0);      
        ctx.lineTo(-14 + kick, 12);     
        ctx.lineTo(-10 + kick, 18);     
        ctx.lineTo(0 + kick, 10);       
        ctx.closePath();
        ctx.fill();

        // 2. Upper Armor Plate (Raised Central Arrow)
        ctx.fillStyle = "#546e7a"; 
        ctx.beginPath();
        ctx.moveTo(14 + kick, 0);       
        ctx.lineTo(-12 + kick, -8);     
        ctx.lineTo(-16 + kick, 0);      
        ctx.lineTo(-12 + kick, 8);      
        ctx.closePath();
        ctx.fill();

        // 3. Central Spine
        ctx.strokeStyle = "rgba(0,0,0,0.2)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-16 + kick, 0); ctx.lineTo(14 + kick, 0);
        ctx.stroke();

        // 4. Side Vents
        ctx.fillStyle = "#263238"; 
        ctx.beginPath(); ctx.moveTo(-8 + kick, -14); ctx.lineTo(-4 + kick, -12); ctx.lineTo(-8 + kick, -10); ctx.fill();
        ctx.beginPath(); ctx.moveTo(-8 + kick, 14); ctx.lineTo(-4 + kick, 12); ctx.lineTo(-8 + kick, 10); ctx.fill();

        // 5. Optics (Status light changed to White for cooldown)
        ctx.fillStyle = this.cooldown > 0 ? "#ff0000" : "#00e676"; 
        ctx.fillRect(-10 + kick, -3, 4, 6);
        

        // F. MUZZLE FLASH
        if (this.flashTimer > 0) {
            ctx.fillStyle = "#fff";
            ctx.beginPath(); ctx.ellipse(50 + kick, 0, 10, 6, 0, 0, Math.PI*2); ctx.fill();
            
            ctx.fillStyle = `rgba(255, 160, 0, ${this.flashTimer / 5})`; 
            let size = 15 + Math.random() * 5;
            ctx.beginPath(); ctx.arc(52 + kick, 0, size, 0, Math.PI*2); ctx.fill();
            
            ctx.strokeStyle = `rgba(255, 200, 50, ${this.flashTimer / 5})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(48+kick, -5); ctx.lineTo(65+kick, -15);
            ctx.moveTo(48+kick, 5); ctx.lineTo(65+kick, 15);
            ctx.stroke();
        }
        ctx.restore();


        // --- LAYER 3: HEALTH BAR ---
        let maxHp = 300; 
        if (this.hp < maxHp && this.hp > 0) {
            let hpPct = Math.max(0, this.hp / maxHp);
            ctx.fillStyle = "#111"; ctx.fillRect(this.x - 16, this.y - 28, 32, 4);
            if (hpPct > 0.6) ctx.fillStyle = "#00e676";      
            else if (hpPct > 0.3) ctx.fillStyle = "#ffea00"; 
            else ctx.fillStyle = "#ff1744";                   
            ctx.fillRect(this.x - 15, this.y - 27, 30 * hpPct, 2);
        }
    }
}

// --- NEW TOWER: TESLA COIL ---
const TWO_PI = Math.PI * 2;
const PI_4 = 0.785398; // 45 degrees in radians

class TeslaTower {
    constructor(col, row) {
        this.col = col;
        this.row = row;
        this.x = col * CELL_SIZE + CELL_SIZE / 2;
        this.y = row * CELL_SIZE + CELL_SIZE / 2;

        // Precalculate Scale & Ranges for fast math
        this.scaleFactor = (CELL_SIZE * 0.95) / 80;
        this.range = 180 * (hasSkill('tesla_range') ? 1.2 : 1);
        this.rangeSq = this.range * this.range; 
        this.chainRange = 180 * (hasSkill('tesla_range') ? 1.2 : 1);
        this.chainRangeSq = this.chainRange * this.chainRange;
        
        // Stats & Timing
        this.continuousDamage = 0.5; 
        this.chainLimit = 4 + (hasSkill('tesla_chain') ? 2 : 0);
        this.cooldown = 0;
        this.maxCooldown = 50;
        this.fireTimer = 0;
        this.maxFireDuration = 30; 

        // Visuals & Object Pooling (Optimization)
        this.targetCoords = []; // Flat array [x1, y1, x2, y2...] to prevent object allocation
        this.hitList = [];      // Reusable array to prevent new Set() allocations
        this.pulse = 0;
        this.ringGradients = null; 
        
        // Lightning Geometry Caching
        this.lightningPath = new Path2D(); 
        this.lightningTimer = 0;
    }

    update(dt) {
        if (this.cooldown > 0) this.cooldown--;
        this.pulse += 0.1;

        let primaryTarget = null;

        // Handle firing state
        if (this.fireTimer > 0) {
            this.fireTimer--;
            primaryTarget = this.getPrimaryTarget();
            
            if (primaryTarget) {
                this.executeChainLightning(primaryTarget);
            } else {
                this.fireTimer = 0; 
                this.targetCoords.length = 0; // Fast clear without reallocating
            }
        } 
        // Handle trigger state
        else if (this.cooldown <= 0) {
            primaryTarget = this.getPrimaryTarget();
            if (primaryTarget) {
                this.fireTimer = this.maxFireDuration;
                this.cooldown = this.maxCooldown + this.maxFireDuration; 
                this.executeChainLightning(primaryTarget); 
            }
        } else {
            this.targetCoords.length = 0; 
        }
    }

    getPrimaryTarget() {
        let primaryTarget = null;
        let minDistSq = this.rangeSq;
        
        // Cache properties locally to reduce property lookups in the loop
        const tx = this.x;
        const ty = this.y;
        const len = enemies.length; 

        for (let i = 0; i < len; i++) {
            let e = enemies[i];
            let dx = e.x - tx;
            let dy = e.y - ty;
            let distSq = dx * dx + dy * dy;

            if (distSq <= minDistSq) {
                minDistSq = distSq;
                primaryTarget = e;
            }
        }
        return primaryTarget;
    }

    executeChainLightning(firstEnemy) {
        let currentEnemy = firstEnemy;
        
        // Reuse hitList instead of allocating a new Set
        const hitList = this.hitList;
        hitList.length = 0; 
        hitList.push(firstEnemy);

        // Reuse targetCoords flat array instead of allocating {x, y} objects
        const coords = this.targetCoords;
        coords.length = 0;
        coords.push(this.x, this.y, currentEnemy.x, currentEnemy.y);

        currentEnemy.hp -= this.continuousDamage;

        const len = enemies.length;
        const chainRangeSq = this.chainRangeSq;

        for (let i = 0; i < this.chainLimit - 1; i++) {
            let nextEnemy = null;
            let closestDistSq = chainRangeSq;
            let cx = currentEnemy.x;
            let cy = currentEnemy.y;

            for (let j = 0; j < len; j++) {
                let e = enemies[j];
                
                // Array.includes is faster than Set.has for small limits (N <= 4)
                if (hitList.includes(e)) continue;

                let dx = e.x - cx;
                let dy = e.y - cy;
                let distSq = dx * dx + dy * dy;

                if (distSq <= closestDistSq) {
                    closestDistSq = distSq;
                    nextEnemy = e;
                }
            }

            if (nextEnemy) {
                nextEnemy.hp -= this.continuousDamage; 
                hitList.push(nextEnemy);
                coords.push(nextEnemy.x, nextEnemy.y);
                currentEnemy = nextEnemy;
            } else {
                break;
            }
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.scale(this.scaleFactor, this.scaleFactor); 

        const isReady = this.cooldown <= this.maxCooldown; 

        // --- 0. GROUND SHADOW ---
        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        ctx.beginPath();
        ctx.arc(2, 2, 38, 0, TWO_PI); 
        ctx.fill();

        // --- 1. HEAVY INDUSTRIAL BASE ---
        ctx.lineWidth = 3;
        
        ctx.fillStyle = "#1f1f1f";
        ctx.strokeStyle = "#0a0a0a";
        this.drawOctagon(38, 15.2);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = "#2b2b2b";
        this.drawOctagon(30, 12);
        ctx.fill();
        ctx.stroke();

        // --- 2. GLOWING VENTS & SUPPORT STRUTS ---
        ctx.fillStyle = isReady ? "#00ffff" : "#004444";
        if (isReady) {
            ctx.shadowBlur = 8;
            ctx.shadowColor = "#00ffff";
        }

        ctx.beginPath();
        ctx.rect(-6, 22, 12, 4);   // Bottom
        ctx.rect(-6, -26, 12, 4);  // Top
        ctx.rect(22, -6, 4, 12);   // Right
        ctx.rect(-26, -6, 4, 12);  // Left
        ctx.fill();

        if (isReady) ctx.shadowBlur = 0; 
        
        ctx.fillStyle = "#444";
        ctx.strokeStyle = "#111";
        ctx.lineWidth = 2;
        
        ctx.beginPath();
        ctx.moveTo(-4, 18); ctx.lineTo(4, 18); ctx.lineTo(3, 34); ctx.lineTo(-3, 34);
        ctx.moveTo(-4, -18); ctx.lineTo(4, -18); ctx.lineTo(3, -34); ctx.lineTo(-3, -34);
        ctx.moveTo(18, -4); ctx.lineTo(18, 4); ctx.lineTo(34, 3); ctx.lineTo(34, -3);
        ctx.moveTo(-18, -4); ctx.lineTo(-18, 4); ctx.lineTo(-34, 3); ctx.lineTo(-34, -3);
        ctx.fill();
        ctx.stroke();

        // --- 3. HIGH-VOLTAGE COILS ---
        if (!this.ringGradients) {
            this.ringGradients = [
                { r: 20, line: "#704e03", grad: ctx.createRadialGradient(0, 0, 10, 0, 0, 20) },
                { r: 15, line: "#8a6608", grad: ctx.createRadialGradient(0, 0, 7.5, 0, 0, 15) },
                { r: 10, line: "#a87b00", grad: ctx.createRadialGradient(0, 0, 5, 0, 0, 10) }
            ];
            this.ringGradients[0].grad.addColorStop(0, "#b8860b"); this.ringGradients[0].grad.addColorStop(1, "#704e03");
            this.ringGradients[1].grad.addColorStop(0, "#daa520"); this.ringGradients[1].grad.addColorStop(1, "#8a6608");
            this.ringGradients[2].grad.addColorStop(0, "#ffd700"); this.ringGradients[2].grad.addColorStop(1, "#a87b00");
        }

        for (let i = 0; i < 3; i++) {
            let ring = this.ringGradients[i];
            ctx.fillStyle = ring.grad;
            ctx.strokeStyle = ring.line;
            ctx.beginPath();
            ctx.arc(0, 0, ring.r, 0, TWO_PI);
            ctx.fill();
            ctx.stroke();
        }

        // --- 4. EMITTER PRONGS ---
        ctx.fillStyle = "#555";
        ctx.strokeStyle = "#111";
        ctx.lineWidth = 1;
        
        ctx.save();
        ctx.rotate(PI_4); 
        ctx.beginPath();
        ctx.moveTo(-3, 6); ctx.lineTo(3, 6); ctx.lineTo(2, 14); ctx.lineTo(-2, 14);
        ctx.moveTo(6, -3); ctx.lineTo(6, 3); ctx.lineTo(14, 2); ctx.lineTo(14, -2);
        ctx.moveTo(-3, -6); ctx.lineTo(3, -6); ctx.lineTo(2, -14); ctx.lineTo(-2, -14);
        ctx.moveTo(-6, -3); ctx.lineTo(-6, 3); ctx.lineTo(-14, 2); ctx.lineTo(-14, -2);
        ctx.fill();
        ctx.stroke();
        ctx.restore();

        // --- 5. CENTRAL EMITTER BALL ---
        if (isReady) {
            let pulseSize = Math.sin(this.pulse * 3) * 2;
            ctx.shadowBlur = 12 + pulseSize;
            ctx.shadowColor = "#e6ac00";
        }

        ctx.fillStyle = "#ffdf00";
        ctx.beginPath();
        ctx.arc(0, 0, 6, 0, TWO_PI);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = "#fff";
        ctx.shadowBlur = 5;
        ctx.shadowColor = "#fff";
        ctx.beginPath();
        ctx.arc(0, 0, 2, 0, TWO_PI);
        ctx.fill();

        ctx.restore(); 

        // --- 6. LIGHTNING EFFECTS ---
        if (this.fireTimer > 0 && this.targetCoords.length > 2) {
            this.renderLightning();
        }
    }

    drawOctagon(size, s) {
        ctx.beginPath();
        ctx.moveTo(-size, -s); ctx.lineTo(-s, -size);
        ctx.lineTo(s, -size); ctx.lineTo(size, -s);
        ctx.lineTo(size, s); ctx.lineTo(s, size);
        ctx.lineTo(-s, size); ctx.lineTo(-size, s);
        ctx.closePath();
    }

    renderLightning() {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        // Only recalculate the jagged lines every 4 frames to save CPU
        if (this.lightningTimer <= 0) {
            this.generateLightningPath();
            this.lightningTimer = 4; 
        }
        this.lightningTimer--;

        // --- FAKE GLOW (Extremely fast compared to shadowBlur) ---
        ctx.strokeStyle = "rgba(0, 255, 255, 0.35)"; 
        ctx.lineWidth = 8;
        ctx.stroke(this.lightningPath); 

        // --- INNER CORE (Solid White) ---
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        ctx.stroke(this.lightningPath);

        // --- SPARKS ---
        const coords = this.targetCoords;
        const len = coords.length;
        for (let i = 2; i < len; i += 2) { // Start at 2 to skip the tower itself
            this.drawSpark(coords[i], coords[i+1]);
        }

        ctx.restore();
    }

    generateLightningPath() {
        const coords = this.targetCoords;
        const len = coords.length;
        
        // Reset the path
        this.lightningPath = new Path2D(); 

        for (let i = 0; i < len - 2; i += 2) {
            let x1 = coords[i];
            let y1 = coords[i+1];
            let x2 = coords[i+2];
            let y2 = coords[i+3];

            let dx = x2 - x1;
            let dy = y2 - y1;
            
            // Fast approximate distance (Chebyshev / Octagonal)
            let absDx = Math.abs(dx);
            let absDy = Math.abs(dy);
            let dist = Math.max(absDx, absDy) + 0.4 * Math.min(absDx, absDy); 
            
            let steps = Math.max(dist * 0.1, 2) | 0; 
            let stepInv = 1 / steps; 

            this.lightningPath.moveTo(x1, y1);
            for (let j = 1; j < steps; j++) {
                let t = j * stepInv;
                let lx = x1 + dx * t;
                let ly = y1 + dy * t;
                
                // Jitter
                let ox = (Math.random() - 0.5) * 8;
                let oy = (Math.random() - 0.5) * 8;
                
                this.lightningPath.lineTo(lx + ox, ly + oy);
            }
            this.lightningPath.lineTo(x2, y2);
        }
    }

    drawSpark(x, y) {
        ctx.fillStyle = "#fff";
        ctx.beginPath();
        ctx.arc(x, y, 2, 0, TWO_PI); 
        ctx.fill();
        
        ctx.fillStyle = "rgba(0, 255, 255, 0.5)";
        ctx.beginPath();
        ctx.arc(x, y, 5, 0, TWO_PI); 
        ctx.fill();
    }
}

class BountyTower {
    constructor(c, r) {
        this.col = c;
        this.row = r;
        this.x = c * CELL_SIZE + CELL_SIZE / 2;
        this.y = r * CELL_SIZE + CELL_SIZE / 2;
        
        this.range = 160; 
        this.roofOpenTimer = 0; 
        this.gearSpin = 0; 
        
        // --- ASYMMETRICAL OFFSETS ---
        this.armBaseX = -14; // Crane is mounted on the left
        this.armBaseY = 0;
        this.crusherX = 14;  // Crusher is on the right
        this.crusherY = 0;

        // --- PERSISTENT MAGNETIC ARM ---
        this.arm = {
            state: "IDLE", 
            x: this.x + this.crusherX + 20,
            y: this.y - 50,
            target: null
        };
    }

    update() {
        this.gearSpin += 0.1;

        if (this.roofOpenTimer > 0) {
            this.roofOpenTimer--;
        }

        let speed = 0.8; // Slow, heavy industrial crawl

        // Rest position: arm hangs naturally to the right of the tower (above the crusher)
        const restX = this.x + this.crusherX + 20;
        const restY = this.y - 50;

        if (this.arm.state === "IDLE" || this.arm.state === "RETURNING") {
            // Move smoothly back to rest position
            let dx = restX - this.arm.x;
            let dy = restY - this.arm.y;
            let dist = Math.hypot(dx, dy);

            if (dist > speed) {
                this.arm.x += (dx / dist) * speed;
                this.arm.y += (dy / dist) * speed;
            } else {
                this.arm.x = restX;
                this.arm.y = restY;
                this.arm.state = "IDLE";
            }

            // Only scan for new targets once fully at rest
            if (this.arm.state === "IDLE") {
                for (let corpse of corpses) {
                    if (!corpse.isTargeted && corpse.landed && corpse.active) {
                        let cDist = Math.hypot(corpse.x - this.x, corpse.y - this.y);
                        if (cDist <= this.range) {
                            corpse.isTargeted = true;
                            this.arm.target = corpse;
                            this.arm.state = "EXTENDING";
                            break; 
                        }
                    }
                }
            }
        } else {
            // Active Target Coordinates
            const grabOffset = 35; // How far above the gravestone top the claw hovers
            let tx = this.arm.target.x;
            let ty = this.arm.target.y - grabOffset;

            if (this.arm.state === "RETRACTING") {
                // Pull the gravestone to hover ABOVE the crusher hole
                tx = this.x + this.crusherX;
                ty = this.y + this.crusherY - 40; // High enough so gravestone hangs above, not in, the hole
                
                // Stick gravestone below the claw â€” offset matches grabOffset so no teleport
                this.arm.target.x = this.arm.x;
                this.arm.target.y = this.arm.y + grabOffset + 20; // Hangs lower below the claw
                this.arm.target.dropY = -20; // Lifted off the ground
            }

            let dx = tx - this.arm.x;
            let dy = ty - this.arm.y;
            let dist = Math.hypot(dx, dy);

            if (dist < speed) {
                this.arm.x = tx;
                this.arm.y = ty;

                if (this.arm.state === "EXTENDING") {
                    this.arm.state = "RETRACTING";
                } else if (this.arm.state === "RETRACTING") {
                    // Release the gravestone above the crusher hole so it falls in
                    this.roofOpenTimer = 40; 
                    money += Math.ceil(this.arm.target.bounty / 2);

                    // Position gravestone above the crusher, release physics
                    let dropped = this.arm.target;
                    dropped.isTargeted = false;        // Re-enable physics
                    dropped.x = this.x + this.crusherX;
                    dropped.y = this.y + this.crusherY; // Ground level at crusher
                    dropped.dropY = -30;               // Start above the hole
                    dropped.velocity = 3;              // Falling downward fast
                    dropped.gravity = 1.5;             // Heavy drop into the hole
                    dropped.landed = false;
                    dropped.fallingIntoHole = true;    // Flag to skip bounce, sink into hole

                    this.arm.target = null;
                    this.arm.state = "RETURNING";
                }
            } else {
                this.arm.x += (dx / dist) * speed;
                this.arm.y += (dy / dist) * speed;
            }
        }
    }

    draw() {
        // --- ROOT CONTEXT SAVE (Prevents Map Shifting) ---
        ctx.save();
        ctx.translate(this.x, this.y);

        // ==========================================
        // 1. HEAVY INDUSTRIAL CHASSIS & SHADOWS
        // ==========================================
        ctx.shadowColor = "rgba(0, 0, 0, 0.8)";
        ctx.shadowBlur = 15;
        ctx.shadowOffsetY = 5;

        // Base Armor Plating 
        ctx.fillStyle = "#16191e";
        ctx.strokeStyle = "#090a0c";
        ctx.lineWidth = 3;
        
        ctx.beginPath();
        ctx.moveTo(-28, -20);
        ctx.lineTo(12, -22); 
        ctx.lineTo(30, -14); 
        ctx.lineTo(32, 16);  
        ctx.lineTo(10, 22);  
        ctx.lineTo(-26, 20); 
        ctx.lineTo(-32, 0);  
        ctx.closePath();
        ctx.fill(); 
        ctx.stroke();

        ctx.shadowBlur = 0; 
        ctx.shadowOffsetY = 0;

        // Inner Metallic Sheen
        let baseGrad = ctx.createLinearGradient(-30, -20, 30, 20);
        baseGrad.addColorStop(0, "#2a3038");
        baseGrad.addColorStop(0.5, "#1b1f24");
        baseGrad.addColorStop(1, "#101216");
        ctx.fillStyle = baseGrad;
        ctx.fill();

        // Warning Hazard Stripes
        ctx.save();
        ctx.clip();
        ctx.lineWidth = 4;
        ctx.strokeStyle = "rgba(255, 150, 0, 0.6)";
        for (let i = -10; i < 40; i += 8) {
            ctx.beginPath(); ctx.moveTo(i, 10); ctx.lineTo(i - 15, 30); ctx.stroke();
        }
        ctx.restore();

        // Exhaust Vents
        ctx.fillStyle = "#050608";
        for (let i = 0; i < 4; i++) {
            ctx.fillRect(-22 + (i * 5), 12, 3, 6);
        }

        ctx.fillStyle = "#404854";
        const rivets = [[-24, -16], [8, -18], [24, -10], [26, 12], [8, 18], [-22, 16]];
        for (let r of rivets) {
            ctx.beginPath(); ctx.arc(r[0], r[1], 1.5, 0, Math.PI * 2); ctx.fill();
        }


        // ==========================================
        // 2. THE PLASMA FUSION CRUSHER 
        // ==========================================
        ctx.save();
        ctx.translate(this.crusherX, this.crusherY);

        let ringGrad = ctx.createRadialGradient(0, 0, 8, 0, 0, 16);
        ringGrad.addColorStop(0, "#1a1e24");
        ringGrad.addColorStop(1, "#0a0c0f");
        ctx.fillStyle = ringGrad;
        ctx.strokeStyle = "#30363d";
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(0, 0, 15, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

        ctx.strokeStyle = "#404854";
        ctx.lineWidth = 1.5;
        for (let i = 0; i < 12; i++) {
            ctx.save();
            ctx.rotate((i * Math.PI) / 6 + this.gearSpin * 0.1); 
            ctx.beginPath(); ctx.moveTo(15, 0); ctx.lineTo(18, 0); ctx.stroke();
            ctx.restore();
        }

        ctx.fillStyle = "#020203";
        ctx.beginPath(); ctx.arc(0, 0, 12, 0, Math.PI * 2); ctx.fill();

        ctx.save();
        ctx.clip(new Path2D(`M -12 -12 h 24 v 24 h -24 Z`)); 
        
        ctx.fillStyle = "#2c313a";
        ctx.strokeStyle = "#16191e";
        ctx.lineWidth = 1;
        
        ctx.save();
        ctx.translate(-5, 0);
        ctx.rotate(this.gearSpin * 1.5);
        for(let i=0; i<5; i++) { 
            ctx.rotate((Math.PI*2)/5); 
            ctx.beginPath(); ctx.moveTo(0, -2); ctx.lineTo(6, -1); ctx.lineTo(6, 1); ctx.lineTo(0, 2); ctx.fill(); ctx.stroke();
        }
        ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI*2); ctx.fill(); 
        ctx.restore();
        
        ctx.save();
        ctx.translate(5, 0);
        ctx.rotate(-this.gearSpin * 1.5); 
        for(let i=0; i<5; i++) { 
            ctx.rotate((Math.PI*2)/5); 
            ctx.beginPath(); ctx.moveTo(0, -2); ctx.lineTo(6, -1); ctx.lineTo(6, 1); ctx.lineTo(0, 2); ctx.fill(); ctx.stroke();
        }
        ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI*2); ctx.fill(); 
        ctx.restore();
        ctx.restore(); 

        let openPulse = this.roofOpenTimer > 0 ? 1 : 0.2;
        let timePulse = Math.abs(Math.sin(Date.now() / 100)) * 0.5;
        let pAlpha = (0.3 + timePulse) * openPulse;
        
        if (pAlpha > 0.05) {
            let coreGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 14);
            coreGrad.addColorStop(0, `rgba(0, 255, 255, ${pAlpha + 0.2})`); 
            coreGrad.addColorStop(0.4, `rgba(0, 150, 255, ${pAlpha})`);    
            coreGrad.addColorStop(1, "rgba(0, 50, 255, 0)");               
            ctx.fillStyle = coreGrad;
            ctx.beginPath(); ctx.arc(0, 0, 14, 0, Math.PI * 2); ctx.fill();

            ctx.strokeStyle = "#ffffff";
            ctx.lineWidth = 1;
            for(let i=0; i<3; i++) {
                let sparkAngle = Math.random() * Math.PI * 2;
                let sparkDist = Math.random() * 8;
                ctx.beginPath();
                ctx.moveTo(Math.cos(sparkAngle)*sparkDist, Math.sin(sparkAngle)*sparkDist);
                ctx.lineTo(Math.cos(sparkAngle)*(sparkDist+4), Math.sin(sparkAngle)*(sparkDist+4));
                ctx.stroke();
            }
        }
        ctx.restore(); 


        // ==========================================
        // 3. THE CRANE ARM & IK MATH
        // ==========================================
        ctx.save();
        ctx.translate(this.armBaseX, this.armBaseY);

        ctx.fillStyle = "#1b1f24";
        ctx.strokeStyle = "#404854";
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(0, 0, 9, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        
        ctx.fillStyle = "#0c0e12";
        ctx.beginPath(); ctx.arc(0, 0, 5, 0, Math.PI * 2); ctx.fill();
        
        ctx.fillStyle = "#00ffff"; 
        ctx.beginPath(); ctx.arc(0, -6, 1.5, 0, Math.PI * 2); ctx.fill();

        let targetX = (this.arm.x - this.x) - this.armBaseX;
        let targetY = (this.arm.y - this.y) - this.armBaseY;
        
        let maxReach = 165; 
        let dist = Math.hypot(targetX, targetY);
        if (dist > maxReach) {
            targetX = (targetX / dist) * maxReach;
            targetY = (targetY / dist) * maxReach;
        }

        let L1 = 60, L2 = 55, L3 = 35; 
        if (dist < 5) { targetX = 0; targetY = -0.1; }

        let pts = [
            {x: 0, y: 0},
            {x: targetX * 0.33, y: targetY * 0.33 - 45}, 
            {x: targetX * 0.66, y: targetY * 0.66 - 45},
            {x: targetX, y: targetY}
        ];

        for (let iter = 0; iter < 3; iter++) {
            pts[3] = {x: targetX, y: targetY};
            for (let i = 2; i >= 0; i--) {
                let dx = pts[i].x - pts[i+1].x; let dy = pts[i].y - pts[i+1].y;
                let d = Math.hypot(dx, dy) || 0.001; let L = (i === 2) ? L3 : (i === 1) ? L2 : L1;
                pts[i].x = pts[i+1].x + (dx / d) * L; pts[i].y = pts[i+1].y + (dy / d) * L;
            }
            pts[0] = {x: 0, y: 0};
            for (let i = 1; i <= 3; i++) {
                let dx = pts[i].x - pts[i-1].x; let dy = pts[i].y - pts[i-1].y;
                let d = Math.hypot(dx, dy) || 0.001; let L = (i === 3) ? L3 : (i === 2) ? L2 : L1;
                pts[i].x = pts[i-1].x + (dx / d) * L; pts[i].y = pts[i-1].y + (dy / d) * L;
            }
        }

        for (let i = 0; i < 3; i++) {
            let start = pts[i];
            let end = pts[i+1];
            let angle = Math.atan2(end.y - start.y, end.x - start.x);
            let length = Math.hypot(end.x - start.x, end.y - start.y);
            
            ctx.save();
            ctx.translate(start.x, start.y);
            ctx.rotate(angle);
            
            ctx.fillStyle = "#20252b";
            ctx.strokeStyle = "#000";
            ctx.lineWidth = 1.5;
            ctx.beginPath(); ctx.arc(0, 0, (i === 0) ? 6 : (i === 1) ? 5 : 4, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            
            if (i === 0) {
                let boomGrad = ctx.createLinearGradient(0, -6, 0, 6);
                boomGrad.addColorStop(0, "#4a5361");
                boomGrad.addColorStop(0.5, "#2f353e");
                boomGrad.addColorStop(1, "#1a1e24");
                
                ctx.fillStyle = boomGrad;
                ctx.beginPath(); 
                ctx.moveTo(0, -6); ctx.lineTo(length, -4); ctx.lineTo(length, 4); ctx.lineTo(0, 6);
                ctx.closePath();
                ctx.fill(); ctx.stroke();

                ctx.fillStyle = "#e6a100";
                ctx.fillRect(10, -2, length - 25, 4);
                ctx.fillStyle = "#222";
                for(let k=12; k<length-16; k+=6) ctx.fillRect(k, -2, 2, 4); 

                ctx.fillStyle = "#111";
                ctx.fillRect(5, 6, length*0.6, 2); 
                ctx.fillStyle = "#a8b2bd";
                ctx.fillRect(5 + length*0.6, 6.5, length*0.2, 1); 

            } else if (i === 1) {
                ctx.fillStyle = "#555d66"; 
                ctx.fillRect(0, -4, length, 2);
                ctx.fillRect(0, 2, length, 2);
                
                ctx.strokeStyle = "#00ffff";
                ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(length, 0); ctx.stroke();
                
                ctx.fillStyle = "#111";
                ctx.fillRect(length*0.3, -5, 4, 10);
                ctx.fillRect(length*0.7, -5, 4, 10);

            } else if (i === 2) {
                ctx.fillStyle = "#1b1f24";
                ctx.beginPath();
                ctx.moveTo(0, -3); 
                ctx.lineTo(length - 5, -5); 
                ctx.lineTo(length, -2);
                ctx.lineTo(length, 2);
                ctx.lineTo(length - 5, 5); 
                ctx.lineTo(0, 3); 
                ctx.closePath();
                ctx.fill(); ctx.stroke();
            }
            
            ctx.fillStyle = "#00ffff";
            ctx.shadowColor = "#00ffff";
            ctx.shadowBlur = 5;
            ctx.beginPath(); ctx.arc(0, 0, 1.5, 0, Math.PI*2); ctx.fill();
            ctx.shadowBlur = 0;

            ctx.restore(); 
        }

        // ==========================================
        // 4. THE PLASMA TALON (Aggressive Sci-Fi Claw)
        // ==========================================
        ctx.save();
        ctx.translate(pts[3].x, pts[3].y);
        ctx.scale(0.6, 0.6); // Smaller claws
        // Claws open downward â€” no rotation offset

        let isActive = (this.arm.state === "RETRACTING");
        let clamp = (this.arm.state === "EXTENDING") ? 0.85 : 0.1;

        // --- Wrist Joint / Mount Collar ---
        ctx.fillStyle = "#1a1f27";
        ctx.strokeStyle = "#4a5261";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(-10, -8);
        ctx.lineTo(10, -8);
        ctx.lineTo(12, 0);
        ctx.lineTo(10, 8);
        ctx.lineTo(-10, 8);
        ctx.lineTo(-12, 0);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Collar bolts
        ctx.fillStyle = "#555f6d";
        [[-8, -5], [8, -5], [-8, 5], [8, 5]].forEach(([bx, by]) => {
            ctx.beginPath(); ctx.arc(bx, by, 1.5, 0, Math.PI * 2); ctx.fill();
        });

        // Glowing Core
        let coreIntensity = isActive ? 1 : 0.2;
        let coreGlow = ctx.createRadialGradient(0, 0, 0, 0, 0, 6);
        coreGlow.addColorStop(0, `rgba(0, 255, 255, ${coreIntensity})`);
        coreGlow.addColorStop(1, `rgba(0, 100, 200, 0)`);
        ctx.fillStyle = coreGlow;
        ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI * 2); ctx.fill();

        ctx.fillStyle = isActive ? "#00ffff" : "#0a2a2a";
        ctx.strokeStyle = "#00ffff";
        ctx.lineWidth = 1;
        ctx.beginPath(); ctx.arc(0, 0, 3, 0, Math.PI * 2); ctx.fill(); ctx.stroke();

        // ---- LEFT CLAW ----
        ctx.save();
        ctx.translate(-6, 6);
        ctx.rotate(-clamp);

        // Outer claw body
        ctx.fillStyle = "#22282f";
        ctx.strokeStyle = "#404854";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-5, 5);
        ctx.lineTo(-7, 16);
        ctx.lineTo(-3, 28);   // Long curved tip
        ctx.lineTo(2, 20);
        ctx.lineTo(4, 10);
        ctx.lineTo(2, 0);
        ctx.closePath();
        ctx.fill(); ctx.stroke();

        // Inner plate detail
        ctx.fillStyle = "#2e3540";
        ctx.beginPath();
        ctx.moveTo(0, 2);
        ctx.lineTo(-2, 8);
        ctx.lineTo(-1, 18);
        ctx.lineTo(2, 10);
        ctx.lineTo(1, 2);
        ctx.closePath();
        ctx.fill();

        // Cutting edge glow
        ctx.shadowColor = "#00ffff";
        ctx.shadowBlur = isActive ? 10 : 3;
        ctx.strokeStyle = isActive ? "rgba(0,255,255,0.95)" : "rgba(0,180,180,0.4)";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(-7, 16);
        ctx.lineTo(-3, 28);
        ctx.lineTo(2, 20);
        ctx.stroke();
        ctx.shadowBlur = 0;

        // Serration notches
        ctx.strokeStyle = "#00ffff";
        ctx.lineWidth = 0.75;
        ctx.globalAlpha = 0.5;
        for (let s = 0; s < 4; s++) {
            let sy = 8 + s * 4;
            ctx.beginPath();
            ctx.moveTo(-4, sy);
            ctx.lineTo(-2, sy + 2);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
        ctx.restore();

        // ---- RIGHT CLAW ----
        ctx.save();
        ctx.translate(6, 6);
        ctx.rotate(clamp);

        // Outer claw body
        ctx.fillStyle = "#22282f";
        ctx.strokeStyle = "#404854";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(5, 5);
        ctx.lineTo(7, 16);
        ctx.lineTo(3, 28);
        ctx.lineTo(-2, 20);
        ctx.lineTo(-4, 10);
        ctx.lineTo(-2, 0);
        ctx.closePath();
        ctx.fill(); ctx.stroke();

        // Inner plate detail
        ctx.fillStyle = "#2e3540";
        ctx.beginPath();
        ctx.moveTo(0, 2);
        ctx.lineTo(2, 8);
        ctx.lineTo(1, 18);
        ctx.lineTo(-2, 10);
        ctx.lineTo(-1, 2);
        ctx.closePath();
        ctx.fill();

        // Cutting edge glow
        ctx.shadowColor = "#00ffff";
        ctx.shadowBlur = isActive ? 10 : 3;
        ctx.strokeStyle = isActive ? "rgba(0,255,255,0.95)" : "rgba(0,180,180,0.4)";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(7, 16);
        ctx.lineTo(3, 28);
        ctx.lineTo(-2, 20);
        ctx.stroke();
        ctx.shadowBlur = 0;

        // Serration notches
        ctx.strokeStyle = "#00ffff";
        ctx.lineWidth = 0.75;
        ctx.globalAlpha = 0.5;
        for (let s = 0; s < 4; s++) {
            let sy = 8 + s * 4;
            ctx.beginPath();
            ctx.moveTo(4, sy);
            ctx.lineTo(2, sy + 2);
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
        ctx.restore();

        // ---- CENTER FANG ----
        ctx.save();
        ctx.translate(0, 8);
        let fangDrop = (this.arm.state === "EXTENDING") ? 14 : 4;
        ctx.fillStyle = "#1b1f24";
        ctx.strokeStyle = "#00ffff";
        ctx.lineWidth = 1;
        ctx.shadowColor = "#00ffff";
        ctx.shadowBlur = isActive ? 8 : 2;
        ctx.beginPath();
        ctx.moveTo(-3, 0);
        ctx.lineTo(-2, fangDrop * 0.6);
        ctx.lineTo(0, fangDrop);
        ctx.lineTo(2, fangDrop * 0.6);
        ctx.lineTo(3, 0);
        ctx.closePath();
        ctx.fill(); ctx.stroke();
        ctx.shadowBlur = 0;
        ctx.restore();

        // ---- PLASMA WEBBING when active ----
        if (isActive) {
            ctx.shadowColor = "#00ffff";
            ctx.shadowBlur = 14;

            // Arcing energy between claw tips
            let leftTipX = -Math.sin(clamp) * 14 - 6;
            let leftTipY = Math.cos(clamp) * 22 + 6;
            let rightTipX = Math.sin(clamp) * 14 + 6;
            let rightTipY = Math.cos(clamp) * 22 + 6;

            ctx.strokeStyle = "rgba(0, 255, 255, 0.9)";
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            ctx.moveTo(leftTipX, leftTipY);
            let jitter1 = Math.random() * 6 - 3;
            let jitter2 = Math.random() * 6 - 3;
            ctx.bezierCurveTo(
                leftTipX * 0.5 + jitter1, leftTipY + 4,
                rightTipX * 0.5 + jitter2, rightTipY + 4,
                rightTipX, rightTipY
            );
            ctx.stroke();

            // Secondary thinner arc
            ctx.strokeStyle = "rgba(100, 220, 255, 0.4)";
            ctx.lineWidth = 0.75;
            ctx.beginPath();
            ctx.moveTo(leftTipX, leftTipY - 3);
            ctx.quadraticCurveTo(0, leftTipY + 8 + Math.random() * 4, rightTipX, rightTipY - 3);
            ctx.stroke();

            // Containment field fill
            ctx.fillStyle = "rgba(0, 200, 255, 0.08)";
            ctx.beginPath();
            ctx.moveTo(-8, 4);
            ctx.lineTo(leftTipX, leftTipY);
            ctx.bezierCurveTo(leftTipX * 0.5, leftTipY + 8, rightTipX * 0.5, rightTipY + 8, rightTipX, rightTipY);
            ctx.lineTo(8, 4);
            ctx.closePath();
            ctx.fill();

            ctx.shadowBlur = 0;
        }

        ctx.restore(); // End Talon Context
        ctx.restore(); // End Crane Arm Context

        // --- ROOT CONTEXT RESTORE (Crucial for map stability) ---
        ctx.restore();
    }
}

class Railgun {
    constructor(col, row, buildRotation) {
        this.col = col;
        this.row = row;
        
        this.angle = buildRotation || 0;
        let isHorizontal = Math.abs(Math.sin(this.angle)) < 0.1;
        this.wCells = isHorizontal ? 3 : 2;
        this.hCells = isHorizontal ? 2 : 3;

        this.cellSize = typeof CELL_SIZE !== 'undefined' ? CELL_SIZE : 40;
        this.bw = 3 * this.cellSize;
        this.bh = 2 * this.cellSize;

        this.x = col * this.cellSize + (this.wCells * this.cellSize) / 2;
        this.y = row * this.cellSize + (this.hCells * this.cellSize) / 2;

        this.damage = 3000 * (hasSkill('railgun_damage') ? 1.5 : 1);       // Legendary Damage
        this.cooldown = 0;
        this.maxCooldown = 350;   
        this.maxWindup = 600;     // Extended windup to savor the 6-phase transformation
        this.fov = Math.PI / 2; 
        
        this.headAngle = this.angle; 
        this.currentTarget = null;
        this.windupTimer = 0;
        
        this.laserTimer = 0;
        this.pulse = 0;
        this.coreRotation = 0;
        this.recoil = 0; 
        this.tick = 0;

        // ðŸš€ LEGENDARY ANIMATION STATE (5 Moving Groups)
        this.animState = {
            outerSpread: 0, outerTravel: 0, outerAngle: 0, // Blast Shields
            mainSpread: 0,  mainTravel: 0,  mainAngle: 0,  // Induction Clamps
            innerSpread: 0, innerTravel: 0, innerAngle: 0, // Split Needle Prongs
            finAngle: 0,    finTravel: 0,                  // Rear Stabilizers (NEW)
            accelTravel: 0, accelSpread: 0                 // Ejecting Rails (NEW)
        };

        this.activeBeam = null;
        this.initPaths();
    }

    initPaths() {
        let bw = this.bw, bh = this.bh;
        this.paths = {
            baseShadow: new Path2D(), basePlate: new Path2D(), track: new Path2D(),
            teeth: new Path2D(), chassis: new Path2D(), railCore: new Path2D(),
            innerTop: new Path2D(), mainTop: new Path2D(), outerTop: new Path2D(), finTop: new Path2D(), accelTop: new Path2D(),
            innerBot: new Path2D(), mainBot: new Path2D(), outerBot: new Path2D(), finBot: new Path2D(), accelBot: new Path2D()
        };

        // Static Base
        this.paths.baseShadow.roundRect(-bw/2 + 10, -bh/2 + 10, bw, bh, 15);
        this.paths.basePlate.roundRect(-bw/2 + 4, -bh/2 + 4, bw - 8, bh - 8, 15);
        this.paths.track.arc(-bw/6, 0, bh/2 - 5, 0, Math.PI * 2);

        for (let i = 0; i < 24; i++) {
            let gAng = i * (Math.PI / 12);
            this.paths.teeth.moveTo(-bw/6 + Math.cos(gAng) * (bh/2 - 15), Math.sin(gAng) * (bh/2 - 15));
            this.paths.teeth.lineTo(-bw/6 + Math.cos(gAng) * (bh/2 - 5), Math.sin(gAng) * (bh/2 - 5));
        }

        // Main Body Core
        this.paths.chassis.moveTo(-bw/3, -20); this.paths.chassis.lineTo(-10, -36);   
        this.paths.chassis.lineTo(bw/6, -22); this.paths.chassis.lineTo(bw/4, -12);   
        this.paths.chassis.lineTo(bw/4, 12); this.paths.chassis.lineTo(bw/6, 22);
        this.paths.chassis.lineTo(-10, 36); this.paths.chassis.lineTo(-bw/3, 20); this.paths.chassis.closePath();

        this.paths.railCore.moveTo(0, -5); this.paths.railCore.lineTo(bw*1.22, -5);
        this.paths.railCore.lineTo(bw*1.28, 0); this.paths.railCore.lineTo(bw*1.22, 5); 
        this.paths.railCore.lineTo(0, 5); this.paths.railCore.closePath();

        // --- NEW: Rear Stabilizer Fins ---
        this.paths.finTop.moveTo(-bw*0.4, -15); this.paths.finTop.lineTo(-bw*0.6, -45);
        this.paths.finTop.lineTo(-10, -25); this.paths.finTop.lineTo(0, -15); this.paths.finTop.closePath();
        
        this.paths.finBot.moveTo(-bw*0.4, 15); this.paths.finBot.lineTo(-bw*0.6, 45);
        this.paths.finBot.lineTo(-10, 25); this.paths.finBot.lineTo(0, 15); this.paths.finBot.closePath();

        // Blast Shields (Outer)
        this.paths.outerTop.moveTo(5, -18); this.paths.outerTop.lineTo(25, -38);
        this.paths.outerTop.lineTo(50, -38); this.paths.outerTop.lineTo(55, -30); 
        this.paths.outerTop.lineTo(bw*1.1, -30); this.paths.outerTop.lineTo(bw*1.15, -22); 
        this.paths.outerTop.lineTo(40, -18); this.paths.outerTop.closePath();
        
        this.paths.outerBot.moveTo(5, 18); this.paths.outerBot.lineTo(25, 38);
        this.paths.outerBot.lineTo(50, 38); this.paths.outerBot.lineTo(55, 30); 
        this.paths.outerBot.lineTo(bw*1.1, 30); this.paths.outerBot.lineTo(bw*1.15, 22); 
        this.paths.outerBot.lineTo(40, 18); this.paths.outerBot.closePath();

        // Induction Clamps (Main)
        this.paths.mainTop.moveTo(15, -10); this.paths.mainTop.lineTo(25, -24);
        this.paths.mainTop.lineTo(bw*1.05, -24); this.paths.mainTop.lineTo(bw*1.18, -16); 
        this.paths.mainTop.lineTo(bw*1.25, -10); this.paths.mainTop.lineTo(40, -10); this.paths.mainTop.closePath();
        
        this.paths.mainBot.moveTo(15, 10); this.paths.mainBot.lineTo(25, 24);
        this.paths.mainBot.lineTo(bw*1.05, 24); this.paths.mainBot.lineTo(bw*1.18, 16); 
        this.paths.mainBot.lineTo(bw*1.25, 10); this.paths.mainBot.lineTo(40, 10); this.paths.mainBot.closePath();
        
        // --- NEW: Ejecting Accelerator Rails ---
        this.paths.accelTop.moveTo(bw*0.8, -8); this.paths.accelTop.lineTo(bw*1.3, -8);
        this.paths.accelTop.lineTo(bw*1.4, -4); this.paths.accelTop.lineTo(bw*0.8, -4); this.paths.accelTop.closePath();
        
        this.paths.accelBot.moveTo(bw*0.8, 8); this.paths.accelBot.lineTo(bw*1.3, 8);
        this.paths.accelBot.lineTo(bw*1.4, 4); this.paths.accelBot.lineTo(bw*0.8, 4); this.paths.accelBot.closePath();

        // Split Needle Prongs (Inner)
        this.paths.innerTop.moveTo(0, -1); this.paths.innerTop.lineTo(bw*1.15, -1);
        this.paths.innerTop.lineTo(bw*1.35, -4); this.paths.innerTop.lineTo(bw*1.4, -1); 
        this.paths.innerTop.lineTo(bw*1.4, 0); this.paths.innerTop.lineTo(0, 0); this.paths.innerTop.closePath();

        this.paths.innerBot.moveTo(0, 1); this.paths.innerBot.lineTo(bw*1.15, 1);
        this.paths.innerBot.lineTo(bw*1.35, 4); this.paths.innerBot.lineTo(bw*1.4, 1); 
        this.paths.innerBot.lineTo(bw*1.4, 0); this.paths.innerBot.lineTo(0, 0); this.paths.innerBot.closePath();
    }

    update(dt) {
        this.tick++; 

        if (this.activeBeam) {
            this.activeBeam.length = Math.min(this.activeBeam.maxLength, this.activeBeam.length + this.activeBeam.speed);
            
            // Beam originates from the furthest extended part
            let tipDistance = (this.bw * 1.4) + Math.max(this.animState.innerTravel, this.animState.accelTravel) - this.recoil; 
            let liveOx = this.x + Math.cos(this.headAngle) * tipDistance;
            let liveOy = this.y + Math.sin(this.headAngle) * tipDistance;
            
            let dirX = Math.cos(this.headAngle);
            let dirY = Math.sin(this.headAngle);

            for (let e of enemies) {
                if (!this.activeBeam.hitEnemies.has(e) && e.hp > 0) {
                    let dx = e.x - liveOx, dy = e.y - liveOy;
                    let proj = dx * dirX + dy * dirY; 
                    
                    if (proj > 0 && proj < this.activeBeam.length) {
                        let perpDist = Math.abs(-dirY * dx + dirX * dy);
                        if (perpDist < (this.activeBeam.width / 2) + 25) { 
                            e.hp -= this.damage;
                            this.activeBeam.hitEnemies.add(e);
                        }
                    }
                }
            }
            if (this.laserTimer <= 0) this.activeBeam = null;
        }

        if (this.laserTimer > 0) {
            this.laserTimer--;
            this.recoil = (this.laserTimer / 60) * 70; 
            this.coreRotation += 3.5; 
        } else {
            this.recoil = Math.max(0, this.recoil - 0.4); 
        }

        if (this.windupTimer > 0) {
            this.windupTimer--;
            if (this.currentTarget && this.currentTarget.hp > 0) {
                let dx = this.currentTarget.x - this.x;
                let dy = this.currentTarget.y - this.y;
                let targetAngle = Math.atan2(dy, dx);
                let angleDiff = this.normalizeAngle(targetAngle - this.headAngle);
                // Turns slower, it's a massive heavy weapon
                this.headAngle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), 0.012);
                this.headAngle = this.normalizeAngle(this.headAngle);
            } else {
                this.windupTimer = 0;
                this.currentTarget = null;
            }

            let chargeRatio = 1 - (this.windupTimer / this.maxWindup); 
            this.coreRotation += 0.05 + (chargeRatio * 2.0);

            if (this.windupTimer <= 0 && this.currentTarget) this.fire();
        } else if (this.cooldown > 0) {
            this.cooldown--;
            if (this.laserTimer <= 0) this.idleAnimation();
        } else if (this.laserTimer <= 0) {
            this.idleAnimation();
            let target = this.findTarget();
            if (target) {
                this.currentTarget = target;
                this.windupTimer = this.maxWindup; 
            }
        }

        // =======================================================
        // ðŸŒŸ THE LEGENDARY 6-PHASE TRANSFORMATION SEQUENCE
        // =======================================================
        let t_iSpread = 0, t_iTravel = 0, t_iAngle = 0;
        let t_mSpread = 0, t_mTravel = 0, t_mAngle = 0;
        let t_oSpread = 0, t_oTravel = 0, t_oAngle = 0;
        let t_fAngle = 0,  t_fTravel = 0;
        let t_aTravel = 0, t_aSpread = 0;

        let cr = this.windupTimer > 0 ? 1 - (this.windupTimer / this.maxWindup) : 0;

        if (this.windupTimer > 0) {
            // Slice the charge into 5 distinct phases
            let p1 = Math.min(1, Math.max(0, cr / 0.2));           // 0.0 - 0.2: Unlocking
            let p2 = Math.min(1, Math.max(0, (cr - 0.2) / 0.2));   // 0.2 - 0.4: Spooling & Fins
            let p3 = Math.min(1, Math.max(0, (cr - 0.4) / 0.2));   // 0.4 - 0.6: Clamping
            let p4 = Math.min(1, Math.max(0, (cr - 0.6) / 0.2));   // 0.6 - 0.8: Thrust & Eject
            let p5 = Math.min(1, Math.max(0, (cr - 0.8) / 0.2));   // 0.8 - 1.0: CRITICAL SPLIT

            // 1. Blast Shields
            t_oTravel = -25 * p1;                    
            t_oSpread = 12 * p1 + 8 * p3;            
            t_oAngle  = 0.3 * p1 + 0.15 * p3;        

            // 2. Rear Fins (Deploy to brace for impact)
            t_fAngle = 0.6 * p2;                     
            t_fTravel = -5 * p2;

            // 3. Induction Clamps
            t_mTravel = 25 * p2 - 10 * p4;           
            t_mSpread = 18 * p2;                     
            t_mAngle  = -0.18 * p3;                  

            // 4. Accelerator Rails (Violently eject forward)
            t_aTravel = 60 * p4 + 10 * p5;           
            t_aSpread = 4 * p4;

            // 5. Inner Needle (Pulls back, thrusts, then SPLITS open)
            t_iTravel = -35 * p2 + 85 * p4;          
            t_iSpread = 16 * p5;                     // The Legendary Singularity split
            t_iAngle  = 0.1 * p5;

        } else if (this.laserTimer > 0) {
            // PHASE 6: FIRING BLOWBACK
            t_oTravel = -45; t_oSpread = 35; t_oAngle = 0.7;  // Shields completely shattered open
            t_mTravel = -15; t_mSpread = 15; t_mAngle = 0.15; // Clamps blown backward
            t_iTravel = -55; t_iSpread = 25; t_iAngle = 0.2;  // Prongs forced incredibly wide
            t_fAngle  = 0.8; t_fTravel = -10;                 // Fins buckle under pressure
            t_aTravel = -20; t_aSpread = 10;                  // Rails snap all the way back into chassis
        }

        let lerp = (start, end, amt) => (1 - amt) * start + amt * end;
        let animSpeed = this.laserTimer > 0 ? 0.6 : (cr > 0.6 && cr < 0.8) ? 0.3 : (cr > 0.8) ? 0.4 : 0.12; 

        let a = this.animState;
        a.innerSpread = lerp(a.innerSpread, t_iSpread, animSpeed);
        a.innerTravel = lerp(a.innerTravel, t_iTravel, animSpeed);
        a.innerAngle  = lerp(a.innerAngle,  t_iAngle,  animSpeed);

        a.mainSpread  = lerp(a.mainSpread,  t_mSpread, animSpeed);
        a.mainTravel  = lerp(a.mainTravel,  t_mTravel, animSpeed);
        a.mainAngle   = lerp(a.mainAngle,   t_mAngle,  animSpeed);

        a.outerSpread = lerp(a.outerSpread, t_oSpread, animSpeed);
        a.outerTravel = lerp(a.outerTravel, t_oTravel, animSpeed);
        a.outerAngle  = lerp(a.outerAngle,  t_oAngle,  animSpeed);

        a.finAngle    = lerp(a.finAngle,    t_fAngle,  animSpeed);
        a.finTravel   = lerp(a.finTravel,   t_fTravel, animSpeed);

        a.accelTravel = lerp(a.accelTravel, t_aTravel, animSpeed);
        a.accelSpread = lerp(a.accelSpread, t_aSpread, animSpeed);
    }

    fire() {
        this.cooldown = this.maxCooldown;
        this.laserTimer = 60; 
        this.currentTarget = null; 

        this.activeBeam = {
            length: 0,
            speed: 50,      
            maxLength: 4000, 
            width: 220 * (hasSkill('railgun_width') ? 1.2 : 1),      
            hitEnemies: new Set()
        };
    }

    idleAnimation() {
        this.coreRotation += 0.01;
        this.pulse += 0.01;
        let angleDiff = this.normalizeAngle(this.angle - this.headAngle);
        this.headAngle += Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), 0.002);
    }

    findTarget() {
        let bestTarget = null, bestDistSq = Infinity;
        for (let i = 0; i < enemies.length; i++) {
            let e = enemies[i];
            let dx = e.x - this.x, dy = e.y - this.y;
            let angleToEnemy = Math.atan2(dy, dx);
            let angleDiff = Math.abs(this.normalizeAngle(angleToEnemy - this.angle));

            if (angleDiff <= this.fov / 2) {
                let distSq = dx * dx + dy * dy;
                if (distSq < bestDistSq) {
                    bestDistSq = distSq;
                    bestTarget = e;
                }
            }
        }
        return bestTarget;
    }

    normalizeAngle(a) {
        while (a > Math.PI) a -= Math.PI * 2;
        while (a < -Math.PI) a += Math.PI * 2;
        return a;
    }

    draw() {
        let bw = this.bw, bh = this.bh;
        let chargeRatio = this.windupTimer > 0 ? 1 - (this.windupTimer / this.maxWindup) : 0;
        let isFiring = this.laserTimer > 0;
        let heatRatio = (!isFiring && this.cooldown > 0) ? Math.min(1, this.cooldown / (this.maxCooldown * 0.8)) : 0;
        
        let a = this.animState;
        let tipDistance = (bw * 1.4) + Math.max(a.innerTravel, a.accelTravel) - this.recoil; 

        // 1. Draw Beam First (Underneath gun)
        if (this.activeBeam) {
            let liveOx = this.x + Math.cos(this.headAngle) * tipDistance;
            let liveOy = this.y + Math.sin(this.headAngle) * tipDistance;
            this.renderContinuousBeam(liveOx, liveOy, this.headAngle);
        }

        ctx.save();
        ctx.translate(this.x, this.y);

        // 2. Static Base
        ctx.save();
        ctx.rotate(this.angle);
        ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
        ctx.fill(this.paths.baseShadow);

        let baseGrad = ctx.createLinearGradient(-bw/2, -bh/2, bw/2, bh/2);
        baseGrad.addColorStop(0, "#2a2d33"); baseGrad.addColorStop(0.5, "#414750"); baseGrad.addColorStop(1, "#1c1e22");
        ctx.fillStyle = baseGrad;
        ctx.strokeStyle = "#111";
        ctx.lineWidth = 5;
        ctx.fill(this.paths.basePlate); ctx.stroke(this.paths.basePlate);

        ctx.fillStyle = "#353a42"; ctx.strokeStyle = "#000"; ctx.lineWidth = 3;
        ctx.fill(this.paths.track); ctx.stroke(this.paths.track);
        ctx.strokeStyle = "#5a626d"; ctx.lineWidth = 5; ctx.stroke(this.paths.teeth);
        ctx.restore(); 

        // 3. Rotating Gun Head
        ctx.save();
        ctx.rotate(this.headAngle);
        
        // Phase 5 Violent Screen Shake
        let shakeX = 0, shakeY = 0;
        if (chargeRatio > 0.8 && !isFiring) {
            let severity = (chargeRatio - 0.8) * 60; 
            shakeX = (Math.random() - 0.5) * severity; 
            shakeY = (Math.random() - 0.5) * severity;
        }
        ctx.translate(-this.recoil + shakeX, shakeY);

        // Targeting Laser
        if (chargeRatio > 0.5 && !isFiring && this.currentTarget) {
            ctx.globalCompositeOperation = 'lighter';
            let laserAlpha = (chargeRatio - 0.5) / 0.5;
            ctx.strokeStyle = `rgba(255, 0, 80, ${laserAlpha * 0.9})`;
            ctx.lineWidth = 3;
            
            let dx = this.currentTarget.x - this.x;
            let dy = this.currentTarget.y - this.y;
            let dist = Math.hypot(dx, dy); 
            
            ctx.beginPath();
            ctx.moveTo(tipDistance, 0);
            ctx.lineTo(dist, 0);
            ctx.stroke();
            ctx.globalCompositeOperation = 'source-over';
        }

        let railGrad = ctx.createLinearGradient(0, -bh, 0, bh);
        railGrad.addColorStop(0, "#9ea7b0"); railGrad.addColorStop(0.5, "#757d86"); railGrad.addColorStop(1, "#4b5158");

        // Helper to draw the complex mirrored parts
        const drawJawPiece = (path, travelX, spreadY, angleOffset, jawType, isTop) => {
            ctx.save();
            ctx.translate(travelX, spreadY);
            ctx.rotate(angleOffset * (isTop ? -1 : 1));
            
            ctx.fillStyle = railGrad; 
            ctx.strokeStyle = "#222"; 
            ctx.lineWidth = 2;
            ctx.fill(path); ctx.stroke(path);

            if (heatRatio > 0) {
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = `rgba(255, 60, 0, ${heatRatio * 0.4})`;
                ctx.fill(path);
                ctx.globalCompositeOperation = 'source-over';
            }

            let dir = isTop ? -1 : 1;

            if (jawType === 'fin') {
                ctx.fillStyle = "#ffaa00";
                if (chargeRatio > 0 || isFiring) {
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.fillStyle = `rgba(0, 255, 255, ${chargeRatio || 1})`;
                }
                ctx.beginPath(); ctx.arc(-bw*0.3, 18 * dir, 3, 0, Math.PI*2); ctx.fill();
                ctx.globalCompositeOperation = 'source-over';
            }
            else if (jawType === 'main') {
                ctx.fillStyle = "#40464d";
                ctx.lineWidth = 1.5;
                for (let f = 0; f < 6; f++) {
                    ctx.beginPath(); ctx.rect(40 + (f * 14), isTop ? 24*dir - 4 : 24*dir, 8, 4);
                    ctx.fill(); ctx.stroke();
                }

                for (let c = 0; c < 5; c++) {
                    let cx = 35 + (c * 18), cy = 16 * dir;
                    ctx.fillStyle = "#2a2d33";
                    ctx.beginPath(); ctx.ellipse(cx, cy, 5, 7, 0, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
                    
                    if (chargeRatio > 0.4 || isFiring) {
                        ctx.globalCompositeOperation = 'lighter';
                        let glowAmt = isFiring ? 1 : (chargeRatio - 0.4) / 0.6;
                        ctx.fillStyle = `rgba(0, ${150 + glowAmt*105}, 255, ${glowAmt})`;
                        ctx.beginPath(); ctx.ellipse(cx, cy, 3, 5, 0, 0, Math.PI * 2); ctx.fill();
                        
                        if (c < 4 && chargeRatio > 0.5) {
                            ctx.strokeStyle = `rgba(0, 255, 255, ${glowAmt * 0.9})`;
                            ctx.lineWidth = 2;
                            ctx.beginPath(); ctx.moveTo(cx + 4, cy); ctx.lineTo(cx + 18 - 4, cy); ctx.stroke();
                        }
                        ctx.globalCompositeOperation = 'source-over';
                    }
                }
            } 
            else if (jawType === 'accel') {
                // Glowing rails inside the ejecting parts
                if (chargeRatio > 0.6 || isFiring) {
                    ctx.globalCompositeOperation = 'lighter';
                    let accGlow = isFiring ? 1 : (chargeRatio - 0.6) / 0.4;
                    ctx.strokeStyle = `rgba(0, 255, 255, ${accGlow})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath(); ctx.moveTo(bw*0.85, 6 * dir); ctx.lineTo(bw*1.35, 6 * dir); ctx.stroke();
                    ctx.globalCompositeOperation = 'source-over';
                }
            }
            else if (jawType === 'inner') {
                ctx.fillStyle = (chargeRatio > 0.8 || isFiring) ? "#fff" : "#0ff";
                if (chargeRatio > 0.2 || isFiring) {
                    ctx.globalCompositeOperation = 'lighter';
                    ctx.beginPath(); ctx.arc(bw*1.35, 2 * dir, 4, 0, Math.PI*2); ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                }
            }
            ctx.restore();
        };

        // Render Background Parts (Fins, Outer Shields)
        drawJawPiece(this.paths.finTop, a.finTravel, 0, a.finAngle, 'fin', true);
        drawJawPiece(this.paths.finBot, a.finTravel, 0, a.finAngle, 'fin', false);
        
        drawJawPiece(this.paths.outerTop, a.outerTravel, -a.outerSpread, a.outerAngle, 'outer', true);
        drawJawPiece(this.paths.outerBot, a.outerTravel, a.outerSpread, a.outerAngle, 'outer', false);

        // Main Chassis & Core
        ctx.fillStyle = "#33383e";
        ctx.fill(this.paths.railCore);
        if (chargeRatio > 0 || isFiring) {
            ctx.globalCompositeOperation = 'lighter';
            let coreAlpha = isFiring ? 1 : chargeRatio;
            ctx.fillStyle = `rgba(0, 255, 255, ${coreAlpha})`;
            for(let i=0; i<12; i++) {
                if (chargeRatio > (i/12) || isFiring) {
                    ctx.fillRect(10 + (i * 12), -4, 5, 8); 
                }
            }
            ctx.strokeStyle = `rgba(255, 255, 255, ${coreAlpha * 0.8})`;
            ctx.lineWidth = 2; ctx.stroke(this.paths.railCore);
            ctx.globalCompositeOperation = 'source-over';
        }

        ctx.fillStyle = "#505761"; ctx.strokeStyle = "#111"; ctx.lineWidth = 3;
        ctx.fill(this.paths.chassis); ctx.stroke(this.paths.chassis);

        // Core Holographic Interface
        let rColor, rGlow;
        if (isFiring) { rColor = "255,255,255"; rGlow = "0,255,255"; }
        else if (chargeRatio > 0.8) { rColor = "255,0,255";   rGlow = "255,0,100"; } // LEGENDARY PURPLE/PINK CRITICAL
        else if (chargeRatio > 0.6) { rColor = "255,255,255"; rGlow = "0,255,255"; } 
        else if (chargeRatio > 0.2) { rColor = "0,255,255";   rGlow = "0,170,255"; } 
        else if (this.cooldown > 0) { rColor = "255,80,0";    rGlow = "200,30,0"; }  
        else                        { rColor = "0,255,100";   rGlow = "0,100,50"; }  // Idle Green/Cyan

        ctx.save();
        let uiAlpha = Math.min(1, 0.4 + chargeRatio); 
        ctx.globalCompositeOperation = 'lighter';
        
        ctx.rotate(this.coreRotation);
        ctx.strokeStyle = `rgba(${rColor}, ${uiAlpha})`; 
        ctx.lineWidth = 3; 
        ctx.setLineDash([10, 8, 4, 8]); 
        ctx.beginPath(); ctx.arc(0, 0, 22, 0, Math.PI*2); ctx.stroke();
        
        ctx.setLineDash([]); ctx.lineWidth = 2;
        ctx.strokeStyle = `rgba(${rGlow}, ${uiAlpha * 0.8})`;
        ctx.beginPath(); ctx.arc(0, 0, 14, 0, Math.PI*2); ctx.stroke();

        ctx.fillStyle = `rgba(${rGlow}, ${uiAlpha * 0.6})`;
        ctx.beginPath(); ctx.arc(0, 0, 8 + (chargeRatio * 8), 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = `rgba(${rColor}, ${uiAlpha})`;
        ctx.beginPath(); ctx.arc(0, 0, 4 + (chargeRatio * 4), 0, Math.PI * 2); ctx.fill();
        ctx.restore(); 

        // Render Foreground Parts (Main Clamps, Accel Rails, Inner Prongs)
        drawJawPiece(this.paths.mainTop, a.mainTravel, -a.mainSpread, a.mainAngle, 'main', true);
        drawJawPiece(this.paths.mainBot, a.mainTravel, a.mainSpread, a.mainAngle, 'main', false);
        
        drawJawPiece(this.paths.accelTop, a.accelTravel, -a.accelSpread, 0, 'accel', true);
        drawJawPiece(this.paths.accelBot, a.accelTravel, a.accelSpread, 0, 'accel', false);

        drawJawPiece(this.paths.innerTop, a.innerTravel, -a.innerSpread, a.innerAngle, 'inner', true);
        drawJawPiece(this.paths.innerBot, a.innerTravel, a.innerSpread, a.innerAngle, 'inner', false);

        // Phase 5: Inner Needle Split Energy Arcs (The Singularity Chamber)
        if (chargeRatio > 0.8 && !isFiring) {
            ctx.globalCompositeOperation = 'lighter';
            ctx.strokeStyle = `rgba(255, 255, 255, ${chargeRatio})`;
            ctx.lineWidth = 2 + Math.random() * 3;
            let prongTipX = bw*1.35 + a.innerTravel;
            
            // Arcs connecting the separated top and bottom prongs
            for (let i=0; i<3; i++) {
                this.drawJaggedLine(
                    prongTipX - (Math.random()*20), -a.innerSpread, 
                    prongTipX - (Math.random()*20), a.innerSpread, 
                    15
                );
            }
            ctx.globalCompositeOperation = 'source-over';
        }

        // Accelerator Rings & Implosion Effects
        if (chargeRatio > 0 || isFiring) {
            ctx.globalCompositeOperation = 'lighter';
            let ringAlpha = isFiring ? 1 : chargeRatio;
            
            // Rings along the main barrel
            if (chargeRatio > 0.4 || isFiring) {
                for(let i=1; i<=8; i++) {
                    let pX = 20 + (i * 20) + (chargeRatio * 25); 
                    ctx.fillStyle = `rgba(0, 255, 255, ${ringAlpha * 0.4})`;
                    ctx.beginPath(); ctx.ellipse(pX, 0, 8 + (chargeRatio*12), Math.max(a.mainSpread, 5) * 2.5, 0, 0, Math.PI*2); ctx.fill();
                }
            }

            // The Singularity at the tip
            let trueTipX = (bw * 1.4) + Math.max(a.innerTravel, a.accelTravel);
            
            if (!isFiring) {
                if (chargeRatio > 0.6) {
                    // Floating Halo rings extending ahead of the gun
                    let haloDist = trueTipX + (chargeRatio - 0.6) * 100;
                    ctx.strokeStyle = `rgba(0, 255, 255, ${(chargeRatio - 0.6) * 2})`;
                    ctx.lineWidth = 4;
                    ctx.beginPath(); ctx.ellipse(haloDist, 0, 10, 60, 0, 0, Math.PI*2); ctx.stroke();
                    ctx.beginPath(); ctx.ellipse(haloDist + 30, 0, 6, 40, 0, 0, Math.PI*2); ctx.stroke();

                    // The Implosion Sphere (Black hole effect)
                    if (chargeRatio > 0.8) {
                        let implosionPhase = (this.tick % 10) / 10; 
                        let ringRadius = 200 * (1 - implosionPhase); 
                        ctx.strokeStyle = `rgba(255, 0, 255, ${implosionPhase * chargeRatio})`; // Pink legendary energy
                        ctx.lineWidth = 8;
                        ctx.beginPath(); ctx.ellipse(trueTipX, 0, ringRadius/4, ringRadius, 0, 0, Math.PI*2); ctx.stroke();

                        // Core black hole
                        ctx.fillStyle = `rgba(0, 0, 0, 0.9)`;
                        ctx.beginPath(); ctx.arc(trueTipX, 0, 20, 0, Math.PI * 2); ctx.fill();
                        
                        // Event horizon glow
                        ctx.strokeStyle = `rgba(255, 255, 255, 1)`;
                        ctx.lineWidth = 4;
                        ctx.beginPath(); ctx.arc(trueTipX, 0, 20 + Math.random()*5, 0, Math.PI * 2); ctx.stroke();
                    }
                }

                let orbPulse = 1 + Math.sin(this.tick * 0.5) * 0.3;
                ctx.fillStyle = `rgba(0, 255, 255, 0.4)`;
                ctx.beginPath(); ctx.arc(trueTipX, 0, chargeRatio * 60 * orbPulse, 0, Math.PI * 2); ctx.fill();
            } else {
                // Muzzle Flash
                let alpha = this.laserTimer / 60;
                
                ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
                ctx.lineWidth = 20 * alpha;
                ctx.beginPath(); ctx.ellipse(trueTipX, 0, 200 * (1-alpha), 500 * (1-alpha), 0, 0, Math.PI * 2); ctx.stroke();

                ctx.beginPath(); ctx.ellipse(trueTipX, 0, 150 * alpha, 400 * alpha, 0, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(150, 255, 255, ${alpha * 0.9})`; ctx.fill();
                
                ctx.beginPath(); ctx.ellipse(trueTipX, 0, 60 * alpha, 200 * alpha, 0, 0, Math.PI * 2);
                ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`; ctx.fill();
            }
            ctx.globalCompositeOperation = 'source-over'; 
        }

        ctx.restore(); 
        ctx.restore(); 
    }

    renderContinuousBeam(ox, oy, angle) {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.lineCap = "round";
        
        let dirX = Math.cos(angle);
        let dirY = Math.sin(angle);
        
        let headX = ox + dirX * this.activeBeam.length;
        let headY = oy + dirY * this.activeBeam.length;

        let alpha = this.laserTimer / 60; 
        let width = this.activeBeam.width;

        // Massive deep blue aura
        ctx.strokeStyle = `rgba(0, 100, 255, ${alpha * 0.4})`;
        ctx.lineWidth = width + (Math.random() * 80); 
        ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(headX, headY); ctx.stroke();

        // Cyan core
        ctx.strokeStyle = `rgba(0, 255, 255, ${alpha * 0.9})`;
        ctx.lineWidth = width * 0.7;
        ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(headX, headY); ctx.stroke();

        // White hot center
        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
        ctx.lineWidth = width * 0.3;
        ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(headX, headY); ctx.stroke();

        // Legendary Pink/Purple Lightning wrapping the beam
        ctx.strokeStyle = `rgba(255, 50, 255, ${alpha})`;
        ctx.lineWidth = 8;
        this.drawJaggedLine(ox, oy, headX, headY, width * 1.2); 
        
        ctx.lineWidth = 4;
        ctx.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
        this.drawJaggedLine(ox, oy, headX, headY, width * 0.5); 

        // Impact Explosion
        if (this.activeBeam.length > 50) {
            ctx.beginPath();
            ctx.ellipse(headX, headY, width * 1.2, width * 2.5, angle, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`; ctx.fill();
            
            ctx.beginPath();
            ctx.ellipse(headX + (dirX * 40), headY + (dirY * 40), width * 0.6, width * 3.5, angle, 0, Math.PI * 2);
            ctx.fillStyle = `rgba(0, 255, 255, ${alpha * 0.7})`; ctx.fill();
        }

        ctx.restore();
    }

    drawJaggedLine(x1, y1, x2, y2, jitter) {
        let dx = x2 - x1, dy = y2 - y1;
        let dist = Math.sqrt(dx * dx + dy * dy); 
        if (dist < 10) return;

        let steps = Math.max(dist / 40, 4) | 0; 

        ctx.beginPath();
        ctx.moveTo(x1, y1);
        for (let i = 1; i < steps; i++) {
            let t = i / steps;
            let currentJitter = jitter * (Math.sin(t * Math.PI)); // Max jitter in middle of beam
            let ox = (Math.random() - 0.5) * currentJitter;
            let oy = (Math.random() - 0.5) * currentJitter;
            ctx.lineTo(x1 + dx * t + ox, y1 + dy * t + oy);
        }
        ctx.lineTo(x2, y2);
        ctx.stroke();
    }
}

class SuckerTower {
    constructor(col, row) {
        this.col = col;
        this.row = row;
        this.x = col * CELL_SIZE + CELL_SIZE / 2;
        this.y = row * CELL_SIZE + CELL_SIZE / 2;

        // Precalculate Scale & Ranges for fast math
        this.scaleFactor = (CELL_SIZE * 0.95) / 80;
        this.range = 160 * (hasSkill('sucker_area') ? 1.15 : 1); 
        this.rangeSq = this.range * this.range; 
        this.minDist = 15; // Stop pulling if they get right to the center
        this.minDistSq = this.minDist * this.minDist;
        
        // Stats & Timing
        this.pullStrength = 2 * (hasSkill('sucker_strenght') ? 1.1 : 1); // How fast they are dragged in per frame
        this.cooldown = 0;
        this.maxCooldown = 300; // Wait time between sucks
        this.fireTimer = 0;
        this.maxFireDuration = 45; // How long the tornado lasts

        // Visuals
        this.rotation = 0; // Rotates the fan and tornado
        this.isFiring = false;
    }

    update(dt) {
        if (this.cooldown > 0) this.cooldown--;
        
        // Always spin the fan a little, but spin it fast when firing
        this.rotation += this.isFiring ? 0.3 : 0.05;

        // Handle firing (sucking) state
        if (this.fireTimer > 0) {
            this.fireTimer--;
            this.isFiring = true;
            this.executePull();
            
            if (this.fireTimer <= 0) {
                this.isFiring = false; // Turn off tornado
            }
        } 
        // Handle trigger state
        else if (this.cooldown <= 0) {
            // Check if there are any enemies in range to trigger the attack
            if (this.isEnemyInRange()) {
                this.fireTimer = this.maxFireDuration;
                this.cooldown = this.maxCooldown + this.maxFireDuration; 
                this.isFiring = true;
                this.executePull(); // Start pulling immediately
            }
        }
    }

    isEnemyInRange() {
        for (let i = 0; i < enemies.length; i++) {
            let e = enemies[i];
            let dx = e.x - this.x;
            let dy = e.y - this.y;
            if (dx * dx + dy * dy <= this.rangeSq) {
                return true;
            }
        }
        return false;
    }

    executePull() {
        // Pull ALL enemies currently within the radius
        for (let i = 0; i < enemies.length; i++) {
            let e = enemies[i];
            let dx = this.x - e.x; // Vector pointing TO the tower
            let dy = this.y - e.y;
            let distSq = dx * dx + dy * dy;

            if (distSq <= this.rangeSq && distSq > this.minDistSq) {
                // Optimization: Only do Math.sqrt if they are actually in range
                let dist = Math.sqrt(distSq);
                
                // Move enemy towards the tower (No damage applied)
                e.x += (dx / dist) * this.pullStrength;
                e.y += (dy / dist) * this.pullStrength;
            }
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        
        // Base visuals (scaled like the Tesla Tower)
        ctx.save();
        ctx.scale(this.scaleFactor, this.scaleFactor); 

        const isReady = this.cooldown <= this.maxCooldown; 

        // --- 0. GROUND SHADOW ---
        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        ctx.beginPath();
        ctx.arc(2, 2, 38, 0, Math.PI * 2); 
        ctx.fill();

        // --- 1. HEAVY INDUSTRIAL BASE (Slightly different colors for Wind/Vacuum theme) ---
        ctx.lineWidth = 3;
        
        ctx.fillStyle = "#1a242b"; // Dark blueish gray
        ctx.strokeStyle = "#0a0f12";
        this.drawOctagon(38, 15.2);
        ctx.fill();
        ctx.stroke();

        ctx.fillStyle = "#2a3b47";
        this.drawOctagon(30, 12);
        ctx.fill();
        ctx.stroke();

        // --- 2. VACUUM INTAKE PIT ---
        ctx.fillStyle = "#05080a";
        ctx.beginPath();
        ctx.arc(0, 0, 22, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();

        // --- 3. SPINNING TURBINE BLADES ---
        ctx.save();
        ctx.rotate(this.rotation);
        
        // Inner glowing core
        ctx.fillStyle = this.isFiring ? "#aaddff" : (isReady ? "#447799" : "#223344");
        ctx.shadowBlur = this.isFiring ? 15 : 0;
        ctx.shadowColor = "#aaddff";
        ctx.beginPath();
        ctx.arc(0, 0, 6, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.shadowBlur = 0;
        
        // Draw 5 turbine blades
        ctx.fillStyle = "#557788";
        ctx.strokeStyle = "#112233";
        ctx.lineWidth = 1;
        for (let i = 0; i < 5; i++) {
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(20, -5);
            ctx.lineTo(20, 5);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.rotate((Math.PI * 2) / 5);
        }
        ctx.restore();
        ctx.restore(); // Restore scale to draw range effects accurately

        // --- 4. TORNADO EFFECT (Only draws when sucking) ---
        if (this.isFiring) {
            this.renderTornado();
        }

        ctx.restore(); 
    }

    // Reuse your octagon logic
    drawOctagon(size, s) {
        ctx.beginPath();
        ctx.moveTo(-size, -s); ctx.lineTo(-s, -size);
        ctx.lineTo(s, -size); ctx.lineTo(size, -s);
        ctx.lineTo(size, s); ctx.lineTo(s, size);
        ctx.lineTo(-s, size); ctx.lineTo(-size, s);
        ctx.closePath();
    }

    renderTornado() {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        ctx.lineCap = "round";

        // Draw multiple swirling wind arcs that expand outwards
        for (let i = 0; i < 4; i++) {
            // Calculate an expanding radius that loops back using modulo
            let age = (this.rotation * 15 + i * (this.range / 4));
            let radius = age % this.range;
            
            // Fade out as it reaches the edge of the range
            let alpha = 1 - (radius / this.range);
            
            ctx.strokeStyle = `rgba(180, 230, 255, ${alpha * 0.8})`;
            ctx.lineWidth = 3 + (radius * 0.05); // Gets thicker as it expands
            
            // Spin the angle
            let angle = this.rotation * 3 + (i * Math.PI / 2);
            
            ctx.beginPath();
            // Draw a half-circle arc that looks like a gust of wind
            ctx.arc(0, 0, Math.max(0.1, radius), angle, angle + Math.PI);
            ctx.stroke();
        }
        
        // Optional: draw a faint outer suction ring
        ctx.strokeStyle = "rgba(180, 230, 255, 0.1)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(0, 0, this.range, 0, Math.PI * 2);
        ctx.stroke();

        ctx.restore();
    }
}

class Minigun {
    constructor(col, row) {
        this.col = col;
        this.row = row;
        this.x = col * CELL_SIZE + CELL_SIZE / 2;
        this.y = row * CELL_SIZE + CELL_SIZE / 2;

        // --- STATS ---
        this.range = 280;
        this.damage = 3 + (hasSkill('minigun_dmg') ? 2 : 0);
        this.maxFireRate = 2 * (hasSkill('minigun_speed') ? 0.8 : 1);
        this.currentFireTimer = 0;
        this.maxHp = 500;
        this.hp = this.maxHp;
        this.active = true;

        // --- VISUALS ---
        this.angle = 0;
        this.spinSpeed = 0;
        this.heat = 0;
        this.recoil = 0;
        this.barrelScroll = 0;
        this.shells = [];
    }

    update(dt) {
        if (this.hp <= 0) this.active = false;
        // Assuming 'grid' and 'enemies' are global variables
        if (!grid[this.col][this.row].occupied) this.active = false;

        // 1. Target Finding
        let target = null;
        let minDist = this.range;
        for (let e of enemies) {
            let d = Math.hypot(e.x - this.x, e.y - this.y);
            if (d < minDist) {
                minDist = d;
                target = e;
            }
        }

        // 2. State Logic
        if (target) {
            let dx = target.x - this.x;
            let dy = target.y - this.y;
            let targetAngle = Math.atan2(dy, dx);

            // Aiming (Smooth)
            let angleDiff = targetAngle - this.angle;
            while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
            while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
            this.angle += angleDiff * 0.15;

            // Spool Up
            this.spinSpeed = Math.min(this.spinSpeed + 0.05, 1.0);

            // Fire Logic
            if (Math.abs(angleDiff) < 0.6 && this.spinSpeed > 0.8) {
                if (this.currentFireTimer <= 0) {
                    this.currentFireTimer = this.maxFireRate;
                    this.recoil = 4; // Slightly more visual recoil
                    this.heat = Math.min(this.heat + 0.04, 1.0);

                    // Muzzle Position logic
                    const barrelLen = 45 - this.recoil; // Longer visual barrel
                    const mx = this.x + Math.cos(this.angle) * barrelLen;
                    const my = this.y + Math.sin(this.angle) * barrelLen;

                    const spread = (Math.random() - 0.5) * 0.25;
                    const fireAngle = this.angle + spread;

                    // FIRE
                    projectiles.push(new MinigunBullet(mx, my, fireAngle, this.damage, 9));

                    // Flash
                    if (typeof createParticles === 'function') createParticles(mx, my, "#ffcc00", 2);

                    // Eject Shells
                    this.shells.push({
                        x: this.x, y: this.y,
                        vx: Math.cos(this.angle - 1.8) * 3 + (Math.random() - 0.5), // Eject slightly back-right
                        vy: Math.sin(this.angle - 1.8) * 3 + (Math.random() - 0.5),
                        life: 20, angle: Math.random() * 6
                    });
                }
            }
        } else {
            // Spool Down
            this.spinSpeed *= 0.96;
            this.heat *= 0.97;
        }

        if (this.currentFireTimer > 0) this.currentFireTimer--;
        this.recoil *= 0.8;
        this.barrelScroll += this.spinSpeed * 3;

        // Update Shells
        for (let s of this.shells) { s.x += s.vx; s.y += s.vy; s.life--; s.vx *= 0.9; s.vy *= 0.9; }
        this.shells = this.shells.filter(s => s.life > 0);
    }

    draw() {
        // --- 0. SHELL CASINGS (On the floor) ---
        ctx.fillStyle = "#d4af37"; 
        for (let s of this.shells) {
            ctx.save();
            ctx.translate(s.x, s.y);
            ctx.rotate(s.angle);
            ctx.fillRect(-2, -1, 4, 2);
            ctx.restore();
        }

        ctx.save();
        ctx.translate(this.x, this.y);

        // --- 1. INDUSTRIAL BASE (New Shape) ---
        // Drop shadow for the base
        ctx.fillStyle = "rgba(0,0,0,0.3)";
        ctx.beginPath(); ctx.arc(2, 2, 22, 0, Math.PI * 2); ctx.fill();

        // Main X-Stand
        ctx.fillStyle = "#1a1a1a"; // Dark Metal
        
        // Draw 4 distinct heavy legs
        for(let i=0; i<4; i++) {
            ctx.save(); 
            ctx.rotate((Math.PI/4) + (i * Math.PI/2)); // Rotate 45 deg for X shape
            
            // Leg Strut
            ctx.fillRect(-6, -6, 12, 24); 
            
            // Foot Pad (Chamfered look)
            ctx.fillStyle = "#333";
            ctx.beginPath();
            ctx.moveTo(-8, 18); ctx.lineTo(8, 18);
            ctx.lineTo(10, 24); ctx.lineTo(-10, 24);
            ctx.fill();
            
            // Bolt detail on leg
            ctx.fillStyle = "#555";
            ctx.beginPath(); ctx.arc(0, 12, 2, 0, Math.PI*2); ctx.fill();
            
            ctx.restore();
        }

        // Central Bearing Ring (The turret sits on this)
        ctx.fillStyle = "#222";
        ctx.beginPath(); ctx.arc(0,0, 16, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle = "#444"; ctx.lineWidth = 2; ctx.stroke();
        
        // Rivets on the ring
        ctx.fillStyle = "#666";
        for(let i=0; i<8; i++){
            let ra = i * (Math.PI*2)/8;
            ctx.beginPath(); ctx.arc(Math.cos(ra)*12, Math.sin(ra)*12, 1.5, 0, Math.PI*2); ctx.fill();
        }

        // --- 2. AMMO SYSTEM (Calculated before rotation) ---
        const ammoX = -28;
        const ammoY = 18;
        
        // Calculate where the belt connects to the gun (The "Feed Port")
        // We project a point relative to the gun's angle
        let feedPortX = Math.cos(this.angle - 0.5) * 8; // Offset to the side of the gun
        let feedPortY = Math.sin(this.angle - 0.5) * 8;

        // Belt Curve
        ctx.beginPath();
        ctx.moveTo(ammoX, ammoY);
        // Control point moves slightly with gun to fake flexibility
        ctx.quadraticCurveTo(ammoX, ammoY - 25, feedPortX, feedPortY);
        
        ctx.lineWidth = 7; ctx.strokeStyle = "#111"; ctx.stroke(); // Belt Backing
        ctx.lineWidth = 4; ctx.strokeStyle = "#d4af37"; ctx.setLineDash([2, 3]); ctx.stroke(); // Bullets
        ctx.setLineDash([]);

        // Ammo Box (Green Metal)
        ctx.fillStyle = "#2f3f2f";
        ctx.fillRect(ammoX - 10, ammoY - 10, 24, 20);
        ctx.fillStyle = "#4a5b4a"; // Lid
        ctx.fillRect(ammoX - 8, ammoY - 12, 20, 4);

        // --- 3. ROTATING TURRET HEAD ---
        ctx.rotate(this.angle);
        const kick = -this.recoil;

        // -- Rear Motor Housing (Rounded back) --
        ctx.fillStyle = "#222";
        ctx.beginPath();
        ctx.arc(-12 + kick, 0, 11, Math.PI/2, -Math.PI/2); // Half circle back
        ctx.fill();
        ctx.fillRect(-12 + kick, -11, 10, 22); // Connect to body

        // -- Main Receiver Body --
        ctx.fillStyle = "#3a3a3a"; // Lighter grey for contrast
        // Top shape
        ctx.beginPath();
        ctx.moveTo(-5 + kick, -10);
        ctx.lineTo(15 + kick, -10);
        ctx.lineTo(15 + kick, 10);
        ctx.lineTo(-5 + kick, 10);
        ctx.fill();
        
        // Side mounting plate visual
        ctx.fillStyle = "#1a1a1a";
        ctx.fillRect(-2 + kick, -11, 6, 22);

        // -- BARREL BUNDLE --
        const bW = 46; // Length
        const bH = 14; // Width
        const bX = 15 + kick;
        const bY = -bH/2;

        ctx.fillStyle = "#050505"; // Very dark barrel base
        ctx.fillRect(bX, bY, bW, bH);

        // Spinning Animation (Clipped)
        ctx.save();
        ctx.beginPath(); ctx.rect(bX, bY, bW, bH); ctx.clip();

        // Heat Gradient
        // Calculate color based on heat: Black -> Red -> Orange -> White/Yellow
        let heatR = 60 + (this.heat * 195);
        let heatG = 60 + (this.heat * 140);
        let heatB = 60;
        ctx.fillStyle = `rgb(${heatR}, ${heatG}, ${heatB})`;

        const spacing = 5;
        const scroll = this.barrelScroll % spacing;
        
        // Draw horizontal lines representing the barrels spinning
        for(let i = -spacing; i < bH + spacing; i += spacing) {
            let yPos = bY + i + scroll;
            // Draw barrel tube
            ctx.fillRect(bX, yPos, bW, 2);
            // Highlight (shine)
            ctx.fillStyle = "rgba(255,255,255,0.3)";
            ctx.fillRect(bX, yPos, bW, 1);
            ctx.fillStyle = `rgb(${heatR}, ${heatG}, ${heatB})`; // Reset color
        }
        ctx.restore();

        // -- Barrel Details --
        // 1. Clamp Ring (Middle of barrel)
        ctx.fillStyle = "#222";
        ctx.fillRect(bX + 20, bY - 1, 4, bH + 2);
        
        // 2. Muzzle Plate (The very front tip)
        ctx.fillStyle = "#111";
        ctx.fillRect(bX + bW - 2, bY - 1, 3, bH + 2);
        // Little dots on muzzle plate to show holes
        ctx.fillStyle = "#000";
        ctx.beginPath(); ctx.arc(bX + bW, -3, 1, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(bX + bW, 3, 1, 0, Math.PI*2); ctx.fill();

        ctx.restore(); // End Rotation

        // --- 4. HEALTH BAR ---
        if(typeof drawHealth === 'function') drawHealth(this.x, this.y, this.hp, this.maxHp);
    }
}

class MoneyFarm {
    constructor(col, row) {
        this.col = col;
        this.row = row;
        this.x = col * CELL_SIZE;
        this.y = row * CELL_SIZE;
        
        // Stats
        this.amount = 50 + (hasSkill('farm_val') ? 25 : 0) + (hasSkill('farm_cap') ? 50 : 0);        // Money per wave
        this.active = true;
        
        // Wave Tracking
        this.lastPaidWave = wave; // Track the last wave we paid out for
        
        // Visual Animation
        this.spin = 0;
        this.visualTimer = 0; // Kept for animation loops
        
        // Popup Text Stats
        this.popupText = "";
        this.popupAlpha = 0;
        this.popupY = 0;
    }

    update(dt) {
        // 1. Check if base is still intact
        let isIntact = true;
        for(let i=0; i<2; i++) {
            for(let j=0; j<2; j++) {
                if (!grid[this.col+i][this.row+j].wall) {
                    isIntact = false;
                }
            }
        }

        if (!isIntact) {
            this.cleanup();
            let idx = structures.indexOf(this);
            if (idx !== -1) structures.splice(idx, 1);
            return;
        }

        // 2. Generate Money (Per Wave)
        if (wave > this.lastPaidWave) {
            // Payout
            money += this.amount;
            this.lastPaidWave = wave;
            
            // Visual Popup Init
            this.popupText = "+$" + this.amount;
            this.popupAlpha = 1.0; // Fully visible
            this.popupY = this.y;  // Start at top of building
            
            // Update UI
            if(document.getElementById('money')) document.getElementById('money').innerText = Math.floor(money);
        }

        // 3. Update Visuals
        this.spin += 0.05;
        this.visualTimer += dt;
        
        // Handle Popup Animation (Float up and Fade out)
        if (this.popupAlpha > 0) {
            this.popupY -= 0.5; // Float up
            this.popupAlpha -= 0.01; // Fade out
            if (this.popupAlpha < 0) this.popupAlpha = 0;
        }
    }

    draw() {
        let cx = this.x + CELL_SIZE;
        let cy = this.y + CELL_SIZE;
        let radius = CELL_SIZE - 5;
       
        // We set pct to roughly 0.95 so it looks "active" and glowing, 
        // but keeps the colors interesting (Magenta -> Cyan).
        let pct = 1; 

        // --- 1. THE BASE PAD (Background) ---
        ctx.fillStyle = "#1a1a22"; 
        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI*2);
        ctx.fill();

        ctx.save();
        ctx.strokeStyle = "#330066"; 
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(cx, cy, radius * 0.8, 0, Math.PI*2);
        ctx.arc(cx, cy, radius * 0.5, 0, Math.PI*2);
        for(let i=0; i<8; i++) {
            let angle = (Math.PI/4) * i;
            ctx.moveTo(cx + Math.cos(angle)*(radius*0.5), cy + Math.sin(angle)*(radius*0.5));
            ctx.lineTo(cx + Math.cos(angle)*radius, cy + Math.sin(angle)*radius);
        }
        ctx.stroke();
        ctx.restore();


        // --- 2. THE PROGRESS RING (Circular Energy Gauge) ---
        let gaugeRadius = radius * 0.75;
        ctx.save();
        ctx.lineWidth = 8;
        ctx.lineCap = "round"; 

        // 2a. Background track
        ctx.strokeStyle = "rgba(100, 0, 200, 0.2)";
        ctx.beginPath();
        ctx.arc(cx, cy, gaugeRadius, 0, Math.PI*2);
        ctx.stroke();

        // 2b. The filling energy arc
        let startAngle = -Math.PI / 2;
        let endAngle = startAngle + (Math.PI * 2 * pct);
        
        let colorStart = "#aa00ff"; 
        let colorEnd = "#00eeff"; 

        let gaugeGrad = ctx.createLinearGradient(this.x, this.y, this.x + CELL_SIZE*2, this.y + CELL_SIZE*2);
        gaugeGrad.addColorStop(0, colorStart);
        gaugeGrad.addColorStop(1, colorEnd);

        ctx.strokeStyle = gaugeGrad;
        ctx.shadowColor = colorEnd;
        ctx.shadowBlur = 15;
        
        ctx.beginPath();
        ctx.arc(cx, cy, gaugeRadius, startAngle, endAngle, false);
        ctx.stroke();
        ctx.restore();


        // --- 3. THE CENTRAL XENO-CROP (Alien Crystal Plant) ---
        ctx.save();
        ctx.translate(cx, cy);
        ctx.rotate(Date.now() / 3000);
        
        let coreColor = "#ff00aa"; 
        let outerColor = "#7700aa";

        let plantSize = radius * 0.4;
        
        // Outer petals
        ctx.fillStyle = outerColor;
        ctx.beginPath();
        for(let i=0; i<8; i+=2) { 
             let angle = (Math.PI*2/8) * i;
             ctx.moveTo(0,0);
             ctx.lineTo(Math.cos(angle - 0.3) * plantSize, Math.sin(angle - 0.3) * plantSize);
             ctx.lineTo(Math.cos(angle) * plantSize * 1.2, Math.sin(angle) * plantSize * 1.2); 
             ctx.lineTo(Math.cos(angle + 0.3) * plantSize, Math.sin(angle + 0.3) * plantSize);
        }
        ctx.fill();

        // Inner Core 
        let pulse = Math.sin(Date.now() / 400) * 3;
        let coreSize = (plantSize * 0.5) + pulse;

        ctx.fillStyle = coreColor;
        ctx.shadowColor = coreColor;
        ctx.shadowBlur = 25; 
        ctx.beginPath();
        for(let i=0; i<6; i++) {
            let angle = (Math.PI*2/6) * i;
            let px = Math.cos(angle) * coreSize;
            let py = Math.sin(angle) * coreSize;
            if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();


        // --- 4. ORBITING HARVEST DRONES ---
        // I removed the (pct < 1) check so they are ALWAYS visible
        ctx.save();
        ctx.translate(cx, cy);
        let orbitSpeed = Date.now() / 600;
        let numParticles = 3;
        
        ctx.fillStyle = "#00ffff";
        ctx.shadowColor = "#ffffff";
        ctx.shadowBlur = 10;

        for(let i=0; i<numParticles; i++) {
            let angle = orbitSpeed + (Math.PI*2 / numParticles) * i;
            let px = Math.cos(angle) * gaugeRadius;
            let py = Math.sin(angle) * gaugeRadius;
            
            ctx.beginPath();
            ctx.arc(px, py, 3, 0, Math.PI*2);
            ctx.fill();
        }
        ctx.restore();
        
        // --- 5. FLOATING MONEY TEXT ---
        if (this.popupAlpha > 0) {
            ctx.save();
            ctx.globalAlpha = this.popupAlpha;
            ctx.font = "bold 15px 'Segoe UI', sans-serif";
            ctx.fillStyle = "#ffd700"; // Gold color
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.textAlign = "center";
            
            // Draw Outline
            ctx.strokeText(this.popupText, cx, this.popupY);
            // Draw Fill
            ctx.fillText(this.popupText, cx, this.popupY);
            
            ctx.restore();
        }
    }

    cleanup() {
        for(let i=0; i<2; i++) {
            for(let j=0; j<2; j++) {
                if (this.col + i < COLS && this.row + j < ROWS) {
                    let c = grid[this.col+i][this.row+j];
                    c.occupied = false;
                    c.wall = false;
                    c.wallHp = 100;
                }
            }
        }
        updateFlowField(); 
    }
}
// Helper function for rounded rectangles (paste this outside the class or method)
function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
  ctx.beginPath();
  ctx.moveTo(x + radius, y);
  ctx.lineTo(x + width - radius, y);
  ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
  ctx.lineTo(x + width, y + height - radius);
  ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
  ctx.lineTo(x + radius, y + height);
  ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
  ctx.lineTo(x, y + radius);
  ctx.quadraticCurveTo(x, y, x + radius, y);
  ctx.closePath();
  if (fill) ctx.fill();
  if (stroke) ctx.stroke();
}

    /** CORE SYSTEMS **/
const VIRTUAL_WIDTH = COLS * CELL_SIZE; 
const VIRTUAL_HEIGHT = ROWS * CELL_SIZE;

let scale = 1;
let offsetX = 0;
let offsetY = 0;

// Calculates how to fit the game into the current window
function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // 1. Determine Scale: Fit width OR height, whichever is smaller
    let scaleX = window.innerWidth / VIRTUAL_WIDTH;
    let scaleY = window.innerHeight / VIRTUAL_HEIGHT;
    scale = Math.min(scaleX, scaleY);

    // 2. Determine Centering (Letterboxing)
    // We calculate how much empty space is left and divide by 2 to center it
    offsetX = (window.innerWidth - (VIRTUAL_WIDTH * scale)) / 2;
    offsetY = (window.innerHeight - (VIRTUAL_HEIGHT * scale)) / 2;
}

    function init() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    
    // --- 1. SETUP SCALING ---
    // Apply initial size and event listener for future window resizing
    resize();
    window.addEventListener('resize', resize);

        
        // Init Grid
        for (let x = 0; x < COLS; x++) {
            grid[x] = [];
            for (let y = 0; y < ROWS; y++) {
                grid[x][y] = new Cell(x, y);
                grid[x][y].wallHp = 100;
            }
        }

        // --- BASE OCCUPANCY (2x2) ---
        // Mark the 4 cells covered by the base as occupied so nothing can be built there
        for(let i = 0; i < 2; i++) {
            for(let j = 0; j < 2; j++) {
                let bx = playerBase.x + i;
                let by = playerBase.y + j;
                if (bx >= 0 && bx < COLS && by >= 0 && by < ROWS) {
                    grid[bx][by].occupied = true; 
                }
            }
        }

         // --- 4. BORDERS ---
    // Wall off Top and Bottom
    for (let x = 0; x < COLS; x++) {
        grid[x][0].wall = true;
        grid[x][ROWS - 1].wall = true; 
    }
    // Wall off Left side
    for (let y = 0; y < ROWS; y++) {
        grid[0][y].wall = true;
    }

    // --- 5. INPUT LISTENERS (With Scaling Math) ---
    
    // Helper to calculate Game Coordinates from Screen Coordinates
    function updateMousePos(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        
        // 1. Get position relative to canvas element
        let rawX = clientX - rect.left;
        let rawY = clientY - rect.top;

        // 2. Subtract the black bars (offset) and divide by the zoom level (scale)
        mouseX = (rawX - offsetX) / scale;
        mouseY = (rawY - offsetY) / scale;
    }

        // --- INPUT LISTENERS ---
        canvas.addEventListener('mousedown', (e) => {
            isMouseDown = true;
            updateMousePos(e.clientX, e.clientY);
            handleInput(); 
        });

        window.addEventListener('mouseup', () => {
            isMouseDown = false;
        });

        // Track mouse position AND handle dragging
        // (This is the correct one using getBoundingClientRect)
        window.addEventListener('mousemove', (e) => {
            updateMousePos(e.clientX, e.clientY);
            
            if (isMouseDown) {
                handleInput();
            }
        });

        window.addEventListener('keydown', (e) => {
        const key = e.key.toLowerCase();

        // Tools
        if(key === '1') setTool('wall');
        if(key === '2') setTool('troop');
        if(key === '3') setTool('barracks');
        if(key === '4') setTool('mortar');
        if(key === '5') setTool('delete');
        if(key === '6') setTool('trap'); // Added trap back in if you have it
        if(key === '7') setTool('wall_turret');
        if(key === '8') setTool('money_farm');
        if(key === '9') setTool('sword_troop');
        if(key === 's') setTool('shield_troop');
        if(key === "t") setTool('tesla');        
        if(key === "v") setTool('sucker');
        if(key === "y") setTool('bounty');
        
        // Rotation
        if (key === 'r') {
            buildRotation = (buildRotation + Math.PI / 2) % (Math.PI * 2);
        }
    });

        // --- GAME START ---
        updateFlowField();
        
        // NEW: Trigger the first wave + Animation immediately
        wave = 0; 
        startNextWave(); 

        requestAnimationFrame(gameLoop);
    }

   function updateFlowField() {
        // 1. Reset grid
        for (let x = 0; x < COLS; x++) {
            for (let y = 0; y < ROWS; y++) {
                grid[x][y].distance = Infinity; 
                grid[x][y].vecX = 0;
                grid[x][y].vecY = 0;
            }
        }

        // 2. BFS Flood Fill starting from Base
        let queue = [];
        // Ensure base is within bounds
        if(playerBase.x >= 0 && playerBase.x < COLS && playerBase.y >= 0 && playerBase.y < ROWS) {
            let baseCell = grid[playerBase.x][playerBase.y];
            baseCell.distance = 0;
            queue.push(baseCell);
        }

        while (queue.length > 0) {
            let current = queue.shift();

            // Neighbors (Up, Down, Left, Right)
            let neighbors = [
                {x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}
            ];

            for (let n of neighbors) {
                let nx = current.x + n.x;
                let ny = current.y + n.y;

                if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
                    let nextCell = grid[nx][ny];
                    
                    // If it's not a wall and we haven't visited it yet
                    if (!nextCell.wall && nextCell.distance === Infinity) {
                        nextCell.distance = current.distance + 1;
                        // Point vector towards current (the way we came from)
                        nextCell.vecX = -n.x;
                        nextCell.vecY = -n.y;
                        queue.push(nextCell);
                    }
                }
            }
        }
    }

    function updateLockedButtons() {
    // 1. Define the Map: Button ID -> Skill ID needed
    const lockMap = {
        'btn-sword':      'unlock_sword',
        'btn-shield':     'unlock_shield',
        'btn-bard':       'unlock_bard',
        'btn-wallturret': 'unlock_wall_turret',
        'btn-trap':       'unlock_spikes',
        'btn-cryo':       'unlock_cryo',
        'btn-farm':       'unlock_farm',
        'btn-barracks':   'unlock_barracks',
        'btn-minigun':    'unlock_minigun',
        'btn-mortar':     'unlock_mortar',
        'btn-sucker':     'unlock_sucker',
        'btn-tesla':      'unlock_tesla',
        'btn-railgun':    'unlock_railgun'
    };

    // 2. Loop through every button
    for (const [btnId, skillId] of Object.entries(lockMap)) {
        const btn = document.getElementById(btnId);
        
        if (btn) {
            // Check if we have the skill
            if (playerProgress.unlocked.includes(skillId)) {
                // UNLOCKED: Remove the lock class
                btn.classList.remove('is-locked');
            } else {
                // LOCKED: Add the lock class
                btn.classList.add('is-locked');
            }
        }
    }
}

    // TOOL SELECTION FUNCTION
    function setTool(toolName) {
    // --- 1. CHECK IF LOCKED ---
    // Mapping Tool Names to Button IDs for checking the class
    let btnIdCheck = '';
    switch(toolName) {
        case 'sword_troop': btnIdCheck = 'btn-sword'; break;
        case 'shield_troop':btnIdCheck = 'btn-shield'; break;
        case 'bard_troop':  btnIdCheck = 'btn-bard'; break;
        case 'wall_turret': btnIdCheck = 'btn-wallturret'; break;
        case 'trap':        btnIdCheck = 'btn-trap'; break;
        case 'cryo_tower':  btnIdCheck = 'btn-cryo'; break;
        case 'money_farm':  btnIdCheck = 'btn-farm'; break;
        case 'barracks':    btnIdCheck = 'btn-barracks'; break;
        case 'minigun':     btnIdCheck = 'btn-minigun'; break;
        case 'mortar':      btnIdCheck = 'btn-mortar'; break;
        case 'sucker':      btnIdCheck = 'btn-sucker'; break;
        case 'railgun':     btnIdCheck = 'btn-railgun'; break;
        case 'bounty':      btnIdCheck = 'btn-bounty'; break; // <-- NEW BOUNTY TOWER ADDED HERE
    }

    // If the button exists and has the 'is-locked' class, STOP.
    const btnCheck = document.getElementById(btnIdCheck);
    if (btnCheck && btnCheck.classList.contains('is-locked')) {
        console.log("This item is locked.");
        return; 
    }

    // --- 2. NORMAL SELECTION LOGIC ---
    currentTool = toolName;
    
    const buttons = document.getElementsByClassName('tool-btn');
    for (let i = 0; i < buttons.length; i++) {
        buttons[i].classList.remove('active');
    }

    // Re-use the ID we found above to set active state
    if (btnIdCheck) {
        const btn = document.getElementById(btnIdCheck);
        if (btn) btn.classList.add('active');
    } else {
        // Handle special cases not in the lock list (like Wall or Delete)
        if (toolName === 'wall') document.getElementById('btn-wall').classList.add('active');
        if (toolName === 'delete') document.getElementById('btn-delete').classList.add('active');
    }
}

    function handleInput() {
        if (gameOver) return;

        // Calculate Grid Coordinates of the mouse
        let col = Math.floor(mouseX / CELL_SIZE);
        let row = Math.floor(mouseY / CELL_SIZE);

        // Bounds Check
        if (col < 0 || col >= COLS || row < 0 || row >= ROWS) return;

        let cell = grid[col][row];
        let didChange = false; 

        // --- WALL TOOL ---
        if (currentTool === 'wall') {
            if (!cell.wall && !cell.occupied && money >= 10) {
                cell.wall = true;
                cell.wallHp = 100;
                money -= 10;
                didChange = true;
            }
        }
        
        // --- DELETE TOOL (ROBUST FIX) ---
       else if (currentTool === 'delete') {
            let deletedSomething = false;

            // 1. Remove Traps
            for (let i = traps.length - 1; i >= 0; i--) {
                let t = traps[i];
                // Traps store grid coordinates (col, row)
                if (t.col === col && t.row === row) {
                    traps.splice(i, 1);
                    money += 20; // Refund half of $40
                    deletedSomething = true;
                    // Traps usually don't block paths, so didChange might not be needed, 
                    // but we set it just in case logic changes later.
                }
            }

            // 2. Remove Structures (Prioritize over walls to fix Wall Turret issue)
            // 2. Remove Structures (Prioritize over walls)
        for (let i = structures.length - 1; i >= 0; i--) {
            let s = structures[i];
            
            // Calculate center of structure for clicking
            // If it's a MoneyFarm, it's 2x2 (100x100px), else it's 1x1 (50x50px)
            let size = (s instanceof MoneyFarm) ? CELL_SIZE * 2 : CELL_SIZE;
            let sx = s.col * CELL_SIZE;
            let sy = s.row * CELL_SIZE;

            // Simple AABB collision for the mouse click
            if (mouseX >= sx && mouseX < sx + size &&
                mouseY >= sy && mouseY < sy + size) {
                
                // --- FIX STARTS HERE ---
                // 1. Check if the structure has a special cleanup method (like MoneyFarm)
                if (typeof s.cleanup === 'function') {
                    s.cleanup();
                } 
                // 2. Fallback for standard 1x1 structures
                else {
                    let c = grid[s.col][s.row];
                    c.occupied = false;
                    if (c.wall) {
                        c.wall = false;
                        c.wallHp = 100;
                    }
                    updateFlowField();
                }
                // --- FIX ENDS HERE ---

                structures.splice(i, 1); // Remove from array
                money += (s instanceof MoneyFarm) ? 175 : 100; // Refund (Example amounts)
                
                deletedSomething = true;
                didChange = true;
                break; 
            }
        }

            // 3. Remove Generic Walls (Only if no structure was found)
            // This handles standard walls that don't have buildings on them.
            if (!deletedSomething && cell.wall) {
                cell.wall = false;
                cell.wallHp = 100;
                money += 5;
                didChange = true;
            }
        }

        // --- PLACEMENT TOOLS ---
        else if (currentTool === 'bard_troop') {
             if (money >= 100) {
                 allies.push(new BardTroop(mouseX, mouseY));
                 money -= 100;
             }
        }
        else if (currentTool === 'troop') {
             if (money >= 10) {
                 allies.push(new Soldier(mouseX, mouseY));
                 money -= 10;
             }
        }
        else if (currentTool === 'sword_troop') {
            // Cost Check ($50)
            if (money >= 50) {
                // Spawn the ally at mouse position
                allies.push(new SwordTroop(mouseX, mouseY));
                money -= 50;
                
                // Optional: Particle effect on spawn
                createParticles(mouseX, mouseY, "#00ffff", 10);
            }
        }
        // Inside the tool placement logic (handleInput function)
        else if (currentTool === 'shield_troop') {
            if (money >= 75) {
                allies.push(new ShieldSoldier(mouseX, mouseY));
                money -= 75;
                // Optional spawn effect
                if(typeof createParticles === 'function') createParticles(mouseX, mouseY, "#0088aa", 10);
            }
        }
        else if (currentTool === 'barracks') {
            if (!cell.wall && !cell.occupied && money >= 200) {
                structures.push(new Barracks(col, row));
                cell.occupied = true;
                money -= 200;
                didChange = true; 
            }
        }
        else if (currentTool === 'mortar') {
            if (!cell.wall && !cell.occupied && money >= 200) {
                // Pass col/row as expected by your class
                structures.push(new Mortar(col, row));
                cell.occupied = true;
                money -= 200;
                didChange = true;
            }
        }
        else if (currentTool === 'trap') {
            if (!cell.wall && !cell.occupied && money >= 40) {
                traps.push(new Trap(mouseX, mouseY));
                cell.occupied = true; // Prevent building on top of it
                money -= 40;
                didChange = true;
            }
        }
        // Inside handleInput(x, y) ...

        else if (currentTool === 'wall_turret') {
            // Check if valid spot: Not occupied AND NOT a Wall
            if (!cell.occupied && !cell.wall && money >= 150) {
                // 1. Create the Turret (Pass buildRotation so it faces the right way!)
                let angle = (typeof buildRotation !== 'undefined') ? buildRotation : 0;
                structures.push(new WallTurret(col, row, angle));

                // 2. Make it a "Wall" in the grid
                cell.occupied = true;
                cell.wall = true;      // <--- Enemies still see it as a wall
                cell.wallHp = 300;     // <--- Sets HP to full (300/300)

                // 3. Update Enemy Pathfinding
                updateFlowField(); 
                money -= 150;
                didChange = true;
            }
        }
        else if (currentTool === 'tesla') {
            // Check constraints: Not on a wall, not occupied, have enough money
            if (!cell.wall && !cell.occupied && money >= 250) {
                structures.push(new TeslaTower(col, row));
                cell.occupied = true; // Mark spot as taken
                money -= 250;
                didChange = true;
            }
        }
        else if (currentTool === 'minigun') {
            if (!cell.wall && !cell.occupied && money >= 400) {
                structures.push(new Minigun(col, row));
                cell.occupied = true;
                cell.wall = true;      // <--- Enemies still see it as a wall
                cell.wallHp = 300;
                money -= 400;
                didChange = true;
                
                // Spawn Effect
                createParticles(mouseX, mouseY, "#ffff00", 15);
            }
        }
        else if (currentTool === 'cryo_tower') {
            if (!cell.wall && !cell.occupied && money >= 100) {
                structures.push(new CryoTower(col, row));
                cell.occupied = true;
                cell.wall = true;      // <--- Enemies still see it as a wall
                cell.wallHp = 300;
                money -= 100;
                didChange = true;
                
                // Spawn Effect
                createParticles(mouseX, mouseY, "#ffff00", 15);
            }
        } else if (currentTool === 'sucker') {
            if (!cell.wall && !cell.occupied && money >= 150) {
                structures.push(new SuckerTower(col, row));
                cell.occupied = true;
                cell.wall = true;      // Enemies must path around or attack it
                cell.wallHp = 150;     // Give it some health (adjust as needed)
                money -= 150;
                didChange = true;
                
                // Spawn Effect (Wind/Light Blue particles)
                createParticles(mouseX, mouseY, "#aaddff", 15);
            }
        } else if (currentTool === 'railgun') {
            if (money >= 1500) {
                // Determine dimensions based on current rotation (0 or PI = horizontal, PI/2 or 3PI/2 = vertical)
                let isHorizontal = Math.abs(Math.sin(buildRotation)) < 0.1;
                let wCells = isHorizontal ? 3 : 2;
                let hCells = isHorizontal ? 2 : 3;

                // Prevent placing out of bounds
                if (col + wCells > COLS || row + hCells > ROWS) return;

                // Check if ALL cells in the footprint are free
                let canPlace = true;
                for (let i = 0; i < wCells; i++) {
                    for (let j = 0; j < hCells; j++) {
                        if (grid[col + i][row + j].wall || grid[col + i][row + j].occupied) {
                            canPlace = false;
                            break;
                        }
                    }
                }

                if (canPlace) {
                    // Push the new railgun
                    structures.push(new Railgun(col, row, buildRotation));
                    
                    // Mark all grid cells in the footprint as occupied
                    for (let i = 0; i < wCells; i++) {
                        for (let j = 0; j < hCells; j++) {
                            grid[col + i][row + j].occupied = true;
                            grid[col + i][row + j].wall = true;
                            grid[col + i][row + j].wallHp = 1000; // Strong base health
                        }
                    }
                    money -= 1500;
                    didChange = true;
                    
                    // Optional spawn effect
                    if (typeof createParticles === 'function') createParticles(mouseX, mouseY, "#00ffff", 30);
                }
            }
        }
        else if (currentTool === 'money_farm') {
            let cost = 350;
            
            // Check bounds (needs 2x2 space)
            if (col + 1 >= COLS || row + 1 >= ROWS) return;

            // Check if area is clear (4 cells)
            let isClear = true;
            for(let i=0; i<2; i++) {
                for(let j=0; j<2; j++) {
                    let c = grid[col+i][row+j];
                    if (c.occupied || c.wall) isClear = false;
                }
            }

            if (isClear && money >= cost) {
                money -= cost;
                structures.push(new MoneyFarm(col, row));

                // Mark the 4 cells as "Walls" with LOW HP
                for(let i=0; i<2; i++) {
                    for(let j=0; j<2; j++) {
                        let c = grid[col+i][row+j];
                        c.occupied = true;
                        c.wall = true;
                        c.wallHp = 30; 
                    }
                }
                
                // --- FIX STARTS HERE ---
                // Force the enemies to recalculate their paths immediately
                updateFlowField(); 
                // --- FIX ENDS HERE ---

                didChange = true;
            }
        }
        else if (currentTool === 'bounty') {
            if (!cell.wall && !cell.occupied && money >= 150) {
                // CHANGED: towers.push -> structures.push
                structures.push(new BountyTower(col, row)); 
                cell.occupied = true;
                money -= 150;
                didChange = true; 
            }
        }
        // --- OPTIMIZATION ---
        // Only recalculate paths if the map layout changed (Walls or Buildings)
        if (didChange) {
            updateFlowField();
        }
    }

    function takeDamage(amount) {
    playerBase.hp -= amount;
    
    if (playerBase.hp <= 0) {
        playerBase.hp = 0;
        gameOver = true;

        // --- NEW: Calculate Shards ---
        // 1 Shard per wave, plus a bonus 10 shards if you pass Wave 10
        let shardsEarned = Math.floor(wave)*difficultyMultiplier;

        // --- NEW: Save to Skill Tree ---
        if (typeof playerProgress !== 'undefined') {
            playerProgress.shards += shardsEarned;
            saveProgress(); // Saves to LocalStorage
        }

        // --- Show Game Over Screen ---
        const gameOverScreen = document.getElementById('game-over');
        gameOverScreen.style.display = 'flex';
        
        // Update Wave Count
        document.getElementById('final-wave').innerText = wave;

        // --- NEW: Show Shards Earned on UI ---
        // We try to find an element to show shards, or create one if it's missing
        let shardDisplay = document.getElementById('earned-shards-text');
        
        if (!shardDisplay) {
            // Dynamically create the text element if you haven't added it to HTML yet
            shardDisplay = document.createElement('div');
            shardDisplay.id = 'earned-shards-text';
            shardDisplay.style.color = '#a388ee'; // Void Purple
            shardDisplay.style.fontSize = '24px';
            shardDisplay.style.marginTop = '15px';
            shardDisplay.style.fontWeight = 'bold';
            
            // Append it to the game over content
            // Assuming the parent of 'final-wave' is the main box
            document.getElementById('final-wave').parentNode.appendChild(shardDisplay);
        }
        
        shardDisplay.innerText = `+${shardsEarned} Void Shards`;
    }
}

    function createParticles(x, y, color, count) {
        for(let i=0; i<count; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 6,
                vy: (Math.random() - 0.5) * 6,
                life: 20,
                color: color
            });
        }
    }

    // Physics: Soft Collision / Separation Logic
    function separate(entity, neighbors, pushStrength) {
        // OPTIMIZATION: Only check a random sample of neighbors to save CPU
        // If we check all 500+ enemies against each other, the browser will freeze.
        let checkLimit = 8; 
        let checks = 0;
        let start = Math.floor(Math.random() * neighbors.length); // Random start index

        for (let i = 0; i < neighbors.length; i++) {
            if (checks >= checkLimit) break;
            
            let idx = (start + i) % neighbors.length;
            let other = neighbors[idx];

            if (entity === other) continue; // Don't collide with self

            let dx = entity.x - other.x;
            let dy = entity.y - other.y;
            let distSq = dx*dx + dy*dy;
            
            // If they are touching (radius + radius)
            let combinedRadius = entity.radius + other.radius; 
            // We add a small buffer (* 1.1) so they don't perfectly overlap
            let minDist = combinedRadius * 1.1; 

            if (distSq > 0 && distSq < minDist * minDist) {
                let dist = Math.sqrt(distSq);
                
                // Calculate push vector (normalized)
                let pushX = dx / dist;
                let pushY = dy / dist;

                // Apply Push
                entity.x += pushX * pushStrength;
                entity.y += pushY * pushStrength;
                
                checks++;
            }
        }
    }

    function resolveWallCollision(entity) {
        // 1. Keep in bounds (Canvas edges)
        let mapWidth = COLS * CELL_SIZE;
        let mapHeight = ROWS * CELL_SIZE;

        if (entity.x < entity.radius) { entity.x = entity.radius; entity.vx *= -0.5; }
        if (entity.y < entity.radius) { entity.y = entity.radius; entity.vy *= -0.5; }
        if (entity.x > mapWidth - entity.radius) { entity.x = mapWidth - entity.radius; entity.vx *= -0.5; }
        if (entity.y > mapHeight - entity.radius) { entity.y = mapHeight - entity.radius; entity.vy *= -0.5; }

        // 2. Grid Wall Collision (Check 3x3 cells around the entity)
        let minCol = Math.floor((entity.x - entity.radius) / CELL_SIZE);
        let maxCol = Math.floor((entity.x + entity.radius) / CELL_SIZE);
        let minRow = Math.floor((entity.y - entity.radius) / CELL_SIZE);
        let maxRow = Math.floor((entity.y + entity.radius) / CELL_SIZE);

        for (let c = minCol; c <= maxCol; c++) {
            for (let r = minRow; r <= maxRow; r++) {
                // Ensure we are checking valid grid coordinates
                if (c >= 0 && c < COLS && r >= 0 && r < ROWS) {
                    let cell = grid[c][r];
                    // If it's a wall, resolve collision
                    if (cell.wall) {
                        // Find the closest point on the wall rectangle to the circle center
                        let wallX = c * CELL_SIZE;
                        let wallY = r * CELL_SIZE;
                        
                        let closestX = Math.max(wallX, Math.min(entity.x, wallX + CELL_SIZE));
                        let closestY = Math.max(wallY, Math.min(entity.y, wallY + CELL_SIZE));

                        let distX = entity.x - closestX;
                        let distY = entity.y - closestY;
                        let distSq = (distX * distX) + (distY * distY);

                        // If overlap exists (distance < radius)
                        if (distSq < (entity.radius * entity.radius) && distSq > 0.001) {
                            let dist = Math.sqrt(distSq);
                            let overlap = entity.radius - dist;
                            
                            // Normal vector (direction to push out)
                            let nx = distX / dist;
                            let ny = distY / dist;

                            // Push entity out of wall
                            entity.x += nx * overlap;
                            entity.y += ny * overlap;

                            // Physics Response: Kill velocity moving INTO the wall
                            // Dot product to find velocity along normal
                            let vDot = (entity.vx * nx) + (entity.vy * ny);
                            if (vDot < 0) {
                                // Reflect/Dampen velocity
                                entity.vx -= vDot * nx * 1.2; 
                                entity.vy -= vDot * ny * 1.2;
                            }
                        }
                    }
                }
            }
        }
    }

    function collideWithRect(circle, rx, ry, rw, rh) {
        // Find the closest point on the rectangle to the circle's center
        let testX = circle.x;
        let testY = circle.y;

        if (circle.x < rx) testX = rx;
        else if (circle.x > rx + rw) testX = rx + rw;

        if (circle.y < ry) testY = ry;
        else if (circle.y > ry + rh) testY = ry + rh;

        let distX = circle.x - testX;
        let distY = circle.y - testY;
        let distance = Math.sqrt(distX*distX + distY*distY);

        // If closer than radius, we are inside! Push out.
        if (distance < circle.radius && distance > 0) {
            let overlap = circle.radius - distance;
            let nx = distX / distance;
            let ny = distY / distance;
            
            circle.x += nx * overlap;
            circle.y += ny * overlap;
        }
    }

    function getSmartVector(entity) {
    let col = Math.floor(entity.x / CELL_SIZE);
    let row = Math.floor(entity.y / CELL_SIZE);

    // 1. Check if we are inside the target cell (distance 0)
    // If so, just seek the exact center of this cell to stop jittering
    if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
        if (grid[col][row].distance === 0) {
             let dx = (col * CELL_SIZE + CELL_SIZE / 2) - entity.x;
             let dy = (row * CELL_SIZE + CELL_SIZE / 2) - entity.y;
             // If close enough, stop completely
             if (Math.hypot(dx, dy) < 2) return { x: 0, y: 0 };
        }
    }

    let lowestDist = Infinity;
    let targetX = 0;
    let targetY = 0;
    let count = 0;

    // 2. Check all 8 Neighbors (360 logic)
    // We include {x:0, y:0} (current cell) to ensure we can move WITHIN the current cell
    // if it happens to be the best path (rare, but good for safety).
    let dirs = [
        {x: 0, y: -1}, {x: 0, y: 1}, {x: -1, y: 0}, {x: 1, y: 0}, 
        {x: -1, y: -1}, {x: 1, y: -1}, {x: -1, y: 1}, {x: 1, y: 1},
        {x: 0, y: 0} 
    ];

    for (let d of dirs) {
        let c = col + d.x;
        let r = row + d.y;

        if (c >= 0 && c < COLS && r >= 0 && r < ROWS) {
            let cell = grid[c][r];

            // Ignore walls and unreachable areas
            if (cell.wall || cell.distance === Infinity) continue;

            // Important: We handle corners here.
            // If moving diagonal, check if we are cutting a hard corner.
            if (Math.abs(d.x) === 1 && Math.abs(d.y) === 1) {
                if (grid[col + d.x][row].wall || grid[col][row + d.y].wall) continue;
            }

            // FOUND A BETTER (OR EQUAL) PATH
            // We use "<=" to collect ALL equally good cells. 
            // This averages the direction for smooth angles.
            if (cell.distance < lowestDist) {
                // Found a strictly better path, reset our accumulator
                lowestDist = cell.distance;
                targetX = c * CELL_SIZE + CELL_SIZE / 2;
                targetY = r * CELL_SIZE + CELL_SIZE / 2;
                count = 1;
            } else if (cell.distance === lowestDist) {
                // Found an equally good path, add it to the average
                targetX += c * CELL_SIZE + CELL_SIZE / 2;
                targetY += r * CELL_SIZE + CELL_SIZE / 2;
                count++;
            }
        }
    }

    // 3. Calculate Vector
    if (count > 0) {
        // Average position of all best cells
        targetX /= count;
        targetY /= count;

        let dx = targetX - entity.x;
        let dy = targetY - entity.y;
        let dist = Math.sqrt(dx*dx + dy*dy);

        if (dist > 0.01) {
            return { x: dx / dist, y: dy / dist };
        }
    }

    // Fallback: If no valid neighbors found, just push toward map center
    // (Prevents getting stuck on outer bounds)
    let centerX = (COLS * CELL_SIZE) / 2;
    let centerY = (ROWS * CELL_SIZE) / 2;
    let cx = centerX - entity.x;
    let cy = centerY - entity.y;
    let cLen = Math.hypot(cx, cy);
    return { x: cx / cLen, y: cy / cLen };
}

    // BFS Pathfinding for Soldiers
    function findNextStep(startEntity, targetEntity) {
        let sx = Math.floor(startEntity.x / CELL_SIZE);
        let sy = Math.floor(startEntity.y / CELL_SIZE);
        let tx = Math.floor(targetEntity.x / CELL_SIZE);
        let ty = Math.floor(targetEntity.y / CELL_SIZE);

        // 1. If target is in the same or adjacent tile, move directly
        if (Math.abs(sx - tx) <= 1 && Math.abs(sy - ty) <= 1) {
             if (!grid[tx][ty].wall) return { x: targetEntity.x, y: targetEntity.y };
        }

        // 2. BFS Pathfinding
        let queue = [{ x: sx, y: sy, parent: null }];
        let visited = new Set();
        visited.add(sx + "," + sy);

        let iterations = 0;
        let maxIterations = 200; // Increased search range slightly

        // Track the tile that gets us closest to the enemy (in case we don't finish)
        let closestNode = null;
        let minDistanceToTarget = Infinity;
        
        while (queue.length > 0 && iterations < maxIterations) { 
            let current = queue.shift();
            iterations++;

            // Calculate distance to target from this node
            let dist = Math.abs(current.x - tx) + Math.abs(current.y - ty);
            if (dist < minDistanceToTarget) {
                minDistanceToTarget = dist;
                closestNode = current;
            }

            // If we found the target exactly
            if (current.x === tx && current.y === ty) {
                closestNode = current;
                break; // Stop searching, we found it
            }

            // Check Neighbors
            let neighbors = [{x:0, y:-1}, {x:0, y:1}, {x:-1, y:0}, {x:1, y:0}];

            for (let n of neighbors) {
                let nx = current.x + n.x;
                let ny = current.y + n.y;
                let key = nx + "," + ny;

                if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
                    if (!grid[nx][ny].wall && !visited.has(key)) {
                        visited.add(key);
                        queue.push({ x: nx, y: ny, parent: current });
                    }
                }
            }
        }

        // 3. Backtrack from the 'closestNode' found
        // If we found the target, this backtracks from the target.
        // If we ran out of time, this backtracks from the tile that got closest.
        if (closestNode) {
            let step = closestNode;
            // Walk back up the family tree until we find the Immediate Child of start
            while (step.parent && step.parent.parent !== null) {
                step = step.parent;
            }
            
            return { 
                x: step.x * CELL_SIZE + CELL_SIZE/2, 
                y: step.y * CELL_SIZE + CELL_SIZE/2 
            };
        }

        // Fallback (only happens if fully boxed in)
        return { x: startEntity.x, y: startEntity.y };
    }

function spawnEnemy() {
    let rand = Math.random();
    
    // --- CHANCE CONFIGURATION ---
    let tankChance = (wave > 8) ? 0.15 : (wave > 3 ? 0.1 : 0);
    let runnerChance = (wave > 2) ? 0.25 : (wave > 1 ? 0.2 : 0);
    let shielderChance = (wave > 12) ? 0.10 : 0;
    let leaperChance = (wave > 11) ? 0.10 : 0;
    let breacherChance = (wave > 7) ? 0.05 : 0; 
    let dasherChance = (wave > 6) ? 0.10 : 0; 
    let sniperChance = (wave > 8) ? 0.05 : 0;
    let broodChance = (wave > 10) ? 0.05 : 0; 
    let magnetChance = (wave > 18) ? 0.05 : 0;
    let reviverChance = (wave > 15) ? 0.05 : 0;
    let flyingChance = (wave > 9) ? 0.08 : 0;

    // --- SELECTION LOGIC ---
    let currentTotal = 0;
    
    // 1. DEFINE THE VARIABLE HERE
    let newEnemy = null; 

    // Check Tank
    currentTotal += tankChance;
    if (!newEnemy && rand < currentTotal) { newEnemy = new TankEnemy(); }
    
    // Check Runner
    currentTotal += runnerChance;
    if (!newEnemy && rand < currentTotal) { newEnemy = new RunnerEnemy(); }

    // Check Shielder
    currentTotal += shielderChance;
    if (!newEnemy && rand < currentTotal) { newEnemy = new ShielderEnemy(); }

    // Check Leaper
    currentTotal += leaperChance;
    if (!newEnemy && rand < currentTotal) { newEnemy = new LeaperEnemy(); }

    // Check Breacher
    currentTotal += breacherChance;
    if (!newEnemy && rand < currentTotal) { newEnemy = new BreacherEnemy(); }

    // Check Dasher
    currentTotal += dasherChance;
    if (!newEnemy && rand < currentTotal) { newEnemy = new DasherEnemy(); }
    
    // Check Sniper
    currentTotal += sniperChance;
    if (!newEnemy && rand < currentTotal) { newEnemy = new SniperEnemy(); }
    
    // Check Broodmother
    currentTotal += broodChance;
    if (!newEnemy && rand < currentTotal) { newEnemy = new BroodmotherEnemy(); }

    // Check Magnet
    currentTotal += magnetChance;
    if (!newEnemy && rand < currentTotal) { newEnemy = new MagnetEnemy(); }

    // Check Reviver
    currentTotal += reviverChance;
    if (!newEnemy && rand < currentTotal) { newEnemy = new ReviverEnemy(); }

    // Check Flying
    currentTotal += flyingChance;
    if (!newEnemy && rand < currentTotal) { newEnemy = new FlyingEnemy(); }

    // 2. FALLBACK (If nothing was picked, spawn basic enemy)
    if (!newEnemy) { 
        newEnemy = new Enemy(); 
    }

    // 3. PUSH TO GAME LOOP
    enemies.push(newEnemy);

    // 4. CHECK FOR INTEL CARD
    // Now 'newEnemy' is defined, so this will work!
    checkForNewEnemy(newEnemy);
}

    function startNextWave() {
    wave++;
    waveState = 'spawning';
    enemiesSpawned = 0;

    // 1. Determine if this is a Boss Wave (Every 10th wave)
    const isBossWave = (wave % 10 === 0);

    // 2. Create the Cinematic Announcement
    if (isBossWave) {
        // Red, ominous text for Boss waves
        currentAnnouncement = new WaveAnnouncement(
            `WAVE ${wave}`,       // Title
            "âš  BOSS DETECTED âš ", // Subtitle
            "#ff0044"             // Color (Red)
        );
    } else {
        // Standard White text for normal waves
        currentAnnouncement = new WaveAnnouncement(
            `WAVE ${wave}`,       // Title
            "INCOMING SWARM",     // Subtitle
            "#ffffff"             // Color (White)
        );
    }

    // 3. Calculate Difficulty (Scaling)
    // Number of enemies grows linearly
    enemiesToSpawn = 5 + wave;
    
    // Spawn rate gets faster (lower number = faster), capped at 20 frames minimum
    spawnRate = Math.max(20, 60 - (wave * 0.5));

    // 4. Spawn the Boss
    if (isBossWave) {
        let boss = new BossEnemy();
        enemies.push(boss); // Add boss immediately to the active field
        
        // Optional: Reduce the number of small enemies slightly during a boss fight 
        // so the player isn't totally overwhelmed.
        enemiesToSpawn = Math.floor(enemiesToSpawn * 0.8); 
    }
}

    // --- HELPER 1: LINE OF SIGHT ---
// --- HELPER: CHECK IF PATH IS CLEAR ---
// --- HELPER: THICK LINE OF SIGHT (Prevents Corner Clipping) ---
// --- 1. RAYCASTING (Vision) ---
function castRay(sx, sy, ex, ey) {
    let dx = ex - sx;
    let dy = ey - sy;
    let dist = Math.hypot(dx, dy);
    let steps = dist / (CELL_SIZE / 2); // Check twice per cell

    for (let i = 0; i <= steps; i++) {
        let t = i / steps;
        let cx = sx + dx * t;
        let cy = sy + dy * t;
        
        let col = Math.floor(cx / CELL_SIZE);
        let row = Math.floor(cy / CELL_SIZE);

        if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
            if (grid[col][row].wall) return false; // Hit a wall
        }
    }
    return true; // Clear path
}

// --- IMPROVED HELPER: Thick Raycast ---
// Checks 3 parallel lines to ensure the enemy's body actually fits
function hasLineOfSight(x0, y0, x1, y1, radius = 0) {
    let dx = x1 - x0;
    let dy = y1 - y0;
    let dist = Math.hypot(dx, dy);
    if (dist === 0) return true;

    // Calculate perpendicular offset vector for width
    let nx = -dy / dist; 
    let ny = dx / dist;
    
    // Check 3 Rays: Center, Left Edge, Right Edge
    // We add a tiny buffer (+2) to radius to prevent grazing
    let r = Math.max(0, radius + 2); 
    let offsets = [
        { x: 0, y: 0 },            // Center
        { x: nx * r, y: ny * r },  // Left side of body
        { x: -nx * r, y: -ny * r } // Right side of body
    ];

    for (let o of offsets) {
        let startX = x0 + o.x;
        let startY = y0 + o.y;
        let endX = x1 + o.x;
        let endY = y1 + o.y;

        // Check points along this specific ray
        let steps = Math.ceil(dist / (CELL_SIZE / 2));
        for (let i = 0; i <= steps; i++) {
            let t = i / steps;
            let cx = startX + (endX - startX) * t;
            let cy = startY + (endY - startY) * t;
            
            let col = Math.floor(cx / CELL_SIZE);
            let row = Math.floor(cy / CELL_SIZE);
            
            if (col >= 0 && col < COLS && row >= 0 && row < ROWS) {
                if (grid[col][row].wall) return false; // Blocked
            }
        }
    }
    return true; // Path is wide enough!
}
// --- 2. PATHFINDING (BFS) ---
// --- HELPER: PATHFINDING (BFS) ---
function findPath(unit, target) {
    let startCol = Math.floor(unit.x / CELL_SIZE);
    let startRow = Math.floor(unit.y / CELL_SIZE);
    let endCol = Math.floor(target.x / CELL_SIZE);
    let endRow = Math.floor(target.y / CELL_SIZE);

    if (startCol === endCol && startRow === endRow) return [];

    let queue = [{c: startCol, r: startRow}];
    let visited = new Set();
    let cameFrom = {}; 
    let startKey = `${startCol},${startRow}`;
    
    visited.add(startKey);
    cameFrom[startKey] = null;

    let found = false;
    let finalNode = null;

    while (queue.length > 0) {
        let current = queue.shift();

        if (current.c === endCol && current.r === endRow) {
            found = true;
            finalNode = current;
            break;
        }

        // Define neighbors (Straight & Diagonal)
        let directions = [
            // straight
            {x: 0, y: -1}, {x: 0, y: 1}, {x: -1, y: 0}, {x: 1, y: 0},
            // diagonal
            {x: -1, y: -1}, {x: 1, y: -1}, {x: -1, y: 1}, {x: 1, y: 1}
        ];

        for (let dir of directions) {
            let nc = current.c + dir.x;
            let nr = current.r + dir.y;

            if (nc >= 0 && nc < COLS && nr >= 0 && nr < ROWS) {
                // 1. Basic Wall Check
                if (grid[nc][nr].wall) continue;

                // 2. CORNER CUTTING PREVENTION
                // If moving diagonally (both x and y change), check adjacent straight tiles
                if (dir.x !== 0 && dir.y !== 0) {
                    if (grid[current.c + dir.x][current.r].wall || grid[current.c][current.r + dir.y].wall) {
                        continue; // Block this diagonal move
                    }
                }

                let key = `${nc},${nr}`;
                if (!visited.has(key)) {
                    visited.add(key);
                    cameFrom[key] = current;
                    queue.push({c: nc, r: nr});
                }
            }
        }
    }

    // Reconstruct path
    let path = [];
    if (found) {
        let curr = finalNode;
        while (curr) {
            if (curr.c === startCol && curr.r === startRow) break;
            path.push({
                x: curr.c * CELL_SIZE + CELL_SIZE/2,
                y: curr.r * CELL_SIZE + CELL_SIZE/2
            });
            let key = `${curr.c},${curr.r}`;
            curr = cameFrom[key];
        }
        path.reverse(); // Order: Start -> End
    }
    return path;
}

let lastTime = performance.now();
let gameFrame = 0;

function gameLoop(timestamp) {
    if (!timestamp) timestamp = performance.now();
    let deltaTime = timestamp - lastTime;
    lastTime = timestamp;

    if (deltaTime > 100) deltaTime = 100;
    const dt = deltaTime / (1000 / 60);

    if (!gameActive) {
        requestAnimationFrame(gameLoop);
        return;
    }

    if (gameOver) return;

    gameFrame++; // Increment frame counter for optimizations

    if (hasSkill('core_regen') && gameFrame % 300 === 0 && playerBase.hp < playerBase.maxHp) {
    playerBase.hp += 1;
    }

    // --- 1. CLEAR PHYSICAL SCREEN ---
    ctx.fillStyle = "#050505";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // --- 2. START SCALING SYSTEM ---
    ctx.save();
    ctx.translate(offsetX, offsetY); 
    ctx.scale(scale, scale);         

    // --- 3. DRAW GAME WORLD (Inside Virtual 64x36 Grid) ---
    
    // Background
    ctx.fillStyle = "#111";
    ctx.fillRect(0, 0, VIRTUAL_WIDTH, VIRTUAL_HEIGHT);

    // Grid Lines
    ctx.strokeStyle = "#222";
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let x = 0; x <= COLS; x++) { ctx.moveTo(x*CELL_SIZE,0); ctx.lineTo(x*CELL_SIZE, VIRTUAL_HEIGHT); }
    for (let y = 0; y <= ROWS; y++) { ctx.moveTo(0,y*CELL_SIZE); ctx.lineTo(VIRTUAL_WIDTH, y*CELL_SIZE); }
    ctx.stroke();

    // --- SKILL CHECK: Wall Regeneration ---
    // We check if the player owns the skill inside the playerProgress object
    const hasWallRegen = (typeof playerProgress !== 'undefined' && playerProgress.unlocked.includes('wall_regen'));

    // Walls Logic
    for (let x = 0; x < COLS; x++) {
        for (let y = 0; y < ROWS; y++) {
            let cell = grid[x][y];
            if (cell.wall && !cell.occupied) {
                
                // SKILL TREE: Only regen if skill is unlocked
                if (hasWallRegen) {
                    if (cell.wallHp < 100) cell.wallHp += 0.05 * dt;
                    if (cell.wallHp > 100) cell.wallHp = 100;
                }

                // Colors
                let hpPct = cell.wallHp / 100;
                let gray = Math.floor(60 + (60 * hpPct)); 
                let colMain = `rgb(${gray}, ${gray}, ${gray})`;
                let colLight = `rgb(${gray + 40}, ${gray + 40}, ${gray + 40})`;
                let colDark = `rgb(${gray - 40}, ${gray - 40}, ${gray - 40})`;
                let colDetail = `rgb(${gray - 20}, ${gray - 20}, ${gray - 20})`;

                // Neighbors
                let nUp = (y > 0 && grid[x][y - 1].wall);
                let nDown = (y < ROWS - 1 && grid[x][y + 1].wall);
                let nLeft = (x > 0 && grid[x - 1][y].wall);
                let nRight = (x < COLS - 1 && grid[x + 1][y].wall);

                let drawX = x * CELL_SIZE;
                let drawY = y * CELL_SIZE;
                let coreSize = CELL_SIZE * 0.85; 
                let offset = (CELL_SIZE - coreSize) / 2;
                
                let cX = drawX + offset;
                let cY = drawY + offset;
                let cW = coreSize;
                let cH = coreSize;

                // Draw Base Block
                ctx.fillStyle = colMain;
                ctx.fillRect(cX, cY, cW, cH); 
                
                // Draw Connections
                if (nUp) ctx.fillRect(cX, drawY, cW, offset);
                if (nDown) ctx.fillRect(cX, cY + cH, cW, offset);
                if (nLeft) ctx.fillRect(drawX, cY, offset, cH);
                if (nRight) ctx.fillRect(cX + cW, cY, offset, cH);

                // Grip Lines
                ctx.fillStyle = colDark;
                let lineSpace = 4;
                if (nUp) for(let i = drawY + 2; i < cY; i+=lineSpace) ctx.fillRect(cX + 2, i, cW - 4, 1);
                if (nDown) for(let i = cY + cH + 2; i < drawY + CELL_SIZE; i+=lineSpace) ctx.fillRect(cX + 2, i, cW - 4, 1);
                if (nLeft) for(let i = drawX + 2; i < cX; i+=lineSpace) ctx.fillRect(i, cY + 2, 1, cH - 4);
                if (nRight) for(let i = cX + cW + 2; i < drawX + CELL_SIZE; i+=lineSpace) ctx.fillRect(i, cY + 2, 1, cH - 4);

                // 3D Bevels
                ctx.beginPath(); ctx.strokeStyle = colLight; ctx.lineWidth = 2;
                ctx.moveTo(cX, cY); ctx.lineTo(cX + cW, cY); ctx.stroke(); // Top
                ctx.moveTo(cX, cY); ctx.lineTo(cX, cY + cH); ctx.stroke(); // Left
                
                ctx.beginPath(); ctx.strokeStyle = colDark;
                ctx.moveTo(cX + cW, cY); ctx.lineTo(cX + cW, cY + cH); ctx.stroke(); // Right
                ctx.moveTo(cX, cY + cH); ctx.lineTo(cX + cW, cY + cH); ctx.stroke(); // Bottom

                // Inner Plate
                let pad = 6;
                ctx.fillStyle = colDetail;
                ctx.fillRect(cX + pad, cY + pad, cW - pad*2, cH - pad*2);
                ctx.strokeStyle = colDark; ctx.lineWidth = 1;
                ctx.strokeRect(cX + pad, cY + pad, cW - pad*2, cH - pad*2);
            }
        }
    }

    // --- VOID PORTAL (2x2) ---
    ctx.save();
    const bx = playerBase.x * CELL_SIZE;
    const by = playerBase.y * CELL_SIZE;
    const bSize = CELL_SIZE * 2;
    const centerBx = bx + CELL_SIZE;
    const centerBy = by + CELL_SIZE;
    const time = Date.now();
    const isHit = (Date.now() - (playerBase.lastHitTime || 0)) < 150;

    // Foundation
    ctx.fillStyle = "#1a1a1d"; 
    ctx.shadowColor = "#000"; ctx.shadowBlur = 15;
    ctx.beginPath();
    const cut = 15;
    ctx.moveTo(bx + cut, by); ctx.lineTo(bx + bSize - cut, by); ctx.lineTo(bx + bSize, by + cut);
    ctx.lineTo(bx + bSize, by + bSize - cut); ctx.lineTo(bx + bSize - cut, by + bSize);
    ctx.lineTo(bx + cut, by + bSize); ctx.lineTo(bx, by + bSize - cut); ctx.lineTo(bx, by + cut);
    ctx.closePath(); ctx.fill(); ctx.shadowBlur = 0;

    // Runes
    ctx.save();
    ctx.beginPath(); ctx.rect(bx, by, bSize, bSize); ctx.clip();
    ctx.strokeStyle = isHit ? "#ff0000" : "#a020f0"; ctx.lineWidth = 2;
    ctx.setLineDash([10, 25]); ctx.beginPath(); ctx.arc(centerBx, centerBy, CELL_SIZE * 0.8, 0, Math.PI * 2); ctx.stroke();
    ctx.setLineDash([5, 15]); ctx.beginPath(); ctx.arc(centerBx, centerBy, CELL_SIZE * 0.9, 0, Math.PI * 2); ctx.stroke();
    ctx.restore();

    // Portal Swirl
    const portalRadius = CELL_SIZE * 0.65;
    ctx.fillStyle = "#000";
    ctx.beginPath(); ctx.arc(centerBx, centerBy, portalRadius, 0, Math.PI * 2); ctx.fill();

    ctx.save();
    ctx.translate(centerBx, centerBy);
    ctx.globalCompositeOperation = 'lighter';
    ctx.rotate(time * 0.001);
    const grad1 = ctx.createRadialGradient(0, 0, 10, 0, 0, portalRadius);
    grad1.addColorStop(0, "rgba(0, 0, 0, 0)");
    grad1.addColorStop(0.4, isHit ? "rgba(255, 0, 0, 0.4)" : "rgba(75, 0, 130, 0.4)");
    grad1.addColorStop(0.8, isHit ? "rgba(255, 50, 0, 0.6)" : "rgba(138, 43, 226, 0.6)");
    grad1.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = grad1;
    ctx.beginPath();
    for (let i = 0; i < Math.PI * 2; i += 0.1) {
        let r = portalRadius * (0.9 + Math.sin(i * 5 + time * 0.002) * 0.05);
        ctx.lineTo(Math.cos(i) * r, Math.sin(i) * r);
    }
    ctx.fill();

    // Inner Spiral
    ctx.rotate(time * -0.003);
    const grad2 = ctx.createRadialGradient(0, 0, 5, 0, 0, portalRadius * 0.8);
    grad2.addColorStop(0, "#ffffff");
    grad2.addColorStop(0.2, isHit ? "#ff0000" : "#ff00ff");
    grad2.addColorStop(1, "rgba(0,0,0,0)");
    ctx.fillStyle = grad2;
    for (let i = 0; i < 3; i++) {
        ctx.rotate((Math.PI * 2) / 3);
        ctx.beginPath(); ctx.ellipse(20, 0, portalRadius * 0.6, portalRadius * 0.2, 0.5, 0, Math.PI * 2); ctx.fill();
    }
    ctx.restore();

    // --- SKILL INTEGRATION: Health Bar ---
    // Use playerBase.maxHp if it exists (from Skills), otherwise 100
    const maxHp = playerBase.maxHp || 100;
    const hpPct = Math.max(0, playerBase.hp / maxHp);
    
    const barW = bSize * 0.6;
    const barX = centerBx - barW / 2;
    const barY = by - 10;
    ctx.fillStyle = "rgba(0,0,0,0.8)"; ctx.fillRect(barX, barY, barW, 4);
    const hpColor = hpPct > 0.5 ? "#b042ff" : (hpPct > 0.2 ? "#ff00ff" : "#ff0000");
    ctx.fillStyle = hpColor; ctx.shadowColor = hpColor; ctx.shadowBlur = 5;
    ctx.fillRect(barX, barY, barW * hpPct, 4); ctx.shadowBlur = 0;
    ctx.restore();

    // Hover Ghost (Calculates using Scaled Mouse Coords)
    let gc = Math.floor(mouseX/CELL_SIZE);
    let gr = Math.floor(mouseY/CELL_SIZE);
    if (gc >= 0 && gc < COLS && gr >= 0 && gr < ROWS) {
        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx.strokeRect(gc*CELL_SIZE, gr*CELL_SIZE, CELL_SIZE, CELL_SIZE);
    }

    // --- GAME LOGIC ---

    if (waveState === 'spawning') {
        spawnTimer+=dt;
        if (spawnTimer > spawnRate) {
            spawnEnemy(); 
            enemiesSpawned++;
            spawnTimer = 0;
            if (enemiesSpawned >= enemiesToSpawn) waveState = 'fighting';
        }
    } else if (waveState === 'fighting') {
        if (enemies.length === 0) {                
            money += 50;
            startNextWave(); 
        }
    }
    
    // Structures - Update & Cleanup
    for (let i = structures.length - 1; i >= 0; i--) {
        let s = structures[i];
        if (s.update) s.update(dt);
        if ((s.active === false) || (s.hp !== undefined && s.hp <= 0)) {
            structures.splice(i, 1);
        }
    }

    // Structures - Depth Sort & Draw
    structures.sort((a, b) => a.row - b.row);

    for (let s of structures) {
        if (s.draw) s.draw();
    }

    // Draw corpses that are falling into the crusher hole â€” must render above structures
    for (let i = corpses.length - 1; i >= 0; i--) {
        if (corpses[i].fallingIntoHole) corpses[i].draw();
    }

    // Traps
    for (let i = traps.length - 1; i >= 0; i--) {
        traps[i].update(dt);
        traps[i].draw();
        if (traps[i].hp <= 0) {
            grid[traps[i].col][traps[i].row].occupied = false;
            traps.splice(i, 1);
        }
    }

    // Spikes
    for (let i = spikes.length - 1; i >= 0; i--) {
        spikes[i].update(dt);
        spikes[i].draw();
        if (!spikes[i].active) spikes.splice(i, 1);
    }

    for (let i = corpses.length - 1; i >= 0; i--) {
        corpses[i].update();
        if (!corpses[i].fallingIntoHole) corpses[i].draw(); 
        if (!corpses[i].active) {
            corpses.splice(i, 1);
        }
    }

    // Enemies & Portal Damage
    let baseCenterX = (playerBase.x * CELL_SIZE) + CELL_SIZE;
    let baseCenterY = (playerBase.y * CELL_SIZE) + CELL_SIZE;

    enemies.forEach(e => {
    e.isInvincible = false;
    });

    for (let i = enemies.length - 1; i >= 0; i--) {
        let e = enemies[i];
        e.update(dt);      

        let distToPortal = Math.hypot(e.x - baseCenterX, e.y - baseCenterY);
        if (distToPortal < CELL_SIZE * 0.6) {
            takeDamage(5); 
            playerBase.lastHitTime = Date.now();
            if(typeof createParticles === 'function') createParticles(e.x, e.y, "#a020f0", 8);
            enemies.splice(i, 1);
            continue; 
        }
        e.draw();
        
        if (e.hp <= 0) {
            // 1. Give the player the standard kill bounty
            money += e.bounty; 
            
            if (e.type !== "SKELETON_UNIT") {
                // 2. Spawn the corpse, but now PASS THE BOUNTY into it
                corpses.push(new Corpse(e.x, e.y, e.bounty)); 
            }
            
            if(typeof createParticles === 'function') {
                createParticles(e.x, e.y, "orange", 6);
            }
            
            enemies.splice(i, 1);
        }
    }

    // Allies
    for (let i = allies.length - 1; i >= 0; i--) {
        let a = allies[i];
        a.update(dt);
        a.draw();
        if (a.hp <= 0 || a.lifeTimer <= 0) {
            allies.splice(i, 1);
            createParticles(a.x, a.y, "#00d2ff", 5);
        }
    }

    // Projectiles
    for (let i = projectiles.length - 1; i >= 0; i--) {
        projectiles[i].update(dt);
        projectiles[i].draw();
        if (!projectiles[i].active) projectiles.splice(i, 1);
    }

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        let p = particles[i];
        p.x += p.vx * dt; 
        p.y += p.vy * dt; 
        p.life -= dt;
        ctx.fillStyle = p.color; ctx.globalAlpha = p.life/20;
        ctx.fillRect(p.x, p.y, 3, 3);
        ctx.globalAlpha = 1;
        if (p.life <= 0) particles.splice(i, 1);
    }

    // Blueprint
    drawBlueprint();

        // Announcement
    if (currentAnnouncement && currentAnnouncement.active) {
        currentAnnouncement.update(dt);
        currentAnnouncement.draw();
    }

    // --- 4. END SCALING SYSTEM ---
    ctx.restore();

    // --- 5. UI UPDATES ---
    document.getElementById('hp').innerText = Math.ceil(playerBase.hp);
    document.getElementById('money').innerText = Math.floor(money);
    document.getElementById('wave').innerText = wave;
    let remaining = (enemiesToSpawn - enemiesSpawned) + enemies.length;
    document.getElementById('enemy-count').innerText = remaining > 0 ? remaining : 0;

    requestAnimationFrame(gameLoop);
}

    let currentDifficulty = 'medium'; // Default
    updateLockedButtons();
    // 1. Hook into startGame to capture the chosen difficulty
    const _originalStartGame = startGame;
    startGame = function(mode) {
        currentDifficulty = mode; // Save difficulty for restart
        _originalStartGame(mode);
    }

    // 2. Patch the Game Loop to handle freezing
    const _originalGameLoop = gameLoop;
    gameLoop = function(timestamp) {
        // If paused, keep the loop alive but skip the update/draw logic
        // This freezes the last frame on the canvas behind the menu
        if (isPaused) {
            requestAnimationFrame(gameLoop);
            return;
        }
        _originalGameLoop(timestamp);
    }

    // 3. Toggle Pause Function
    function togglePause() {
        // Prevent pausing if game hasn't started or is over
        if (!gameActive || gameOver) return;

        isPaused = !isPaused;
        const menu = document.getElementById('pause-menu');
        menu.style.display = isPaused ? 'flex' : 'none';
    }

    // 4. Restart Game (Reloads page and auto-starts with same difficulty)
    function restartGame() {
        sessionStorage.setItem('swarm_restart_diff', currentDifficulty);
        location.reload();
    }

    // 5. Main Menu (Reloads page cleanly)
    function goToMainMenu() {
        sessionStorage.removeItem('swarm_restart_diff');
        location.reload();
    }

    // 6. Input Listener for 'P'
    window.addEventListener('keydown', (e) => {
        if (e.key.toLowerCase() === 'p') {
            togglePause();
        }
    });

    // 7. Auto-Start Check (Runs on page load for "Restart" functionality)
    // Checks if we are restarting instantly
    const _restartDiff = sessionStorage.getItem('swarm_restart_diff');
    if (_restartDiff) {
        // FIX: Hide menu immediately to prevent flickering
        const menu = document.getElementById('main-menu');
        if (menu) menu.style.display = 'none';

        sessionStorage.removeItem('swarm_restart_diff');
        
        // Wait briefly for DOM to be ready, then start
        setTimeout(() => startGame(_restartDiff), 100);
    }
    init();

</script>
</body>
</html>
